ecure_id;
			atomic_set(&it->process_usage_count, 1);
			list_add(&it->link, &session->memory_usage);
		}
		else
		{
			/* not found */
			kfree(it);
			it = NULL;
		}
	}

	mutex_unlock(&session->session_lock);

	return (NULL != it) ? 0 : -ENODEV;
}


static int do_ump_dd_release(umpp_session * session, ump_k_release * params)
{
	umpp_session_memory_usage * it;
	int result = -ENODEV;

	mutex_lock(&session->session_lock);

	/* only do a release if found on the session list */
	list_for_each_entry(it, &session->memory_usage, link)
	{
		if (it->id == params->secure_id)
		{
			/* found, a valid call */
			result = 0;

			if (0 == atomic_sub_return(1, &it->process_usage_count))
			{
				/* last ref in this process remove from the usage list and remove the underlying ref */
				list_del(&it->link);
				ump_dd_release(it->mem);
				kfree(it);
			}

			break;
		}
	}
	mutex_unlock(&session->session_lock);

	return result;
}

static int do_ump_dd_sizequery(umpp_session * session, ump_k_sizequery * params)
{
	umpp_session_memory_usage * it;
	int result = -ENODEV;

	mutex_lock(&session->session_lock);

	/* only valid if found on the session list */
	list_for_each_entry(it, &session->memory_usage, link)
	{
		if (it->id == params->secure_id)
		{
			/* found, a valid call */
			params->size = ump_dd_size_get_64(it->mem);
			result = 0;
			break;
		}

	}
	mutex_unlock(&session->session_lock);

	return result;
}

static int do_ump_dd_allocation_flags_get(umpp_session * session, ump_k_allocation_flags * params)
{
	umpp_session_memory_usage * it;
	int result = -ENODEV;

	mutex_lock(&session->session_lock);

	/* only valid if found on the session list */
	list_for_each_entry(it, &session->memory_usage, link)
	{
		if (it->id == params->secure_id)
		{
			/* found, a valid call */
			params->alloc_flags = ump_dd_allocation_flags_get(it->mem);
			result = 0;
			break;
		}

	}
	mutex_unlock(&session->session_lock);

	return result;
}

static int do_ump_dd_msync_now(umpp_session * session, ump_k_msync * params)
{
	umpp_session_memory_usage * it;
	int result = -ENODEV;

	mutex_lock(&session->session_lock);

	/* only valid if found on the session list */
	list_for_each_entry(it, &session->memory_usage, link)
	{
		if (it->id == params->secure_id)
		{
			/* found, do the cache op */
#ifdef CONFIG_COMPAT
			if (is_compat_task())
			{
				umpp_dd_cpu_msync_now(it->mem, params->cache_operation, compat_ptr(params->mapped_ptr.compat_value), params->size);
				result = 0;
			}
			else
			{
#endif
				umpp_dd_cpu_msync_now(it->mem, params->cache_operation, params->mapped_ptr.value, params->size);
				result = 0;
#ifdef CONFIG_COMPAT
			}
#endif
			break;
		}
	}
	mutex_unlock(&session->session_lock);

	return result;
}


void umpp_import_handlers_init(umpp_session * session)
{
	int i;
	mutex_lock(&import_list_lock);
	for ( i = 1; i < UMPP_EXTERNAL_MEM_COUNT; i++ )
	{
		if (import_handlers[i])
		{
			import_handlers[i]->session_begin(&session->import_handler_data[i]);
			/* It is OK if session_begin returned an error.
			 * We won't do any import calls if so */
		}
	}
	mutex_unlock(&import_list_lock);
}

void umpp_import_handlers_term(umpp_session * session)
{
	int i;
	mutex_lock(&import_list_lock);
	for ( i = 1; i < UMPP_EXTERNAL_MEM_COUNT; i++ )
	{
		/* only call if session_begin succeeded */
		if (session->import_handler_data[i] != NULL)
		{
			/* if session_beging succeeded the handler
			 * should not have unregistered with us */
			BUG_ON(!import_handlers[i]);
			import_handlers[i]->session_end(session->import_handler_data[i]);
			session->import_handler_data[i] = NULL;
		}
	}
	mutex_unlock(&import_list_lock);
}

int ump_import_module_register(enum ump_external_memory_type type, struct ump_import_handler * handler)
{
	int res = -EEXIST;

	/* validate input */
	BUG_ON(type == 0 || type >= UMPP_EXTERNAL_MEM_COUNT);
	BUG_ON(!handler);
	BUG_ON(!handler->linux_module);
	BUG_ON(!handler->session_begin);
	BUG_ON(!handler->session_end);
	BUG_ON(!handler->import);

	mutex_lock(&import_list_lock);

	if (!import_handlers[type])
	{
		import_handlers[type] = handler;
		res = 0;
	}

	mutex_unlock(&import_list_lock);

	return res;
}

void ump_import_module_unregister(enum ump_external_memory_type type)
{
	BUG_ON(type == 0 || type >= UMPP_EXTERNAL_MEM_COUNT);

	mutex_lock(&import_list_lock);
	/* an error to call this if ump_import_module_register didn't succeed */
	BUG_ON(!import_handlers[type]);
	import_handlers[type] = NULL;
	mutex_unlock(&import_list_lock);
}

static struct ump_import_handler * import_handler_get(unsigned int type_id)
{
	enum ump_external_memory_type type;
	struct ump_import_handler * handler;

	/* validate and convert input */
	/* handle bad data here, not just BUG_ON */
	if (type_id == 0 || type_id >= UMPP_EXTERNAL_MEM_COUNT)
		return NULL;

	type = (enum ump_external_memory_type)type_id;

	/* find the handler */
	mutex_lock(&import_list_lock);

	handler = import_handlers[type];

	if (handler)
	{
		if (!try_module_get(handler->linux_module))
		{
			handler = NULL;
		}
	}

	mutex_unlock(&import_list_lock);

	return handler;
}

static void import_handler_put(struct ump_import_handler * handler)
{
	module_put(handler->linux_module);
}

static int do_ump_dd_import(umpp_session * session, ump_k_import * params)
{
	ump_dd_handle new_allocation = UMP_DD_INVALID_MEMORY_HANDLE;
	struct ump_import_handler * handler;

	handler = import_handler_get(params->type);

	if (handler)
	{
		/* try late binding if not already bound */
		if (!session->import_handler_data[params->type])
		{
			handler->session_begin(&session->import_handler_data[params->type]);
		}

		/* do we have a bound session? */
		if (session->import_handler_data[params->type])
		{
			new_allocation = handler->import( session->import_handler_data[params->type],
		                                      params->phandle.value,
		                                      params->alloc_flags);
		}

		/* done with the handler */
		import_handler_put(handler);
	}

	/* did the import succeed? */
	if (UMP_DD_INVALID_MEMORY_HANDLE != new_allocation)
	{
		umpp_session_memory_usage * tracker;

		tracker = kmalloc(sizeof(*tracker), GFP_KERNEL | __GFP_HARDWALL);
		if (NULL != tracker)
		{
			/* update the return struct with the new ID */
			params->secure_id = ump_dd_secure_id_get(new_allocation);

			tracker->mem = new_allocation;
			tracker->id = params->secure_id;
			atomic_set(&tracker->process_usage_count, 1);

			/* link it into the session in-use list */
			mutex_lock(&session->session_lock);
			list_add(&tracker->link, &session->memory_usage);
			mutex_unlock(&session->session_lock);

			return 0;
		}
		ump_dd_release(new_allocation);
	}

	return -ENOMEM;

}

#ifdef HAVE_UNLOCKED_IOCTL
static long umpp_linux_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
#else
static int umpp_linux_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
#endif
{
	int ret;
	uint64_t msg[(UMP_CALL_MAX_SIZE+7)>>3]; /* alignment fixup */
	uint32_t size = _IOC_SIZE(cmd);
	struct umpp_session *session = filp->private_data;

#ifndef HAVE_UNLOCKED_IOCTL
	(void)inode; /* unused arg */
#endif

	/*
	 * extract the type and number bitfields, and don't decode
	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
	 */
	if (_IOC_TYPE(cmd) != UMP_IOC_MAGIC)
	{
		return -ENOTTY;

	}
	if (_IOC_NR(cmd) > UMP_IOC_MAXNR)
	{
		return -ENOTTY;
	}

	switch(cmd)
	{
		case UMP_FUNC_ALLOCATE:
			if (size != sizeof(ump_k_allocate))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user *)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_allocate(session, (ump_k_allocate *)&msg);
			if (ret)
			{
				return ret;
			}
			if (copy_to_user((void *)arg, &msg, size))
			{
				return -EFAULT;
			}
			return 0;
		case UMP_FUNC_SIZEQUERY:
			if (size != sizeof(ump_k_sizequery))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user *)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_sizequery(session,(ump_k_sizequery*) &msg);
			if (ret)
			{
				return ret;
			}
			if (copy_to_user((void *)arg, &msg, size))
			{
				return -EFAULT;
			}
			return 0;
		case UMP_FUNC_MSYNC:
			if (size != sizeof(ump_k_msync))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user *)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_msync_now(session,(ump_k_msync*) &msg);
			if (ret)
			{
				return ret;
			}
			if (copy_to_user((void *)arg, &msg, size))
			{
				return -EFAULT;
			}
			return 0;
		case UMP_FUNC_IMPORT:
			if (size != sizeof(ump_k_import))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user*)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_import(session, (ump_k_import*) &msg);
			if (ret)
			{
				return ret;
			}
			if (copy_to_user((void *)arg, &msg, size))
			{
				return -EFAULT;
			}
			return 0;
		/* used only by v1 API */
		case UMP_FUNC_ALLOCATION_FLAGS_GET:
			if (size != sizeof(ump_k_allocation_flags))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user *)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_allocation_flags_get(session,(ump_k_allocation_flags*) &msg);
			if (ret)
			{
				return ret;
			}
			if (copy_to_user((void *)arg, &msg, size))
			{
				return -EFAULT;
			}
			return 0;
		case UMP_FUNC_RETAIN:
			if (size != sizeof(ump_k_retain))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user *)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_retain(session,(ump_k_retain*) &msg);
			if (ret)
			{
				return ret;
			}
			return 0;
		case UMP_FUNC_RELEASE:
			if (size != sizeof(ump_k_release))
			{
				return -ENOTTY;
			}
			if (copy_from_user(&msg, (void __user *)arg, size))
			{
				return -EFAULT;
			}
			ret = do_ump_dd_release(session,(ump_k_release*) &msg);
			if (ret)
			{
				return ret;
			}
			return 0;
		default:
			/* not ours */
			return -ENOTTY;
	}
	/*redundant below*/
	return -ENOTTY;
}


/* Export UMP kernel space API functions */
EXPORT_SYMBOL(ump_dd_allocate_64);
EXPORT_SYMBOL(ump_dd_allocation_flags_get);
EXPORT_SYMBOL(ump_dd_secure_id_get);
EXPORT_SYMBOL(ump_dd_from_secure_id);
EXPORT_SYMBOL(ump_dd_phys_blocks_get_64);
EXPORT_SYMBOL(ump_dd_size_get_64);
EXPORT_SYMBOL(ump_dd_retain);
EXPORT_SYMBOL(ump_dd_release);
EXPORT_SYMBOL(ump_dd_create_from_phys_blocks_64);
#ifdef CONFIG_KDS
EXPORT_SYMBOL(ump_dd_kds_resource_get);
#endif

/* import API */
EXPORT_SYMBOL(ump_import_module_register);
EXPORT_SYMBOL(ump_import_module_unregister);



/* V1 API */
EXPORT_SYMBOL(ump_dd_handle_create_from_secure_id);
EXPORT_SYMBOL(ump_dd_phys_block_count_get);
EXPORT_SYMBOL(ump_dd_phys_block_get);
EXPORT_SYMBOL(ump_dd_phys_blocks_get);
EXPORT_SYMBOL(ump_dd_size_get);
EXPORT_SYMBOL(ump_dd_reference_add);
EXPORT_SYMBOL(ump_dd_reference_release);
EXPORT_SYMBOL(ump_dd_handle_create_from_phys_blocks);


/* Setup init and exit functions for this module */
module_init(umpp_linux_initialize_module);
module_exit(umpp_linux_cleanup_module);

/* And some module informatio */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("ARM Ltd.");
MODULE_VERSION(UMP_REV_STRING);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*************************************************************************/ /*!
@File
@Title          Services Firmware image utilities used at init time
@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
@Description    Services Firmware image utilities used at init time
@License        Dual MIT/GPLv2

The contents of this file are subject to the MIT license as set out below.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Alternatively, the contents of this file may be used under the terms of
the GNU General Public License Version 2 ("GPL") in which case the provisions
of GPL are applicable instead of those above.

If you wish to allow use of your version of this file only under the terms of
GPL, and not to allow others to use your version of this file under the terms
of the MIT license, indicate your decision by deleting the provisions above
and replace them with the notice and other provisions required by GPL as set
out in the file called "GPL-COPYING" included in this distribution. If you do
not delete the provisions above, a recipient may use your version of this file
under the terms of either the MIT license or GPL.

This License is also included in this distribution in the file called
"MIT-COPYING".

EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ /**************************************************************************/

#include "rgxfwimageutils.h"

#if defined(RGX_FEATURE_MIPS)
#include "pvr_debug.h"
#endif


/************************************************************************
* FW Segments configuration
************************************************************************/
typedef struct _RGX_FW_SEGMENT_
{
	IMG_UINT32 ui32SegId;        /*!< Segment Id */
	IMG_UINT32 ui32SegStartAddr; /*!< Segment Start Addr */
	IMG_UINT32 ui32SegAllocSize; /*!< Amount of memory to allocate for that segment */
	IMG_UINT32 ui32FWMemOffset;  /*!< Offset of this segment in the collated FW mem allocation */
	IMG_CHAR   *pszSegName;
} RGX_FW_SEGMENT;


#if defined(RGX_FEATURE_META)
static RGX_FW_SEGMENT asRGXFWCodeSegments[] = {
/* Seg ID                 Seg Start Addr           Alloc size   FWMem offset  Name */
{RGXFW_SEGMMU_TEXT_ID,    RGXFW_BOOTLDR_META_ADDR, 0x31000,      0,           "Bootldr and Code"}, /* Has to be the first one to get the proper DevV addr */
};
static RGX_FW_SEGMENT asRGXFWDataSegments[] = {
/* Seg ID                 Seg Start Addr           Alloc size   FWMem offset  Name */
{RGXFW_SEGMMU_DATA_ID,    0x38880000,              0x17000,      0,           "Local Shared and Data"},
};
#else
static RGX_FW_SEGMENT asRGXFWCodeSegments[] = {
/* Seg ID   Seg Start Addr                         Alloc size                         FWMem offset                         Name */
{    0,     RGXMIPSFW_BOOT_NMI_CODE_VIRTUAL_BASE,  RGXMIPSFW_BOOT_NMI_CODE_SIZE,      RGXMIPSFW_BOOT_NMI_CODE_OFFSET,      "Bootldr and NMI code"},
{    1,     RGXMIPSFW_EXCEPTIONS_VIRTUAL_BASE,     RGXMIPSFW_EXCEPTIONSVECTORS_SIZE,  RGXMIPSFW_EXCEPTIONSVECTORS_OFFSET,  "Exception vectors"},
{    2,     RGXMIPSFW_CODE_VIRTUAL_BASE,           RGXMIPSFW_CODE_SIZE,               RGXMIPSFW_CODE_OFFSET,               "Text"},
};
static RGX_FW_SEGMENT asRGXFWDataSegments[] = {
/* Seg ID   Seg Start Addr                         Alloc size                         FWMem offset                         Name */
{    3,     RGXMIPSFW_BOOT_NMI_DATA_VIRTUAL_BASE,  RGXMIPSFW_BOOT_NMI_DATA_SIZE,      RGXMIPSFW_BOOT_NMI_DATA_OFFSET,      "Bootldr and NMI data"},
{    4,     RGXMIPSFW_DATA_VIRTUAL_BASE,           RGXMIPSFW_DATA_SIZE,               RGXMIPSFW_DATA_OFFSET,               "Local Data"},
{    5,     RGXMIPSFW_STACK_VIRTUAL_BASE,          RGXMIPSFW_STACK_SIZE,              RGXMIPSFW_DATA_SIZE,                 "Stack"},
};
#endif

#define RGXFW_NUM_CODE_SEGMENTS  (sizeof(asRGXFWCodeSegments)/sizeof(asRGXFWCodeSegments[0]))
#define RGXFW_NUM_DATA_SEGMENTS  (sizeof(asRGXFWDataSegments)/sizeof(asRGXFWDataSegments[0]))


/*!
*******************************************************************************

 @Function      FindMMUSegment

 @Description   Given a 32 bit FW address attempt to find the corresponding
                pointer to FW allocation

 @Input         ui32OffsetIn      : 32 bit FW address
 @Input         pvHostFWCodeAddr  : Pointer to FW code
 @Input         pvHostFWDataAddr  : Pointer to FW data
 @Input         uiHostAddrOut     : CPU pointer equivalent to ui32OffsetIn

 @Return        PVRSRV_ERROR

******************************************************************************/
static PVRSRV_ERROR FindMMUSegment(IMG_UINT32 ui32OffsetIn,
                                   void *pvHostFWCodeAddr,
                                   void *pvHostFWDataAddr,
                                   void **uiHostAddrOut)
{
	RGX_FW_SEGMENT *psSegArr;
	IMG_UINT32 i;

	psSegArr = asRGXFWCodeSegments;
	for (i = 0; i < RGXFW_NUM_CODE_SEGMENTS; i++)
	{
		if ((ui32OffsetIn >= psSegArr[i].ui32SegStartAddr) &&
		    (ui32OffsetIn < (psSegArr[i].ui32SegStartAddr + psSegArr[i].ui32SegAllocSize)))
		{
			*uiHostAddrOut = pvHostFWCodeAddr;
			goto found;
		}
	}

	psSegArr = asRGXFWDataSegments;
	for (i = 0; i < RGXFW_NUM_DATA_SEGMENTS; i++)
	{
		if ((ui32OffsetIn >= psSegArr[i].ui32SegStartAddr) &&
		   (ui32OffsetIn < (psSegArr[i].ui32SegStartAddr + psSegArr[i].ui32SegAllocSize)))
		{
			*uiHostAddrOut = pvHostFWDataAddr;
			goto found;
		}
	}

	return PVRSRV_ERROR_INIT_FAILURE;

found:
	/* Direct Mem write to mapped memory */
	ui32OffsetIn -= psSegArr[i].ui32SegStartAddr;
	ui32OffsetIn += psSegArr[i].ui32FWMemOffset;

	/* Add offset to pointer to FW allocation only if
	 * that allocation is available
	 */
	if (*uiHostAddrOut)
	{
		*(IMG_UINT8 **)uiHostAddrOut += ui32OffsetIn;
	}

	return PVRSRV_OK;
}

#if defined(RGX_FEATURE_META)
/*!
*******************************************************************************

 @Function      RGXFWConfigureSegID

 @Description   Configures a single segment of the Segment MMU
                (base, limit and out_addr)

 @Input         hPrivate        : Implementation specific data
 @Input         ui64SegOutAddr  : Segment output base address (40 bit devVaddr)
 @Input         ui32SegBase     : Segment input base address (32 bit FW address)
 @Input         ui32SegLimit    : Segment size
 @Input         ui32SegID       : Segment ID
 @Input         pszName         : Segment name
 @Input         ppui32BootConf  : Pointer to bootloader data

 @Return        void

******************************************************************************/
static void RGXFWConfigureSegID(const void *hPrivate,
                                IMG_UINT64 ui64SegOutAddr,
                                IMG_UINT32 ui32SegBase,
                                IMG_UINT32 ui32SegLimit,
                                IMG_UINT32 ui32SegID,
                                IMG_CHAR* pszName,
                                IMG_UINT32 **ppui32BootConf)
{
	IMG_UINT32 *pui32BootConf = *ppui32BootConf;
	IMG_UINT32 ui32SegOutAddr0  = ui64SegOutAddr & 0x00000000FFFFFFFFUL;
	IMG_UINT32 ui32SegOutAddr1  = (ui64SegOutAddr >> 32) & 0x00000000FFFFFFFFUL;

	/* META segments have a minimum size */
	IMG_UINT32 ui32LimitOff = (ui32SegLimit < RGXFW_SEGMMU_ALIGN) ?
	                          RGXFW_SEGMMU_ALIGN : ui32SegLimit;
	/* the limit is an offset, therefore off = size - 1 */
	ui32LimitOff -= 1;

	RGXCommentLogInit(hPrivate,
	                  "* FW %s - seg%d: meta_addr = 0x%08x, devv_addr = 0x%llx, limit = 0x%x",
	                  pszName, ui32SegID,
	                  ui32SegBase, (unsigned long long)ui64SegOutAddr,
	                  ui32LimitOff);

	ui32SegBase |= RGXFW_SEGMMU_ALLTHRS_WRITEABLE;

	*pui32BootConf++ = META_CR_MMCU_SEGMENTn_BASE(ui32SegID);
	*pui32BootConf++ = ui32SegBase;

	*pui32BootConf++ = META_CR_MMCU_SEGMENTn_LIMIT(ui32SegID);
	*pui32BootConf++ = ui32LimitOff;

	*pui32BootConf++ = META_CR_MMCU_SEGMENTn_OUTA0(ui32SegID);
	*pui32BootConf++ = ui32SegOutAddr0;

	*pui32BootConf++ = META_CR_MMCU_SEGMENTn_OUTA1(ui32SegID);
	*pui32BootConf++ = ui32SegOutAddr1;

	*ppui32BootConf = pui32BootConf;
}

/*!
*******************************************************************************

 @Function      RGXFWConfigureSegMMU

 @Description   Configures META's Segment MMU

 @Input         hPrivate             : Implementation specific data
 @Input         psFWCodeDevVAddrBase : FW code base device virtual address
 @Input         psFWDataDevVAddrBase : FW data base device virtual address
 @Input         ppui32BootConf       : Pointer to bootloader data

 @Return        void

******************************************************************************/
static void RGXFWConfigureSegMMU(const void       *hPrivate,
                                 IMG_DEV_VIRTADDR *psFWCodeDevVAddrBase,
                                 IMG_DEV_VIRTADDR *psFWDataDevVAddrBase,
                                 IMG_UINT32       **ppui32BootConf)
{
	IMG_UINT64 ui64SegOutAddr;
	IMG_UINT32 i;

	PVR_UNREFERENCED_PARAMETER(psFWCodeDevVAddrBase);

	/* Configure Segment MMU */
	RGXCommentLogInit(hPrivate, "********** FW configure Segment MMU **********");

	for (i = 0; i < RGXFW_NUM_DATA_SEGMENTS; i++)
	{
		ui64SegOutAddr = (psFWDataDevVAddrBase->uiAddr |
		                  RGXFW_SEGMMU_OUTADDR_TOP(META_MMU_CONTEXT_MAPPING, RGXFW_SEGMMU_META_DM_ID)) +
		                  asRGXFWDataSegments[i].ui32FWMemOffset;

		RGXFWConfigureSegID(hPrivate,
		                    ui64SegOutAddr,
		                    asRGXFWDataSegments[i].ui32SegStartAddr,
		                    asRGXFWDataSegments[i].ui32SegAllocSize,
		                    asRGXFWDataSegments[i].ui32SegId,
		                    asRGXFWDataSegments[i].pszSegName,
		                    ppui32BootConf); /*write the sequence to the bootldr */
	}
}

/*!
*******************************************************************************

 @Function      RGXFWConfigureMetaCaches

 @Description   Configure and enable the Meta instruction and data caches

 @Input         hPrivate          : Implementation specific data
 @Input         ui32NumThreads    : Number of FW threads in use
 @Input         ui32MainThreadID  : ID of the FW thread in use
                                    (only meaningful if ui32NumThreads == 1)
 @Input         ppui32BootConf    : Pointer to bootloader data

 @Return        void

******************************************************************************/
static void RGXFWConfigureMetaCaches(const void *hPrivate,
                                     IMG_UINT32 ui32NumThreads,
                                     IMG_UINT32 ui32MainThreadID,
                                     IMG_UINT32 **ppui32BootConf)
{
	IMG_UINT32 *pui32BootConf = *ppui32BootConf;
	IMG_UINT32 ui32DCacheT0, ui32ICacheT0;
	IMG_UINT32 ui32DCacheT1, ui32ICacheT1;
	IMG_UINT32 ui32DCacheT2, ui32ICacheT2;
	IMG_UINT32 ui32DCacheT3, ui32ICacheT3;

#define META_CR_MMCU_LOCAL_EBCTRL                        (0x04830600)
#define META_CR_MMCU_LOCAL_EBCTRL_ICWIN                  (0x3 << 14)
#define META_CR_MMCU_LOCAL_EBCTRL_DCWIN                  (0x3 << 6)
#define META_CR_SYSC_DCPART(n)                           (0x04830200 + (n)*0x8)
#define META_CR_SYSC_DCPARTX_CACHED_WRITE_ENABLE         (0x1 << 31)
#define META_CR_SYSC_ICPART(n)                           (0x04830220 + (n)*0x8)
#define META_CR_SYSC_XCPARTX_LOCAL_ADDR_OFFSET_TOP_HALF  (0x8 << 16)
#define META_CR_SYSC_XCPARTX_LOCAL_ADDR_FULL_CACHE       (0xF)
#define META_CR_SYSC_XCPARTX_LOCAL_ADDR_HALF_CACHE       (0x7)
#define META_CR_MMCU_DCACHE_CTRL                         (0x04830018)
#define META_CR_MMCU_ICACHE_CTRL                         (0x04830020)
#define META_CR_MMCU_XCACHE_CTRL_CACHE_HITS_EN           (0x1)

	RGXCommentLogInit(hPrivate, "********** Meta caches configuration *********");

	/* Initialise I/Dcache settings */
	ui32DCacheT0 = ui32DCacheT1 = META_CR_SYSC_DCPARTX_CACHED_WRITE_ENABLE;
	ui32DCacheT2 = ui32DCacheT3 = META_CR_SYSC_DCPARTX_CACHED_WRITE_ENABLE;
	ui32ICacheT0 = ui32ICacheT1 = ui32ICacheT2 = ui32ICacheT3 = 0;

	if (ui32NumThreads == 1)
	{
		if (ui32MainThreadID == 0)
		{
			ui32DCacheT0 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_FULL_CACHE;
			ui32ICacheT0 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_FULL_CACHE;
		}
		else
		{
			ui32DCacheT1 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_FULL_CACHE;
			ui32ICacheT1 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_FULL_CACHE;
		}
	}
	else
	{
		ui32DCacheT0 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_HALF_CACHE;
		ui32ICacheT0 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_HALF_CACHE;

		ui32DCacheT1 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_HALF_CACHE |
		                META_CR_SYSC_XCPARTX_LOCAL_ADDR_OFFSET_TOP_HALF;
		ui32ICacheT1 |= META_CR_SYSC_XCPARTX_LOCAL_ADDR_HALF_CACHE |
		                META_CR_SYSC_XCPARTX_LOCAL_ADDR_OFFSET_TOP_HALF;
	}

	/* Local region MMU enhanced bypass: WIN-3 mode for code and data caches */
	*pui32BootConf++ = META_CR_MMCU_LOCAL_EBCTRL;
	*pui32BootConf++ = META_CR_MMCU_LOCAL_EBCTRL_ICWIN |
	                   META_CR_MMCU_LOCAL_EBCTRL_DCWIN;

	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_MMCU_LOCAL_EBCTRL,
	                  META_CR_MMCU_LOCAL_EBCTRL_ICWIN | META_CR_MMCU_LOCAL_EBCTRL_DCWIN);

	/* Data cache partitioning thread 0 to 3 */
	*pui32BootConf++ = META_CR_SYSC_DCPART(0);
	*pui32BootConf++ = ui32DCacheT0;
	*pui32BootConf++ = META_CR_SYSC_DCPART(1);
	*pui32BootConf++ = ui32DCacheT1;
	*pui32BootConf++ = META_CR_SYSC_DCPART(2);
	*pui32BootConf++ = ui32DCacheT2;
	*pui32BootConf++ = META_CR_SYSC_DCPART(3);
	*pui32BootConf++ = ui32DCacheT3;

	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_DCPART(0), ui32DCacheT0);
	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_DCPART(1), ui32DCacheT1);
	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_DCPART(2), ui32DCacheT2);
	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_DCPART(3), ui32DCacheT3);

	/* Enable data cache hits */
	*pui32BootConf++ = META_CR_MMCU_DCACHE_CTRL;
	*pui32BootConf++ = META_CR_MMCU_XCACHE_CTRL_CACHE_HITS_EN;

	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_MMCU_DCACHE_CTRL,
	                  META_CR_MMCU_XCACHE_CTRL_CACHE_HITS_EN);

	/* Instruction cache partitioning thread 0 to 3 */
	*pui32BootConf++ = META_CR_SYSC_ICPART(0);
	*pui32BootConf++ = ui32ICacheT0;
	*pui32BootConf++ = META_CR_SYSC_ICPART(1);
	*pui32BootConf++ = ui32ICacheT1;
	*pui32BootConf++ = META_CR_SYSC_ICPART(2);
	*pui32BootConf++ = ui32ICacheT2;
	*pui32BootConf++ = META_CR_SYSC_ICPART(3);
	*pui32BootConf++ = ui32ICacheT3;

	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_ICPART(0), ui32ICacheT0);
	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_ICPART(1), ui32ICacheT1);
	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_ICPART(2), ui32ICacheT2);
	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_SYSC_ICPART(3), ui32ICacheT3);

	/* Enable instruction cache hits */
	*pui32BootConf++ = META_CR_MMCU_ICACHE_CTRL;
	*pui32BootConf++ = META_CR_MMCU_XCACHE_CTRL_CACHE_HITS_EN;

	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  META_CR_MMCU_ICACHE_CTRL,
	                  META_CR_MMCU_XCACHE_CTRL_CACHE_HITS_EN);

	*pui32BootConf++ = 0x040000C0;
	*pui32BootConf++ = 0;

	RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
	                  0x040000C0, 0);

	*ppui32BootConf = pui32BootConf;
}

/*!
*******************************************************************************

 @Function      ProcessLDRCommandStream

 @Description   Process the output of the Meta toolchain in the .LDR format
                copying code and data sections into their final location and
                passing some information to the Meta bootloader

 @Input         hPrivate             : Implementation specific data
 @Input         pbLDR                : Pointer to FW blob
 @Input         pvHostFWCodeAddr     : Pointer to FW code
 @Input         pvHostFWDataAddr     : Pointer to FW data
 @Input         pvHostFWCorememAddr  : Pointer to FW coremem code
 @Input         ppui32BootConf       : Pointer to bootloader data

 @Return        PVRSRV_ERROR

******************************************************************************/
static PVRSRV_ERROR ProcessLDRCommandStream(const void *hPrivate,
                                            const IMG_BYTE* pbLDR,
                                            void* pvHostFWCodeAddr,
                                            void* pvHostFWDataAddr,
                                            void* pvHostFWCorememAddr,
                                            IMG_UINT32 **ppui32BootConf)
{
	RGX_META_LDR_BLOCK_HDR *psHeader = (RGX_META_LDR_BLOCK_HDR *) pbLDR;
	RGX_META_LDR_L1_DATA_BLK *psL1Data =
	    (RGX_META_LDR_L1_DATA_BLK*) ((IMG_UINT8 *) pbLDR + psHeader->ui32SLData);

	IMG_UINT32 *pui32BootConf = *ppui32BootConf;

	RGXCommentLogInit(hPrivate, "**********************************************");
	RGXCommentLogInit(hPrivate, "************** Begin LDR Parsing *************");
	RGXCommentLogInit(hPrivate, "**********************************************");

	while (psL1Data != NULL)
	{
		if (RGX_META_LDR_BLK_IS_COMMENT(psL1Data->ui16Cmd))
		{
			/* Don't process comment blocks */
			goto NextBlock;
		}

		switch (psL1Data->ui16Cmd & RGX_META_LDR_CMD_MASK)
		{
			case RGX_META_LDR_CMD_LOADMEM:
			{
				RGX_META_LDR_L2_DATA_BLK *psL2Block =
				    (RGX_META_LDR_L2_DATA_BLK*) (((IMG_UINT8 *) pbLDR) + psL1Data->aui32CmdData[1]);
				IMG_UINT32 ui32Offset = psL1Data->aui32CmdData[0];
				IMG_UINT32 ui32DataSize = psL2Block->ui16Length - 6 /* L2 Tag length and checksum */;
				void *pvWriteAddr;
				PVRSRV_ERROR eError;

				if (RGX_META_IS_COREMEM_CODE(ui32Offset))
				{
					if(pvHostFWCorememAddr == NULL)
					{
						RGXErrorLogInit(hPrivate,
						                "ProcessLDRCommandStream: Coremem code found"
 						                "but no coremem allocation available!");

						return PVRSRV_ERROR_INIT_FAILURE;
					}

					/* Copy coremem data to buffer. The FW copies it to the actual coremem */
					ui32Offset -= RGX_META_COREMEM_CODE_BADDR;
#if defined(RGX_META_COREMEM_CODE) || defined(RGX_META_COREMEM_DATA)
					RGXMemCopy(hPrivate,
					           (void*)((IMG_UINT8 *)pvHostFWCorememAddr + ui32Offset),
					           psL2Block->aui32BlockData,
					           ui32DataSize);
#else
					/* no need to copy the dummy symbols */
					PVR_UNREFERENCED_PARAMETER(pvHostFWCorememAddr);
#endif
				}
				else
				{
					/* Global range is aliased to local range */
					ui32Offset &= ~META_MEM_GLOBAL_RANGE_BIT;

					eError = FindMMUSegment(ui32Offset,
					                        pvHostFWCodeAddr,
					                        pvHostFWDataAddr,
					                        &pvWriteAddr);

					if (eError != PVRSRV_OK)
					{
						RGXErrorLogInit(hPrivate,
						                "ProcessLDRCommandStream: Addr 0x%x (size: %d) not found in any segment",
						                ui32Offset, ui32DataSize);
						return eError;
					}

					/* Write to FW allocation only if available */
					if (pvWriteAddr)
					{
						RGXMemCopy(hPrivate,
						           pvWriteAddr,
						           psL2Block->aui32BlockData,
						           ui32DataSize);
					}
				}

				break;
			}
			case RGX_META_LDR_CMD_LOADCORE:
			case RGX_META_LDR_CMD_LOADMMREG:
			{
				return PVRSRV_ERROR_INIT_FAILURE;
			}
			case RGX_META_LDR_CMD_START_THREADS:
			{
				/* Don't process this block */
				break;
			}
			case RGX_META_LDR_CMD_ZEROMEM:
			{
				IMG_UINT32 ui32Offset = psL1Data->aui32CmdData[0];
				IMG_UINT32 ui32ByteCount = psL1Data->aui32CmdData[1];
				void *pvWriteAddr;
				PVRSRV_ERROR  eError;

				if (RGX_META_IS_COREMEM_DATA(ui32Offset))
				{
					/* cannot zero coremem directly */
					break;
				}

				/* Global range is aliased to local range */
				ui32Offset &= ~META_MEM_GLOBAL_RANGE_BIT;

				eError = FindMMUSegment(ui32Offset,
				                        pvHostFWCodeAddr,
				                        pvHostFWDataAddr,
				                        &pvWriteAddr);

				if(eError != PVRSRV_OK)
				{
					RGXErrorLogInit(hPrivate,
					                "ProcessLDRCommandStream: Addr 0x%x (size: %d) not found in any segment",
					                ui32Offset, ui32ByteCount);
					return eError;
				}

				/* Write to FW allocation only if available */
				if (pvWriteAddr)
				{
					RGXMemSet(hPrivate, pvWriteAddr, 0, ui32ByteCount);
				}

				break;
			}
			case RGX_META_LDR_CMD_CONFIG:
			{
				RGX_META_LDR_L2_DATA_BLK *psL2Block =
				    (RGX_META_LDR_L2_DATA_BLK*) (((IMG_UINT8 *) pbLDR) + psL1Data->aui32CmdData[0]);
				RGX_META_LDR_CFG_BLK *psConfigCommand = (RGX_META_LDR_CFG_BLK*) psL2Block->aui32BlockData;
				IMG_UINT32 ui32L2BlockSize = psL2Block->ui16Length - 6 /* L2 Tag length and checksum */;
				IMG_UINT32 ui32CurrBlockSize = 0;

				while(ui32L2BlockSize)
				{
					switch (psConfigCommand->ui32Type)
					{
						case RGX_META_LDR_CFG_PAUSE:
						case RGX_META_LDR_CFG_READ:
						{
							ui32CurrBlockSize = 8;
							return PVRSRV_ERROR_INIT_FAILURE;
						}
						case RGX_META_LDR_CFG_WRITE:
						{
							IMG_UINT32 ui32RegisterOffset = psConfigCommand->aui32BlockData[0];
							IMG_UINT32 ui32RegisterValue  = psConfigCommand->aui32BlockData[1];

							/* Only write to bootloader if we got a valid
							 * pointer to the FW code allocation
							 */
							if (pui32BootConf)
							{
								/* Do register write */
								*pui32BootConf++ = ui32RegisterOffset;
								*pui32BootConf++ = ui32RegisterValue;
							}

							RGXCommentLogInit(hPrivate, "Meta SP: [0x%08x] = 0x%08x",
							                  ui32RegisterOffset, ui32RegisterValue);

							ui32CurrBlockSize = 12;
							break;
						}
						case RGX_META_LDR_CFG_MEMSET:
						case RGX_META_LDR_CFG_MEMCHECK:
						{
							ui32CurrBlockSize = 20;
							return PVRSRV_ERROR_INIT_FAILURE;
						}
						default:
						{
							return PVRSRV_ERROR_INIT_FAILURE;
						}
					}
					ui32L2BlockSize -= ui32CurrBlockSize;
					psConfigCommand = (RGX_META_LDR_CFG_BLK*) (((IMG_UINT8*) psConfigCommand) + ui32CurrBlockSize);
				}

				break;
			}
			default:
			{
				return PVRSRV_ERROR_INIT_FAILURE;
			}
		}

NextBlock:

		if (psL1Data->ui32Next == 0xFFFFFFFF)
		{
			psL1Data = NULL;
		}
		else
		{
			psL1Data = (RGX_META_LDR_L1_DATA_BLK*) (((IMG_UINT8 *) pbLDR) + psL1Data->ui32Next);
		}
	}

	*ppui32BootConf = pui32BootConf;

	RGXCommentLogInit(hPrivate, "**********************************************");
	RGXCommentLogInit(hPrivate, "************** End Loader Parsing ************");
	RGXCommentLogInit(hPrivate, "**********************************************");

	return PVRSRV_OK;
}
#else /* RGX_FEATURE_META */
/*!
*******************************************************************************

 @Function      ProcessELFCommandStream

 @Description   Process the output of the Mips toolchain in the .ELF format
                copying code and data sections into their final location

 @Input         hPrivate          : Implementation specific data
 @Input         pbELF             : Pointer to FW blob
 @Input         pvHostFWCodeAddr  : Pointer to FW code
 @Input         pvHostFWDataAddr  : Pointer to FW data

 @Return        PVRSRV_ERROR

******************************************************************************/
static PVRSRV_ERROR ProcessELFCommandStream(const void *hPrivate,
                                            const IMG_BYTE *pbELF,
                                            void *pvHostFWCodeAddr,
                                            void *pvHostFWDataAddr)
{
	IMG_UINT32 ui32Entry;
	RGX_MIPS_ELF_HDR *psHeader = (RGX_MIPS_ELF_HDR *)pbELF;
	RGX_MIPS_ELF_PROGRAM_HDR *psProgramHeader =
	    (RGX_MIPS_ELF_PROGRAM_HDR *)(pbELF + psHeader->ui32Ephoff);
	PVRSRV_ERROR eError;

	for (ui32Entry = 0; ui32Entry < psHeader->ui32Ephnum; ui32Entry++, psProgramHeader++)
	{
		void *pvWriteAddr;

		/* Only consider loadable entries in the ELF segment table */
		if (psProgramHeader->ui32Ptype != ELF_PT_LOAD) continue;

		eError = FindMMUSegment(psProgramHeader->ui32Pvaddr,
		                        pvHostFWCodeAddr,
		                        pvHostFWDataAddr,
		                        &pvWriteAddr);

		if (eError != PVRSRV_OK)
		{
			RGXErrorLogInit(hPrivate,
			                "ProcessLDRCommandStream: Addr 0x%x (size: %d) not found in any segment",
			                psProgramHeader->ui32Pvaddr,
			                psProgramHeader->ui32Pfilesz);
			return eError;
		}

		/* Write to FW allocation only if available */
		if (pvWriteAddr)
		{
			RGXMemCopy(hPrivate,
			           pvWriteAddr,
			           (IMG_PBYTE)(pbELF + psProgramHeader->ui32Poffset),
			           psProgramHeader->ui32Pfilesz);

			RGXMemSet(hPrivate,
			          (IMG_PBYTE)pvWriteAddr + psProgramHeader->ui32Pfilesz,
			          0,
			          psProgramHeader->ui32Pmemsz - psProgramHeader->ui32Pfilesz);
		}
	}

	return PVRSRV_OK;
}
#endif /* RGX_FEATURE_META */


void RGXGetFWImageAllocSize(IMG_DEVMEM_SIZE_T *puiFWCodeAllocSize,
                            IMG_DEVMEM_SIZE_T *puiFWDataAllocSize,
                            IMG_DEVMEM_SIZE_T *puiFWCorememAllocSize)
{
	IMG_UINT32 i;

	*puiFWCodeAllocSize = 0;
	*puiFWDataAllocSize = 0;
	*puiFWCorememAllocSize = 0;

	/* Calculate how much memory the FW needs for its code and data segments */

	for(i = 0; i < RGXFW_NUM_CODE_SEGMENTS; i++) {
		*puiFWCodeAllocSize += asRGXFWCodeSegments[i].ui32SegAllocSize;
	}

	for(i = 0; i < RGXFW_NUM_DATA_SEGMENTS; i++) {
		*puiFWDataAllocSize += asRGXFWDataSegments[i].ui32SegAllocSize;
	}

#if defined(RGX_META_COREMEM_CODE)
	*puiFWCorememAllocSize = RGX_META_COREMEM_CODE_SIZE;
#endif

#if defined(RGX_FEATURE_MIPS)
	PVR_ASSERT((*puiFWCodeAllocSize % RGXMIPSFW_PAGE_SIZE) == 0);
	PVR_ASSERT((*puiFWDataAllocSize % RGXMIPSFW_PAGE_SIZE) == 0);
#endif
}


PVRSRV_ERROR RGXProcessFWImage(const void           *hPrivate,
                               const IMG_BYTE       *pbRGXFirmware,
                               void                 *pvFWCode,
                               void                 *pvFWData,
                               void                 *pvFWCorememCode,
                               IMG_DEV_VIRTADDR     *psFWCodeDevVAddrBase,
                               IMG_DEV_VIRTADDR     *psFWDataDevVAddrBase,
                               IMG_DEV_VIRTADDR     *psFWCorememDevVAddrBase,
                               RGXFWIF_DEV_VIRTADDR *psFWCorememFWAddr,
                               RGXFWIF_DEV_VIRTADDR *psRGXFwInit,
                               IMG_UINT32           ui32NumThreads,
                               IMG_UINT32           ui32MainThreadID)
{
	PVRSRV_ERROR eError = PVRSRV_OK;

#if defined(RGX_FEATURE_META)
	IMG_UINT32 *pui32BootConf = NULL;

	/* Skip bootloader configuration if a pointer to the FW code
	 * allocation is not available
	 */
	if (pvFWCode)
	{
		/* This variable points to the bootloader code which is mostly
		 * a sequence of <register address,register value> pairs
		 */
		pui32BootConf = ((IMG_UINT32*) pvFWCode) + RGXFW_BOOTLDR_CONF_OFFSET;
	
		/* Slave port and JTAG accesses are privileged */
		*pui32BootConf++ = META_CR_SYSC_JTAG_THREAD;
		*pui32BootConf++ = META_CR_SYSC_JTAG_THREAD_PRIV_EN;

		RGXFWConfigureSegMMU(hPrivate,
		                     psFWCodeDevVAddrBase,
		                     psFWDataDevVAddrBase,
		                     &pui32BootConf);
	}

	/* Process FW image data stream */
	eError = ProcessLDRCommandStream(hPrivate,
	                                 pbRGXFirmware,
	                                 pvFWCode,
	                                 pvFWData,
	                                 pvFWCorememCode,
	                                 &pui32BootConf);
	if (eError != PVRSRV_OK)
	{
		RGXErrorLogInit(hPrivate, "RGXProcessFWImage: Processing FW image failed (%d)", eError);
		return eError;
	}

	/* Skip bootloader configuration if a pointer to the FW code
	 * allocation is not available
	 */
	if (pvFWCode)
	{
		if ((ui32NumThreads == 0) || (ui32NumThreads > 2) || (ui32MainThreadID >= 2))
		{
			RGXErrorLogInit(hPrivate,
			                "ProcessFWImage: Wrong Meta threads configuration, using one thread only");

			ui32NumThreads = 1;
			ui32MainThreadID = 0;
		}

		RGXFWConfigureMetaCaches(hPrivate,
		                         ui32NumThreads,
		                         ui32MainThreadID,
		                         &pui32BootConf);

		/* Signal the end of the conf sequence */
		*pui32BootConf++ = 0x0;
		*pui32BootConf++ = 0x0;

		/* The FW main argv arguments start here */
		*pui32BootConf++ = psRGXFwInit->ui32Addr;

#if defined(RGX_META_COREMEM_CODE) || defined(RGX_META_COREMEM_DATA)
		*pui32BootConf++ = psFWCorememFWAddr->ui32Addr;
#else
		PVR_UNREFERENCED_PARAMETER(psFWCorememFWAddr);
#endif

#if defined(RGX_FEATURE_META_DMA)
		*pui32BootConf++ = (IMG_UINT32) (psFWCorememDevVAddrBase->uiAddr >> 32);
		*pui32BootConf++ = (IMG_UINT32) psFWCorememDevVAddrBase->uiAddr;
#else
		PVR_UNREFERENCED_PARAMETER(psFWCorememDevVAddrBase);
#endif
	}

#else /* defined(RGX_FEATURE_META) */
	/* Process FW image data stream */
	eError = ProcessELFCommandStream(hPrivate,
	                                 pbRGXFirmware,
	                                 pvFWCode,
	                                 pvFWData);
	if (eError != PVRSRV_OK)
	{
		RGXErrorLogInit(hPrivate, "RGXProcessFWImage: Processing FW image failed (%d)", eError);
		return eError;
	}

	PVR_UNREFERENCED_PARAMETER(pvFWCorememCode); /* Coremem N/A in MIPS */
	PVR_UNREFERENCED_PARAMETER(psFWCodeDevVAddrBase);
	PVR_UNREFERENCED_PARAMETER(psFWDataDevVAddrBase);
	PVR_UNREFERENCED_PARAMETER(psFWCorememDevVAddrBase);
	PVR_UNREFERENCED_PARAMETER(psFWCorememFWAddr);
	PVR_UNREFERENCED_PARAMETER(psRGXFwInit);
	PVR_UNREFERENCED_PARAMETER(ui32NumThreads);
	PVR_UNREFERENCED_PARAMETER(ui32MainThreadID);
#endif

	return eError;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright (C) 2015 MediaTek Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */


#ifndef __STEP_C_H__
#define __STEP_C_H__


#include <linux/wakelock.h>
#include <linux/interrupt.h>
#include <linux/miscdevice.h>
#include <linux/platform_device.h>
#include <linux/input.h>
#include <linux/workqueue.h>
#include <linux/slab.h>
#include <linux/module.h>

#include <linux/i2c.h>
#include <linux/irq.h>
#include <linux/uaccess.h>
#include <linux/delay.h>
#include <linux/kobject.h>
#include <linux/atomic.h>
#include <linux/ioctl.h>

#include <batch.h>
#include <sensors_io.h>
#include <hwmsen_helper.h>
#include <hwmsensor.h>
#include <hwmsen_dev.h>



#define STEP_C_TAG					"<STEP_COUNTER> "
#define STEP_C_FUN(f)				pr_err(STEP_C_TAG"%s\n", __func__)
#define STEP_C_ERR(fmt, args...)	pr_err(STEP_C_TAG"%s %d : "fmt, __func__, __LINE__, ##args)
#define STEP_C_LOG(fmt, args...)	pr_err(STEP_C_TAG fmt, ##args)
#define STEP_C_VER(fmt, args...)	pr_err(STEP_C_TAG"%s: "fmt, __func__, ##args) /* ((void)0) */

#define	OP_STEP_C_DELAY		0X01
#define	OP_STEP_C_ENABLE		0X02
#define	OP_STEP_C_GET_DATA	0X04

#define STEP_C_INVALID_VALUE -1

#define EVENT_TYPE_STEP_C_VALUE				ABS_X
#define EVENT_TYPE_STEP_C_STATUS			ABS_WHEEL
#define EVENT_TYPE_STEP_DETECTOR_VALUE		REL_Y
#define EVENT_TYPE_SIGNIFICANT_VALUE		REL_Z



#define STEP_C_VALUE_MAX (32767)
#define STEP_C_VALUE_MIN (-32768)
#define STEP_C_STATUS_MIN (0)
#define STEP_C_STATUS_MAX (64)
#define STEP_C_DIV_MAX (32767)
#define STEP_C_DIV_MIN (1)


#define MAX_CHOOSE_STEP_C_NUM 5

struct step_c_control_path {
	int (*open_report_data)(int open);/* open data rerport to HAL */
	int (*enable_nodata)(int en);/* only enable not report event to HAL */
	int (*enable_step_detect)(int en);
	int (*enable_significant)(int en);
	int (*step_c_set_delay)(u64 delay);
	int (*step_d_set_delay)(u64 delay);
	bool is_report_input_direct;
	bool is_support_batch;/* version2.used for batch mode support flag */
};

struct step_c_data_path {
	int (*get_data)(uint32_t *value, int *status);
	int (*get_data_step_d)(uint32_t *value, int *status);
	int (*get_data_significant)(uint32_t *value, int *status);
	int vender_div;
};

struct step_c_init_info {
	char *name;
	int (*init)(void);
	int (*uninit)(void);
	struct platform_driver *platform_diver_addr;
};

struct step_c_data {
	uint32_t counter;
	int status;
	int data_updata;
};

struct step_c_drv_obj {
	void *self;
	int polling;
	int (*step_c_operate)(void *self, uint32_t command, void *buff_in, int size_in,
		void *buff_out, int size_out, int *actualout);
};

struct step_c_context {
	struct input_dev   *idev;
	struct miscdevice   mdev;
	struct work_struct  report;
	struct mutex step_c_op_mutex;
	atomic_t            delay; /*polling period for reporting input event*/
	atomic_t            wake;  /*user-space request to wake-up, used with stop*/
	struct timer_list   timer;  /* polling timer */
	atomic_t            trace;

	atomic_t                early_suspend;

	struct step_c_data       drv_data;
	struct step_c_control_path   step_c_ctl;
	struct step_c_data_path   step_c_data;
	bool			is_active_nodata;
	bool			is_active_data;		/* Active and HAL need data . */
	bool		is_first_data_after_enable;
	bool		is_polling_run;
	bool		is_step_c_batch_enable;	/* version2.this is used for judging whether sensor is in batch mode */
	bool		is_step_d_batch_enable;	/* version2.this is used for judging whether sensor is in batch mode */
};

/* for auto detect */
typedef enum {
	TYPE_STEP_NON   = 0,
	TYPE_STEP_DETECTOR  = 1,
	TYPE_SIGNIFICANT = 2

} STEP_NOTIFY_TYPE;

extern int  step_notify(STEP_NOTIFY_TYPE type);

extern int step_c_driver_add(struct step_c_init_info *obj);
extern int step_c_data_report(struct input_dev *dev, uint32_t value, int status);
extern int step_c_register_control_path(struct step_c_control_path *ctl);
extern int step_c_register_data_path(struct step_c_data_path *data);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* b44.c: Broadcom 44xx/47xx Fast Ethernet device driver.
 *
 * Copyright (C) 2002 David S. Miller (davem@redhat.com)
 * Copyright (C) 2004 Pekka Pietikainen (pp@ee.oulu.fi)
 * Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
 * Copyright (C) 2006 Felix Fietkau (nbd@openwrt.org)
 * Copyright (C) 2006 Broadcom Corporation.
 * Copyright (C) 2007 Michael Buesch <m@bues.ch>
 * Copyright (C) 2013 Hauke Mehrtens <hauke@hauke-m.de>
 *
 * Distribute under GPL.
 */

#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/types.h>
#include <linux/netdevice.h>
#include <linux/ethtool.h>
#include <linux/mii.h>
#include <linux/if_ether.h>
#include <linux/if_vlan.h>
#include <linux/etherdevice.h>
#include <linux/pci.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/dma-mapping.h>
#include <linux/ssb/ssb.h>
#include <linux/slab.h>
#include <linux/phy.h>

#include <asm/uaccess.h>
#include <asm/io.h>
#include <asm/irq.h>


#include "b44.h"

#define DRV_MODULE_NAME		"b44"
#define DRV_MODULE_VERSION	"2.0"
#define DRV_DESCRIPTION		"Broadcom 44xx/47xx 10/100 PCI ethernet driver"

#define B44_DEF_MSG_ENABLE	  \
	(NETIF_MSG_DRV		| \
	 NETIF_MSG_PROBE	| \
	 NETIF_MSG_LINK		| \
	 NETIF_MSG_TIMER	| \
	 NETIF_MSG_IFDOWN	| \
	 NETIF_MSG_IFUP		| \
	 NETIF_MSG_RX_ERR	| \
	 NETIF_MSG_TX_ERR)

/* length of time before we decide the hardware is borked,
 * and dev->tx_timeout() should be called to fix the problem
 */
#define B44_TX_TIMEOUT			(5 * HZ)

/* hardware minimum and maximum for a single frame's data payload */
#define B44_MIN_MTU			60
#define B44_MAX_MTU			1500

#define B44_RX_RING_SIZE		512
#define B44_DEF_RX_RING_PENDING		200
#define B44_RX_RING_BYTES	(sizeof(struct dma_desc) * \
				 B44_RX_RING_SIZE)
#define B44_TX_RING_SIZE		512
#define B44_DEF_TX_RING_PENDING		(B44_TX_RING_SIZE - 1)
#define B44_TX_RING_BYTES	(sizeof(struct dma_desc) * \
				 B44_TX_RING_SIZE)

#define TX_RING_GAP(BP)	\
	(B44_TX_RING_SIZE - (BP)->tx_pending)
#define TX_BUFFS_AVAIL(BP)						\
	(((BP)->tx_cons <= (BP)->tx_prod) ?				\
	  (BP)->tx_cons + (BP)->tx_pending - (BP)->tx_prod :		\
	  (BP)->tx_cons - (BP)->tx_prod - TX_RING_GAP(BP))
#define NEXT_TX(N)		(((N) + 1) & (B44_TX_RING_SIZE - 1))

#define RX_PKT_OFFSET		(RX_HEADER_LEN + 2)
#define RX_PKT_BUF_SZ		(1536 + RX_PKT_OFFSET)

/* minimum number of free TX descriptors required to wake up TX process */
#define B44_TX_WAKEUP_THRESH		(B44_TX_RING_SIZE / 4)

/* b44 internal pattern match filter info */
#define B44_PATTERN_BASE	0x400
#define B44_PATTERN_SIZE	0x80
#define B44_PMASK_BASE		0x600
#define B44_PMASK_SIZE		0x10
#define B44_MAX_PATTERNS	16
#define B44_ETHIPV6UDP_HLEN	62
#define B44_ETHIPV4UDP_HLEN	42

MODULE_AUTHOR("Felix Fietkau, Florian Schirmer, Pekka Pietikainen, David S. Miller");
MODULE_DESCRIPTION(DRV_DESCRIPTION);
MODULE_LICENSE("GPL");
MODULE_VERSION(DRV_MODULE_VERSION);

static int b44_debug = -1;	/* -1 == use B44_DEF_MSG_ENABLE as value */
module_param(b44_debug, int, 0);
MODULE_PARM_DESC(b44_debug, "B44 bitmapped debugging message enable value");


#ifdef CONFIG_B44_PCI
static const struct pci_device_id b44_pci_tbl[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_BCM4401) },
	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_BCM4401B0) },
	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_BCM4401B1) },
	{ 0 } /* terminate list with empty entry */
};
MODULE_DEVICE_TABLE(pci, b44_pci_tbl);

static struct pci_driver b44_pci_driver = {
	.name		= DRV_MODULE_NAME,
	.id_table	= b44_pci_tbl,
};
#endif /* CONFIG_B44_PCI */

static const struct ssb_device_id b44_ssb_tbl[] = {
	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_ETHERNET, SSB_ANY_REV),
	SSB_DEVTABLE_END
};
MODULE_DEVICE_TABLE(ssb, b44_ssb_tbl);

static void b44_halt(struct b44 *);
static void b44_init_rings(struct b44 *);

#define B44_FULL_RESET		1
#define B44_FULL_RESET_SKIP_PHY	2
#define B44_PARTIAL_RESET	3
#define B44_CHIP_RESET_FULL	4
#define B44_CHIP_RESET_PARTIAL	5

static void b44_init_hw(struct b44 *, int);

static int dma_desc_sync_size;
static int instance;

static const char b44_gstrings[][ETH_GSTRING_LEN] = {
#define _B44(x...)	# x,
B44_STAT_REG_DECLARE
#undef _B44
};

static inline void b44_sync_dma_desc_for_device(struct ssb_device *sdev,
						dma_addr_t dma_base,
						unsigned long offset,
						enum dma_data_direction dir)
{
	dma_sync_single_for_device(sdev->dma_dev, dma_base + offset,
				   dma_desc_sync_size, dir);
}

static inline void b44_sync_dma_desc_for_cpu(struct ssb_device *sdev,
					     dma_addr_t dma_base,
					     unsigned long offset,
					     enum dma_data_direction dir)
{
	dma_sync_single_for_cpu(sdev->dma_dev, dma_base + offset,
				dma_desc_sync_size, dir);
}

static inline unsigned long br32(const struct b44 *bp, unsigned long reg)
{
	return ssb_read32(bp->sdev, reg);
}

static inline void bw32(const struct b44 *bp,
			unsigned long reg, unsigned long val)
{
	ssb_write32(bp->sdev, reg, val);
}

static int b44_wait_bit(struct b44 *bp, unsigned long reg,
			u32 bit, unsigned long timeout, const int clear)
{
	unsigned long i;

	for (i = 0; i < timeout; i++) {
		u32 val = br32(bp, reg);

		if (clear && !(val & bit))
			break;
		if (!clear && (val & bit))
			break;
		udelay(10);
	}
	if (i == timeout) {
		if (net_ratelimit())
			netdev_err(bp->dev, "BUG!  Timeout waiting for bit %08x of register %lx to %s\n",
				   bit, reg, clear ? "clear" : "set");

		return -ENODEV;
	}
	return 0;
}

static inline void __b44_cam_read(struct b44 *bp, unsigned char *data, int index)
{
	u32 val;

	bw32(bp, B44_CAM_CTRL, (CAM_CTRL_READ |
			    (index << CAM_CTRL_INDEX_SHIFT)));

	b44_wait_bit(bp, B44_CAM_CTRL, CAM_CTRL_BUSY, 100, 1);

	val = br32(bp, B44_CAM_DATA_LO);

	data[2] = (val >> 24) & 0xFF;
	data[3] = (val >> 16) & 0xFF;
	data[4] = (val >> 8) & 0xFF;
	data[5] = (val >> 0) & 0xFF;

	val = br32(bp, B44_CAM_DATA_HI);

	data[0] = (val >> 8) & 0xFF;
	data[1] = (val >> 0) & 0xFF;
}

static inline void __b44_cam_write(struct b44 *bp, unsigned char *data, int index)
{
	u32 val;

	val  = ((u32) data[2]) << 24;
	val |= ((u32) data[3]) << 16;
	val |= ((u32) data[4]) <<  8;
	val |= ((u32) data[5]) <<  0;
	bw32(bp, B44_CAM_DATA_LO, val);
	val = (CAM_DATA_HI_VALID |
	       (((u32) data[0]) << 8) |
	       (((u32) data[1]) << 0));
	bw32(bp, B44_CAM_DATA_HI, val);
	bw32(bp, B44_CAM_CTRL, (CAM_CTRL_WRITE |
			    (index << CAM_CTRL_INDEX_SHIFT)));
	b44_wait_bit(bp, B44_CAM_CTRL, CAM_CTRL_BUSY, 100, 1);
}

static inline void __b44_disable_ints(struct b44 *bp)
{
	bw32(bp, B44_IMASK, 0);
}

static void b44_disable_ints(struct b44 *bp)
{
	__b44_disable_ints(bp);

	/* Flush posted writes. */
	br32(bp, B44_IMASK);
}

static void b44_enable_ints(struct b44 *bp)
{
	bw32(bp, B44_IMASK, bp->imask);
}

static int __b44_readphy(struct b44 *bp, int phy_addr, int reg, u32 *val)
{
	int err;

	bw32(bp, B44_EMAC_ISTAT, EMAC_INT_MII);
	bw32(bp, B44_MDIO_DATA, (MDIO_DATA_SB_START |
			     (MDIO_OP_READ << MDIO_DATA_OP_SHIFT) |
			     (phy_addr << MDIO_DATA_PMD_SHIFT) |
			     (reg << MDIO_DATA_RA_SHIFT) |
			     (MDIO_TA_VALID << MDIO_DATA_TA_SHIFT)));
	err = b44_wait_bit(bp, B44_EMAC_ISTAT, EMAC_INT_MII, 100, 0);
	*val = br32(bp, B44_MDIO_DATA) & MDIO_DATA_DATA;

	return err;
}

static int __b44_writephy(struct b44 *bp, int phy_addr, int reg, u32 val)
{
	bw32(bp, B44_EMAC_ISTAT, EMAC_INT_MII);
	bw32(bp, B44_MDIO_DATA, (MDIO_DATA_SB_START |
			     (MDIO_OP_WRITE << MDIO_DATA_OP_SHIFT) |
			     (phy_addr << MDIO_DATA_PMD_SHIFT) |
			     (reg << MDIO_DATA_RA_SHIFT) |
			     (MDIO_TA_VALID << MDIO_DATA_TA_SHIFT) |
			     (val & MDIO_DATA_DATA)));
	return b44_wait_bit(bp, B44_EMAC_ISTAT, EMAC_INT_MII, 100, 0);
}

static inline int b44_readphy(struct b44 *bp, int reg, u32 *val)
{
	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		return 0;

	return __b44_readphy(bp, bp->phy_addr, reg, val);
}

static inline int b44_writephy(struct b44 *bp, int reg, u32 val)
{
	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		return 0;

	return __b44_writephy(bp, bp->phy_addr, reg, val);
}

/* miilib interface */
static int b44_mdio_read_mii(struct net_device *dev, int phy_id, int location)
{
	u32 val;
	struct b44 *bp = netdev_priv(dev);
	int rc = __b44_readphy(bp, phy_id, location, &val);
	if (rc)
		return 0xffffffff;
	return val;
}

static void b44_mdio_write_mii(struct net_device *dev, int phy_id, int location,
			       int val)
{
	struct b44 *bp = netdev_priv(dev);
	__b44_writephy(bp, phy_id, location, val);
}

static int b44_mdio_read_phylib(struct mii_bus *bus, int phy_id, int location)
{
	u32 val;
	struct b44 *bp = bus->priv;
	int rc = __b44_readphy(bp, phy_id, location, &val);
	if (rc)
		return 0xffffffff;
	return val;
}

static int b44_mdio_write_phylib(struct mii_bus *bus, int phy_id, int location,
				 u16 val)
{
	struct b44 *bp = bus->priv;
	return __b44_writephy(bp, phy_id, location, val);
}

static int b44_phy_reset(struct b44 *bp)
{
	u32 val;
	int err;

	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		return 0;
	err = b44_writephy(bp, MII_BMCR, BMCR_RESET);
	if (err)
		return err;
	udelay(100);
	err = b44_readphy(bp, MII_BMCR, &val);
	if (!err) {
		if (val & BMCR_RESET) {
			netdev_err(bp->dev, "PHY Reset would not complete\n");
			err = -ENODEV;
		}
	}

	return err;
}

static void __b44_set_flow_ctrl(struct b44 *bp, u32 pause_flags)
{
	u32 val;

	bp->flags &= ~(B44_FLAG_TX_PAUSE | B44_FLAG_RX_PAUSE);
	bp->flags |= pause_flags;

	val = br32(bp, B44_RXCONFIG);
	if (pause_flags & B44_FLAG_RX_PAUSE)
		val |= RXCONFIG_FLOW;
	else
		val &= ~RXCONFIG_FLOW;
	bw32(bp, B44_RXCONFIG, val);

	val = br32(bp, B44_MAC_FLOW);
	if (pause_flags & B44_FLAG_TX_PAUSE)
		val |= (MAC_FLOW_PAUSE_ENAB |
			(0xc0 & MAC_FLOW_RX_HI_WATER));
	else
		val &= ~MAC_FLOW_PAUSE_ENAB;
	bw32(bp, B44_MAC_FLOW, val);
}

static void b44_set_flow_ctrl(struct b44 *bp, u32 local, u32 remote)
{
	u32 pause_enab = 0;

	/* The driver supports only rx pause by default because
	   the b44 mac tx pause mechanism generates excessive
	   pause frames.
	   Use ethtool to turn on b44 tx pause if necessary.
	 */
	if ((local & ADVERTISE_PAUSE_CAP) &&
	    (local & ADVERTISE_PAUSE_ASYM)){
		if ((remote & LPA_PAUSE_ASYM) &&
		    !(remote & LPA_PAUSE_CAP))
			pause_enab |= B44_FLAG_RX_PAUSE;
	}

	__b44_set_flow_ctrl(bp, pause_enab);
}

#ifdef CONFIG_BCM47XX
#include <bcm47xx_nvram.h>
static void b44_wap54g10_workaround(struct b44 *bp)
{
	char buf[20];
	u32 val;
	int err;

	/*
	 * workaround for bad hardware design in Linksys WAP54G v1.0
	 * see https://dev.openwrt.org/ticket/146
	 * check and reset bit "isolate"
	 */
	if (bcm47xx_nvram_getenv("boardnum", buf, sizeof(buf)) < 0)
		return;
	if (simple_strtoul(buf, NULL, 0) == 2) {
		err = __b44_readphy(bp, 0, MII_BMCR, &val);
		if (err)
			goto error;
		if (!(val & BMCR_ISOLATE))
			return;
		val &= ~BMCR_ISOLATE;
		err = __b44_writephy(bp, 0, MII_BMCR, val);
		if (err)
			goto error;
	}
	return;
error:
	pr_warn("PHY: cannot reset MII transceiver isolate bit\n");
}
#else
static inline void b44_wap54g10_workaround(struct b44 *bp)
{
}
#endif

static int b44_setup_phy(struct b44 *bp)
{
	u32 val;
	int err;

	b44_wap54g10_workaround(bp);

	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		return 0;
	if ((err = b44_readphy(bp, B44_MII_ALEDCTRL, &val)) != 0)
		goto out;
	if ((err = b44_writephy(bp, B44_MII_ALEDCTRL,
				val & MII_ALEDCTRL_ALLMSK)) != 0)
		goto out;
	if ((err = b44_readphy(bp, B44_MII_TLEDCTRL, &val)) != 0)
		goto out;
	if ((err = b44_writephy(bp, B44_MII_TLEDCTRL,
				val | MII_TLEDCTRL_ENABLE)) != 0)
		goto out;

	if (!(bp->flags & B44_FLAG_FORCE_LINK)) {
		u32 adv = ADVERTISE_CSMA;

		if (bp->flags & B44_FLAG_ADV_10HALF)
			adv |= ADVERTISE_10HALF;
		if (bp->flags & B44_FLAG_ADV_10FULL)
			adv |= ADVERTISE_10FULL;
		if (bp->flags & B44_FLAG_ADV_100HALF)
			adv |= ADVERTISE_100HALF;
		if (bp->flags & B44_FLAG_ADV_100FULL)
			adv |= ADVERTISE_100FULL;

		if (bp->flags & B44_FLAG_PAUSE_AUTO)
			adv |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;

		if ((err = b44_writephy(bp, MII_ADVERTISE, adv)) != 0)
			goto out;
		if ((err = b44_writephy(bp, MII_BMCR, (BMCR_ANENABLE |
						       BMCR_ANRESTART))) != 0)
			goto out;
	} else {
		u32 bmcr;

		if ((err = b44_readphy(bp, MII_BMCR, &bmcr)) != 0)
			goto out;
		bmcr &= ~(BMCR_FULLDPLX | BMCR_ANENABLE | BMCR_SPEED100);
		if (bp->flags & B44_FLAG_100_BASE_T)
			bmcr |= BMCR_SPEED100;
		if (bp->flags & B44_FLAG_FULL_DUPLEX)
			bmcr |= BMCR_FULLDPLX;
		if ((err = b44_writephy(bp, MII_BMCR, bmcr)) != 0)
			goto out;

		/* Since we will not be negotiating there is no safe way
		 * to determine if the link partner supports flow control
		 * or not.  So just disable it completely in this case.
		 */
		b44_set_flow_ctrl(bp, 0, 0);
	}

out:
	return err;
}

static void b44_stats_update(struct b44 *bp)
{
	unsigned long reg;
	u64 *val;

	val = &bp->hw_stats.tx_good_octets;
	u64_stats_update_begin(&bp->hw_stats.syncp);

	for (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL) {
		*val++ += br32(bp, reg);
	}

	/* Pad */
	reg += 8*4UL;

	for (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL) {
		*val++ += br32(bp, reg);
	}

	u64_stats_update_end(&bp->hw_stats.syncp);
}

static void b44_link_report(struct b44 *bp)
{
	if (!netif_carrier_ok(bp->dev)) {
		netdev_info(bp->dev, "Link is down\n");
	} else {
		netdev_info(bp->dev, "Link is up at %d Mbps, %s duplex\n",
			    (bp->flags & B44_FLAG_100_BASE_T) ? 100 : 10,
			    (bp->flags & B44_FLAG_FULL_DUPLEX) ? "full" : "half");

		netdev_info(bp->dev, "Flow control is %s for TX and %s for RX\n",
			    (bp->flags & B44_FLAG_TX_PAUSE) ? "on" : "off",
			    (bp->flags & B44_FLAG_RX_PAUSE) ? "on" : "off");
	}
}

static void b44_check_phy(struct b44 *bp)
{
	u32 bmsr, aux;

	if (bp->flags & B44_FLAG_EXTERNAL_PHY) {
		bp->flags |= B44_FLAG_100_BASE_T;
		if (!netif_carrier_ok(bp->dev)) {
			u32 val = br32(bp, B44_TX_CTRL);
			if (bp->flags & B44_FLAG_FULL_DUPLEX)
				val |= TX_CTRL_DUPLEX;
			else
				val &= ~TX_CTRL_DUPLEX;
			bw32(bp, B44_TX_CTRL, val);
			netif_carrier_on(bp->dev);
			b44_link_report(bp);
		}
		return;
	}

	if (!b44_readphy(bp, MII_BMSR, &bmsr) &&
	    !b44_readphy(bp, B44_MII_AUXCTRL, &aux) &&
	    (bmsr != 0xffff)) {
		if (aux & MII_AUXCTRL_SPEED)
			bp->flags |= B44_FLAG_100_BASE_T;
		else
			bp->flags &= ~B44_FLAG_100_BASE_T;
		if (aux & MII_AUXCTRL_DUPLEX)
			bp->flags |= B44_FLAG_FULL_DUPLEX;
		else
			bp->flags &= ~B44_FLAG_FULL_DUPLEX;

		if (!netif_carrier_ok(bp->dev) &&
		    (bmsr & BMSR_LSTATUS)) {
			u32 val = br32(bp, B44_TX_CTRL);
			u32 local_adv, remote_adv;

			if (bp->flags & B44_FLAG_FULL_DUPLEX)
				val |= TX_CTRL_DUPLEX;
			else
				val &= ~TX_CTRL_DUPLEX;
			bw32(bp, B44_TX_CTRL, val);

			if (!(bp->flags & B44_FLAG_FORCE_LINK) &&
			    !b44_readphy(bp, MII_ADVERTISE, &local_adv) &&
			    !b44_readphy(bp, MII_LPA, &remote_adv))
				b44_set_flow_ctrl(bp, local_adv, remote_adv);

			/* Link now up */
			netif_carrier_on(bp->dev);
			b44_link_report(bp);
		} else if (netif_carrier_ok(bp->dev) && !(bmsr & BMSR_LSTATUS)) {
			/* Link now down */
			netif_carrier_off(bp->dev);
			b44_link_report(bp);
		}

		if (bmsr & BMSR_RFAULT)
			netdev_warn(bp->dev, "Remote fault detected in PHY\n");
		if (bmsr & BMSR_JCD)
			netdev_warn(bp->dev, "Jabber detected in PHY\n");
	}
}

static void b44_timer(unsigned long __opaque)
{
	struct b44 *bp = (struct b44 *) __opaque;

	spin_lock_irq(&bp->lock);

	b44_check_phy(bp);

	b44_stats_update(bp);

	spin_unlock_irq(&bp->lock);

	mod_timer(&bp->timer, round_jiffies(jiffies + HZ));
}

static void b44_tx(struct b44 *bp)
{
	u32 cur, cons;
	unsigned bytes_compl = 0, pkts_compl = 0;

	cur  = br32(bp, B44_DMATX_STAT) & DMATX_STAT_CDMASK;
	cur /= sizeof(struct dma_desc);

	/* XXX needs updating when NETIF_F_SG is supported */
	for (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {
		struct ring_info *rp = &bp->tx_buffers[cons];
		struct sk_buff *skb = rp->skb;

		BUG_ON(skb == NULL);

		dma_unmap_single(bp->sdev->dma_dev,
				 rp->mapping,
				 skb->len,
				 DMA_TO_DEVICE);
		rp->skb = NULL;

		bytes_compl += skb->len;
		pkts_compl++;

		dev_kfree_skb_irq(skb);
	}

	netdev_completed_queue(bp->dev, pkts_compl, bytes_compl);
	bp->tx_cons = cons;
	if (netif_queue_stopped(bp->dev) &&
	    TX_BUFFS_AVAIL(bp) > B44_TX_WAKEUP_THRESH)
		netif_wake_queue(bp->dev);

	bw32(bp, B44_GPTIMER, 0);
}

/* Works like this.  This chip writes a 'struct rx_header" 30 bytes
 * before the DMA address you give it.  So we allocate 30 more bytes
 * for the RX buffer, DMA map all of it, skb_reserve the 30 bytes, then
 * point the chip at 30 bytes past where the rx_header will go.
 */
static int b44_alloc_rx_skb(struct b44 *bp, int src_idx, u32 dest_idx_unmasked)
{
	struct dma_desc *dp;
	struct ring_info *src_map, *map;
	struct rx_header *rh;
	struct sk_buff *skb;
	dma_addr_t mapping;
	int dest_idx;
	u32 ctrl;

	src_map = NULL;
	if (src_idx >= 0)
		src_map = &bp->rx_buffers[src_idx];
	dest_idx = dest_idx_unmasked & (B44_RX_RING_SIZE - 1);
	map = &bp->rx_buffers[dest_idx];
	skb = netdev_alloc_skb(bp->dev, RX_PKT_BUF_SZ);
	if (skb == NULL)
		return -ENOMEM;

	mapping = dma_map_single(bp->sdev->dma_dev, skb->data,
				 RX_PKT_BUF_SZ,
				 DMA_FROM_DEVICE);

	/* Hardware bug work-around, the chip is unable to do PCI DMA
	   to/from anything above 1GB :-( */
	if (dma_mapping_error(bp->sdev->dma_dev, mapping) ||
		mapping + RX_PKT_BUF_SZ > DMA_BIT_MASK(30)) {
		/* Sigh... */
		if (!dma_mapping_error(bp->sdev->dma_dev, mapping))
			dma_unmap_single(bp->sdev->dma_dev, mapping,
					     RX_PKT_BUF_SZ, DMA_FROM_DEVICE);
		dev_kfree_skb_any(skb);
		skb = alloc_skb(RX_PKT_BUF_SZ, GFP_ATOMIC | GFP_DMA);
		if (skb == NULL)
			return -ENOMEM;
		mapping = dma_map_single(bp->sdev->dma_dev, skb->data,
					 RX_PKT_BUF_SZ,
					 DMA_FROM_DEVICE);
		if (dma_mapping_error(bp->sdev->dma_dev, mapping) ||
		    mapping + RX_PKT_BUF_SZ > DMA_BIT_MASK(30)) {
			if (!dma_mapping_error(bp->sdev->dma_dev, mapping))
				dma_unmap_single(bp->sdev->dma_dev, mapping, RX_PKT_BUF_SZ,DMA_FROM_DEVICE);
			dev_kfree_skb_any(skb);
			return -ENOMEM;
		}
		bp->force_copybreak = 1;
	}

	rh = (struct rx_header *) skb->data;

	rh->len = 0;
	rh->flags = 0;

	map->skb = skb;
	map->mapping = mapping;

	if (src_map != NULL)
		src_map->skb = NULL;

	ctrl = (DESC_CTRL_LEN & RX_PKT_BUF_SZ);
	if (dest_idx == (B44_RX_RING_SIZE - 1))
		ctrl |= DESC_CTRL_EOT;

	dp = &bp->rx_ring[dest_idx];
	dp->ctrl = cpu_to_le32(ctrl);
	dp->addr = cpu_to_le32((u32) mapping + bp->dma_offset);

	if (bp->flags & B44_FLAG_RX_RING_HACK)
		b44_sync_dma_desc_for_device(bp->sdev, bp->rx_ring_dma,
			                    dest_idx * sizeof(*dp),
			                    DMA_BIDIRECTIONAL);

	return RX_PKT_BUF_SZ;
}

static void b44_recycle_rx(struct b44 *bp, int src_idx, u32 dest_idx_unmasked)
{
	struct dma_desc *src_desc, *dest_desc;
	struct ring_info *src_map, *dest_map;
	struct rx_header *rh;
	int dest_idx;
	__le32 ctrl;

	dest_idx = dest_idx_unmasked & (B44_RX_RING_SIZE - 1);
	dest_desc = &bp->rx_ring[dest_idx];
	dest_map = &bp->rx_buffers[dest_idx];
	src_desc = &bp->rx_ring[src_idx];
	src_map = &bp->rx_buffers[src_idx];

	dest_map->skb = src_map->skb;
	rh = (struct rx_header *) src_map->skb->data;
	rh->len = 0;
	rh->flags = 0;
	dest_map->mapping = src_map->mapping;

	if (bp->flags & B44_FLAG_RX_RING_HACK)
		b44_sync_dma_desc_for_cpu(bp->sdev, bp->rx_ring_dma,
			                 src_idx * sizeof(*src_desc),
			                 DMA_BIDIRECTIONAL);

	ctrl = src_desc->ctrl;
	if (dest_idx == (B44_RX_RING_SIZE - 1))
		ctrl |= cpu_to_le32(DESC_CTRL_EOT);
	else
		ctrl &= cpu_to_le32(~DESC_CTRL_EOT);

	dest_desc->ctrl = ctrl;
	dest_desc->addr = src_desc->addr;

	src_map->skb = NULL;

	if (bp->flags & B44_FLAG_RX_RING_HACK)
		b44_sync_dma_desc_for_device(bp->sdev, bp->rx_ring_dma,
					     dest_idx * sizeof(*dest_desc),
					     DMA_BIDIRECTIONAL);

	dma_sync_single_for_device(bp->sdev->dma_dev, dest_map->mapping,
				   RX_PKT_BUF_SZ,
				   DMA_FROM_DEVICE);
}

static int b44_rx(struct b44 *bp, int budget)
{
	int received;
	u32 cons, prod;

	received = 0;
	prod  = br32(bp, B44_DMARX_STAT) & DMARX_STAT_CDMASK;
	prod /= sizeof(struct dma_desc);
	cons = bp->rx_cons;

	while (cons != prod && budget > 0) {
		struct ring_info *rp = &bp->rx_buffers[cons];
		struct sk_buff *skb = rp->skb;
		dma_addr_t map = rp->mapping;
		struct rx_header *rh;
		u16 len;

		dma_sync_single_for_cpu(bp->sdev->dma_dev, map,
					RX_PKT_BUF_SZ,
					DMA_FROM_DEVICE);
		rh = (struct rx_header *) skb->data;
		len = le16_to_cpu(rh->len);
		if ((len > (RX_PKT_BUF_SZ - RX_PKT_OFFSET)) ||
		    (rh->flags & cpu_to_le16(RX_FLAG_ERRORS))) {
		drop_it:
			b44_recycle_rx(bp, cons, bp->rx_prod);
		drop_it_no_recycle:
			bp->dev->stats.rx_dropped++;
			goto next_pkt;
		}

		if (len == 0) {
			int i = 0;

			do {
				udelay(2);
				barrier();
				len = le16_to_cpu(rh->len);
			} while (len == 0 && i++ < 5);
			if (len == 0)
				goto drop_it;
		}

		/* Omit CRC. */
		len -= 4;

		if (!bp->force_copybreak && len > RX_COPY_THRESHOLD) {
			int skb_size;
			skb_size = b44_alloc_rx_skb(bp, cons, bp->rx_prod);
			if (skb_size < 0)
				goto drop_it;
			dma_unmap_single(bp->sdev->dma_dev, map,
					 skb_size, DMA_FROM_DEVICE);
			/* Leave out rx_header */
			skb_put(skb, len + RX_PKT_OFFSET);
			skb_pull(skb, RX_PKT_OFFSET);
		} else {
			struct sk_buff *copy_skb;

			b44_recycle_rx(bp, cons, bp->rx_prod);
			copy_skb = netdev_alloc_skb_ip_align(bp->dev, len);
			if (copy_skb == NULL)
				goto drop_it_no_recycle;

			skb_put(copy_skb, len);
			/* DMA sync done above, copy just the actual packet */
			skb_copy_from_linear_data_offset(skb, RX_PKT_OFFSET,
							 copy_skb->data, len);
			skb = copy_skb;
		}
		skb_checksum_none_assert(skb);
		skb->protocol = eth_type_trans(skb, bp->dev);
		netif_receive_skb(skb);
		received++;
		budget--;
	next_pkt:
		bp->rx_prod = (bp->rx_prod + 1) &
			(B44_RX_RING_SIZE - 1);
		cons = (cons + 1) & (B44_RX_RING_SIZE - 1);
	}

	bp->rx_cons = cons;
	bw32(bp, B44_DMARX_PTR, cons * sizeof(struct dma_desc));

	return received;
}

static int b44_poll(struct napi_struct *napi, int budget)
{
	struct b44 *bp = container_of(napi, struct b44, napi);
	int work_done;
	unsigned long flags;

	spin_lock_irqsave(&bp->lock, flags);

	if (bp->istat & (ISTAT_TX | ISTAT_TO)) {
		/* spin_lock(&bp->tx_lock); */
		b44_tx(bp);
		/* spin_unlock(&bp->tx_lock); */
	}
	if (bp->istat & ISTAT_RFO) {	/* fast recovery, in ~20msec */
		bp->istat &= ~ISTAT_RFO;
		b44_disable_ints(bp);
		ssb_device_enable(bp->sdev, 0); /* resets ISTAT_RFO */
		b44_init_rings(bp);
		b44_init_hw(bp, B44_FULL_RESET_SKIP_PHY);
		netif_wake_queue(bp->dev);
	}

	spin_unlock_irqrestore(&bp->lock, flags);

	work_done = 0;
	if (bp->istat & ISTAT_RX)
		work_done += b44_rx(bp, budget);

	if (bp->istat & ISTAT_ERRORS) {
		spin_lock_irqsave(&bp->lock, flags);
		b44_halt(bp);
		b44_init_rings(bp);
		b44_init_hw(bp, B44_FULL_RESET_SKIP_PHY);
		netif_wake_queue(bp->dev);
		spin_unlock_irqrestore(&bp->lock, flags);
		work_done = 0;
	}

	if (work_done < budget) {
		napi_complete(napi);
		b44_enable_ints(bp);
	}

	return work_done;
}

static irqreturn_t b44_interrupt(int irq, void *dev_id)
{
	struct net_device *dev = dev_id;
	struct b44 *bp = netdev_priv(dev);
	u32 istat, imask;
	int handled = 0;

	spin_lock(&bp->lock);

	istat = br32(bp, B44_ISTAT);
	imask = br32(bp, B44_IMASK);

	/* The interrupt mask register controls which interrupt bits
	 * will actually raise an interrupt to the CPU when set by hw/firmware,
	 * but doesn't mask off the bits.
	 */
	istat &= imask;
	if (istat) {
		handled = 1;

		if (unlikely(!netif_running(dev))) {
			netdev_info(dev, "late interrupt\n");
			goto irq_ack;
		}

		if (napi_schedule_prep(&bp->napi)) {
			/* NOTE: These writes are posted by the readback of
			 *       the ISTAT register below.
			 */
			bp->istat = istat;
			__b44_disable_ints(bp);
			__napi_schedule(&bp->napi);
		}

irq_ack:
		bw32(bp, B44_ISTAT, istat);
		br32(bp, B44_ISTAT);
	}
	spin_unlock(&bp->lock);
	return IRQ_RETVAL(handled);
}

static void b44_tx_timeout(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);

	netdev_err(dev, "transmit timed out, resetting\n");

	spin_lock_irq(&bp->lock);

	b44_halt(bp);
	b44_init_rings(bp);
	b44_init_hw(bp, B44_FULL_RESET);

	spin_unlock_irq(&bp->lock);

	b44_enable_ints(bp);

	netif_wake_queue(dev);
}

static netdev_tx_t b44_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);
	int rc = NETDEV_TX_OK;
	dma_addr_t mapping;
	u32 len, entry, ctrl;
	unsigned long flags;

	len = skb->len;
	spin_lock_irqsave(&bp->lock, flags);

	/* This is a hard error, log it. */
	if (unlikely(TX_BUFFS_AVAIL(bp) < 1)) {
		netif_stop_queue(dev);
		netdev_err(dev, "BUG! Tx Ring full when queue awake!\n");
		goto err_out;
	}

	mapping = dma_map_single(bp->sdev->dma_dev, skb->data, len, DMA_TO_DEVICE);
	if (dma_mapping_error(bp->sdev->dma_dev, mapping) || mapping + len > DMA_BIT_MASK(30)) {
		struct sk_buff *bounce_skb;

		/* Chip can't handle DMA to/from >1GB, use bounce buffer */
		if (!dma_mapping_error(bp->sdev->dma_dev, mapping))
			dma_unmap_single(bp->sdev->dma_dev, mapping, len,
					     DMA_TO_DEVICE);

		bounce_skb = alloc_skb(len, GFP_ATOMIC | GFP_DMA);
		if (!bounce_skb)
			goto err_out;

		mapping = dma_map_single(bp->sdev->dma_dev, bounce_skb->data,
					 len, DMA_TO_DEVICE);
		if (dma_mapping_error(bp->sdev->dma_dev, mapping) || mapping + len > DMA_BIT_MASK(30)) {
			if (!dma_mapping_error(bp->sdev->dma_dev, mapping))
				dma_unmap_single(bp->sdev->dma_dev, mapping,
						     len, DMA_TO_DEVICE);
			dev_kfree_skb_any(bounce_skb);
			goto err_out;
		}

		skb_copy_from_linear_data(skb, skb_put(bounce_skb, len), len);
		dev_kfree_skb_any(skb);
		skb = bounce_skb;
	}

	entry = bp->tx_prod;
	bp->tx_buffers[entry].skb = skb;
	bp->tx_buffers[entry].mapping = mapping;

	ctrl  = (len & DESC_CTRL_LEN);
	ctrl |= DESC_CTRL_IOC | DESC_CTRL_SOF | DESC_CTRL_EOF;
	if (entry == (B44_TX_RING_SIZE - 1))
		ctrl |= DESC_CTRL_EOT;

	bp->tx_ring[entry].ctrl = cpu_to_le32(ctrl);
	bp->tx_ring[entry].addr = cpu_to_le32((u32) mapping+bp->dma_offset);

	if (bp->flags & B44_FLAG_TX_RING_HACK)
		b44_sync_dma_desc_for_device(bp->sdev, bp->tx_ring_dma,
			                    entry * sizeof(bp->tx_ring[0]),
			                    DMA_TO_DEVICE);

	entry = NEXT_TX(entry);

	bp->tx_prod = entry;

	wmb();

	bw32(bp, B44_DMATX_PTR, entry * sizeof(struct dma_desc));
	if (bp->flags & B44_FLAG_BUGGY_TXPTR)
		bw32(bp, B44_DMATX_PTR, entry * sizeof(struct dma_desc));
	if (bp->flags & B44_FLAG_REORDER_BUG)
		br32(bp, B44_DMATX_PTR);

	netdev_sent_queue(dev, skb->len);

	if (TX_BUFFS_AVAIL(bp) < 1)
		netif_stop_queue(dev);

out_unlock:
	spin_unlock_irqrestore(&bp->lock, flags);

	return rc;

err_out:
	rc = NETDEV_TX_BUSY;
	goto out_unlock;
}

static int b44_change_mtu(struct net_device *dev, int new_mtu)
{
	struct b44 *bp = netdev_priv(dev);

	if (new_mtu < B44_MIN_MTU || new_mtu > B44_MAX_MTU)
		return -EINVAL;

	if (!netif_running(dev)) {
		/* We'll just catch it later when the
		 * device is up'd.
		 */
		dev->mtu = new_mtu;
		return 0;
	}

	spin_lock_irq(&bp->lock);
	b44_halt(bp);
	dev->mtu = new_mtu;
	b44_init_rings(bp);
	b44_init_hw(bp, B44_FULL_RESET);
	spin_unlock_irq(&bp->lock);

	b44_enable_ints(bp);

	return 0;
}

/* Free up pending packets in all rx/tx rings.
 *
 * The chip has been shut down and the driver detached from
 * the networking, so no interrupts or new tx packets will
 * end up in the driver.  bp->lock is not held and we are not
 * in an interrupt context and thus may sleep.
 */
static void b44_free_rings(struct b44 *bp)
{
	struct ring_info *rp;
	int i;

	for (i = 0; i < B44_RX_RING_SIZE; i++) {
		rp = &bp->rx_buffers[i];

		if (rp->skb == NULL)
			continue;
		dma_unmap_single(bp->sdev->dma_dev, rp->mapping, RX_PKT_BUF_SZ,
				 DMA_FROM_DEVICE);
		dev_kfree_skb_any(rp->skb);
		rp->skb = NULL;
	}

	/* XXX needs changes once NETIF_F_SG is set... */
	for (i = 0; i < B44_TX_RING_SIZE; i++) {
		rp = &bp->tx_buffers[i];

		if (rp->skb == NULL)
			continue;
		dma_unmap_single(bp->sdev->dma_dev, rp->mapping, rp->skb->len,
				 DMA_TO_DEVICE);
		dev_kfree_skb_any(rp->skb);
		rp->skb = NULL;
	}
}

/* Initialize tx/rx rings for packet processing.
 *
 * The chip has been shut down and the driver detached from
 * the networking, so no interrupts or new tx packets will
 * end up in the driver.
 */
static void b44_init_rings(struct b44 *bp)
{
	int i;

	b44_free_rings(bp);

	memset(bp->rx_ring, 0, B44_RX_RING_BYTES);
	memset(bp->tx_ring, 0, B44_TX_RING_BYTES);

	if (bp->flags & B44_FLAG_RX_RING_HACK)
		dma_sync_single_for_device(bp->sdev->dma_dev, bp->rx_ring_dma,
					   DMA_TABLE_BYTES, DMA_BIDIRECTIONAL);

	if (bp->flags & B44_FLAG_TX_RING_HACK)
		dma_sync_single_for_device(bp->sdev->dma_dev, bp->tx_ring_dma,
					   DMA_TABLE_BYTES, DMA_TO_DEVICE);

	for (i = 0; i < bp->rx_pending; i++) {
		if (b44_alloc_rx_skb(bp, -1, i) < 0)
			break;
	}
}

/*
 * Must not be invoked with interrupt sources disabled and
 * the hardware shutdown down.
 */
static void b44_free_consistent(struct b44 *bp)
{
	kfree(bp->rx_buffers);
	bp->rx_buffers = NULL;
	kfree(bp->tx_buffers);
	bp->tx_buffers = NULL;
	if (bp->rx_ring) {
		if (bp->flags & B44_FLAG_RX_RING_HACK) {
			dma_unmap_single(bp->sdev->dma_dev, bp->rx_ring_dma,
					 DMA_TABLE_BYTES, DMA_BIDIRECTIONAL);
			kfree(bp->rx_ring);
		} else
			dma_free_coherent(bp->sdev->dma_dev, DMA_TABLE_BYTES,
					  bp->rx_ring, bp->rx_ring_dma);
		bp->rx_ring = NULL;
		bp->flags &= ~B44_FLAG_RX_RING_HACK;
	}
	if (bp->tx_ring) {
		if (bp->flags & B44_FLAG_TX_RING_HACK) {
			dma_unmap_single(bp->sdev->dma_dev, bp->tx_ring_dma,
					 DMA_TABLE_BYTES, DMA_TO_DEVICE);
			kfree(bp->tx_ring);
		} else
			dma_free_coherent(bp->sdev->dma_dev, DMA_TABLE_BYTES,
					  bp->tx_ring, bp->tx_ring_dma);
		bp->tx_ring = NULL;
		bp->flags &= ~B44_FLAG_TX_RING_HACK;
	}
}

/*
 * Must not be invoked with interrupt sources disabled and
 * the hardware shutdown down.  Can sleep.
 */
static int b44_alloc_consistent(struct b44 *bp, gfp_t gfp)
{
	int size;

	size  = B44_RX_RING_SIZE * sizeof(struct ring_info);
	bp->rx_buffers = kzalloc(size, gfp);
	if (!bp->rx_buffers)
		goto out_err;

	size = B44_TX_RING_SIZE * sizeof(struct ring_info);
	bp->tx_buffers = kzalloc(size, gfp);
	if (!bp->tx_buffers)
		goto out_err;

	size = DMA_TABLE_BYTES;
	bp->rx_ring = dma_alloc_coherent(bp->sdev->dma_dev, size,
					 &bp->rx_ring_dma, gfp);
	if (!bp->rx_ring) {
		/* Allocation may have failed due to pci_alloc_consistent
		   insisting on use of GFP_DMA, which is more restrictive
		   than necessary...  */
		struct dma_desc *rx_ring;
		dma_addr_t rx_ring_dma;

		rx_ring = kzalloc(size, gfp);
		if (!rx_ring)
			goto out_err;

		rx_ring_dma = dma_map_single(bp->sdev->dma_dev, rx_ring,
					     DMA_TABLE_BYTES,
					     DMA_BIDIRECTIONAL);

		if (dma_mapping_error(bp->sdev->dma_dev, rx_ring_dma) ||
			rx_ring_dma + size > DMA_BIT_MASK(30)) {
			kfree(rx_ring);
			goto out_err;
		}

		bp->rx_ring = rx_ring;
		bp->rx_ring_dma = rx_ring_dma;
		bp->flags |= B44_FLAG_RX_RING_HACK;
	}

	bp->tx_ring = dma_alloc_coherent(bp->sdev->dma_dev, size,
					 &bp->tx_ring_dma, gfp);
	if (!bp->tx_ring) {
		/* Allocation may have failed due to ssb_dma_alloc_consistent
		   insisting on use of GFP_DMA, which is more restrictive
		   than necessary...  */
		struct dma_desc *tx_ring;
		dma_addr_t tx_ring_dma;

		tx_ring = kzalloc(size, gfp);
		if (!tx_ring)
			goto out_err;

		tx_ring_dma = dma_map_single(bp->sdev->dma_dev, tx_ring,
					     DMA_TABLE_BYTES,
					     DMA_TO_DEVICE);

		if (dma_mapping_error(bp->sdev->dma_dev, tx_ring_dma) ||
			tx_ring_dma + size > DMA_BIT_MASK(30)) {
			kfree(tx_ring);
			goto out_err;
		}

		bp->tx_ring = tx_ring;
		bp->tx_ring_dma = tx_ring_dma;
		bp->flags |= B44_FLAG_TX_RING_HACK;
	}

	return 0;

out_err:
	b44_free_consistent(bp);
	return -ENOMEM;
}

/* bp->lock is held. */
static void b44_clear_stats(struct b44 *bp)
{
	unsigned long reg;

	bw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);
	for (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL)
		br32(bp, reg);
	for (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL)
		br32(bp, reg);
}

/* bp->lock is held. */
static void b44_chip_reset(struct b44 *bp, int reset_kind)
{
	struct ssb_device *sdev = bp->sdev;
	bool was_enabled;

	was_enabled = ssb_device_is_enabled(bp->sdev);

	ssb_device_enable(bp->sdev, 0);
	ssb_pcicore_dev_irqvecs_enable(&sdev->bus->pcicore, sdev);

	if (was_enabled) {
		bw32(bp, B44_RCV_LAZY, 0);
		bw32(bp, B44_ENET_CTRL, ENET_CTRL_DISABLE);
		b44_wait_bit(bp, B44_ENET_CTRL, ENET_CTRL_DISABLE, 200, 1);
		bw32(bp, B44_DMATX_CTRL, 0);
		bp->tx_prod = bp->tx_cons = 0;
		if (br32(bp, B44_DMARX_STAT) & DMARX_STAT_EMASK) {
			b44_wait_bit(bp, B44_DMARX_STAT, DMARX_STAT_SIDLE,
				     100, 0);
		}
		bw32(bp, B44_DMARX_CTRL, 0);
		bp->rx_prod = bp->rx_cons = 0;
	}

	b44_clear_stats(bp);

	/*
	 * Don't enable PHY if we are doing a partial reset
	 * we are probably going to power down
	 */
	if (reset_kind == B44_CHIP_RESET_PARTIAL)
		return;

	switch (sdev->bus->bustype) {
	case SSB_BUSTYPE_SSB:
		bw32(bp, B44_MDIO_CTRL, (MDIO_CTRL_PREAMBLE |
		     (DIV_ROUND_CLOSEST(ssb_clockspeed(sdev->bus),
					B44_MDC_RATIO)
		     & MDIO_CTRL_MAXF_MASK)));
		break;
	case SSB_BUSTYPE_PCI:
		bw32(bp, B44_MDIO_CTRL, (MDIO_CTRL_PREAMBLE |
		     (0x0d & MDIO_CTRL_MAXF_MASK)));
		break;
	case SSB_BUSTYPE_PCMCIA:
	case SSB_BUSTYPE_SDIO:
		WARN_ON(1); /* A device with this bus does not exist. */
		break;
	}

	br32(bp, B44_MDIO_CTRL);

	if (!(br32(bp, B44_DEVCTRL) & DEVCTRL_IPP)) {
		bw32(bp, B44_ENET_CTRL, ENET_CTRL_EPSEL);
		br32(bp, B44_ENET_CTRL);
		bp->flags |= B44_FLAG_EXTERNAL_PHY;
	} else {
		u32 val = br32(bp, B44_DEVCTRL);

		if (val & DEVCTRL_EPR) {
			bw32(bp, B44_DEVCTRL, (val & ~DEVCTRL_EPR));
			br32(bp, B44_DEVCTRL);
			udelay(100);
		}
		bp->flags &= ~B44_FLAG_EXTERNAL_PHY;
	}
}

/* bp->lock is held. */
static void b44_halt(struct b44 *bp)
{
	b44_disable_ints(bp);
	/* reset PHY */
	b44_phy_reset(bp);
	/* power down PHY */
	netdev_info(bp->dev, "powering down PHY\n");
	bw32(bp, B44_MAC_CTRL, MAC_CTRL_PHY_PDOWN);
	/* now reset the chip, but without enabling the MAC&PHY
	 * part of it. This has to be done _after_ we shut down the PHY */
	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		b44_chip_reset(bp, B44_CHIP_RESET_FULL);
	else
		b44_chip_reset(bp, B44_CHIP_RESET_PARTIAL);
}

/* bp->lock is held. */
static void __b44_set_mac_addr(struct b44 *bp)
{
	bw32(bp, B44_CAM_CTRL, 0);
	if (!(bp->dev->flags & IFF_PROMISC)) {
		u32 val;

		__b44_cam_write(bp, bp->dev->dev_addr, 0);
		val = br32(bp, B44_CAM_CTRL);
		bw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);
	}
}

static int b44_set_mac_addr(struct net_device *dev, void *p)
{
	struct b44 *bp = netdev_priv(dev);
	struct sockaddr *addr = p;
	u32 val;

	if (netif_running(dev))
		return -EBUSY;

	if (!is_valid_ether_addr(addr->sa_data))
		return -EINVAL;

	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);

	spin_lock_irq(&bp->lock);

	val = br32(bp, B44_RXCONFIG);
	if (!(val & RXCONFIG_CAM_ABSENT))
		__b44_set_mac_addr(bp);

	spin_unlock_irq(&bp->lock);

	return 0;
}

/* Called at device open time to get the chip ready for
 * packet processing.  Invoked with bp->lock held.
 */
static void __b44_set_rx_mode(struct net_device *);
static void b44_init_hw(struct b44 *bp, int reset_kind)
{
	u32 val;

	b44_chip_reset(bp, B44_CHIP_RESET_FULL);
	if (reset_kind == B44_FULL_RESET) {
		b44_phy_reset(bp);
		b44_setup_phy(bp);
	}

	/* Enable CRC32, set proper LED modes and power on PHY */
	bw32(bp, B44_MAC_CTRL, MAC_CTRL_CRC32_ENAB | MAC_CTRL_PHY_LEDCTRL);
	bw32(bp, B44_RCV_LAZY, (1 << RCV_LAZY_FC_SHIFT));

	/* This sets the MAC address too.  */
	__b44_set_rx_mode(bp->dev);

	/* MTU + eth header + possible VLAN tag + struct rx_header */
	bw32(bp, B44_RXMAXLEN, bp->dev->mtu + ETH_HLEN + 8 + RX_HEADER_LEN);
	bw32(bp, B44_TXMAXLEN, bp->dev->mtu + ETH_HLEN + 8 + RX_HEADER_LEN);

	bw32(bp, B44_TX_WMARK, 56); /* XXX magic */
	if (reset_kind == B44_PARTIAL_RESET) {
		bw32(bp, B44_DMARX_CTRL, (DMARX_CTRL_ENABLE |
				      (RX_PKT_OFFSET << DMARX_CTRL_ROSHIFT)));
	} else {
		bw32(bp, B44_DMATX_CTRL, DMATX_CTRL_ENABLE);
		bw32(bp, B44_DMATX_ADDR, bp->tx_ring_dma + bp->dma_offset);
		bw32(bp, B44_DMARX_CTRL, (DMARX_CTRL_ENABLE |
				      (RX_PKT_OFFSET << DMARX_CTRL_ROSHIFT)));
		bw32(bp, B44_DMARX_ADDR, bp->rx_ring_dma + bp->dma_offset);

		bw32(bp, B44_DMARX_PTR, bp->rx_pending);
		bp->rx_prod = bp->rx_pending;

		bw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);
	}

	val = br32(bp, B44_ENET_CTRL);
	bw32(bp, B44_ENET_CTRL, (val | ENET_CTRL_ENABLE));

	netdev_reset_queue(bp->dev);
}

static int b44_open(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);
	int err;

	err = b44_alloc_consistent(bp, GFP_KERNEL);
	if (err)
		goto out;

	napi_enable(&bp->napi);

	b44_init_rings(bp);
	b44_init_hw(bp, B44_FULL_RESET);

	b44_check_phy(bp);

	err = request_irq(dev->irq, b44_interrupt, IRQF_SHARED, dev->name, dev);
	if (unlikely(err < 0)) {
		napi_disable(&bp->napi);
		b44_chip_reset(bp, B44_CHIP_RESET_PARTIAL);
		b44_free_rings(bp);
		b44_free_consistent(bp);
		goto out;
	}

	init_timer(&bp->timer);
	bp->timer.expires = jiffies + HZ;
	bp->timer.data = (unsigned long) bp;
	bp->timer.function = b44_timer;
	add_timer(&bp->timer);

	b44_enable_ints(bp);

	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		phy_start(bp->phydev);

	netif_start_queue(dev);
out:
	return err;
}

#ifdef CONFIG_NET_POLL_CONTROLLER
/*
 * Polling receive - used by netconsole and other diagnostic tools
 * to allow network i/o with interrupts disabled.
 */
static void b44_poll_controller(struct net_device *dev)
{
	disable_irq(dev->irq);
	b44_interrupt(dev->irq, dev);
	enable_irq(dev->irq);
}
#endif

static void bwfilter_table(struct b44 *bp, u8 *pp, u32 bytes, u32 table_offset)
{
	u32 i;
	u32 *pattern = (u32 *) pp;

	for (i = 0; i < bytes; i += sizeof(u32)) {
		bw32(bp, B44_FILT_ADDR, table_offset + i);
		bw32(bp, B44_FILT_DATA, pattern[i / sizeof(u32)]);
	}
}

static int b44_magic_pattern(u8 *macaddr, u8 *ppattern, u8 *pmask, int offset)
{
	int magicsync = 6;
	int k, j, len = offset;
	int ethaddr_bytes = ETH_ALEN;

	memset(ppattern + offset, 0xff, magicsync);
	for (j = 0; j < magicsync; j++)
		set_bit(len++, (unsigned long *) pmask);

	for (j = 0; j < B44_MAX_PATTERNS; j++) {
		if ((B44_PATTERN_SIZE - len) >= ETH_ALEN)
			ethaddr_bytes = ETH_ALEN;
		else
			ethaddr_bytes = B44_PATTERN_SIZE - len;
		if (ethaddr_bytes <=0)
			break;
		for (k = 0; k< ethaddr_bytes; k++) {
			ppattern[offset + magicsync +
				(j * ETH_ALEN) + k] = macaddr[k];
			set_bit(len++, (unsigned long *) pmask);
		}
	}
	return len - 1;
}

/* Setup magic packet patterns in the b44 WOL
 * pattern matching filter.
 */
static void b44_setup_pseudo_magicp(struct b44 *bp)
{

	u32 val;
	int plen0, plen1, plen2;
	u8 *pwol_pattern;
	u8 pwol_mask[B44_PMASK_SIZE];

	pwol_pattern = kzalloc(B44_PATTERN_SIZE, GFP_KERNEL);
	if (!pwol_pattern)
		return;

	/* Ipv4 magic packet pattern - pattern 0.*/
	memset(pwol_mask, 0, B44_PMASK_SIZE);
	plen0 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,
				  B44_ETHIPV4UDP_HLEN);

   	bwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE, B44_PATTERN_BASE);
   	bwfilter_table(bp, pwol_mask, B44_PMASK_SIZE, B44_PMASK_BASE);

	/* Raw ethernet II magic packet pattern - pattern 1 */
	memset(pwol_pattern, 0, B44_PATTERN_SIZE);
	memset(pwol_mask, 0, B44_PMASK_SIZE);
	plen1 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,
				  ETH_HLEN);

   	bwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE,
		       B44_PATTERN_BASE + B44_PATTERN_SIZE);
  	bwfilter_table(bp, pwol_mask, B44_PMASK_SIZE,
		       B44_PMASK_BASE + B44_PMASK_SIZE);

	/* Ipv6 magic packet pattern - pattern 2 */
	memset(pwol_pattern, 0, B44_PATTERN_SIZE);
	memset(pwol_mask, 0, B44_PMASK_SIZE);
	plen2 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,
				  B44_ETHIPV6UDP_HLEN);

   	bwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE,
		       B44_PATTERN_BASE + B44_PATTERN_SIZE + B44_PATTERN_SIZE);
  	bwfilter_table(bp, pwol_mask, B44_PMASK_SIZE,
		       B44_PMASK_BASE + B44_PMASK_SIZE + B44_PMASK_SIZE);

	kfree(pwol_pattern);

	/* set these pattern's lengths: one less than each real length */
	val = plen0 | (plen1 << 8) | (plen2 << 16) | WKUP_LEN_ENABLE_THREE;
	bw32(bp, B44_WKUP_LEN, val);

	/* enable wakeup pattern matching */
	val = br32(bp, B44_DEVCTRL);
	bw32(bp, B44_DEVCTRL, val | DEVCTRL_PFE);

}

#ifdef CONFIG_B44_PCI
static void b44_setup_wol_pci(struct b44 *bp)
{
	u16 val;

	if (bp->sdev->bus->bustype != SSB_BUSTYPE_SSB) {
		bw32(bp, SSB_TMSLOW, br32(bp, SSB_TMSLOW) | SSB_TMSLOW_PE);
		pci_read_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, &val);
		pci_write_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, val | SSB_PE);
	}
}
#else
static inline void b44_setup_wol_pci(struct b44 *bp) { }
#endif /* CONFIG_B44_PCI */

static void b44_setup_wol(struct b44 *bp)
{
	u32 val;

	bw32(bp, B44_RXCONFIG, RXCONFIG_ALLMULTI);

	if (bp->flags & B44_FLAG_B0_ANDLATER) {

		bw32(bp, B44_WKUP_LEN, WKUP_LEN_DISABLE);

		val = bp->dev->dev_addr[2] << 24 |
			bp->dev->dev_addr[3] << 16 |
			bp->dev->dev_addr[4] << 8 |
			bp->dev->dev_addr[5];
		bw32(bp, B44_ADDR_LO, val);

		val = bp->dev->dev_addr[0] << 8 |
			bp->dev->dev_addr[1];
		bw32(bp, B44_ADDR_HI, val);

		val = br32(bp, B44_DEVCTRL);
		bw32(bp, B44_DEVCTRL, val | DEVCTRL_MPM | DEVCTRL_PFE);

 	} else {
 		b44_setup_pseudo_magicp(bp);
 	}
	b44_setup_wol_pci(bp);
}

static int b44_close(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);

	netif_stop_queue(dev);

	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		phy_stop(bp->phydev);

	napi_disable(&bp->napi);

	del_timer_sync(&bp->timer);

	spin_lock_irq(&bp->lock);

	b44_halt(bp);
	b44_free_rings(bp);
	netif_carrier_off(dev);

	spin_unlock_irq(&bp->lock);

	free_irq(dev->irq, dev);

	if (bp->flags & B44_FLAG_WOL_ENABLE) {
		b44_init_hw(bp, B44_PARTIAL_RESET);
		b44_setup_wol(bp);
	}

	b44_free_consistent(bp);

	return 0;
}

static struct rtnl_link_stats64 *b44_get_stats64(struct net_device *dev,
					struct rtnl_link_stats64 *nstat)
{
	struct b44 *bp = netdev_priv(dev);
	struct b44_hw_stats *hwstat = &bp->hw_stats;
	unsigned int start;

	do {
		start = u64_stats_fetch_begin_irq(&hwstat->syncp);

		/* Convert HW stats into rtnl_link_stats64 stats. */
		nstat->rx_packets = hwstat->rx_pkts;
		nstat->tx_packets = hwstat->tx_pkts;
		nstat->rx_bytes   = hwstat->rx_octets;
		nstat->tx_bytes   = hwstat->tx_octets;
		nstat->tx_errors  = (hwstat->tx_jabber_pkts +
				     hwstat->tx_oversize_pkts +
				     hwstat->tx_underruns +
				     hwstat->tx_excessive_cols +
				     hwstat->tx_late_cols);
		nstat->multicast  = hwstat->rx_multicast_pkts;
		nstat->collisions = hwstat->tx_total_cols;

		nstat->rx_length_errors = (hwstat->rx_oversize_pkts +
					   hwstat->rx_undersize);
		nstat->rx_over_errors   = hwstat->rx_missed_pkts;
		nstat->rx_frame_errors  = hwstat->rx_align_errs;
		nstat->rx_crc_errors    = hwstat->rx_crc_errs;
		nstat->rx_errors        = (hwstat->rx_jabber_pkts +
					   hwstat->rx_oversize_pkts +
					   hwstat->rx_missed_pkts +
					   hwstat->rx_crc_align_errs +
					   hwstat->rx_undersize +
					   hwstat->rx_crc_errs +
					   hwstat->rx_align_errs +
					   hwstat->rx_symbol_errs);

		nstat->tx_aborted_errors = hwstat->tx_underruns;
#if 0
		/* Carrier lost counter seems to be broken for some devices */
		nstat->tx_carrier_errors = hwstat->tx_carrier_lost;
#endif
	} while (u64_stats_fetch_retry_irq(&hwstat->syncp, start));

	return nstat;
}

static int __b44_load_mcast(struct b44 *bp, struct net_device *dev)
{
	struct netdev_hw_addr *ha;
	int i, num_ents;

	num_ents = min_t(int, netdev_mc_count(dev), B44_MCAST_TABLE_SIZE);
	i = 0;
	netdev_for_each_mc_addr(ha, dev) {
		if (i == num_ents)
			break;
		__b44_cam_write(bp, ha->addr, i++ + 1);
	}
	return i+1;
}

static void __b44_set_rx_mode(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);
	u32 val;

	val = br32(bp, B44_RXCONFIG);
	val &= ~(RXCONFIG_PROMISC | RXCONFIG_ALLMULTI);
	if ((dev->flags & IFF_PROMISC) || (val & RXCONFIG_CAM_ABSENT)) {
		val |= RXCONFIG_PROMISC;
		bw32(bp, B44_RXCONFIG, val);
	} else {
		unsigned char zero[6] = {0, 0, 0, 0, 0, 0};
		int i = 1;

		__b44_set_mac_addr(bp);

		if ((dev->flags & IFF_ALLMULTI) ||
		    (netdev_mc_count(dev) > B44_MCAST_TABLE_SIZE))
			val |= RXCONFIG_ALLMULTI;
		else
			i = __b44_load_mcast(bp, dev);

		for (; i < 64; i++)
			__b44_cam_write(bp, zero, i);

		bw32(bp, B44_RXCONFIG, val);
        	val = br32(bp, B44_CAM_CTRL);
	        bw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);
	}
}

static void b44_set_rx_mode(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);

	spin_lock_irq(&bp->lock);
	__b44_set_rx_mode(dev);
	spin_unlock_irq(&bp->lock);
}

static u32 b44_get_msglevel(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);
	return bp->msg_enable;
}

static void b44_set_msglevel(struct net_device *dev, u32 value)
{
	struct b44 *bp = netdev_priv(dev);
	bp->msg_enable = value;
}

static void b44_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct b44 *bp = netdev_priv(dev);
	struct ssb_bus *bus = bp->sdev->bus;

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	switch (bus->bustype) {
	case SSB_BUSTYPE_PCI:
		strlcpy(info->bus_info, pci_name(bus->host_pci), sizeof(info->bus_info));
		break;
	case SSB_BUSTYPE_SSB:
		strlcpy(info->bus_info, "SSB", sizeof(info->bus_info));
		break;
	case SSB_BUSTYPE_PCMCIA:
	case SSB_BUSTYPE_SDIO:
		WARN_ON(1); /* A device with this bus does not exist. */
		break;
	}
}

static int b44_nway_reset(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);
	u32 bmcr;
	int r;

	spin_lock_irq(&bp->lock);
	b44_readphy(bp, MII_BMCR, &bmcr);
	b44_readphy(bp, MII_BMCR, &bmcr);
	r = -EINVAL;
	if (bmcr & BMCR_ANENABLE) {
		b44_writephy(bp, MII_BMCR,
			     bmcr | BMCR_ANRESTART);
		r = 0;
	}
	spin_unlock_irq(&bp->lock);

	return r;
}

static int b44_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
{
	struct b44 *bp = netdev_priv(dev);

	if (bp->flags & B44_FLAG_EXTERNAL_PHY) {
		BUG_ON(!bp->phydev);
		return phy_ethtool_gset(bp->phydev, cmd);
	}

	cmd->supported = (SUPPORTED_Autoneg);
	cmd->supported |= (SUPPORTED_100baseT_Half |
			  SUPPORTED_100baseT_Full |
			  SUPPORTED_10baseT_Half |
			  SUPPORTED_10baseT_Full |
			  SUPPORTED_MII);

	cmd->advertising = 0;
	if (bp->flags & B44_FLAG_ADV_10HALF)
		cmd->advertising |= ADVERTISED_10baseT_Half;
	if (bp->flags & B44_FLAG_ADV_10FULL)
		cmd->advertising |= ADVERTISED_10baseT_Full;
	if (bp->flags & B44_FLAG_ADV_100HALF)
		cmd->advertising |= ADVERTISED_100baseT_Half;
	if (bp->flags & B44_FLAG_ADV_100FULL)
		cmd->advertising |= ADVERTISED_100baseT_Full;
	cmd->advertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;
	ethtool_cmd_speed_set(cmd, ((bp->flags & B44_FLAG_100_BASE_T) ?
				    SPEED_100 : SPEED_10));
	cmd->duplex = (bp->flags & B44_FLAG_FULL_DUPLEX) ?
		DUPLEX_FULL : DUPLEX_HALF;
	cmd->port = 0;
	cmd->phy_address = bp->phy_addr;
	cmd->transceiver = (bp->flags & B44_FLAG_EXTERNAL_PHY) ?
		XCVR_EXTERNAL : XCVR_INTERNAL;
	cmd->autoneg = (bp->flags & B44_FLAG_FORCE_LINK) ?
		AUTONEG_DISABLE : AUTONEG_ENABLE;
	if (cmd->autoneg == AUTONEG_ENABLE)
		cmd->advertising |= ADVERTISED_Autoneg;
	if (!netif_running(dev)){
		ethtool_cmd_speed_set(cmd, 0);
		cmd->duplex = 0xff;
	}
	cmd->maxtxpkt = 0;
	cmd->maxrxpkt = 0;
	return 0;
}

static int b44_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
{
	struct b44 *bp = netdev_priv(dev);
	u32 speed;
	int ret;

	if (bp->flags & B44_FLAG_EXTERNAL_PHY) {
		BUG_ON(!bp->phydev);
		spin_lock_irq(&bp->lock);
		if (netif_running(dev))
			b44_setup_phy(bp);

		ret = phy_ethtool_sset(bp->phydev, cmd);

		spin_unlock_irq(&bp->lock);

		return ret;
	}

	speed = ethtool_cmd_speed(cmd);

	/* We do not support gigabit. */
	if (cmd->autoneg == AUTONEG_ENABLE) {
		if (cmd->advertising &
		    (ADVERTISED_1000baseT_Half |
		     ADVERTISED_1000baseT_Full))
			return -EINVAL;
	} else if ((speed != SPEED_100 &&
		    speed != SPEED_10) ||
		   (cmd->duplex != DUPLEX_HALF &&
		    cmd->duplex != DUPLEX_FULL)) {
			return -EINVAL;
	}

	spin_lock_irq(&bp->lock);

	if (cmd->autoneg == AUTONEG_ENABLE) {
		bp->flags &= ~(B44_FLAG_FORCE_LINK |
			       B44_FLAG_100_BASE_T |
			       B44_FLAG_FULL_DUPLEX |
			       B44_FLAG_ADV_10HALF |
			       B44_FLAG_ADV_10FULL |
			       B44_FLAG_ADV_100HALF |
			       B44_FLAG_ADV_100FULL);
		if (cmd->advertising == 0) {
			bp->flags |= (B44_FLAG_ADV_10HALF |
				      B44_FLAG_ADV_10FULL |
				      B44_FLAG_ADV_100HALF |
				      B44_FLAG_ADV_100FULL);
		} else {
			if (cmd->advertising & ADVERTISED_10baseT_Half)
				bp->flags |= B44_FLAG_ADV_10HALF;
			if (cmd->advertising & ADVERTISED_10baseT_Full)
				bp->flags |= B44_FLAG_ADV_10FULL;
			if (cmd->advertising & ADVERTISED_100baseT_Half)
				bp->flags |= B44_FLAG_ADV_100HALF;
			if (cmd->advertising & ADVERTISED_100baseT_Full)
				bp->flags |= B44_FLAG_ADV_100FULL;
		}
	} else {
		bp->flags |= B44_FLAG_FORCE_LINK;
		bp->flags &= ~(B44_FLAG_100_BASE_T | B44_FLAG_FULL_DUPLEX);
		if (speed == SPEED_100)
			bp->flags |= B44_FLAG_100_BASE_T;
		if (cmd->duplex == DUPLEX_FULL)
			bp->flags |= B44_FLAG_FULL_DUPLEX;
	}

	if (netif_running(dev))
		b44_setup_phy(bp);

	spin_unlock_irq(&bp->lock);

	return 0;
}

static void b44_get_ringparam(struct net_device *dev,
			      struct ethtool_ringparam *ering)
{
	struct b44 *bp = netdev_priv(dev);

	ering->rx_max_pending = B44_RX_RING_SIZE - 1;
	ering->rx_pending = bp->rx_pending;

	/* XXX ethtool lacks a tx_max_pending, oops... */
}

static int b44_set_ringparam(struct net_device *dev,
			     struct ethtool_ringparam *ering)
{
	struct b44 *bp = netdev_priv(dev);

	if ((ering->rx_pending > B44_RX_RING_SIZE - 1) ||
	    (ering->rx_mini_pending != 0) ||
	    (ering->rx_jumbo_pending != 0) ||
	    (ering->tx_pending > B44_TX_RING_SIZE - 1))
		return -EINVAL;

	spin_lock_irq(&bp->lock);

	bp->rx_pending = ering->rx_pending;
	bp->tx_pending = ering->tx_pending;

	b44_halt(bp);
	b44_init_rings(bp);
	b44_init_hw(bp, B44_FULL_RESET);
	netif_wake_queue(bp->dev);
	spin_unlock_irq(&bp->lock);

	b44_enable_ints(bp);

	return 0;
}

static void b44_get_pauseparam(struct net_device *dev,
				struct ethtool_pauseparam *epause)
{
	struct b44 *bp = netdev_priv(dev);

	epause->autoneg =
		(bp->flags & B44_FLAG_PAUSE_AUTO) != 0;
	epause->rx_pause =
		(bp->flags & B44_FLAG_RX_PAUSE) != 0;
	epause->tx_pause =
		(bp->flags & B44_FLAG_TX_PAUSE) != 0;
}

static int b44_set_pauseparam(struct net_device *dev,
				struct ethtool_pauseparam *epause)
{
	struct b44 *bp = netdev_priv(dev);

	spin_lock_irq(&bp->lock);
	if (epause->autoneg)
		bp->flags |= B44_FLAG_PAUSE_AUTO;
	else
		bp->flags &= ~B44_FLAG_PAUSE_AUTO;
	if (epause->rx_pause)
		bp->flags |= B44_FLAG_RX_PAUSE;
	else
		bp->flags &= ~B44_FLAG_RX_PAUSE;
	if (epause->tx_pause)
		bp->flags |= B44_FLAG_TX_PAUSE;
	else
		bp->flags &= ~B44_FLAG_TX_PAUSE;
	if (bp->flags & B44_FLAG_PAUSE_AUTO) {
		b44_halt(bp);
		b44_init_rings(bp);
		b44_init_hw(bp, B44_FULL_RESET);
	} else {
		__b44_set_flow_ctrl(bp, bp->flags);
	}
	spin_unlock_irq(&bp->lock);

	b44_enable_ints(bp);

	return 0;
}

static void b44_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
	switch(stringset) {
	case ETH_SS_STATS:
		memcpy(data, *b44_gstrings, sizeof(b44_gstrings));
		break;
	}
}

static int b44_get_sset_count(struct net_device *dev, int sset)
{
	switch (sset) {
	case ETH_SS_STATS:
		return ARRAY_SIZE(b44_gstrings);
	default:
		return -EOPNOTSUPP;
	}
}

static void b44_get_ethtool_stats(struct net_device *dev,
				  struct ethtool_stats *stats, u64 *data)
{
	struct b44 *bp = netdev_priv(dev);
	struct b44_hw_stats *hwstat = &bp->hw_stats;
	u64 *data_src, *data_dst;
	unsigned int start;
	u32 i;

	spin_lock_irq(&bp->lock);
	b44_stats_update(bp);
	spin_unlock_irq(&bp->lock);

	do {
		data_src = &hwstat->tx_good_octets;
		data_dst = data;
		start = u64_stats_fetch_begin_irq(&hwstat->syncp);

		for (i = 0; i < ARRAY_SIZE(b44_gstrings); i++)
			*data_dst++ = *data_src++;

	} while (u64_stats_fetch_retry_irq(&hwstat->syncp, start));
}

static void b44_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
{
	struct b44 *bp = netdev_priv(dev);

	wol->supported = WAKE_MAGIC;
	if (bp->flags & B44_FLAG_WOL_ENABLE)
		wol->wolopts = WAKE_MAGIC;
	else
		wol->wolopts = 0;
	memset(&wol->sopass, 0, sizeof(wol->sopass));
}

static int b44_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
{
	struct b44 *bp = netdev_priv(dev);

	spin_lock_irq(&bp->lock);
	if (wol->wolopts & WAKE_MAGIC)
		bp->flags |= B44_FLAG_WOL_ENABLE;
	else
		bp->flags &= ~B44_FLAG_WOL_ENABLE;
	spin_unlock_irq(&bp->lock);

	return 0;
}

static const struct ethtool_ops b44_ethtool_ops = {
	.get_drvinfo		= b44_get_drvinfo,
	.get_settings		= b44_get_settings,
	.set_settings		= b44_set_settings,
	.nway_reset		= b44_nway_reset,
	.get_link		= ethtool_op_get_link,
	.get_wol		= b44_get_wol,
	.set_wol		= b44_set_wol,
	.get_ringparam		= b44_get_ringparam,
	.set_ringparam		= b44_set_ringparam,
	.get_pauseparam		= b44_get_pauseparam,
	.set_pauseparam		= b44_set_pauseparam,
	.get_msglevel		= b44_get_msglevel,
	.set_msglevel		= b44_set_msglevel,
	.get_strings		= b44_get_strings,
	.get_sset_count		= b44_get_sset_count,
	.get_ethtool_stats	= b44_get_ethtool_stats,
};

static int b44_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
	struct b44 *bp = netdev_priv(dev);
	int err = -EINVAL;

	if (!netif_running(dev))
		goto out;

	spin_lock_irq(&bp->lock);
	if (bp->flags & B44_FLAG_EXTERNAL_PHY) {
		BUG_ON(!bp->phydev);
		err = phy_mii_ioctl(bp->phydev, ifr, cmd);
	} else {
		err = generic_mii_ioctl(&bp->mii_if, if_mii(ifr), cmd, NULL);
	}
	spin_unlock_irq(&bp->lock);
out:
	return err;
}

static int b44_get_invariants(struct b44 *bp)
{
	struct ssb_device *sdev = bp->sdev;
	int err = 0;
	u8 *addr;

	bp->dma_offset = ssb_dma_translation(sdev);

	if (sdev->bus->bustype == SSB_BUSTYPE_SSB &&
	    instance > 1) {
		addr = sdev->bus->sprom.et1mac;
		bp->phy_addr = sdev->bus->sprom.et1phyaddr;
	} else {
		addr = sdev->bus->sprom.et0mac;
		bp->phy_addr = sdev->bus->sprom.et0phyaddr;
	}
	/* Some ROMs have buggy PHY addresses with the high
	 * bits set (sign extension?). Truncate them to a
	 * valid PHY address. */
	bp->phy_addr &= 0x1F;

	memcpy(bp->dev->dev_addr, addr, ETH_ALEN);

	if (!is_valid_ether_addr(&bp->dev->dev_addr[0])){
		pr_err("Invalid MAC address found in EEPROM\n");
		return -EINVAL;
	}

	bp->imask = IMASK_DEF;

	/* XXX - really required?
	   bp->flags |= B44_FLAG_BUGGY_TXPTR;
	*/

	if (bp->sdev->id.revision >= 7)
		bp->flags |= B44_FLAG_B0_ANDLATER;

	return err;
}

static const struct net_device_ops b44_netdev_ops = {
	.ndo_open		= b44_open,
	.ndo_stop		= b44_close,
	.ndo_start_xmit		= b44_start_xmit,
	.ndo_get_stats64	= b44_get_stats64,
	.ndo_set_rx_mode	= b44_set_rx_mode,
	.ndo_set_mac_address	= b44_set_mac_addr,
	.ndo_validate_addr	= eth_validate_addr,
	.ndo_do_ioctl		= b44_ioctl,
	.ndo_tx_timeout		= b44_tx_timeout,
	.ndo_change_mtu		= b44_change_mtu,
#ifdef CONFIG_NET_POLL_CONTROLLER
	.ndo_poll_controller	= b44_poll_controller,
#endif
};

static void b44_adjust_link(struct net_device *dev)
{
	struct b44 *bp = netdev_priv(dev);
	struct phy_device *phydev = bp->phydev;
	bool status_changed = 0;

	BUG_ON(!phydev);

	if (bp->old_link != phydev->link) {
		status_changed = 1;
		bp->old_link = phydev->link;
	}

	/* reflect duplex change */
	if (phydev->link) {
		if ((phydev->duplex == DUPLEX_HALF) &&
		    (bp->flags & B44_FLAG_FULL_DUPLEX)) {
			status_changed = 1;
			bp->flags &= ~B44_FLAG_FULL_DUPLEX;
		} else if ((phydev->duplex == DUPLEX_FULL) &&
			   !(bp->flags & B44_FLAG_FULL_DUPLEX)) {
			status_changed = 1;
			bp->flags |= B44_FLAG_FULL_DUPLEX;
		}
	}

	if (status_changed) {
		u32 val = br32(bp, B44_TX_CTRL);
		if (bp->flags & B44_FLAG_FULL_DUPLEX)
			val |= TX_CTRL_DUPLEX;
		else
			val &= ~TX_CTRL_DUPLEX;
		bw32(bp, B44_TX_CTRL, val);
		phy_print_status(phydev);
	}
}

static int b44_register_phy_one(struct b44 *bp)
{
	struct mii_bus *mii_bus;
	struct ssb_device *sdev = bp->sdev;
	struct phy_device *phydev;
	char bus_id[MII_BUS_ID_SIZE + 3];
	struct ssb_sprom *sprom = &sdev->bus->sprom;
	int err;

	mii_bus = mdiobus_alloc();
	if (!mii_bus) {
		dev_err(sdev->dev, "mdiobus_alloc() failed\n");
		err = -ENOMEM;
		goto err_out;
	}

	mii_bus->priv = bp;
	mii_bus->read = b44_mdio_read_phylib;
	mii_bus->write = b44_mdio_write_phylib;
	mii_bus->name = "b44_eth_mii";
	mii_bus->parent = sdev->dev;
	mii_bus->phy_mask = ~(1 << bp->phy_addr);
	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%x", instance);
	mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
	if (!mii_bus->irq) {
		dev_err(sdev->dev, "mii_bus irq allocation failed\n");
		err = -ENOMEM;
		goto err_out_mdiobus;
	}

	memset(mii_bus->irq, PHY_POLL, sizeof(int) * PHY_MAX_ADDR);

	bp->mii_bus = mii_bus;

	err = mdiobus_register(mii_bus);
	if (err) {
		dev_err(sdev->dev, "failed to register MII bus\n");
		goto err_out_mdiobus_irq;
	}

	if (!bp->mii_bus->phy_map[bp->phy_addr] &&
	    (sprom->boardflags_lo & (B44_BOARDFLAG_ROBO | B44_BOARDFLAG_ADM))) {

		dev_info(sdev->dev,
			 "could not find PHY at %i, use fixed one\n",
			 bp->phy_addr);

		bp->phy_addr = 0;
		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, "fixed-0",
			 bp->phy_addr);
	} else {
		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,
			 bp->phy_addr);
	}

	phydev = phy_connect(bp->dev, bus_id, &b44_adjust_link,
			     PHY_INTERFACE_MODE_MII);
	if (IS_ERR(phydev)) {
		dev_err(sdev->dev, "could not attach PHY at %i\n",
			bp->phy_addr);
		err = PTR_ERR(phydev);
		goto err_out_mdiobus_unregister;
	}

	/* mask with MAC supported features */
	phydev->supported &= (SUPPORTED_100baseT_Half |
			      SUPPORTED_100baseT_Full |
			      SUPPORTED_Autoneg |
			      SUPPORTED_MII);
	phydev->advertising = phydev->supported;

	bp->phydev = phydev;
	bp->old_link = 0;
	bp->phy_addr = phydev->addr;

	dev_info(sdev->dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s)\n",
		 phydev->drv->name, dev_name(&phydev->dev));

	return 0;

err_out_mdiobus_unregister:
	mdiobus_unregister(mii_bus);

err_out_mdiobus_irq:
	kfree(mii_bus->irq);

err_out_mdiobus:
	mdiobus_free(mii_bus);

err_out:
	return err;
}

static void b44_unregister_phy_one(struct b44 *bp)
{
	struct mii_bus *mii_bus = bp->mii_bus;

	phy_disconnect(bp->phydev);
	mdiobus_unregister(mii_bus);
	kfree(mii_bus->irq);
	mdiobus_free(mii_bus);
}

static int b44_init_one(struct ssb_device *sdev,
			const struct ssb_device_id *ent)
{
	struct net_device *dev;
	struct b44 *bp;
	int err;

	instance++;

	pr_info_once("%s version %s\n", DRV_DESCRIPTION, DRV_MODULE_VERSION);

	dev = alloc_etherdev(sizeof(*bp));
	if (!dev) {
		err = -ENOMEM;
		goto out;
	}

	SET_NETDEV_DEV(dev, sdev->dev);

	/* No interesting netdevice features in this card... */
	dev->features |= 0;

	bp = netdev_priv(dev);
	bp->sdev = sdev;
	bp->dev = dev;
	bp->force_copybreak = 0;

	bp->msg_enable = netif_msg_init(b44_debug, B44_DEF_MSG_ENABLE);

	spin_lock_init(&bp->lock);

	bp->rx_pending = B44_DEF_RX_RING_PENDING;
	bp->tx_pending = B44_DEF_TX_RING_PENDING;

	dev->netdev_ops = &b44_netdev_ops;
	netif_napi_add(dev, &bp->napi, b44_poll, 64);
	dev->watchdog_timeo = B44_TX_TIMEOUT;
	dev->irq = sdev->irq;
	dev->ethtool_ops = &b44_ethtool_ops;

	err = ssb_bus_powerup(sdev->bus, 0);
	if (err) {
		dev_err(sdev->dev,
			"Failed to powerup the bus\n");
		goto err_out_free_dev;
	}

	if (dma_set_mask_and_coherent(sdev->dma_dev, DMA_BIT_MASK(30))) {
		dev_err(sdev->dev,
			"Required 30BIT DMA mask unsupported by the system\n");
		goto err_out_powerdown;
	}

	err = b44_get_invariants(bp);
	if (err) {
		dev_err(sdev->dev,
			"Problem fetching invariants of chip, aborting\n");
		goto err_out_powerdown;
	}

	if (bp->phy_addr == B44_PHY_ADDR_NO_PHY) {
		dev_err(sdev->dev, "No PHY present on this MAC, aborting\n");
		err = -ENODEV;
		goto err_out_powerdown;
	}

	bp->mii_if.dev = dev;
	bp->mii_if.mdio_read = b44_mdio_read_mii;
	bp->mii_if.mdio_write = b44_mdio_write_mii;
	bp->mii_if.phy_id = bp->phy_addr;
	bp->mii_if.phy_id_mask = 0x1f;
	bp->mii_if.reg_num_mask = 0x1f;

	/* By default, advertise all speed/duplex settings. */
	bp->flags |= (B44_FLAG_ADV_10HALF | B44_FLAG_ADV_10FULL |
		      B44_FLAG_ADV_100HALF | B44_FLAG_ADV_100FULL);

	/* By default, auto-negotiate PAUSE. */
	bp->flags |= B44_FLAG_PAUSE_AUTO;

	err = register_netdev(dev);
	if (err) {
		dev_err(sdev->dev, "Cannot register net device, aborting\n");
		goto err_out_powerdown;
	}

	netif_carrier_off(dev);

	ssb_set_drvdata(sdev, dev);

	/* Chip reset provides power to the b44 MAC & PCI cores, which
	 * is necessary for MAC register access.
	 */
	b44_chip_reset(bp, B44_CHIP_RESET_FULL);

	/* do a phy reset to test if there is an active phy */
	err = b44_phy_reset(bp);
	if (err < 0) {
		dev_err(sdev->dev, "phy reset failed\n");
		goto err_out_unregister_netdev;
	}

	if (bp->flags & B44_FLAG_EXTERNAL_PHY) {
		err = b44_register_phy_one(bp);
		if (err) {
			dev_err(sdev->dev, "Cannot register PHY, aborting\n");
			goto err_out_unregister_netdev;
		}
	}

	netdev_info(dev, "%s %pM\n", DRV_DESCRIPTION, dev->dev_addr);

	return 0;

err_out_unregister_netdev:
	unregister_netdev(dev);
err_out_powerdown:
	ssb_bus_may_powerdown(sdev->bus);

err_out_free_dev:
	free_netdev(dev);

out:
	return err;
}

static void b44_remove_one(struct ssb_device *sdev)
{
	struct net_device *dev = ssb_get_drvdata(sdev);
	struct b44 *bp = netdev_priv(dev);

	unregister_netdev(dev);
	if (bp->flags & B44_FLAG_EXTERNAL_PHY)
		b44_unregister_phy_one(bp);
	ssb_device_disable(sdev, 0);
	ssb_bus_may_powerdown(sdev->bus);
	free_netdev(dev);
	ssb_pcihost_set_power_state(sdev, PCI_D3hot);
	ssb_set_drvdata(sdev, NULL);
}

static int b44_suspend(struct ssb_device *sdev, pm_message_t state)
{
	struct net_device *dev = ssb_get_drvdata(sdev);
	struct b44 *bp = netdev_priv(dev);

	if (!netif_running(dev))
		return 0;

	del_timer_sync(&bp->timer);

	spin_lock_irq(&bp->lock);

	b44_halt(bp);
	netif_carrier_off(bp->dev);
	netif_device_detach(bp->dev);
	b44_free_rings(bp);

	spin_unlock_irq(&bp->lock);

	free_irq(dev->irq, dev);
	if (bp->flags & B44_FLAG_WOL_ENABLE) {
		b44_init_hw(bp, B44_PARTIAL_RESET);
		b44_setup_wol(bp);
	}

	ssb_pcihost_set_power_state(sdev, PCI_D3hot);
	return 0;
}

static int b44_resume(struct ssb_device *sdev)
{
	struct net_device *dev = ssb_get_drvdata(sdev);
	struct b44 *bp = netdev_priv(dev);
	int rc = 0;

	rc = ssb_bus_powerup(sdev->bus, 0);
	if (rc) {
		dev_err(sdev->dev,
			"Failed to powerup the bus\n");
		return rc;
	}

	if (!netif_running(dev))
		return 0;

	spin_lock_irq(&bp->lock);
	b44_init_rings(bp);
	b44_init_hw(bp, B44_FULL_RESET);
	spin_unlock_irq(&bp->lock);

	/*
	 * As a shared interrupt, the handler can be called immediately. To be
	 * able to check the interrupt status the hardware must already be
	 * powered back on (b44_init_hw).
	 */
	rc = request_irq(dev->irq, b44_interrupt, IRQF_SHARED, dev->name, dev);
	if (rc) {
		netdev_err(dev, "request_irq failed\n");
		spin_lock_irq(&bp->lock);
		b44_halt(bp);
		b44_free_rings(bp);
		spin_unlock_irq(&bp->lock);
		return rc;
	}

	netif_device_attach(bp->dev);

	b44_enable_ints(bp);
	netif_wake_queue(dev);

	mod_timer(&bp->timer, jiffies + 1);

	return 0;
}

static struct ssb_driver b44_ssb_driver = {
	.name		= DRV_MODULE_NAME,
	.id_table	= b44_ssb_tbl,
	.probe		= b44_init_one,
	.remove		= b44_remove_one,
	.suspend	= b44_suspend,
	.resume		= b44_resume,
};

static inline int __init b44_pci_init(void)
{
	int err = 0;
#ifdef CONFIG_B44_PCI
	err = ssb_pcihost_register(&b44_pci_driver);
#endif
	return err;
}

static inline void b44_pci_exit(void)
{
#ifdef CONFIG_B44_PCI
	ssb_pcihost_unregister(&b44_pci_driver);
#endif
}

static int __init b44_init(void)
{
	unsigned int dma_desc_align_size = dma_get_cache_alignment();
	int err;

	/* Setup paramaters for syncing RX/TX DMA descriptors */
	dma_desc_sync_size = max_t(unsigned int, dma_desc_align_size, sizeof(struct dma_desc));

	err = b44_pci_init();
	if (err)
		return err;
	err = ssb_driver_register(&b44_ssb_driver);
	if (err)
		b44_pci_exit();
	return err;
}

static void __exit b44_cleanup(void)
{
	ssb_driver_unregister(&b44_ssb_driver);
	b44_pci_exit();
}

module_init(b44_init);
module_exit(b44_cleanup);

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Copyright (c) 2014 Qualcomm Atheros, Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* "API" level of the ath10k testmode interface. Bump it after every
 * incompatible interface change.
 */
#define ATH10K_TESTMODE_VERSION_MAJOR 1

/* Bump this after every _compatible_ interface change, for example
 * addition of a new command or an attribute.
 */
#define ATH10K_TESTMODE_VERSION_MINOR 0

#define ATH10K_TM_DATA_MAX_LEN		5000

enum ath10k_tm_attr {
	__ATH10K_TM_ATTR_INVALID	= 0,
	ATH10K_TM_ATTR_CMD		= 1,
	ATH10K_TM_ATTR_DATA		= 2,
	ATH10K_TM_ATTR_WMI_CMDID	= 3,
	ATH10K_TM_ATTR_VERSION_MAJOR	= 4,
	ATH10K_TM_ATTR_VERSION_MINOR	= 5,

	/* keep last */
	__ATH10K_TM_ATTR_AFTER_LAST,
	ATH10K_TM_ATTR_MAX		= __ATH10K_TM_ATTR_AFTER_LAST - 1,
};

/* All ath10k testmode interface commands specified in
 * ATH10K_TM_ATTR_CMD
 */
enum ath10k_tm_cmd {
	/* Returns the supported ath10k testmode interface version in
	 * ATH10K_TM_ATTR_VERSION. Always guaranteed to work. User space
	 * uses this to verify it's using the correct version of the
	 * testmode interface
	 */
	ATH10K_TM_CMD_GET_VERSION = 0,

	/* Boots the UTF firmware, the netdev interface must be down at the
	 * time.
	 */
	ATH10K_TM_CMD_UTF_START = 1,

	/* Shuts down the UTF firmware and puts the driver back into OFF
	 * state.
	 */
	ATH10K_TM_CMD_UTF_STOP = 2,

	/* The command used to transmit a WMI command to the firmware and
	 * the event to receive WMI events from the firmware. Without
	 * struct wmi_cmd_hdr header, only the WMI payload. Command id is
	 * provided with ATH10K_TM_ATTR_WMI_CMDID and payload in
	 * ATH10K_TM_ATTR_DATA.
	 */
	ATH10K_TM_CMD_WMI = 3,
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /******************************************************************************
 *
 * Copyright(c) 2009-2010  Realtek Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * The full GNU General Public License is included in this distribution in the
 * file called LICENSE.
 *
 * Contact Information:
 * wlanfae <wlanfae@realtek.com>
 * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
 * Hsinchu 300, Taiwan.
 *
 * Larry Finger <Larry.Finger@lwfinger.net>
 *
 *****************************************************************************/

#include "../wifi.h"
#include "../efuse.h"
#include "../base.h"
#include "../regd.h"
#include "../cam.h"
#include "../ps.h"
#include "../pci.h"
#include "reg.h"
#include "def.h"
#include "phy.h"
#include "dm.h"
#include "fw.h"
#include "led.h"
#include "hw.h"
#include "../pwrseqcmd.h"
#include "pwrseq.h"
#include "../btcoexist/rtl_btc.h"

#define LLT_CONFIG	5

static void _rtl8821ae_return_beacon_queue_skb(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[BEACON_QUEUE];
	unsigned long flags;

	spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
	while (skb_queue_len(&ring->queue)) {
		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
		struct sk_buff *skb = __skb_dequeue(&ring->queue);

		pci_unmap_single(rtlpci->pdev,
				 rtlpriv->cfg->ops->get_desc(
				 (u8 *)entry, true, HW_DESC_TXBUFF_ADDR),
				 skb->len, PCI_DMA_TODEVICE);
		kfree_skb(skb);
		ring->idx = (ring->idx + 1) % ring->entries;
	}
	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
}

static void _rtl8821ae_set_bcn_ctrl_reg(struct ieee80211_hw *hw,
					u8 set_bits, u8 clear_bits)
{
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	struct rtl_priv *rtlpriv = rtl_priv(hw);

	rtlpci->reg_bcn_ctrl_val |= set_bits;
	rtlpci->reg_bcn_ctrl_val &= ~clear_bits;

	rtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlpci->reg_bcn_ctrl_val);
}

void _rtl8821ae_stop_tx_beacon(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 tmp1byte;

	tmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);
	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte & (~BIT(6)));
	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);
	tmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);
	tmp1byte &= ~(BIT(0));
	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);
}

void _rtl8821ae_resume_tx_beacon(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 tmp1byte;

	tmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);
	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte | BIT(6));
	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);
	tmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);
	tmp1byte |= BIT(0);
	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);
}

static void _rtl8821ae_enable_bcn_sub_func(struct ieee80211_hw *hw)
{
	_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(1));
}

static void _rtl8821ae_disable_bcn_sub_func(struct ieee80211_hw *hw)
{
	_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(1), 0);
}

static void _rtl8821ae_set_fw_clock_on(struct ieee80211_hw *hw,
				       u8 rpwm_val, bool b_need_turn_off_ckk)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	bool b_support_remote_wake_up;
	u32 count = 0, isr_regaddr, content;
	bool b_schedule_timer = b_need_turn_off_ckk;

	rtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,
					(u8 *)(&b_support_remote_wake_up));

	if (!rtlhal->fw_ready)
		return;
	if (!rtlpriv->psc.fw_current_inpsmode)
		return;

	while (1) {
		spin_lock_bh(&rtlpriv->locks.fw_ps_lock);
		if (rtlhal->fw_clk_change_in_progress) {
			while (rtlhal->fw_clk_change_in_progress) {
				spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
				count++;
				udelay(100);
				if (count > 1000)
					goto change_done;
				spin_lock_bh(&rtlpriv->locks.fw_ps_lock);
			}
			spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
		} else {
			rtlhal->fw_clk_change_in_progress = false;
			spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
			goto change_done;
		}
	}
change_done:
	if (IS_IN_LOW_POWER_STATE_8821AE(rtlhal->fw_ps_state)) {
		rtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_SET_RPWM,
					(u8 *)(&rpwm_val));
		if (FW_PS_IS_ACK(rpwm_val)) {
			isr_regaddr = REG_HISR;
			content = rtl_read_dword(rtlpriv, isr_regaddr);
			while (!(content & IMR_CPWM) && (count < 500)) {
				udelay(50);
				count++;
				content = rtl_read_dword(rtlpriv, isr_regaddr);
			}

			if (content & IMR_CPWM) {
				rtl_write_word(rtlpriv, isr_regaddr, 0x0100);
				rtlhal->fw_ps_state = FW_PS_STATE_RF_ON_8821AE;
				RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
					 "Receive CPWM INT!!! Set rtlhal->FwPSState = %X\n",
					 rtlhal->fw_ps_state);
			}
		}

		spin_lock_bh(&rtlpriv->locks.fw_ps_lock);
		rtlhal->fw_clk_change_in_progress = false;
		spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
		if (b_schedule_timer)
			mod_timer(&rtlpriv->works.fw_clockoff_timer,
				  jiffies + MSECS(10));
	} else  {
		spin_lock_bh(&rtlpriv->locks.fw_ps_lock);
		rtlhal->fw_clk_change_in_progress = false;
		spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
	}
}

static void _rtl8821ae_set_fw_clock_off(struct ieee80211_hw *hw,
					u8 rpwm_val)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	struct rtl8192_tx_ring *ring;
	enum rf_pwrstate rtstate;
	bool b_schedule_timer = false;
	u8 queue;

	if (!rtlhal->fw_ready)
		return;
	if (!rtlpriv->psc.fw_current_inpsmode)
		return;
	if (!rtlhal->allow_sw_to_change_hwclc)
		return;
	rtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RF_STATE, (u8 *)(&rtstate));
	if (rtstate == ERFOFF || rtlpriv->psc.inactive_pwrstate == ERFOFF)
		return;

	for (queue = 0; queue < RTL_PCI_MAX_TX_QUEUE_COUNT; queue++) {
		ring = &rtlpci->tx_ring[queue];
		if (skb_queue_len(&ring->queue)) {
			b_schedule_timer = true;
			break;
		}
	}

	if (b_schedule_timer) {
		mod_timer(&rtlpriv->works.fw_clockoff_timer,
			  jiffies + MSECS(10));
		return;
	}

	if (FW_PS_STATE(rtlhal->fw_ps_state) !=
		FW_PS_STATE_RF_OFF_LOW_PWR_8821AE) {
		spin_lock_bh(&rtlpriv->locks.fw_ps_lock);
		if (!rtlhal->fw_clk_change_in_progress) {
			rtlhal->fw_clk_change_in_progress = true;
			spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
			rtlhal->fw_ps_state = FW_PS_STATE(rpwm_val);
			rtl_write_word(rtlpriv, REG_HISR, 0x0100);
			rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,
						      (u8 *)(&rpwm_val));
			spin_lock_bh(&rtlpriv->locks.fw_ps_lock);
			rtlhal->fw_clk_change_in_progress = false;
			spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
		} else {
			spin_unlock_bh(&rtlpriv->locks.fw_ps_lock);
			mod_timer(&rtlpriv->works.fw_clockoff_timer,
				  jiffies + MSECS(10));
		}
	}
}

static void _rtl8821ae_set_fw_ps_rf_on(struct ieee80211_hw *hw)
{
	u8 rpwm_val = 0;

	rpwm_val |= (FW_PS_STATE_RF_OFF_8821AE | FW_PS_ACK);
	_rtl8821ae_set_fw_clock_on(hw, rpwm_val, true);
}

static void _rtl8821ae_fwlps_leave(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	bool fw_current_inps = false;
	u8 rpwm_val = 0, fw_pwrmode = FW_PS_ACTIVE_MODE;

	if (ppsc->low_power_enable) {
		rpwm_val = (FW_PS_STATE_ALL_ON_8821AE|FW_PS_ACK);/* RF on */
		_rtl8821ae_set_fw_clock_on(hw, rpwm_val, false);
		rtlhal->allow_sw_to_change_hwclc = false;
		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,
				(u8 *)(&fw_pwrmode));
		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,
				(u8 *)(&fw_current_inps));
	} else {
		rpwm_val = FW_PS_STATE_ALL_ON_8821AE;	/* RF on */
		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,
				(u8 *)(&rpwm_val));
		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,
				(u8 *)(&fw_pwrmode));
		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,
				(u8 *)(&fw_current_inps));
	}
}

static void _rtl8821ae_fwlps_enter(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	bool fw_current_inps = true;
	u8 rpwm_val;

	if (ppsc->low_power_enable) {
		rpwm_val = FW_PS_STATE_RF_OFF_LOW_PWR_8821AE;	/* RF off */
		rtlpriv->cfg->ops->set_hw_reg(hw,
				HW_VAR_FW_PSMODE_STATUS,
				(u8 *)(&fw_current_inps));
		rtlpriv->cfg->ops->set_hw_reg(hw,
				HW_VAR_H2C_FW_PWRMODE,
				(u8 *)(&ppsc->fwctrl_psmode));
		rtlhal->allow_sw_to_change_hwclc = true;
		_rtl8821ae_set_fw_clock_off(hw, rpwm_val);
	} else {
		rpwm_val = FW_PS_STATE_RF_OFF_8821AE;	/* RF off */
		rtlpriv->cfg->ops->set_hw_reg(hw,
				HW_VAR_FW_PSMODE_STATUS,
				(u8 *)(&fw_current_inps));
		rtlpriv->cfg->ops->set_hw_reg(hw,
				HW_VAR_H2C_FW_PWRMODE,
				(u8 *)(&ppsc->fwctrl_psmode));
		rtlpriv->cfg->ops->set_hw_reg(hw,
				HW_VAR_SET_RPWM,
				(u8 *)(&rpwm_val));
	}
}

static void _rtl8821ae_download_rsvd_page(struct ieee80211_hw *hw,
					  bool dl_whole_packets)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
	u8 tmp_regcr, tmp_reg422, bcnvalid_reg;
	u8 count = 0, dlbcn_count = 0;
	bool send_beacon = false;

	tmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);
	rtl_write_byte(rtlpriv, REG_CR + 1, (tmp_regcr | BIT(0)));

	_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(3));
	_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(4), 0);

	tmp_reg422 = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);
	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,
		       tmp_reg422 & (~BIT(6)));
	if (tmp_reg422 & BIT(6))
		send_beacon = true;

	do {
		bcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);
		rtl_write_byte(rtlpriv, REG_TDECTRL + 2,
			       (bcnvalid_reg | BIT(0)));
		_rtl8821ae_return_beacon_queue_skb(hw);

		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
			rtl8812ae_set_fw_rsvdpagepkt(hw, false,
						     dl_whole_packets);
		else
			rtl8821ae_set_fw_rsvdpagepkt(hw, false,
						     dl_whole_packets);

		bcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);
		count = 0;
		while (!(bcnvalid_reg & BIT(0)) && count < 20) {
			count++;
			udelay(10);
			bcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);
		}
		dlbcn_count++;
	} while (!(bcnvalid_reg & BIT(0)) && dlbcn_count < 5);

	if (!(bcnvalid_reg & BIT(0)))
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Download RSVD page failed!\n");
	if (bcnvalid_reg & BIT(0) && rtlhal->enter_pnp_sleep) {
		rtl_write_byte(rtlpriv, REG_TDECTRL + 2, bcnvalid_reg | BIT(0));
		_rtl8821ae_return_beacon_queue_skb(hw);
		if (send_beacon) {
			dlbcn_count = 0;
			do {
				rtl_write_byte(rtlpriv, REG_TDECTRL + 2,
					       bcnvalid_reg | BIT(0));

				_rtl8821ae_return_beacon_queue_skb(hw);

				if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
					rtl8812ae_set_fw_rsvdpagepkt(hw, true,
								     false);
				else
					rtl8821ae_set_fw_rsvdpagepkt(hw, true,
								     false);

				/* check rsvd page download OK. */
				bcnvalid_reg = rtl_read_byte(rtlpriv,
							     REG_TDECTRL + 2);
				count = 0;
				while (!(bcnvalid_reg & BIT(0)) && count < 20) {
					count++;
					udelay(10);
					bcnvalid_reg =
					  rtl_read_byte(rtlpriv,
							REG_TDECTRL + 2);
				}
				dlbcn_count++;
			} while (!(bcnvalid_reg & BIT(0)) && dlbcn_count < 5);

			if (!(bcnvalid_reg & BIT(0)))
				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
					 "2 Download RSVD page failed!\n");
		}
	}

	if (bcnvalid_reg & BIT(0))
		rtl_write_byte(rtlpriv, REG_TDECTRL + 2, BIT(0));

	_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);
	_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(4));

	if (send_beacon)
		rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp_reg422);

	if (!rtlhal->enter_pnp_sleep) {
		tmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);
		rtl_write_byte(rtlpriv, REG_CR + 1, (tmp_regcr & ~(BIT(0))));
	}
}

void rtl8821ae_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));

	switch (variable) {
	case HW_VAR_ETHER_ADDR:
		*((u32 *)(val)) = rtl_read_dword(rtlpriv, REG_MACID);
		*((u16 *)(val+4)) = rtl_read_word(rtlpriv, REG_MACID + 4);
		break;
	case HW_VAR_BSSID:
		*((u32 *)(val)) = rtl_read_dword(rtlpriv, REG_BSSID);
		*((u16 *)(val+4)) = rtl_read_word(rtlpriv, REG_BSSID+4);
		break;
	case HW_VAR_MEDIA_STATUS:
		val[0] = rtl_read_byte(rtlpriv, REG_CR+2) & 0x3;
		break;
	case HW_VAR_SLOT_TIME:
		*((u8 *)(val)) = mac->slot_time;
		break;
	case HW_VAR_BEACON_INTERVAL:
		*((u16 *)(val)) = rtl_read_word(rtlpriv, REG_BCN_INTERVAL);
		break;
	case HW_VAR_ATIM_WINDOW:
		*((u16 *)(val)) =  rtl_read_word(rtlpriv, REG_ATIMWND);
		break;
	case HW_VAR_RCR:
		*((u32 *)(val)) = rtlpci->receive_config;
		break;
	case HW_VAR_RF_STATE:
		*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;
		break;
	case HW_VAR_FWLPS_RF_ON:{
		enum rf_pwrstate rfstate;
		u32 val_rcr;

		rtlpriv->cfg->ops->get_hw_reg(hw,
					      HW_VAR_RF_STATE,
					      (u8 *)(&rfstate));
		if (rfstate == ERFOFF) {
			*((bool *)(val)) = true;
		} else {
			val_rcr = rtl_read_dword(rtlpriv, REG_RCR);
			val_rcr &= 0x00070000;
			if (val_rcr)
				*((bool *)(val)) = false;
			else
				*((bool *)(val)) = true;
		}
		break; }
	case HW_VAR_FW_PSMODE_STATUS:
		*((bool *)(val)) = ppsc->fw_current_inpsmode;
		break;
	case HW_VAR_CORRECT_TSF:{
		u64 tsf;
		u32 *ptsf_low = (u32 *)&tsf;
		u32 *ptsf_high = ((u32 *)&tsf) + 1;

		*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));
		*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);

		*((u64 *)(val)) = tsf;

		break; }
	case HAL_DEF_WOWLAN:
		if (ppsc->wo_wlan_mode)
			*((bool *)(val)) = true;
		else
			*((bool *)(val)) = false;
		break;
	default:
		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
			 "switch case not process %x\n", variable);
		break;
	}
}

void rtl8821ae_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	u8 idx;

	switch (variable) {
	case HW_VAR_ETHER_ADDR:{
			for (idx = 0; idx < ETH_ALEN; idx++) {
				rtl_write_byte(rtlpriv, (REG_MACID + idx),
					       val[idx]);
			}
			break;
		}
	case HW_VAR_BASIC_RATE:{
			u16 b_rate_cfg = ((u16 *)val)[0];
			b_rate_cfg = b_rate_cfg & 0x15f;
			rtl_write_word(rtlpriv, REG_RRSR, b_rate_cfg);
			break;
		}
	case HW_VAR_BSSID:{
			for (idx = 0; idx < ETH_ALEN; idx++) {
				rtl_write_byte(rtlpriv, (REG_BSSID + idx),
					       val[idx]);
			}
			break;
		}
	case HW_VAR_SIFS:
		rtl_write_byte(rtlpriv, REG_SIFS_CTX + 1, val[0]);
		rtl_write_byte(rtlpriv, REG_SIFS_TRX + 1, val[0]);

		rtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);
		rtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);

		rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM + 1, val[0]);
		rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM, val[0]);
		break;
	case HW_VAR_R2T_SIFS:
		rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM + 1, val[0]);
		break;
	case HW_VAR_SLOT_TIME:{
		u8 e_aci;

		RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
			 "HW_VAR_SLOT_TIME %x\n", val[0]);

		rtl_write_byte(rtlpriv, REG_SLOT, val[0]);

		for (e_aci = 0; e_aci < AC_MAX; e_aci++) {
			rtlpriv->cfg->ops->set_hw_reg(hw,
						      HW_VAR_AC_PARAM,
						      (u8 *)(&e_aci));
		}
		break; }
	case HW_VAR_ACK_PREAMBLE:{
		u8 reg_tmp;
		u8 short_preamble = (bool)(*(u8 *)val);

		reg_tmp = rtl_read_byte(rtlpriv, REG_TRXPTCL_CTL+2);
		if (short_preamble) {
			reg_tmp |= BIT(1);
			rtl_write_byte(rtlpriv, REG_TRXPTCL_CTL + 2,
				       reg_tmp);
		} else {
			reg_tmp &= (~BIT(1));
			rtl_write_byte(rtlpriv,
				REG_TRXPTCL_CTL + 2,
				reg_tmp);
		}
		break; }
	case HW_VAR_WPA_CONFIG:
		rtl_write_byte(rtlpriv, REG_SECCFG, *((u8 *)val));
		break;
	case HW_VAR_AMPDU_MIN_SPACE:{
		u8 min_spacing_to_set;
		u8 sec_min_space;

		min_spacing_to_set = *((u8 *)val);
		if (min_spacing_to_set <= 7) {
			sec_min_space = 0;

			if (min_spacing_to_set < sec_min_space)
				min_spacing_to_set = sec_min_space;

			mac->min_space_cfg = ((mac->min_space_cfg &
					       0xf8) |
					      min_spacing_to_set);

			*val = min_spacing_to_set;

			RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
				 "Set HW_VAR_AMPDU_MIN_SPACE: %#x\n",
				  mac->min_space_cfg);

			rtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,
				       mac->min_space_cfg);
		}
		break; }
	case HW_VAR_SHORTGI_DENSITY:{
		u8 density_to_set;

		density_to_set = *((u8 *)val);
		mac->min_space_cfg |= (density_to_set << 3);

		RT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,
			 "Set HW_VAR_SHORTGI_DENSITY: %#x\n",
			  mac->min_space_cfg);

		rtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,
			       mac->min_space_cfg);

		break; }
	case HW_VAR_AMPDU_FACTOR:{
		u32	ampdu_len =  (*((u8 *)val));

		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
			if (ampdu_len < VHT_AGG_SIZE_128K)
				ampdu_len =
					(0x2000 << (*((u8 *)val))) - 1;
			else
				ampdu_len = 0x1ffff;
		} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
			if (ampdu_len < HT_AGG_SIZE_64K)
				ampdu_len =
					(0x2000 << (*((u8 *)val))) - 1;
			else
				ampdu_len = 0xffff;
		}
		ampdu_len |= BIT(31);

		rtl_write_dword(rtlpriv,
			REG_AMPDU_MAX_LENGTH_8812, ampdu_len);
		break; }
	case HW_VAR_AC_PARAM:{
		u8 e_aci = *((u8 *)val);

		rtl8821ae_dm_init_edca_turbo(hw);
		if (rtlpci->acm_method != EACMWAY2_SW)
			rtlpriv->cfg->ops->set_hw_reg(hw,
						      HW_VAR_ACM_CTRL,
						      (u8 *)(&e_aci));
		break; }
	case HW_VAR_ACM_CTRL:{
		u8 e_aci = *((u8 *)val);
		union aci_aifsn *p_aci_aifsn =
		    (union aci_aifsn *)(&mac->ac[0].aifs);
		u8 acm = p_aci_aifsn->f.acm;
		u8 acm_ctrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);

		acm_ctrl =
		    acm_ctrl | ((rtlpci->acm_method == 2) ? 0x0 : 0x1);

		if (acm) {
			switch (e_aci) {
			case AC0_BE:
				acm_ctrl |= ACMHW_BEQEN;
				break;
			case AC2_VI:
				acm_ctrl |= ACMHW_VIQEN;
				break;
			case AC3_VO:
				acm_ctrl |= ACMHW_VOQEN;
				break;
			default:
				RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
					 "HW_VAR_ACM_CTRL acm set failed: eACI is %d\n",
					 acm);
				break;
			}
		} else {
			switch (e_aci) {
			case AC0_BE:
				acm_ctrl &= (~ACMHW_BEQEN);
				break;
			case AC2_VI:
				acm_ctrl &= (~ACMHW_VIQEN);
				break;
			case AC3_VO:
				acm_ctrl &= (~ACMHW_BEQEN);
				break;
			default:
				RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
					 "switch case not process\n");
				break;
			}
		}

		RT_TRACE(rtlpriv, COMP_QOS, DBG_TRACE,
			 "SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\n",
			 acm_ctrl);
		rtl_write_byte(rtlpriv, REG_ACMHWCTRL, acm_ctrl);
		break; }
	case HW_VAR_RCR:
		rtl_write_dword(rtlpriv, REG_RCR, ((u32 *)(val))[0]);
		rtlpci->receive_config = ((u32 *)(val))[0];
		break;
	case HW_VAR_RETRY_LIMIT:{
		u8 retry_limit = ((u8 *)(val))[0];

		rtl_write_word(rtlpriv, REG_RL,
			       retry_limit << RETRY_LIMIT_SHORT_SHIFT |
			       retry_limit << RETRY_LIMIT_LONG_SHIFT);
		break; }
	case HW_VAR_DUAL_TSF_RST:
		rtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));
		break;
	case HW_VAR_EFUSE_BYTES:
		rtlefuse->efuse_usedbytes = *((u16 *)val);
		break;
	case HW_VAR_EFUSE_USAGE:
		rtlefuse->efuse_usedpercentage = *((u8 *)val);
		break;
	case HW_VAR_IO_CMD:
		rtl8821ae_phy_set_io_cmd(hw, (*(enum io_type *)val));
		break;
	case HW_VAR_SET_RPWM:{
		u8 rpwm_val;

		rpwm_val = rtl_read_byte(rtlpriv, REG_PCIE_HRPWM);
		udelay(1);

		if (rpwm_val & BIT(7)) {
			rtl_write_byte(rtlpriv, REG_PCIE_HRPWM,
				       (*(u8 *)val));
		} else {
			rtl_write_byte(rtlpriv, REG_PCIE_HRPWM,
				       ((*(u8 *)val) | BIT(7)));
		}

		break; }
	case HW_VAR_H2C_FW_PWRMODE:
		rtl8821ae_set_fw_pwrmode_cmd(hw, (*(u8 *)val));
		break;
	case HW_VAR_FW_PSMODE_STATUS:
		ppsc->fw_current_inpsmode = *((bool *)val);
		break;
	case HW_VAR_INIT_RTS_RATE:
		break;
	case HW_VAR_RESUME_CLK_ON:
		_rtl8821ae_set_fw_ps_rf_on(hw);
		break;
	case HW_VAR_FW_LPS_ACTION:{
		bool b_enter_fwlps = *((bool *)val);

		if (b_enter_fwlps)
			_rtl8821ae_fwlps_enter(hw);
		 else
			_rtl8821ae_fwlps_leave(hw);
		 break; }
	case HW_VAR_H2C_FW_JOINBSSRPT:{
		u8 mstatus = (*(u8 *)val);

		if (mstatus == RT_MEDIA_CONNECT) {
			rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID,
						      NULL);
			_rtl8821ae_download_rsvd_page(hw, false);
		}
		rtl8821ae_set_fw_media_status_rpt_cmd(hw, mstatus);

		break; }
	case HW_VAR_H2C_FW_P2P_PS_OFFLOAD:
		rtl8821ae_set_p2p_ps_offload_cmd(hw, (*(u8 *)val));
		break;
	case HW_VAR_AID:{
		u16 u2btmp;
		u2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);
		u2btmp &= 0xC000;
		rtl_write_word(rtlpriv, REG_BCN_PSR_RPT, (u2btmp |
			       mac->assoc_id));
		break; }
	case HW_VAR_CORRECT_TSF:{
		u8 btype_ibss = ((u8 *)(val))[0];

		if (btype_ibss)
			_rtl8821ae_stop_tx_beacon(hw);

		_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(3));

		rtl_write_dword(rtlpriv, REG_TSFTR,
				(u32)(mac->tsf & 0xffffffff));
		rtl_write_dword(rtlpriv, REG_TSFTR + 4,
				(u32)((mac->tsf >> 32) & 0xffffffff));

		_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);

		if (btype_ibss)
			_rtl8821ae_resume_tx_beacon(hw);
		break; }
	case HW_VAR_NAV_UPPER: {
		u32	us_nav_upper = ((u32)*val);

		if (us_nav_upper > HAL_92C_NAV_UPPER_UNIT * 0xFF) {
			RT_TRACE(rtlpriv, COMP_INIT , DBG_WARNING,
				 "The setting value (0x%08X us) of NAV_UPPER is larger than (%d * 0xFF)!!!\n",
				 us_nav_upper, HAL_92C_NAV_UPPER_UNIT);
			break;
		}
		rtl_write_byte(rtlpriv, REG_NAV_UPPER,
			       ((u8)((us_nav_upper +
				HAL_92C_NAV_UPPER_UNIT - 1) /
				HAL_92C_NAV_UPPER_UNIT)));
		break; }
	case HW_VAR_KEEP_ALIVE: {
		u8 array[2];
		array[0] = 0xff;
		array[1] = *((u8 *)val);
		rtl8821ae_fill_h2c_cmd(hw, H2C_8821AE_KEEP_ALIVE_CTRL, 2,
				       array);
		break; }
	default:
		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
			 "switch case not process %x\n", variable);
		break;
	}
}

static bool _rtl8821ae_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	bool status = true;
	long count = 0;
	u32 value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) |
		    _LLT_OP(_LLT_WRITE_ACCESS);

	rtl_write_dword(rtlpriv, REG_LLT_INIT, value);

	do {
		value = rtl_read_dword(rtlpriv, REG_LLT_INIT);
		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))
			break;

		if (count > POLLING_LLT_THRESHOLD) {
			RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
				 "Failed to polling write LLT done at address %d!\n",
				 address);
			status = false;
			break;
		}
	} while (++count);

	return status;
}

static bool _rtl8821ae_llt_table_init(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	unsigned short i;
	u8 txpktbuf_bndy;
	u32 rqpn;
	u8 maxpage;
	bool status;

	maxpage = 255;
	txpktbuf_bndy = 0xF8;
	rqpn = 0x80e70808;
	if (rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8812AE) {
		txpktbuf_bndy = 0xFA;
		rqpn = 0x80e90808;
	}

	rtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);
	rtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, MAX_RX_DMA_BUFFER_SIZE - 1);

	rtl_write_byte(rtlpriv, REG_TDECTRL + 1, txpktbuf_bndy);

	rtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
	rtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);

	rtl_write_byte(rtlpriv, REG_PBP, 0x31);
	rtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, 0x4);

	for (i = 0; i < (txpktbuf_bndy - 1); i++) {
		status = _rtl8821ae_llt_write(hw, i, i + 1);
		if (!status)
			return status;
	}

	status = _rtl8821ae_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);
	if (!status)
		return status;

	for (i = txpktbuf_bndy; i < maxpage; i++) {
		status = _rtl8821ae_llt_write(hw, i, (i + 1));
		if (!status)
			return status;
	}

	status = _rtl8821ae_llt_write(hw, maxpage, txpktbuf_bndy);
	if (!status)
		return status;

	rtl_write_dword(rtlpriv, REG_RQPN, rqpn);

	rtl_write_byte(rtlpriv, REG_RQPN_NPQ, 0x00);

	return true;
}

static void _rtl8821ae_gen_refresh_led_state(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	struct rtl_led *pled0 = &pcipriv->ledctl.sw_led0;
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));

	if (rtlpriv->rtlhal.up_first_time)
		return;

	if (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)
		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
			rtl8812ae_sw_led_on(hw, pled0);
		else
			rtl8821ae_sw_led_on(hw, pled0);
	else if (ppsc->rfoff_reason == RF_CHANGE_BY_INIT)
		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
			rtl8812ae_sw_led_on(hw, pled0);
		else
			rtl8821ae_sw_led_on(hw, pled0);
	else
		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
			rtl8812ae_sw_led_off(hw, pled0);
		else
			rtl8821ae_sw_led_off(hw, pled0);
}

static bool _rtl8821ae_init_mac(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));

	u8 bytetmp = 0;
	u16 wordtmp = 0;
	bool mac_func_enable = rtlhal->mac_func_enable;

	rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x00);

	/*Auto Power Down to CHIP-off State*/
	bytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1) & (~BIT(7));
	rtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, bytetmp);

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
		/* HW Power on sequence*/
		if (!rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK,
					      PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,
					      RTL8812_NIC_ENABLE_FLOW)) {
				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
					 "init 8812 MAC Fail as power on failure\n");
				return false;
		}
	} else {
		/* HW Power on sequence */
		if (!rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_A_MSK,
					      PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,
					      RTL8821A_NIC_ENABLE_FLOW)){
			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
				"init 8821 MAC Fail as power on failure\n");
			return false;
		}
	}

	bytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO) | BIT(4);
	rtl_write_byte(rtlpriv, REG_APS_FSMCO, bytetmp);

	bytetmp = rtl_read_byte(rtlpriv, REG_CR);
	bytetmp = 0xff;
	rtl_write_byte(rtlpriv, REG_CR, bytetmp);
	mdelay(2);

	bytetmp = 0xff;
	rtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, bytetmp);
	mdelay(2);

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		bytetmp = rtl_read_byte(rtlpriv, REG_SYS_CFG + 3);
		if (bytetmp & BIT(0)) {
			bytetmp = rtl_read_byte(rtlpriv, 0x7c);
			bytetmp |= BIT(6);
			rtl_write_byte(rtlpriv, 0x7c, bytetmp);
		}
	}

	bytetmp = rtl_read_byte(rtlpriv, REG_GPIO_MUXCFG + 1);
	bytetmp &= ~BIT(4);
	rtl_write_byte(rtlpriv, REG_GPIO_MUXCFG + 1, bytetmp);

	rtl_write_word(rtlpriv, REG_CR, 0x2ff);

	if (!mac_func_enable) {
		if (!_rtl8821ae_llt_table_init(hw))
			return false;
	}

	rtl_write_dword(rtlpriv, REG_HISR, 0xffffffff);
	rtl_write_dword(rtlpriv, REG_HISRE, 0xffffffff);

	/* Enable FW Beamformer Interrupt */
	bytetmp = rtl_read_byte(rtlpriv, REG_FWIMR + 3);
	rtl_write_byte(rtlpriv, REG_FWIMR + 3, bytetmp | BIT(6));

	wordtmp = rtl_read_word(rtlpriv, REG_TRXDMA_CTRL);
	wordtmp &= 0xf;
	wordtmp |= 0xF5B1;
	rtl_write_word(rtlpriv, REG_TRXDMA_CTRL, wordtmp);

	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 1, 0x1F);
	rtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);
	rtl_write_word(rtlpriv, REG_RXFLTMAP2, 0xFFFF);
	/*low address*/
	rtl_write_dword(rtlpriv, REG_BCNQ_DESA,
			rtlpci->tx_ring[BEACON_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_MGQ_DESA,
			rtlpci->tx_ring[MGNT_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_VOQ_DESA,
			rtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_VIQ_DESA,
			rtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_BEQ_DESA,
			rtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_BKQ_DESA,
			rtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_HQ_DESA,
			rtlpci->tx_ring[HIGH_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_RX_DESA,
			rtlpci->rx_ring[RX_MPDU_QUEUE].dma & DMA_BIT_MASK(32));

	rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 3, 0x77);

	rtl_write_dword(rtlpriv, REG_INT_MIG, 0);

	rtl_write_dword(rtlpriv, REG_MCUTST_1, 0);

	rtl_write_byte(rtlpriv, REG_SECONDARY_CCA_CTRL, 0x3);
	_rtl8821ae_gen_refresh_led_state(hw);

	return true;
}

static void _rtl8821ae_hw_configure(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	u32 reg_rrsr;

	reg_rrsr = RATE_ALL_CCK | RATE_ALL_OFDM_AG;

	rtl_write_dword(rtlpriv, REG_RRSR, reg_rrsr);
	/* ARFB table 9 for 11ac 5G 2SS */
	rtl_write_dword(rtlpriv, REG_ARFR0 + 4, 0xfffff000);
	/* ARFB table 10 for 11ac 5G 1SS */
	rtl_write_dword(rtlpriv, REG_ARFR1 + 4, 0x003ff000);
	/* ARFB table 11 for 11ac 24G 1SS */
	rtl_write_dword(rtlpriv, REG_ARFR2, 0x00000015);
	rtl_write_dword(rtlpriv, REG_ARFR2 + 4, 0x003ff000);
	/* ARFB table 12 for 11ac 24G 1SS */
	rtl_write_dword(rtlpriv, REG_ARFR3, 0x00000015);
	rtl_write_dword(rtlpriv, REG_ARFR3 + 4, 0xffcff000);
	/* 0x420[7] = 0 , enable retry AMPDU in new AMPD not singal MPDU. */
	rtl_write_word(rtlpriv, REG_FWHW_TXQ_CTRL, 0x1F00);
	rtl_write_byte(rtlpriv, REG_AMPDU_MAX_TIME, 0x70);

	/*Set retry limit*/
	rtl_write_word(rtlpriv, REG_RL, 0x0707);

	/* Set Data / Response auto rate fallack retry count*/
	rtl_write_dword(rtlpriv, REG_DARFRC, 0x01000000);
	rtl_write_dword(rtlpriv, REG_DARFRC + 4, 0x07060504);
	rtl_write_dword(rtlpriv, REG_RARFRC, 0x01000000);
	rtl_write_dword(rtlpriv, REG_RARFRC + 4, 0x07060504);

	rtlpci->reg_bcn_ctrl_val = 0x1d;
	rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtlpci->reg_bcn_ctrl_val);

	/* TBTT prohibit hold time. Suggested by designer TimChen. */
	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);

	/* AGGR_BK_TIME Reg51A 0x16 */
	rtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0040);

	/*For Rx TP. Suggested by SD1 Richard. Added by tynli. 2010.04.12.*/
	rtl_write_dword(rtlpriv, REG_FAST_EDCA_CTRL, 0x03086666);

	rtl_write_byte(rtlpriv, REG_HT_SINGLE_AMPDU, 0x80);
	rtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x20);
	rtl_write_word(rtlpriv, REG_MAX_AGGR_NUM, 0x1F1F);
}

static u16 _rtl8821ae_mdio_read(struct rtl_priv *rtlpriv, u8 addr)
{
	u16 ret = 0;
	u8 tmp = 0, count = 0;

	rtl_write_byte(rtlpriv, REG_MDIO_CTL, addr | BIT(6));
	tmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(6);
	count = 0;
	while (tmp && count < 20) {
		udelay(10);
		tmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(6);
		count++;
	}
	if (0 == tmp)
		ret = rtl_read_word(rtlpriv, REG_MDIO_RDATA);

	return ret;
}

static void _rtl8821ae_mdio_write(struct rtl_priv *rtlpriv, u8 addr, u16 data)
{
	u8 tmp = 0, count = 0;

	rtl_write_word(rtlpriv, REG_MDIO_WDATA, data);
	rtl_write_byte(rtlpriv, REG_MDIO_CTL, addr | BIT(5));
	tmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(5);
	count = 0;
	while (tmp && count < 20) {
		udelay(10);
		tmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(5);
		count++;
	}
}

static u8 _rtl8821ae_dbi_read(struct rtl_priv *rtlpriv, u16 addr)
{
	u16 read_addr = addr & 0xfffc;
	u8 tmp = 0, count = 0, ret = 0;

	rtl_write_word(rtlpriv, REG_DBI_ADDR, read_addr);
	rtl_write_byte(rtlpriv, REG_DBI_FLAG, 0x2);
	tmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);
	count = 0;
	while (tmp && count < 20) {
		udelay(10);
		tmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);
		count++;
	}
	if (0 == tmp) {
		read_addr = REG_DBI_RDATA + addr % 4;
		ret = rtl_read_word(rtlpriv, read_addr);
	}
	return ret;
}

static void _rtl8821ae_dbi_write(struct rtl_priv *rtlpriv, u16 addr, u8 data)
{
	u8 tmp = 0, count = 0;
	u16 wrtie_addr, remainder = addr % 4;

	wrtie_addr = REG_DBI_WDATA + remainder;
	rtl_write_byte(rtlpriv, wrtie_addr, data);

	wrtie_addr = (addr & 0xfffc) | (BIT(0) << (remainder + 12));
	rtl_write_word(rtlpriv, REG_DBI_ADDR, wrtie_addr);

	rtl_write_byte(rtlpriv, REG_DBI_FLAG, 0x1);

	tmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);
	count = 0;
	while (tmp && count < 20) {
		udelay(10);
		tmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);
		count++;
	}
}

static void _rtl8821ae_enable_aspm_back_door(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	u8 tmp;

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		if (_rtl8821ae_mdio_read(rtlpriv, 0x04) != 0x8544)
			_rtl8821ae_mdio_write(rtlpriv, 0x04, 0x8544);

		if (_rtl8821ae_mdio_read(rtlpriv, 0x0b) != 0x0070)
			_rtl8821ae_mdio_write(rtlpriv, 0x0b, 0x0070);
	}

	tmp = _rtl8821ae_dbi_read(rtlpriv, 0x70f);
	_rtl8821ae_dbi_write(rtlpriv, 0x70f, tmp | BIT(7));

	tmp = _rtl8821ae_dbi_read(rtlpriv, 0x719);
	_rtl8821ae_dbi_write(rtlpriv, 0x719, tmp | BIT(3) | BIT(4));

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
		tmp  = _rtl8821ae_dbi_read(rtlpriv, 0x718);
		_rtl8821ae_dbi_write(rtlpriv, 0x718, tmp|BIT(4));
	}
}

void rtl8821ae_enable_hw_security_config(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 sec_reg_value;
	u8 tmp;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		 "PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\n",
		  rtlpriv->sec.pairwise_enc_algorithm,
		  rtlpriv->sec.group_enc_algorithm);

	if (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {
		RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
			 "not open hw encryption\n");
		return;
	}

	sec_reg_value = SCR_TXENCENABLE | SCR_RXDECENABLE;

	if (rtlpriv->sec.use_defaultkey) {
		sec_reg_value |= SCR_TXUSEDK;
		sec_reg_value |= SCR_RXUSEDK;
	}

	sec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);

	tmp = rtl_read_byte(rtlpriv, REG_CR + 1);
	rtl_write_byte(rtlpriv, REG_CR + 1, tmp | BIT(1));

	RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
		 "The SECR-value %x\n", sec_reg_value);

	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);
}

/* Static MacID Mapping (cf. Used in MacIdDoStaticMapping) ---------- */
#define MAC_ID_STATIC_FOR_DEFAULT_PORT				0
#define MAC_ID_STATIC_FOR_BROADCAST_MULTICAST		1
#define MAC_ID_STATIC_FOR_BT_CLIENT_START				2
#define MAC_ID_STATIC_FOR_BT_CLIENT_END				3
/* ----------------------------------------------------------- */

static void rtl8821ae_macid_initialize_mediastatus(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8	media_rpt[4] = {RT_MEDIA_CONNECT, 1,
		MAC_ID_STATIC_FOR_BROADCAST_MULTICAST,
		MAC_ID_STATIC_FOR_BT_CLIENT_END};

	rtlpriv->cfg->ops->set_hw_reg(hw,
		HW_VAR_H2C_FW_MEDIASTATUSRPT, media_rpt);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "Initialize MacId media status: from %d to %d\n",
		 MAC_ID_STATIC_FOR_BROADCAST_MULTICAST,
		 MAC_ID_STATIC_FOR_BT_CLIENT_END);
}

static bool _rtl8821ae_check_pcie_dma_hang(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 tmp;

	/* write reg 0x350 Bit[26]=1. Enable debug port. */
	tmp = rtl_read_byte(rtlpriv, REG_DBI_CTRL + 3);
	if (!(tmp & BIT(2))) {
		rtl_write_byte(rtlpriv, REG_DBI_CTRL + 3, (tmp | BIT(2)));
		mdelay(100);
	}

	/* read reg 0x350 Bit[25] if 1 : RX hang */
	/* read reg 0x350 Bit[24] if 1 : TX hang */
	tmp = rtl_read_byte(rtlpriv, REG_DBI_CTRL + 3);
	if ((tmp & BIT(0)) || (tmp & BIT(1))) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "CheckPcieDMAHang8821AE(): true! Reset PCIE DMA!\n");
		return true;
	} else {
		return false;
	}
}

static bool _rtl8821ae_reset_pcie_interface_dma(struct ieee80211_hw *hw,
					 bool mac_power_on,
					 bool in_watchdog)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	u8 tmp;
	bool release_mac_rx_pause;
	u8 backup_pcie_dma_pause;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "\n");

	/* 1. Disable register write lock. 0x1c[1] = 0 */
	tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL);
	tmp &= ~(BIT(1));
	rtl_write_byte(rtlpriv, REG_RSV_CTRL, tmp);
	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		/* write 0xCC bit[2] = 1'b1 */
		tmp = rtl_read_byte(rtlpriv, REG_PMC_DBG_CTRL2);
		tmp |= BIT(2);
		rtl_write_byte(rtlpriv, REG_PMC_DBG_CTRL2, tmp);
	}

	/* 2. Check and pause TRX DMA */
	/* write 0x284 bit[18] = 1'b1 */
	/* write 0x301 = 0xFF */
	tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
	if (tmp & BIT(2)) {
		/* Already pause before the function for another purpose. */
		release_mac_rx_pause = false;
	} else {
		rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp | BIT(2)));
		release_mac_rx_pause = true;
	}
	backup_pcie_dma_pause = rtl_read_byte(rtlpriv, REG_PCIE_CTRL_REG + 1);
	if (backup_pcie_dma_pause != 0xFF)
		rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFF);

	if (mac_power_on) {
		/* 3. reset TRX function */
		/* write 0x100 = 0x00 */
		rtl_write_byte(rtlpriv, REG_CR, 0);
	}

	/* 4. Reset PCIe DMA. 0x3[0] = 0 */
	tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);
	tmp &= ~(BIT(0));
	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp);

	/* 5. Enable PCIe DMA. 0x3[0] = 1 */
	tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);
	tmp |= BIT(0);
	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp);

	if (mac_power_on) {
		/* 6. enable TRX function */
		/* write 0x100 = 0xFF */
		rtl_write_byte(rtlpriv, REG_CR, 0xFF);

		/* We should init LLT & RQPN and
		 * prepare Tx/Rx descrptor address later
		 * because MAC function is reset.*/
	}

	/* 7. Restore PCIe autoload down bit */
	/* 8812AE does not has the defination. */
	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		/* write 0xF8 bit[17] = 1'b1 */
		tmp = rtl_read_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL + 2);
		tmp |= BIT(1);
		rtl_write_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL + 2, tmp);
	}

	/* In MAC power on state, BB and RF maybe in ON state,
	 * if we release TRx DMA here.
	 * it will cause packets to be started to Tx/Rx,
	 * so we release Tx/Rx DMA later.*/
	if (!mac_power_on/* || in_watchdog*/) {
		/* 8. release TRX DMA */
		/* write 0x284 bit[18] = 1'b0 */
		/* write 0x301 = 0x00 */
		if (release_mac_rx_pause) {
			tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
			rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL,
				       tmp & (~BIT(2)));
		}
		rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1,
			       backup_pcie_dma_pause);
	}

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		/* 9. lock system register */
		/* write 0xCC bit[2] = 1'b0 */
		tmp = rtl_read_byte(rtlpriv, REG_PMC_DBG_CTRL2);
		tmp &= ~(BIT(2));
		rtl_write_byte(rtlpriv, REG_PMC_DBG_CTRL2, tmp);
	}
	return true;
}

static void _rtl8821ae_get_wakeup_reason(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	struct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);
	u8 fw_reason = 0;
	struct timeval ts;

	fw_reason = rtl_read_byte(rtlpriv, REG_MCUTST_WOWLAN);

	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "WOL Read 0x1c7 = %02X\n",
		 fw_reason);

	ppsc->wakeup_reason = 0;

	rtlhal->last_suspend_sec = ts.tv_sec;

	switch (fw_reason) {
	case FW_WOW_V2_PTK_UPDATE_EVENT:
		ppsc->wakeup_reason = WOL_REASON_PTK_UPDATE;
		do_gettimeofday(&ts);
		ppsc->last_wakeup_time = ts.tv_sec*1000 + ts.tv_usec/1000;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a WOL PTK Key update event!\n");
		break;
	case FW_WOW_V2_GTK_UPDATE_EVENT:
		ppsc->wakeup_reason = WOL_REASON_GTK_UPDATE;
		do_gettimeofday(&ts);
		ppsc->last_wakeup_time = ts.tv_sec*1000 + ts.tv_usec/1000;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a WOL GTK Key update event!\n");
		break;
	case FW_WOW_V2_DISASSOC_EVENT:
		ppsc->wakeup_reason = WOL_REASON_DISASSOC;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a disassociation event!\n");
		break;
	case FW_WOW_V2_DEAUTH_EVENT:
		ppsc->wakeup_reason = WOL_REASON_DEAUTH;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a deauth event!\n");
		break;
	case FW_WOW_V2_FW_DISCONNECT_EVENT:
		ppsc->wakeup_reason = WOL_REASON_AP_LOST;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a Fw disconnect decision (AP lost) event!\n");
	break;
	case FW_WOW_V2_MAGIC_PKT_EVENT:
		ppsc->wakeup_reason = WOL_REASON_MAGIC_PKT;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a magic packet event!\n");
		break;
	case FW_WOW_V2_UNICAST_PKT_EVENT:
		ppsc->wakeup_reason = WOL_REASON_UNICAST_PKT;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's an unicast packet event!\n");
		break;
	case FW_WOW_V2_PATTERN_PKT_EVENT:
		ppsc->wakeup_reason = WOL_REASON_PATTERN_PKT;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's a pattern match event!\n");
		break;
	case FW_WOW_V2_RTD3_SSID_MATCH_EVENT:
		ppsc->wakeup_reason = WOL_REASON_RTD3_SSID_MATCH;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's an RTD3 Ssid match event!\n");
		break;
	case FW_WOW_V2_REALWOW_V2_WAKEUPPKT:
		ppsc->wakeup_reason = WOL_REASON_REALWOW_V2_WAKEUPPKT;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's an RealWoW wake packet event!\n");
		break;
	case FW_WOW_V2_REALWOW_V2_ACKLOST:
		ppsc->wakeup_reason = WOL_REASON_REALWOW_V2_ACKLOST;
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "It's an RealWoW ack lost event!\n");
		break;
	default:
		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
			 "WOL Read 0x1c7 = %02X, Unknown reason!\n",
			  fw_reason);
		break;
	}
}

static void _rtl8821ae_init_trx_desc_hw_address(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));

	/*low address*/
	rtl_write_dword(rtlpriv, REG_BCNQ_DESA,
			rtlpci->tx_ring[BEACON_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_MGQ_DESA,
			rtlpci->tx_ring[MGNT_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_VOQ_DESA,
			rtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_VIQ_DESA,
			rtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_BEQ_DESA,
			rtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_BKQ_DESA,
			rtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_HQ_DESA,
			rtlpci->tx_ring[HIGH_QUEUE].dma & DMA_BIT_MASK(32));
	rtl_write_dword(rtlpriv, REG_RX_DESA,
			rtlpci->rx_ring[RX_MPDU_QUEUE].dma & DMA_BIT_MASK(32));
}

static bool _rtl8821ae_init_llt_table(struct ieee80211_hw *hw, u32 boundary)
{
	bool status = true;
	u32 i;
	u32 txpktbuf_bndy = boundary;
	u32 last_entry_of_txpktbuf = LAST_ENTRY_OF_TX_PKT_BUFFER;

	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {
		status = _rtl8821ae_llt_write(hw, i , i + 1);
		if (!status)
			return status;
	}

	status = _rtl8821ae_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);
	if (!status)
		return status;

	for (i = txpktbuf_bndy ; i < last_entry_of_txpktbuf ; i++) {
		status = _rtl8821ae_llt_write(hw, i, (i + 1));
		if (!status)
			return status;
	}

	status = _rtl8821ae_llt_write(hw, last_entry_of_txpktbuf,
				      txpktbuf_bndy);
	if (!status)
		return status;

	return status;
}

static bool _rtl8821ae_dynamic_rqpn(struct ieee80211_hw *hw, u32 boundary,
			     u16 npq_rqpn_value, u32 rqpn_val)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 tmp;
	bool ret = true;
	u16 count = 0, tmp16;
	bool support_remote_wakeup;

	rtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,
				      (u8 *)(&support_remote_wakeup));

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "boundary=0x%#X, NPQ_RQPNValue=0x%#X, RQPNValue=0x%#X\n",
		  boundary, npq_rqpn_value, rqpn_val);

	/* stop PCIe DMA
	 * 1. 0x301[7:0] = 0xFE */
	rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);

	/* wait TXFF empty
	 * 2. polling till 0x41A[15:0]=0x07FF */
	tmp16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);
	while ((tmp16 & 0x07FF) != 0x07FF) {
		udelay(100);
		tmp16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);
		count++;
		if ((count % 200) == 0) {
			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
				 "Tx queue is not empty for 20ms!\n");
		}
		if (count >= 1000) {
			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
				 "Wait for Tx FIFO empty timeout!\n");
			break;
		}
	}

	/* TX pause
	 * 3. reg 0x522=0xFF */
	rtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);

	/* Wait TX State Machine OK
	 * 4. polling till reg 0x5FB~0x5F8 = 0x00000000 for 50ms */
	count = 0;
	while (rtl_read_byte(rtlpriv, REG_SCH_TXCMD) != 0) {
		udelay(100);
		count++;
		if (count >= 500) {
			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
				 "Wait for TX State Machine ready timeout !!\n");
			break;
		}
	}

	/* stop RX DMA path
	 * 5.	0x284[18] = 1
	 * 6.	wait till 0x284[17] == 1
	 * wait RX DMA idle */
	count = 0;
	tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
	rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp | BIT(2)));
	do {
		tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
		udelay(10);
		count++;
	} while (!(tmp & BIT(1)) && count < 100);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "Wait until Rx DMA Idle. count=%d REG[0x286]=0x%x\n",
		  count, tmp);

	/* reset BB
	 * 7.	0x02 [0] = 0 */
	tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);
	tmp &= ~(BIT(0));
	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, tmp);

	/* Reset TRX MAC
	 * 8.	 0x100 = 0x00
	 * Delay (1ms) */
	rtl_write_byte(rtlpriv, REG_CR, 0x00);
	udelay(1000);

	/* Disable MAC Security Engine
	 * 9.	0x100 bit[9]=0 */
	tmp = rtl_read_byte(rtlpriv, REG_CR + 1);
	tmp &= ~(BIT(1));
	rtl_write_byte(rtlpriv, REG_CR + 1, tmp);

	/* To avoid DD-Tim Circuit hang
	 * 10.	0x553 bit[5]=1 */
	tmp = rtl_read_byte(rtlpriv, REG_DUAL_TSF_RST);
	rtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (tmp | BIT(5)));

	/* Enable MAC Security Engine
	 * 11.	0x100 bit[9]=1 */
	tmp = rtl_read_byte(rtlpriv, REG_CR + 1);
	rtl_write_byte(rtlpriv, REG_CR + 1, (tmp | BIT(1)));

	/* Enable TRX MAC
	 * 12.	 0x100 = 0xFF
	 *	Delay (1ms) */
	rtl_write_byte(rtlpriv, REG_CR, 0xFF);
	udelay(1000);

	/* Enable BB
	 * 13.	0x02 [0] = 1 */
	tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);
	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, (tmp | BIT(0)));

	/* beacon setting
	 * 14,15. set beacon head page (reg 0x209 and 0x424) */
	rtl_write_byte(rtlpriv, REG_TDECTRL + 1, (u8)boundary);
	rtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, (u8)boundary);
	rtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, (u8)boundary);

	/* 16.	WMAC_LBK_BF_HD 0x45D[7:0]
	 * WMAC_LBK_BF_HD */
	rtl_write_byte(rtlpriv, REG_TXPKTBUF_WMAC_LBK_BF_HD,
		       (u8)boundary);

	rtl_write_word(rtlpriv, REG_TRXFF_BNDY, boundary);

	/* init LLT
	 * 17. init LLT */
	if (!_rtl8821ae_init_llt_table(hw, boundary)) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_WARNING,
			 "Failed to init LLT table!\n");
		return false;
	}

	/* reallocate RQPN
	 * 18. reallocate RQPN and init LLT */
	rtl_write_word(rtlpriv, REG_RQPN_NPQ, npq_rqpn_value);
	rtl_write_dword(rtlpriv, REG_RQPN, rqpn_val);

	/* release Tx pause
	 * 19. 0x522=0x00 */
	rtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);

	/* enable PCIE DMA
	 * 20. 0x301[7:0] = 0x00
	 * 21. 0x284[18] = 0 */
	rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x00);
	tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
	rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp&~BIT(2)));

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "End.\n");
	return ret;
}

static void _rtl8821ae_simple_initialize_adapter(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);

#if (USE_SPECIFIC_FW_TO_SUPPORT_WOWLAN == 1)
	/* Re-download normal Fw. */
	rtl8821ae_set_fw_related_for_wowlan(hw, false);
#endif

	/* Re-Initialize LLT table. */
	if (rtlhal->re_init_llt_table) {
		u32 rqpn = 0x80e70808;
		u8 rqpn_npq = 0, boundary = 0xF8;
		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
			rqpn = 0x80e90808;
			boundary = 0xFA;
		}
		if (_rtl8821ae_dynamic_rqpn(hw, boundary, rqpn_npq, rqpn))
			rtlhal->re_init_llt_table = false;
	}

	ppsc->rfpwr_state = ERFON;
}

static void _rtl8821ae_enable_l1off(struct ieee80211_hw *hw)
{
	u8 tmp  = 0;
	struct rtl_priv *rtlpriv = rtl_priv(hw);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "--->\n");

	tmp = _rtl8821ae_dbi_read(rtlpriv, 0x160);
	if (!(tmp & (BIT(2) | BIT(3)))) {
		RT_TRACE(rtlpriv, COMP_POWER | COMP_INIT, DBG_LOUD,
			 "0x160(%#x)return!!\n", tmp);
		return;
	}

	tmp = _rtl8821ae_mdio_read(rtlpriv, 0x1b);
	_rtl8821ae_mdio_write(rtlpriv, 0x1b, (tmp | BIT(4)));

	tmp = _rtl8821ae_dbi_read(rtlpriv, 0x718);
	_rtl8821ae_dbi_write(rtlpriv, 0x718, tmp | BIT(5));

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "<---\n");
}

static void _rtl8821ae_enable_ltr(struct ieee80211_hw *hw)
{
	u8 tmp  = 0;
	struct rtl_priv *rtlpriv = rtl_priv(hw);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "--->\n");

	/* Check 0x98[10] */
	tmp = _rtl8821ae_dbi_read(rtlpriv, 0x99);
	if (!(tmp & BIT(2))) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "<---0x99(%#x) return!!\n", tmp);
		return;
	}

	/* LTR idle latency, 0x90 for 144us */
	rtl_write_dword(rtlpriv, 0x798, 0x88908890);

	/* LTR active latency, 0x3c for 60us */
	rtl_write_dword(rtlpriv, 0x79c, 0x883c883c);

	tmp = rtl_read_byte(rtlpriv, 0x7a4);
	rtl_write_byte(rtlpriv, 0x7a4, (tmp | BIT(4)));

	tmp = rtl_read_byte(rtlpriv, 0x7a4);
	rtl_write_byte(rtlpriv, 0x7a4, (tmp & (~BIT(0))));
	rtl_write_byte(rtlpriv, 0x7a4, (tmp | BIT(0)));

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "<---\n");
}

static bool _rtl8821ae_wowlan_initialize_adapter(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
	bool init_finished = true;
	u8 tmp = 0;

	/* Get Fw wake up reason. */
	_rtl8821ae_get_wakeup_reason(hw);

	/* Patch Pcie Rx DMA hang after S3/S4 several times.
	 * The root cause has not be found. */
	if (_rtl8821ae_check_pcie_dma_hang(hw))
		_rtl8821ae_reset_pcie_interface_dma(hw, true, false);

	/* Prepare Tx/Rx Desc Hw address. */
	_rtl8821ae_init_trx_desc_hw_address(hw);

	/* Release Pcie Interface Rx DMA to allow wake packet DMA. */
	rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);
	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Enable PCIE Rx DMA.\n");

	/* Check wake up event.
	 * We should check wake packet bit before disable wowlan by H2C or
	 * Fw will clear the bit. */
	tmp = rtl_read_byte(rtlpriv, REG_FTISR + 3);
	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
		 "Read REG_FTISR 0x13f = %#X\n", tmp);

	/* Set the WoWLAN related function control disable. */
	rtl8821ae_set_fw_wowlan_mode(hw, false);
	rtl8821ae_set_fw_remote_wake_ctrl_cmd(hw, 0);

	if (rtlhal->hw_rof_enable) {
		tmp = rtl_read_byte(rtlpriv, REG_HSISR + 3);
		if (tmp & BIT(1)) {
			/* Clear GPIO9 ISR */
			rtl_write_byte(rtlpriv, REG_HSISR + 3, tmp | BIT(1));
			init_finished = false;
		} else {
			init_finished = true;
		}
	}

	if (init_finished) {
		_rtl8821ae_simple_initialize_adapter(hw);

		/* Release Pcie Interface Tx DMA. */
		rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x00);
		/* Release Pcie RX DMA */
		rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, 0x02);

		tmp = rtl_read_byte(rtlpriv, REG_CR + 1);
		rtl_write_byte(rtlpriv, REG_CR + 1, (tmp & (~BIT(0))));

		_rtl8821ae_enable_l1off(hw);
		_rtl8821ae_enable_ltr(hw);
	}

	return init_finished;
}

static void _rtl8812ae_bb8812_config_1t(struct ieee80211_hw *hw)
{
	/* BB OFDM RX Path_A */
	rtl_set_bbreg(hw, 0x808, 0xff, 0x11);
	/* BB OFDM TX Path_A */
	rtl_set_bbreg(hw, 0x80c, MASKLWORD, 0x1111);
	/* BB CCK R/Rx Path_A */
	rtl_set_bbreg(hw, 0xa04, 0x0c000000, 0x0);
	/* MCS support */
	rtl_set_bbreg(hw, 0x8bc, 0xc0000060, 0x4);
	/* RF Path_B HSSI OFF */
	rtl_set_bbreg(hw, 0xe00, 0xf, 0x4);
	/* RF Path_B Power Down */
	rtl_set_bbreg(hw, 0xe90, MASKDWORD, 0);
	/* ADDA Path_B OFF */
	rtl_set_bbreg(hw, 0xe60, MASKDWORD, 0);
	rtl_set_bbreg(hw, 0xe64, MASKDWORD, 0);
}

static void _rtl8821ae_poweroff_adapter(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	u8 u1b_tmp;

	rtlhal->mac_func_enable = false;

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		/* Combo (PCIe + USB) Card and PCIe-MF Card */
		/* 1. Run LPS WL RFOFF flow */
		/* RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		"=====>CardDisableRTL8812E,RTL8821A_NIC_LPS_ENTER_FLOW\n");
		*/
		rtl_hal_pwrseqcmdparsing(rtlpriv,
			PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,
			PWR_INTF_PCI_MSK, RTL8821A_NIC_LPS_ENTER_FLOW);
	}
	/* 2. 0x1F[7:0] = 0 */
	/* turn off RF */
	/* rtl_write_byte(rtlpriv, REG_RF_CTRL, 0x00); */
	if ((rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(7)) &&
		rtlhal->fw_ready) {
		rtl8821ae_firmware_selfreset(hw);
	}

	/* Reset MCU. Suggested by Filen. */
	u1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN+1);
	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN+1, (u1b_tmp & (~BIT(2))));

	/* g.	MCUFWDL 0x80[1:0]=0	 */
	/* reset MCU ready status */
	rtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		/* HW card disable configuration. */
		rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,
			PWR_INTF_PCI_MSK, RTL8821A_NIC_DISABLE_FLOW);
	} else {
		/* HW card disable configuration. */
		rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,
			PWR_INTF_PCI_MSK, RTL8812_NIC_DISABLE_FLOW);
	}

	/* Reset MCU IO Wrapper */
	u1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);
	rtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, (u1b_tmp & (~BIT(0))));
	u1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);
	rtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1b_tmp | BIT(0));

	/* 7. RSV_CTRL 0x1C[7:0] = 0x0E */
	/* lock ISO/CLK/Power control register */
	rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0e);
}

int rtl8821ae_hw_init(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	bool rtstatus = true;
	int err;
	u8 tmp_u1b;
	bool support_remote_wakeup;
	u32 nav_upper = WIFI_NAV_UPPER_US;

	rtlhal->being_init_adapter = true;
	rtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,
				      (u8 *)(&support_remote_wakeup));
	rtlpriv->intf_ops->disable_aspm(hw);

	/*YP wowlan not considered*/

	tmp_u1b = rtl_read_byte(rtlpriv, REG_CR);
	if (tmp_u1b != 0 && tmp_u1b != 0xEA) {
		rtlhal->mac_func_enable = true;
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "MAC has already power on.\n");
	} else {
		rtlhal->mac_func_enable = false;
		rtlhal->fw_ps_state = FW_PS_STATE_ALL_ON_8821AE;
	}

	if (support_remote_wakeup &&
		rtlhal->wake_from_pnp_sleep &&
		rtlhal->mac_func_enable) {
		if (_rtl8821ae_wowlan_initialize_adapter(hw)) {
			rtlhal->being_init_adapter = false;
			return 0;
		}
	}

	if (_rtl8821ae_check_pcie_dma_hang(hw)) {
		_rtl8821ae_reset_pcie_interface_dma(hw,
						    rtlhal->mac_func_enable,
						    false);
		rtlhal->mac_func_enable = false;
	}

	/* Reset MAC/BB/RF status if it is not powered off
	 * before calling initialize Hw flow to prevent
	 * from interface and MAC status mismatch.
	 * 2013.06.21, by tynli. Suggested by SD1 JackieLau. */
	if (rtlhal->mac_func_enable) {
		_rtl8821ae_poweroff_adapter(hw);
		rtlhal->mac_func_enable = false;
	}

	rtstatus = _rtl8821ae_init_mac(hw);
	if (rtstatus != true) {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Init MAC failed\n");
		err = 1;
		return err;
	}

	tmp_u1b = rtl_read_byte(rtlpriv, REG_SYS_CFG);
	tmp_u1b &= 0x7F;
	rtl_write_byte(rtlpriv, REG_SYS_CFG, tmp_u1b);

	err = rtl8821ae_download_fw(hw, false);
	if (err) {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
			 "Failed to download FW. Init HW without FW now\n");
		err = 1;
		rtlhal->fw_ready = false;
		return err;
	} else {
		rtlhal->fw_ready = true;
	}
	ppsc->fw_current_inpsmode = false;
	rtlhal->fw_ps_state = FW_PS_STATE_ALL_ON_8821AE;
	rtlhal->fw_clk_change_in_progress = false;
	rtlhal->allow_sw_to_change_hwclc = false;
	rtlhal->last_hmeboxnum = 0;

	/*SIC_Init(Adapter);
	if(rtlhal->AMPDUBurstMode)
		rtl_write_byte(rtlpriv,REG_AMPDU_BURST_MODE_8812,  0x7F);*/

	rtl8821ae_phy_mac_config(hw);
	/* because last function modify RCR, so we update
	 * rcr var here, or TP will unstable for receive_config
	 * is wrong, RX RCR_ACRC32 will cause TP unstabel & Rx
	 * RCR_APP_ICV will cause mac80211 unassoc for cisco 1252
	rtlpci->receive_config = rtl_read_dword(rtlpriv, REG_RCR);
	rtlpci->receive_config &= ~(RCR_ACRC32 | RCR_AICV);
	rtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);*/
	rtl8821ae_phy_bb_config(hw);

	rtl8821ae_phy_rf_config(hw);

	if (rtlpriv->phy.rf_type == RF_1T1R &&
		rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
		_rtl8812ae_bb8812_config_1t(hw);

	_rtl8821ae_hw_configure(hw);

	rtl8821ae_phy_switch_wirelessband(hw, BAND_ON_2_4G);

	/*set wireless mode*/

	rtlhal->mac_func_enable = true;

	rtl_cam_reset_all_entry(hw);

	rtl8821ae_enable_hw_security_config(hw);

	ppsc->rfpwr_state = ERFON;

	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);
	_rtl8821ae_enable_aspm_back_door(hw);
	rtlpriv->intf_ops->enable_aspm(hw);

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE &&
	    (rtlhal->rfe_type == 1 || rtlhal->rfe_type == 5))
		rtl_set_bbreg(hw, 0x900, 0x00000303, 0x0302);

	rtl8821ae_bt_hw_init(hw);
	rtlpriv->rtlhal.being_init_adapter = false;

	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_NAV_UPPER, (u8 *)&nav_upper);

	/* rtl8821ae_dm_check_txpower_tracking(hw); */
	/* rtl8821ae_phy_lc_calibrate(hw); */
	if (support_remote_wakeup)
		rtl_write_byte(rtlpriv, REG_WOW_CTRL, 0);

	/* Release Rx DMA*/
	tmp_u1b = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
	if (tmp_u1b & BIT(2)) {
		/* Release Rx DMA if needed*/
		tmp_u1b &= ~BIT(2);
		rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, tmp_u1b);
	}

	/* Release Tx/Rx PCIE DMA if*/
	rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0);

	rtl8821ae_dm_init(hw);
	rtl8821ae_macid_initialize_mediastatus(hw);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "rtl8821ae_hw_init() <====\n");
	return err;
}

static enum version_8821ae _rtl8821ae_read_chip_version(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	enum version_8821ae version = VERSION_UNKNOWN;
	u32 value32;

	value32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "ReadChipVersion8812A 0xF0 = 0x%x\n", value32);

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
		rtlphy->rf_type = RF_2T2R;
	else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE)
		rtlphy->rf_type = RF_1T1R;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "RF_Type is %x!!\n", rtlphy->rf_type);

	if (value32 & TRP_VAUX_EN) {
		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
			if (rtlphy->rf_type == RF_2T2R)
				version = VERSION_TEST_CHIP_2T2R_8812;
			else
				version = VERSION_TEST_CHIP_1T1R_8812;
		} else
			version = VERSION_TEST_CHIP_8821;
	} else {
		if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
			u32 rtl_id = ((value32 & CHIP_VER_RTL_MASK) >> 12) + 1;

			if (rtlphy->rf_type == RF_2T2R)
				version =
					(enum version_8821ae)(CHIP_8812
					| NORMAL_CHIP |
					RF_TYPE_2T2R);
			else
				version = (enum version_8821ae)(CHIP_8812
					| NORMAL_CHIP);

			version = (enum version_8821ae)(version | (rtl_id << 12));
		} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
			u32 rtl_id = value32 & CHIP_VER_RTL_MASK;

			version = (enum version_8821ae)(CHIP_8821
				| NORMAL_CHIP | rtl_id);
		}
	}

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
		/*WL_HWROF_EN.*/
		value32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);
		rtlhal->hw_rof_enable = ((value32 & WL_HWROF_EN) ? 1 : 0);
	}

	switch (version) {
	case VERSION_TEST_CHIP_1T1R_8812:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_TEST_CHIP_1T1R_8812\n");
		break;
	case VERSION_TEST_CHIP_2T2R_8812:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_TEST_CHIP_2T2R_8812\n");
		break;
	case VERSION_NORMAL_TSMC_CHIP_1T1R_8812:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID:VERSION_NORMAL_TSMC_CHIP_1T1R_8812\n");
		break;
	case VERSION_NORMAL_TSMC_CHIP_2T2R_8812:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_NORMAL_TSMC_CHIP_2T2R_8812\n");
		break;
	case VERSION_NORMAL_TSMC_CHIP_1T1R_8812_C_CUT:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_NORMAL_TSMC_CHIP_1T1R_8812 C CUT\n");
		break;
	case VERSION_NORMAL_TSMC_CHIP_2T2R_8812_C_CUT:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_NORMAL_TSMC_CHIP_2T2R_8812 C CUT\n");
		break;
	case VERSION_TEST_CHIP_8821:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_TEST_CHIP_8821\n");
		break;
	case VERSION_NORMAL_TSMC_CHIP_8821:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_NORMAL_TSMC_CHIP_8821 A CUT\n");
		break;
	case VERSION_NORMAL_TSMC_CHIP_8821_B_CUT:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: VERSION_NORMAL_TSMC_CHIP_8821 B CUT\n");
		break;
	default:
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Chip Version ID: Unknow (0x%X)\n", version);
		break;
	}

	return version;
}

static int _rtl8821ae_set_media_status(struct ieee80211_hw *hw,
				     enum nl80211_iftype type)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 bt_msr = rtl_read_byte(rtlpriv, MSR);
	enum led_ctl_mode ledaction = LED_CTL_NO_LINK;
	bt_msr &= 0xfc;

	rtl_write_dword(rtlpriv, REG_BCN_CTRL, 0);
	RT_TRACE(rtlpriv, COMP_BEACON, DBG_LOUD,
		"clear 0x550 when set HW_VAR_MEDIA_STATUS\n");

	if (type == NL80211_IFTYPE_UNSPECIFIED ||
	    type == NL80211_IFTYPE_STATION) {
		_rtl8821ae_stop_tx_beacon(hw);
		_rtl8821ae_enable_bcn_sub_func(hw);
	} else if (type == NL80211_IFTYPE_ADHOC ||
		type == NL80211_IFTYPE_AP) {
		_rtl8821ae_resume_tx_beacon(hw);
		_rtl8821ae_disable_bcn_sub_func(hw);
	} else {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
			 "Set HW_VAR_MEDIA_STATUS: No such media status(%x).\n",
			 type);
	}

	switch (type) {
	case NL80211_IFTYPE_UNSPECIFIED:
		bt_msr |= MSR_NOLINK;
		ledaction = LED_CTL_LINK;
		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
			 "Set Network type to NO LINK!\n");
		break;
	case NL80211_IFTYPE_ADHOC:
		bt_msr |= MSR_ADHOC;
		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
			 "Set Network type to Ad Hoc!\n");
		break;
	case NL80211_IFTYPE_STATION:
		bt_msr |= MSR_INFRA;
		ledaction = LED_CTL_LINK;
		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
			 "Set Network type to STA!\n");
		break;
	case NL80211_IFTYPE_AP:
		bt_msr |= MSR_AP;
		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
			 "Set Network type to AP!\n");
		break;
	default:
		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
			 "Network type %d not support!\n", type);
		return 1;
	}

	rtl_write_byte(rtlpriv, (MSR), bt_msr);
	rtlpriv->cfg->ops->led_control(hw, ledaction);
	if ((bt_msr & MSR_MASK) == MSR_AP)
		rtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);
	else
		rtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);

	return 0;
}

void rtl8821ae_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	u32 reg_rcr = rtlpci->receive_config;

	if (rtlpriv->psc.rfpwr_state != ERFON)
		return;

	if (check_bssid) {
		reg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);
		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,
					      (u8 *)(&reg_rcr));
		_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(4));
	} else if (!check_bssid) {
		reg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));
		_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(4), 0);
		rtlpriv->cfg->ops->set_hw_reg(hw,
			HW_VAR_RCR, (u8 *)(&reg_rcr));
	}
}

int rtl8821ae_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "rtl8821ae_set_network_type!\n");

	if (_rtl8821ae_set_media_status(hw, type))
		return -EOPNOTSUPP;

	if (rtlpriv->mac80211.link_state == MAC80211_LINKED) {
		if (type != NL80211_IFTYPE_AP)
			rtl8821ae_set_check_bssid(hw, true);
	} else {
		rtl8821ae_set_check_bssid(hw, false);
	}

	return 0;
}

/* don't set REG_EDCA_BE_PARAM here because mac80211 will send pkt when scan */
void rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	rtl8821ae_dm_init_edca_turbo(hw);
	switch (aci) {
	case AC1_BK:
		rtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0xa44f);
		break;
	case AC0_BE:
		/* rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, u4b_ac_param); */
		break;
	case AC2_VI:
		rtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x5e4322);
		break;
	case AC3_VO:
		rtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x2f3222);
		break;
	default:
		RT_ASSERT(false, "invalid aci: %d !\n", aci);
		break;
	}
}

void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));

	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] & 0xFFFFFFFF);
	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] & 0xFFFFFFFF);
	rtlpci->irq_enabled = true;
	/* there are some C2H CMDs have been sent before
	system interrupt is enabled, e.g., C2H, CPWM.
	*So we need to clear all C2H events that FW has
	notified, otherwise FW won't schedule any commands anymore.
	*/
	/* rtl_write_byte(rtlpriv, REG_C2HEVT_CLEAR, 0); */
	/*enable system interrupt*/
	rtl_write_dword(rtlpriv, REG_HSIMR, rtlpci->sys_irq_mask & 0xFFFFFFFF);
}

void rtl8821ae_disable_interrupt(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));

	rtl_write_dword(rtlpriv, REG_HIMR, IMR_DISABLED);
	rtl_write_dword(rtlpriv, REG_HIMRE, IMR_DISABLED);
	rtlpci->irq_enabled = false;
	/*synchronize_irq(rtlpci->pdev->irq);*/
}

static void _rtl8821ae_clear_pci_pme_status(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	u16 cap_hdr;
	u8 cap_pointer;
	u8 cap_id = 0xff;
	u8 pmcs_reg;
	u8 cnt = 0;

	/* Get the Capability pointer first,
	 * the Capability Pointer is located at
	 * offset 0x34 from the Function Header */

	pci_read_config_byte(rtlpci->pdev, 0x34, &cap_pointer);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "PCI configration 0x34 = 0x%2x\n", cap_pointer);

	do {
		pci_read_config_word(rtlpci->pdev, cap_pointer, &cap_hdr);
		cap_id = cap_hdr & 0xFF;

		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "in pci configration, cap_pointer%x = %x\n",
			  cap_pointer, cap_id);

		if (cap_id == 0x01) {
			break;
		} else {
			/* point to next Capability */
			cap_pointer = (cap_hdr >> 8) & 0xFF;
			/* 0: end of pci capability, 0xff: invalid value */
			if (cap_pointer == 0x00 || cap_pointer == 0xff) {
				cap_id = 0xff;
				break;
			}
		}
	} while (cnt++ < 200);

	if (cap_id == 0x01) {
		/* Get the PM CSR (Control/Status Register),
		 * The PME_Status is located at PM Capatibility offset 5, bit 7
		 */
		pci_read_config_byte(rtlpci->pdev, cap_pointer + 5, &pmcs_reg);

		if (pmcs_reg & BIT(7)) {
			/* PME event occured, clear the PM_Status by write 1 */
			pmcs_reg = pmcs_reg | BIT(7);

			pci_write_config_byte(rtlpci->pdev, cap_pointer + 5,
					      pmcs_reg);
			/* Read it back to check */
			pci_read_config_byte(rtlpci->pdev, cap_pointer + 5,
					     &pmcs_reg);
			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
				 "Clear PME status 0x%2x to 0x%2x\n",
				  cap_pointer + 5, pmcs_reg);
		} else {
			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
				 "PME status(0x%2x) = 0x%2x\n",
				  cap_pointer + 5, pmcs_reg);
		}
	} else {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_WARNING,
			 "Cannot find PME Capability\n");
	}
}

void rtl8821ae_card_disable(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);
	struct rtl_mac *mac = rtl_mac(rtlpriv);
	enum nl80211_iftype opmode;
	bool support_remote_wakeup;
	u8 tmp;
	u32 count = 0;

	rtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,
				      (u8 *)(&support_remote_wakeup));

	RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);

	if (!(support_remote_wakeup && mac->opmode == NL80211_IFTYPE_STATION)
	    || !rtlhal->enter_pnp_sleep) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Normal Power off\n");
		mac->link_state = MAC80211_NOLINK;
		opmode = NL80211_IFTYPE_UNSPECIFIED;
		_rtl8821ae_set_media_status(hw, opmode);
		_rtl8821ae_poweroff_adapter(hw);
	} else {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Wowlan Supported.\n");
		/* 3 <1> Prepare for configuring wowlan related infomations */
		/* Clear Fw WoWLAN event. */
		rtl_write_byte(rtlpriv, REG_MCUTST_WOWLAN, 0x0);

#if (USE_SPECIFIC_FW_TO_SUPPORT_WOWLAN == 1)
		rtl8821ae_set_fw_related_for_wowlan(hw, true);
#endif
		/* Dynamically adjust Tx packet boundary
		 * for download reserved page packet.
		 * reserve 30 pages for rsvd page */
		if (_rtl8821ae_dynamic_rqpn(hw, 0xE0, 0x3, 0x80c20d0d))
			rtlhal->re_init_llt_table = true;

		/* 3 <2> Set Fw releted H2C cmd. */

		/* Set WoWLAN related security information. */
		rtl8821ae_set_fw_global_info_cmd(hw);

		_rtl8821ae_download_rsvd_page(hw, true);

		/* Just enable AOAC related functions when we connect to AP. */
		printk("mac->link_state = %d\n", mac->link_state);
		if (mac->link_state >= MAC80211_LINKED &&
		    mac->opmode == NL80211_IFTYPE_STATION) {
			rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID, NULL);
			rtl8821ae_set_fw_media_status_rpt_cmd(hw,
							      RT_MEDIA_CONNECT);

			rtl8821ae_set_fw_wowlan_mode(hw, true);
			/* Enable Fw Keep alive mechanism. */
			rtl8821ae_set_fw_keep_alive_cmd(hw, true);

			/* Enable disconnect decision control. */
			rtl8821ae_set_fw_disconnect_decision_ctrl_cmd(hw, true);
		}

		/* 3 <3> Hw Configutations */

		/* Wait untill Rx DMA Finished before host sleep.
		 * FW Pause Rx DMA may happens when received packet doing dma.
		 */
		rtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, BIT(2));

		tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
		count = 0;
		while (!(tmp & BIT(1)) && (count++ < 100)) {
			udelay(10);
			tmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);
		}
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Wait Rx DMA Finished before host sleep. count=%d\n",
			  count);

		/* reset trx ring */
		rtlpriv->intf_ops->reset_trx_ring(hw);

		rtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, 0x0);

		_rtl8821ae_clear_pci_pme_status(hw);
		tmp = rtl_read_byte(rtlpriv, REG_SYS_CLKR);
		rtl_write_byte(rtlpriv, REG_SYS_CLKR, tmp | BIT(3));
		/* prevent 8051 to be reset by PERST */
		rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x20);
		rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x60);
	}

	if (rtlpriv->rtlhal.driver_is_goingto_unload ||
	    ppsc->rfoff_reason > RF_CHANGE_BY_PS)
		rtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);
	/* For wowlan+LPS+32k. */
	if (support_remote_wakeup && rtlhal->enter_pnp_sleep) {
		/* Set the WoWLAN related function control enable.
		 * It should be the last H2C cmd in the WoWLAN flow. */
		rtl8821ae_set_fw_remote_wake_ctrl_cmd(hw, 1);

		/* Stop Pcie Interface Tx DMA. */
		rtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xff);
		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Stop PCIE Tx DMA.\n");

		/* Wait for TxDMA idle. */
		count = 0;
		do {
			tmp = rtl_read_byte(rtlpriv, REG_PCIE_CTRL_REG);
			udelay(10);
			count++;
		} while ((tmp != 0) && (count < 100));
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "Wait Tx DMA Finished before host sleep. count=%d\n",
			  count);

		if (rtlhal->hw_rof_enable) {
			printk("hw_rof_enable\n");
			tmp = rtl_read_byte(rtlpriv, REG_HSISR + 3);
			rtl_write_byte(rtlpriv, REG_HSISR + 3, tmp | BIT(1));
		}
	}
	/* after power off we should do iqk again */
	rtlpriv->phy.iqk_initialized = false;
}

void rtl8821ae_interrupt_recognized(struct ieee80211_hw *hw,
				  u32 *p_inta, u32 *p_intb)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));

	*p_inta = rtl_read_dword(rtlpriv, ISR) & rtlpci->irq_mask[0];
	rtl_write_dword(rtlpriv, ISR, *p_inta);

	*p_intb = rtl_read_dword(rtlpriv, REG_HISRE) & rtlpci->irq_mask[1];
	rtl_write_dword(rtlpriv, REG_HISRE, *p_intb);
}

void rtl8821ae_set_beacon_related_registers(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
	u16 bcn_interval, atim_window;

	bcn_interval = mac->beacon_interval;
	atim_window = 2;	/*FIX MERGE */
	rtl8821ae_disable_interrupt(hw);
	rtl_write_word(rtlpriv, REG_ATIMWND, atim_window);
	rtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);
	rtl_write_word(rtlpriv, REG_BCNTCFG, 0x660f);
	rtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x18);
	rtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x18);
	rtl_write_byte(rtlpriv, 0x606, 0x30);
	rtlpci->reg_bcn_ctrl_val |= BIT(3);
	rtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlpci->reg_bcn_ctrl_val);
	rtl8821ae_enable_interrupt(hw);
}

void rtl8821ae_set_beacon_interval(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	u16 bcn_interval = mac->beacon_interval;

	RT_TRACE(rtlpriv, COMP_BEACON, DBG_DMESG,
		 "beacon_interval:%d\n", bcn_interval);
	rtl8821ae_disable_interrupt(hw);
	rtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);
	rtl8821ae_enable_interrupt(hw);
}

void rtl8821ae_update_interrupt_mask(struct ieee80211_hw *hw,
				   u32 add_msr, u32 rm_msr)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));

	RT_TRACE(rtlpriv, COMP_INTR, DBG_LOUD,
		 "add_msr:%x, rm_msr:%x\n", add_msr, rm_msr);

	if (add_msr)
		rtlpci->irq_mask[0] |= add_msr;
	if (rm_msr)
		rtlpci->irq_mask[0] &= (~rm_msr);
	rtl8821ae_disable_interrupt(hw);
	rtl8821ae_enable_interrupt(hw);
}

static u8 _rtl8821ae_get_chnl_group(u8 chnl)
{
	u8 group = 0;

	if (chnl <= 14) {
		if (1 <= chnl && chnl <= 2)
			group = 0;
	else if (3 <= chnl && chnl <= 5)
			group = 1;
	else if (6 <= chnl && chnl <= 8)
			group = 2;
	else if (9 <= chnl && chnl <= 11)
			group = 3;
	else /*if (12 <= chnl && chnl <= 14)*/
			group = 4;
	} else {
		if (36 <= chnl && chnl <= 42)
			group = 0;
	else if (44 <= chnl && chnl <= 48)
			group = 1;
	else if (50 <= chnl && chnl <= 58)
			group = 2;
	else if (60 <= chnl && chnl <= 64)
			group = 3;
	else if (100 <= chnl && chnl <= 106)
			group = 4;
	else if (108 <= chnl && chnl <= 114)
			group = 5;
	else if (116 <= chnl && chnl <= 122)
			group = 6;
	else if (124 <= chnl && chnl <= 130)
			group = 7;
	else if (132 <= chnl && chnl <= 138)
			group = 8;
	else if (140 <= chnl && chnl <= 144)
			group = 9;
	else if (149 <= chnl && chnl <= 155)
			group = 10;
	else if (157 <= chnl && chnl <= 161)
			group = 11;
	else if (165 <= chnl && chnl <= 171)
			group = 12;
	else if (173 <= chnl && chnl <= 177)
			group = 13;
		else
			/*RT_TRACE(rtlpriv, COMP_EFUSE,DBG_LOUD,
				"5G, Channel %d in Group not found\n",chnl);*/
			RT_ASSERT(!COMP_EFUSE,
				"5G, Channel %d in Group not found\n", chnl);
	}
	return group;
}

static void _rtl8821ae_read_power_value_fromprom(struct ieee80211_hw *hw,
	struct txpower_info_2g *pwrinfo24g,
	struct txpower_info_5g *pwrinfo5g,
	bool autoload_fail,
	u8 *hwinfo)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u32 rfPath, eeAddr = EEPROM_TX_PWR_INX, group, TxCount = 0;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "hal_ReadPowerValueFromPROM8821ae(): hwinfo[0x%x]=0x%x\n",
		 (eeAddr+1), hwinfo[eeAddr+1]);
	if (0xFF == hwinfo[eeAddr+1])  /*YJ,add,120316*/
		autoload_fail = true;

	if (autoload_fail) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
			 "auto load fail : Use Default value!\n");
		for (rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++) {
			/*2.4G default value*/
			for (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {
				pwrinfo24g->index_cck_base[rfPath][group] =	0x2D;
				pwrinfo24g->index_bw40_base[rfPath][group] = 0x2D;
			}
			for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
				if (TxCount == 0) {
					pwrinfo24g->bw20_diff[rfPath][0] = 0x02;
					pwrinfo24g->ofdm_diff[rfPath][0] = 0x04;
				} else {
					pwrinfo24g->bw20_diff[rfPath][TxCount] = 0xFE;
					pwrinfo24g->bw40_diff[rfPath][TxCount] = 0xFE;
					pwrinfo24g->cck_diff[rfPath][TxCount] =	0xFE;
					pwrinfo24g->ofdm_diff[rfPath][TxCount] = 0xFE;
				}
			}
			/*5G default value*/
			for (group = 0 ; group < MAX_CHNL_GROUP_5G; group++)
				pwrinfo5g->index_bw40_base[rfPath][group] = 0x2A;

			for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
				if (TxCount == 0) {
					pwrinfo5g->ofdm_diff[rfPath][0] = 0x04;
					pwrinfo5g->bw20_diff[rfPath][0] = 0x00;
					pwrinfo5g->bw80_diff[rfPath][0] = 0xFE;
					pwrinfo5g->bw160_diff[rfPath][0] = 0xFE;
				} else {
					pwrinfo5g->ofdm_diff[rfPath][0] = 0xFE;
					pwrinfo5g->bw20_diff[rfPath][0] = 0xFE;
					pwrinfo5g->bw40_diff[rfPath][0] = 0xFE;
					pwrinfo5g->bw80_diff[rfPath][0] = 0xFE;
					pwrinfo5g->bw160_diff[rfPath][0] = 0xFE;
				}
			}
		}
		return;
	}

	rtl_priv(hw)->efuse.txpwr_fromeprom = true;

	for (rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++) {
		/*2.4G default value*/
		for (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {
			pwrinfo24g->index_cck_base[rfPath][group] = hwinfo[eeAddr++];
			if (pwrinfo24g->index_cck_base[rfPath][group] == 0xFF)
				pwrinfo24g->index_cck_base[rfPath][group] = 0x2D;
		}
		for (group = 0 ; group < MAX_CHNL_GROUP_24G - 1; group++) {
			pwrinfo24g->index_bw40_base[rfPath][group] = hwinfo[eeAddr++];
			if (pwrinfo24g->index_bw40_base[rfPath][group] == 0xFF)
				pwrinfo24g->index_bw40_base[rfPath][group] = 0x2D;
		}
		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
			if (TxCount == 0) {
				pwrinfo24g->bw40_diff[rfPath][TxCount] = 0;
				/*bit sign number to 8 bit sign number*/
				pwrinfo24g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;
				if (pwrinfo24g->bw20_diff[rfPath][TxCount] & BIT(3))
					pwrinfo24g->bw20_diff[rfPath][TxCount] |= 0xF0;
				/*bit sign number to 8 bit sign number*/
				pwrinfo24g->ofdm_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);
				if (pwrinfo24g->ofdm_diff[rfPath][TxCount] & BIT(3))
					pwrinfo24g->ofdm_diff[rfPath][TxCount] |= 0xF0;

				pwrinfo24g->cck_diff[rfPath][TxCount] = 0;
				eeAddr++;
			} else {
				pwrinfo24g->bw40_diff[rfPath][TxCount] = (hwinfo[eeAddr]&0xf0) >> 4;
				if (pwrinfo24g->bw40_diff[rfPath][TxCount] & BIT(3))
					pwrinfo24g->bw40_diff[rfPath][TxCount] |= 0xF0;

				pwrinfo24g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);
				if (pwrinfo24g->bw20_diff[rfPath][TxCount] & BIT(3))
					pwrinfo24g->bw20_diff[rfPath][TxCount] |= 0xF0;

				eeAddr++;

				pwrinfo24g->ofdm_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;
				if (pwrinfo24g->ofdm_diff[rfPath][TxCount] & BIT(3))
					pwrinfo24g->ofdm_diff[rfPath][TxCount] |= 0xF0;

				pwrinfo24g->cck_diff[rfPath][TxCount] =	(hwinfo[eeAddr] & 0x0f);
				if (pwrinfo24g->cck_diff[rfPath][TxCount] & BIT(3))
					pwrinfo24g->cck_diff[rfPath][TxCount] |= 0xF0;

				eeAddr++;
			}
		}

		/*5G default value*/
		for (group = 0 ; group < MAX_CHNL_GROUP_5G; group++) {
			pwrinfo5g->index_bw40_base[rfPath][group] = hwinfo[eeAddr++];
			if (pwrinfo5g->index_bw40_base[rfPath][group] == 0xFF)
				pwrinfo5g->index_bw40_base[rfPath][group] = 0xFE;
		}

		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
			if (TxCount == 0) {
				pwrinfo5g->bw40_diff[rfPath][TxCount] = 0;

				pwrinfo5g->bw20_diff[rfPath][0] = (hwinfo[eeAddr] & 0xf0) >> 4;
				if (pwrinfo5g->bw20_diff[rfPath][TxCount] & BIT(3))
					pwrinfo5g->bw20_diff[rfPath][TxCount] |= 0xF0;

				pwrinfo5g->ofdm_diff[rfPath][0] = (hwinfo[eeAddr] & 0x0f);
				if (pwrinfo5g->ofdm_diff[rfPath][TxCount] & BIT(3))
					pwrinfo5g->ofdm_diff[rfPath][TxCount] |= 0xF0;

				eeAddr++;
			} else {
				pwrinfo5g->bw40_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;
				if (pwrinfo5g->bw40_diff[rfPath][TxCount] & BIT(3))
					pwrinfo5g->bw40_diff[rfPath][TxCount] |= 0xF0;

				pwrinfo5g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);
				if (pwrinfo5g->bw20_diff[rfPath][TxCount] & BIT(3))
					pwrinfo5g->bw20_diff[rfPath][TxCount] |= 0xF0;

				eeAddr++;
			}
		}

		pwrinfo5g->ofdm_diff[rfPath][1] =	(hwinfo[eeAddr] & 0xf0) >> 4;
		pwrinfo5g->ofdm_diff[rfPath][2] =	(hwinfo[eeAddr] & 0x0f);

		eeAddr++;

		pwrinfo5g->ofdm_diff[rfPath][3] = (hwinfo[eeAddr] & 0x0f);

		eeAddr++;

		for (TxCount = 1; TxCount < MAX_TX_COUNT; TxCount++) {
			if (pwrinfo5g->ofdm_diff[rfPath][TxCount] & BIT(3))
				pwrinfo5g->ofdm_diff[rfPath][TxCount] |= 0xF0;
		}
		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
			pwrinfo5g->bw80_diff[rfPath][TxCount] =	(hwinfo[eeAddr] & 0xf0) >> 4;
			/* 4bit sign number to 8 bit sign number */
			if (pwrinfo5g->bw80_diff[rfPath][TxCount] & BIT(3))
				pwrinfo5g->bw80_diff[rfPath][TxCount] |= 0xF0;
			/* 4bit sign number to 8 bit sign number */
			pwrinfo5g->bw160_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);
			if (pwrinfo5g->bw160_diff[rfPath][TxCount] & BIT(3))
				pwrinfo5g->bw160_diff[rfPath][TxCount] |= 0xF0;

			eeAddr++;
		}
	}
}
#if 0
static void _rtl8812ae_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,
						 bool autoload_fail,
						 u8 *hwinfo)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
	struct txpower_info_2g pwrinfo24g;
	struct txpower_info_5g pwrinfo5g;
	u8 channel5g[CHANNEL_MAX_NUMBER_5G] = {
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 149, 151, 153, 155, 157,
		159, 161, 163, 165, 167, 168, 169, 171, 173, 175, 177};
	u8 channel5g_80m[CHANNEL_MAX_NUMBER_5G_80M] = {42, 58, 106, 122, 138, 155, 171};
	u8 rf_path, index;
	u8 i;

	_rtl8821ae_read_power_value_fromprom(hw, &pwrinfo24g,
					&pwrinfo5g, autoload_fail, hwinfo);

	for (rf_path = 0; rf_path < 2; rf_path++) {
		for (i = 0; i < CHANNEL_MAX_NUMBER_2G; i++) {
			index = _rtl8821ae_get_chnl_group(i + 1);

			if (i == CHANNEL_MAX_NUMBER_2G - 1) {
				rtlefuse->txpwrlevel_cck[rf_path][i] =
					pwrinfo24g.index_cck_base[rf_path][5];
				rtlefuse->txpwrlevel_ht40_1s[rf_path][i] =
					pwrinfo24g.index_bw40_base[rf_path][index];
			} else {
				rtlefuse->txpwrlevel_cck[rf_path][i] =
					pwrinfo24g.index_cck_base[rf_path][index];
				rtlefuse->txpwrlevel_ht40_1s[rf_path][i] =
					pwrinfo24g.index_bw40_base[rf_path][index];
			}
		}

		for (i = 0; i < CHANNEL_MAX_NUMBER_5G; i++) {
			index = _rtl8821ae_get_chnl_group(channel5g[i]);
			rtlefuse->txpwr_5g_bw40base[rf_path][i] =
					pwrinfo5g.index_bw40_base[rf_path][index];
		}
		for (i = 0; i < CHANNEL_MAX_NUMBER_5G_80M; i++) {
			u8 upper, lower;
			index = _rtl8821ae_get_chnl_group(channel5g_80m[i]);
			upper = pwrinfo5g.index_bw40_base[rf_path][index];
			lower = pwrinfo5g.index_bw40_base[rf_path][index + 1];

			rtlefuse->txpwr_5g_bw80base[rf_path][i] = (upper + lower) / 2;
		}
		for (i = 0; i < MAX_TX_COUNT; i++) {
			rtlefuse->txpwr_cckdiff[rf_path][i] =
				pwrinfo24g.cck_diff[rf_path][i];
			rtlefuse->txpwr_legacyhtdiff[rf_path][i] =
				pwrinfo24g.ofdm_diff[rf_path][i];
			rtlefuse->txpwr_ht20diff[rf_path][i] =
				pwrinfo24g.bw20_diff[rf_path][i];
			rtlefuse->txpwr_ht40diff[rf_path][i] =
				pwrinfo24g.bw40_diff[rf_path][i];

			rtlefuse->txpwr_5g_ofdmdiff[rf_path][i] =
				pwrinfo5g.ofdm_diff[rf_path][i];
			rtlefuse->txpwr_5g_bw20diff[rf_path][i] =
				pwrinfo5g.bw20_diff[rf_path][i];
			rtlefuse->txpwr_5g_bw40diff[rf_path][i] =
				pwrinfo5g.bw40_diff[rf_path][i];
			rtlefuse->txpwr_5g_bw80diff[rf_path][i] =
				pwrinfo5g.bw80_diff[rf_path][i];
		}
	}

	if (!autoload_fail) {
		rtlefuse->eeprom_regulatory =
			hwinfo[EEPROM_RF_BOARD_OPTION] & 0x07;/*bit0~2*/
		if (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xFF)
			rtlefuse->eeprom_regulatory = 0;
	} else {
		rtlefuse->eeprom_regulatory = 0;
	}

	RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
	"eeprom_regulatory = 0x%x\n", rtlefuse->eeprom_regulatory);
}
#endif
static void _rtl8821ae_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,
						 bool autoload_fail,
						 u8 *hwinfo)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
	struct txpower_info_2g pwrinfo24g;
	struct txpower_info_5g pwrinfo5g;
	u8 channel5g[CHANNEL_MAX_NUMBER_5G] = {
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
		56, 58, 60, 62, 64, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 149, 151, 153, 155, 157,
		159, 161, 163, 165, 167, 168, 169, 171,
		173, 175, 177};
	u8 channel5g_80m[CHANNEL_MAX_NUMBER_5G_80M] = {
		42, 58, 106, 122, 138, 155, 171};
	u8 rf_path, index;
	u8 i;

	_rtl8821ae_read_power_value_fromprom(hw, &pwrinfo24g,
		&pwrinfo5g, autoload_fail, hwinfo);

	for (rf_path = 0; rf_path < 2; rf_path++) {
		for (i = 0; i < CHANNEL_MAX_NUMBER_2G; i++) {
			index = _rtl8821ae_get_chnl_group(i + 1);

			if (i == CHANNEL_MAX_NUMBER_2G - 1) {
				rtlefuse->txpwrlevel_cck[rf_path][i] =
					pwrinfo24g.index_cck_base[rf_path][5];
				rtlefuse->txpwrlevel_ht40_1s[rf_path][i] =
					pwrinfo24g.index_bw40_base[rf_path][index];
			} else {
				rtlefuse->txpwrlevel_cck[rf_path][i] =
					pwrinfo24g.index_cck_base[rf_path][index];
				rtlefuse->txpwrlevel_ht40_1s[rf_path][i] =
					pwrinfo24g.index_bw40_base[rf_path][index];
			}
		}

		for (i = 0; i < CHANNEL_MAX_NUMBER_5G; i++) {
			index = _rtl8821ae_get_chnl_group(channel5g[i]);
			rtlefuse->txpwr_5g_bw40base[rf_path][i] =
				pwrinfo5g.index_bw40_base[rf_path][index];
		}
		for (i = 0; i < CHANNEL_MAX_NUMBER_5G_80M; i++) {
			u8 upper, lower;
			index = _rtl8821ae_get_chnl_group(channel5g_80m[i]);
			upper = pwrinfo5g.index_bw40_base[rf_path][index];
			lower = pwrinfo5g.index_bw40_base[rf_path][index + 1];

			rtlefuse->txpwr_5g_bw80base[rf_path][i] = (upper + lower) / 2;
		}
		for (i = 0; i < MAX_TX_COUNT; i++) {
			rtlefuse->txpwr_cckdiff[rf_path][i] =
				pwrinfo24g.cck_diff[rf_path][i];
			rtlefuse->txpwr_legacyhtdiff[rf_path][i] =
				pwrinfo24g.ofdm_diff[rf_path][i];
			rtlefuse->txpwr_ht20diff[rf_path][i] =
				pwrinfo24g.bw20_diff[rf_path][i];
			rtlefuse->txpwr_ht40diff[rf_path][i] =
				pwrinfo24g.bw40_diff[rf_path][i];

			rtlefuse->txpwr_5g_ofdmdiff[rf_path][i] =
				pwrinfo5g.ofdm_diff[rf_path][i];
			rtlefuse->txpwr_5g_bw20diff[rf_path][i] =
				pwrinfo5g.bw20_diff[rf_path][i];
			rtlefuse->txpwr_5g_bw40diff[rf_path][i] =
				pwrinfo5g.bw40_diff[rf_path][i];
			rtlefuse->txpwr_5g_bw80diff[rf_path][i] =
				pwrinfo5g.bw80_diff[rf_path][i];
		}
	}
	/*bit0~2*/
	if (!autoload_fail) {
		rtlefuse->eeprom_regulatory = hwinfo[EEPROM_RF_BOARD_OPTION] & 0x07;
		if (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xFF)
			rtlefuse->eeprom_regulatory = 0;
	} else {
		rtlefuse->eeprom_regulatory = 0;
	}

	RTPRINT(rtlpriv, FINIT, INIT_TXPOWER,
	"eeprom_regulatory = 0x%x\n", rtlefuse->eeprom_regulatory);
}

static void _rtl8812ae_read_pa_type(struct ieee80211_hw *hw, u8 *hwinfo,
				    bool autoload_fail)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);

	if (!autoload_fail) {
		rtlhal->pa_type_2g = hwinfo[0xBC];
		rtlhal->lna_type_2g = hwinfo[0xBD];
		if (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {
			rtlhal->pa_type_2g = 0;
			rtlhal->lna_type_2g = 0;
		}
		rtlhal->external_pa_2g = ((rtlhal->pa_type_2g & BIT(5)) &&
					  (rtlhal->pa_type_2g & BIT(4))) ?
					 1 : 0;
		rtlhal->external_lna_2g = ((rtlhal->lna_type_2g & BIT(7)) &&
					   (rtlhal->lna_type_2g & BIT(3))) ?
					  1 : 0;

		rtlhal->pa_type_5g = hwinfo[0xBC];
		rtlhal->lna_type_5g = hwinfo[0xBF];
		if (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {
			rtlhal->pa_type_5g = 0;
			rtlhal->lna_type_5g = 0;
		}
		rtlhal->external_pa_5g = ((rtlhal->pa_type_5g & BIT(1)) &&
					  (rtlhal->pa_type_5g & BIT(0))) ?
					 1 : 0;
		rtlhal->external_lna_5g = ((rtlhal->lna_type_5g & BIT(7)) &&
					   (rtlhal->lna_type_5g & BIT(3))) ?
					  1 : 0;
	} else {
		rtlhal->external_pa_2g  = 0;
		rtlhal->external_lna_2g = 0;
		rtlhal->external_pa_5g  = 0;
		rtlhal->external_lna_5g = 0;
	}
}

static void _rtl8821ae_read_pa_type(struct ieee80211_hw *hw, u8 *hwinfo,
				    bool autoload_fail)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);

	if (!autoload_fail) {
		rtlhal->pa_type_2g = hwinfo[0xBC];
		rtlhal->lna_type_2g = hwinfo[0xBD];
		if (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {
			rtlhal->pa_type_2g = 0;
			rtlhal->lna_type_2g = 0;
		}
		rtlhal->external_pa_2g = (rtlhal->pa_type_2g & BIT(5)) ? 1 : 0;
		rtlhal->external_lna_2g = (rtlhal->lna_type_2g & BIT(7)) ? 1 : 0;

		rtlhal->pa_type_5g = hwinfo[0xBC];
		rtlhal->lna_type_5g = hwinfo[0xBF];
		if (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {
			rtlhal->pa_type_5g = 0;
			rtlhal->lna_type_5g = 0;
		}
		rtlhal->external_pa_5g = (rtlhal->pa_type_5g & BIT(1)) ? 1 : 0;
		rtlhal->external_lna_5g = (rtlhal->lna_type_5g & BIT(7)) ? 1 : 0;
	} else {
		rtlhal->external_pa_2g  = 0;
		rtlhal->external_lna_2g = 0;
		rtlhal->external_pa_5g  = 0;
		rtlhal->external_lna_5g = 0;
	}
}

static void _rtl8821ae_read_rfe_type(struct ieee80211_hw *hw, u8 *hwinfo,
			      bool autoload_fail)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);

	if (!autoload_fail) {
		if (hwinfo[EEPROM_RFE_OPTION] & BIT(7)) {
			if (rtlhal->external_lna_5g) {
				if (rtlhal->external_pa_5g) {
					if (rtlhal->external_lna_2g &&
					    rtlhal->external_pa_2g)
						rtlhal->rfe_type = 3;
					else
						rtlhal->rfe_type = 0;
				} else {
					rtlhal->rfe_type = 2;
				}
			} else {
				rtlhal->rfe_type = 4;
			}
		} else {
			rtlhal->rfe_type = hwinfo[EEPROM_RFE_OPTION] & 0x3F;

			if (rtlhal->rfe_type == 4 &&
			    (rtlhal->external_pa_5g ||
			     rtlhal->external_pa_2g ||
			     rtlhal->external_lna_5g ||
			     rtlhal->external_lna_2g)) {
				if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)
					rtlhal->rfe_type = 2;
			}
		}
	} else {
		rtlhal->rfe_type = 0x04;
	}

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "RFE Type: 0x%2x\n", rtlhal->rfe_type);
}

static void _rtl8812ae_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,
					      bool auto_load_fail, u8 *hwinfo)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 value;

	if (!auto_load_fail) {
		value = *(u8 *)&hwinfo[EEPROM_RF_BOARD_OPTION];
		if (((value & 0xe0) >> 5) == 0x1)
			rtlpriv->btcoexist.btc_info.btcoexist = 1;
		else
			rtlpriv->btcoexist.btc_info.btcoexist = 0;
		rtlpriv->btcoexist.btc_info.bt_type = BT_RTL8812A;

		value = hwinfo[EEPROM_RF_BT_SETTING];
		rtlpriv->btcoexist.btc_info.ant_num = (value & 0x1);
	} else {
		rtlpriv->btcoexist.btc_info.btcoexist = 0;
		rtlpriv->btcoexist.btc_info.bt_type = BT_RTL8812A;
		rtlpriv->btcoexist.btc_info.ant_num = ANT_X2;
	}
	/*move BT_InitHalVars() to init_sw_vars*/
}

static void _rtl8821ae_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,
					      bool auto_load_fail, u8 *hwinfo)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u8 value;
	u32 tmpu_32;

	if (!auto_load_fail) {
		tmpu_32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);
		if (tmpu_32 & BIT(18))
			rtlpriv->btcoexist.btc_info.btcoexist = 1;
		else
			rtlpriv->btcoexist.btc_info.btcoexist = 0;
		rtlpriv->btcoexist.btc_info.bt_type = BT_RTL8821A;

		value = hwinfo[EEPROM_RF_BT_SETTING];
		rtlpriv->btcoexist.btc_info.ant_num = (value & 0x1);
	} else {
		rtlpriv->btcoexist.btc_info.btcoexist = 0;
		rtlpriv->btcoexist.btc_info.bt_type = BT_RTL8821A;
		rtlpriv->btcoexist.btc_info.ant_num = ANT_X2;
	}
	/*move BT_InitHalVars() to init_sw_vars*/
}

static void _rtl8821ae_read_adapter_info(struct ieee80211_hw *hw, bool b_pseudo_test)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
	u16 i, usvalue;
	u8 hwinfo[HWSET_MAX_SIZE];
	u16 eeprom_id;

	if (b_pseudo_test) {
		;/* need add */
	}

	if (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {
		rtl_efuse_shadow_map_update(hw);
		memcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
		       HWSET_MAX_SIZE);
	} else if (rtlefuse->epromtype == EEPROM_93C46) {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
			 "RTL819X Not boot from eeprom, check it !!");
	}

	RT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, "MAP\n",
		      hwinfo, HWSET_MAX_SIZE);

	eeprom_id = *((u16 *)&hwinfo[0]);
	if (eeprom_id != RTL_EEPROM_ID) {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
			 "EEPROM ID(%#x) is invalid!!\n", eeprom_id);
		rtlefuse->autoload_failflag = true;
	} else {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");
		rtlefuse->autoload_failflag = false;
	}

	if (rtlefuse->autoload_failflag) {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
			 "RTL8812AE autoload_failflag, check it !!");
		return;
	}

	rtlefuse->eeprom_version = *(u8 *)&hwinfo[EEPROM_VERSION];
	if (rtlefuse->eeprom_version == 0xff)
			rtlefuse->eeprom_version = 0;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROM version: 0x%2x\n", rtlefuse->eeprom_version);

	rtlefuse->eeprom_vid = *(u16 *)&hwinfo[EEPROM_VID];
	rtlefuse->eeprom_did = *(u16 *)&hwinfo[EEPROM_DID];
	rtlefuse->eeprom_svid = *(u16 *)&hwinfo[EEPROM_SVID];
	rtlefuse->eeprom_smid = *(u16 *)&hwinfo[EEPROM_SMID];
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROMId = 0x%4x\n", eeprom_id);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROM VID = 0x%4x\n", rtlefuse->eeprom_vid);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROM DID = 0x%4x\n", rtlefuse->eeprom_did);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROM SVID = 0x%4x\n", rtlefuse->eeprom_svid);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROM SMID = 0x%4x\n", rtlefuse->eeprom_smid);

	/*customer ID*/
	rtlefuse->eeprom_oemid = *(u8 *)&hwinfo[EEPROM_CUSTOMER_ID];
	if (rtlefuse->eeprom_oemid == 0xFF)
		rtlefuse->eeprom_oemid = 0;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "EEPROM Customer ID: 0x%2x\n", rtlefuse->eeprom_oemid);

	for (i = 0; i < 6; i += 2) {
		usvalue = *(u16 *)&hwinfo[EEPROM_MAC_ADDR + i];
		*((u16 *)(&rtlefuse->dev_addr[i])) = usvalue;
	}

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		 "dev_addr: %pM\n", rtlefuse->dev_addr);

	_rtl8821ae_read_txpower_info_from_hwpg(hw, rtlefuse->autoload_failflag,
					       hwinfo);

	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {
		_rtl8812ae_read_pa_type(hw, hwinfo, rtlefuse->autoload_failflag);
		_rtl8812ae_read_bt_coexist_info_from_hwpg(hw,
				rtlefuse->autoload_failflag, hwinfo);
	} else {
		_rtl8821ae_read_pa_type(hw, hwinfo, rtlefuse->autoload_failflag);
		_rtl8821ae_read_bt_coexist_info_from_hwpg(hw,
				rtlefuse->autoload_failflag, hwinfo);
	}

	_rtl8821ae_read_rfe_type(hw, hwinfo, rtlefuse->autoload_failflag);
	/*board type*/
	rtlefuse->board_type = ODM_BOARD_DEFAULT;
	if (rtlhal->external_lna_2g != 0)
		rtlefuse->board_type |= ODM_BOARD_EXT_LNA;
	if (rtlhal->external_lna_5g != 0)
		rtlefuse->board_type |= ODM_BOARD_EXT_LNA_5G;
	if (rtlhal->external_pa_2g != 0)
		rtlefuse->board_type |= ODM_BOARD_EXT_PA;
	if (rtlhal->external_pa_5g != 0)
		rtlefuse->board_type |= ODM_BOARD_EXT_PA_5G;

	if (rtlpriv->btcoexist.btc_info.btcoexist == 1)
		rtlefuse->board_type |= ODM_BOARD_BT;

	rtlhal->board_type = rtlefuse->board_type;
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "board_type = 0x%x\n", rtlefuse->board_type);

	rtlefuse->eeprom_channelplan = *(u8 *)&hwinfo[EEPROM_CHANNELPLAN];
	if (rtlefuse->eeprom_channelplan == 0xff)
		rtlefuse->eeprom_channelplan = 0x7F;

	/* set channel paln to world wide 13 */
	/* rtlefuse->channel_plan = (u8)rtlefuse->eeprom_channelplan; */

	/*parse xtal*/
	rtlefuse->crystalcap = hwinfo[EEPROM_XTAL_8821AE];
	if (rtlefuse->crystalcap == 0xFF)
		rtlefuse->crystalcap = 0x20;

	rtlefuse->eeprom_thermalmeter = *(u8 *)&hwinfo[EEPROM_THERMAL_METER];
	if ((rtlefuse->eeprom_thermalmeter == 0xff) ||
	    rtlefuse->autoload_failflag) {
		rtlefuse->apk_thermalmeterignore = true;
		rtlefuse->eeprom_thermalmeter = 0xff;
	}

	rtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		 "thermalmeter = 0x%x\n", rtlefuse->eeprom_thermalmeter);

	if (!rtlefuse->autoload_failflag) {
		rtlefuse->antenna_div_cfg =
		  (hwinfo[EEPROM_RF_BOARD_OPTION] & 0x18) >> 3;
		if (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xff)
			rtlefuse->antenna_div_cfg = 0;

		if (rtlpriv->btcoexist.btc_info.btcoexist == 1 &&
		    rtlpriv->btcoexist.btc_info.ant_num == ANT_X1)
			rtlefuse->antenna_div_cfg = 0;

		rtlefuse->antenna_div_type = hwinfo[EEPROM_RF_ANTENNA_OPT_88E];
		if (rtlefuse->antenna_div_type == 0xff)
			rtlefuse->antenna_div_type = FIXED_HW_ANTDIV;
	} else {
		rtlefuse->antenna_div_cfg = 0;
		rtlefuse->antenna_div_type = 0;
	}

	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
		"SWAS: bHwAntDiv = %x, TRxAntDivType = %x\n",
		rtlefuse->antenna_div_cfg, rtlefuse->antenna_div_type);

	pcipriv->ledctl.led_opendrain = true;

	if (rtlhal->oem_id == RT_CID_DEFAULT) {
		switch (rtlefuse->eeprom_oemid) {
		case RT_CID_DEFAULT:
			break;
		case EEPROM_CID_TOSHIBA:
			rtlhal->oem_id = RT_CID_TOSHIBA;
			break;
		case EEPROM_CID_CCX:
			rtlhal->oem_id = RT_CID_CCX;
			break;
		case EEPROM_CID_QMI:
			rtlhal->oem_id = RT_CID_819X_QMI;
			break;
		case EEPROM_CID_WHQL:
			break;
		default:
			break;
		}
	}
}

/*static void _rtl8821ae_hal_customized_behavior(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));

	pcipriv->ledctl.led_opendrain = true;
	switch (rtlhal->oem_id) {
	case RT_CID_819X_HP:
		pcipriv->ledctl.led_opendrain = true;
		break;
	case RT_CID_819X_LENOVO:
	case RT_CID_DEFAULT:
	case RT_CID_TOSHIBA:
	case RT_CID_CCX:
	case RT_CID_819X_ACER:
	case RT_CID_WHQL:
	default:
		break;
	}
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		 "RT Customized ID: 0x%02X\n", rtlhal->oem_id);
}*/

void rtl8821ae_read_eeprom_info(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	u8 tmp_u1b;

	rtlhal->version = _rtl8821ae_read_chip_version(hw);
	if (get_rf_type(rtlphy) == RF_1T1R)
		rtlpriv->dm.rfpath_rxenable[0] = true;
	else
		rtlpriv->dm.rfpath_rxenable[0] =
		    rtlpriv->dm.rfpath_rxenable[1] = true;
	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "VersionID = 0x%4x\n",
						rtlhal->version);

	tmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);
	if (tmp_u1b & BIT(4)) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EEPROM\n");
		rtlefuse->epromtype = EEPROM_93C46;
	} else {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EFUSE\n");
		rtlefuse->epromtype = EEPROM_BOOT_EFUSE;
	}

	if (tmp_u1b & BIT(5)) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");
		rtlefuse->autoload_failflag = false;
		_rtl8821ae_read_adapter_info(hw, false);
	} else {
		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Autoload ERR!!\n");
	}
	/*hal_ReadRFType_8812A()*/
	/* _rtl8821ae_hal_customized_behavior(hw); */
}

static void rtl8821ae_update_hal_rate_table(struct ieee80211_hw *hw,
		struct ieee80211_sta *sta)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
	u32 ratr_value;
	u8 ratr_index = 0;
	u8 b_nmode = mac->ht_enable;
	u8 mimo_ps = IEEE80211_SMPS_OFF;
	u16 shortgi_rate;
	u32 tmp_ratr_value;
	u8 curtxbw_40mhz = mac->bw_40;
	u8 b_curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?
				1 : 0;
	u8 b_curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?
				1 : 0;
	enum wireless_mode wirelessmode = mac->mode;

	if (rtlhal->current_bandtype == BAND_ON_5G)
		ratr_value = sta->supp_rates[1] << 4;
	else
		ratr_value = sta->supp_rates[0];
	if (mac->opmode == NL80211_IFTYPE_ADHOC)
		ratr_value = 0xfff;
	ratr_value |= (sta->ht_cap.mcs.rx_mask[1] << 20 |
			sta->ht_cap.mcs.rx_mask[0] << 12);
	switch (wirelessmode) {
	case WIRELESS_MODE_B:
		if (ratr_value & 0x0000000c)
			ratr_value &= 0x0000000d;
		else
			ratr_value &= 0x0000000f;
		break;
	case WIRELESS_MODE_G:
		ratr_value &= 0x00000FF5;
		break;
	case WIRELESS_MODE_N_24G:
	case WIRELESS_MODE_N_5G:
		b_nmode = 1;
		if (mimo_ps == IEEE80211_SMPS_STATIC) {
			ratr_value &= 0x0007F005;
		} else {
			u32 ratr_mask;

			if (get_rf_type(rtlphy) == RF_1T2R ||
			    get_rf_type(rtlphy) == RF_1T1R)
				ratr_mask = 0x000ff005;
			else
				ratr_mask = 0x0f0ff005;

			ratr_value &= ratr_mask;
		}
		break;
	default:
		if (rtlphy->rf_type == RF_1T2R)
			ratr_value &= 0x000ff0ff;
		else
			ratr_value &= 0x0f0ff0ff;

		break;
	}

	if ((rtlpriv->btcoexist.bt_coexistence) &&
	     (rtlpriv->btcoexist.bt_coexist_type == BT_CSR_BC4) &&
	     (rtlpriv->btcoexist.bt_cur_state) &&
	     (rtlpriv->btcoexist.bt_ant_isolation) &&
	     ((rtlpriv->btcoexist.bt_service == BT_SCO) ||
	     (rtlpriv->btcoexist.bt_service == BT_BUSY)))
		ratr_value &= 0x0fffcfc0;
	else
		ratr_value &= 0x0FFFFFFF;

	if (b_nmode && ((curtxbw_40mhz &&
			 b_curshortgi_40mhz) || (!curtxbw_40mhz &&
						 b_curshortgi_20mhz))) {
		ratr_value |= 0x10000000;
		tmp_ratr_value = (ratr_value >> 12);

		for (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {
			if ((1 << shortgi_rate) & tmp_ratr_value)
				break;
		}

		shortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |
		    (shortgi_rate << 4) | (shortgi_rate);
	}

	rtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);

	RT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,
		 "%x\n", rtl_read_dword(rtlpriv, REG_ARFR0));
}

static u8 _rtl8821ae_mrate_idx_to_arfr_id(
	struct ieee80211_hw *hw, u8 rate_index,
	enum wireless_mode wirelessmode)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	u8 ret = 0;
	switch (rate_index) {
	case RATR_INX_WIRELESS_NGB:
		if (rtlphy->rf_type == RF_1T1R)
			ret = 1;
		else
			ret = 0;
		; break;
	case RATR_INX_WIRELESS_N:
	case RATR_INX_WIRELESS_NG:
		if (rtlphy->rf_type == RF_1T1R)
			ret = 5;
		else
			ret = 4;
		; break;
	case RATR_INX_WIRELESS_NB:
		if (rtlphy->rf_type == RF_1T1R)
			ret = 3;
		else
			ret = 2;
		; break;
	case RATR_INX_WIRELESS_GB:
		ret = 6;
		break;
	case RATR_INX_WIRELESS_G:
		ret = 7;
		break;
	case RATR_INX_WIRELESS_B:
		ret = 8;
		break;
	case RATR_INX_WIRELESS_MC:
		if ((wirelessmode == WIRELESS_MODE_B)
			|| (wirelessmode == WIRELESS_MODE_G)
			|| (wirelessmode == WIRELESS_MODE_N_24G)
			|| (wirelessmode == WIRELESS_MODE_AC_24G))
			ret = 6;
		else
			ret = 7;
	case RATR_INX_WIRELESS_AC_5N:
		if (rtlphy->rf_type == RF_1T1R)
			ret = 10;
		else
			ret = 9;
		break;
	case RATR_INX_WIRELESS_AC_24N:
		if (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_80) {
			if (rtlphy->rf_type == RF_1T1R)
				ret = 10;
			else
				ret = 9;
		} else {
			if (rtlphy->rf_type == RF_1T1R)
				ret = 11;
			else
				ret = 12;
		}
		break;
	default:
		ret = 0; break;
	}
	return ret;
}

static u32 _rtl8821ae_rate_to_bitmap_2ssvht(__le16 vht_rate)
{
	u8 i, j, tmp_rate;
	u32 rate_bitmap = 0;

	for (i = j = 0; i < 4; i += 2, j += 10) {
		tmp_rate = (le16_to_cpu(vht_rate) >> i) & 3;

		switch (tmp_rate) {
		case 2:
			rate_bitmap = rate_bitmap | (0x03ff << j);
			break;
		case 1:
			rate_bitmap = rate_bitmap | (0x01ff << j);
			break;
		case 0:
			rate_bitmap = rate_bitmap | (0x00ff << j);
			break;
		default:
			break;
		}
	}

	return rate_bitmap;
}

static u32 _rtl8821ae_set_ra_vht_ratr_bitmap(struct ieee80211_hw *hw,
					     enum wireless_mode wirelessmode,
					     u32 ratr_bitmap)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	u32 ret_bitmap = ratr_bitmap;

	if (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40
		|| rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_80)
		ret_bitmap = ratr_bitmap;
	else if (wirelessmode == WIRELESS_MODE_AC_5G
		|| wirelessmode == WIRELESS_MODE_AC_24G) {
		if (rtlphy->rf_type == RF_1T1R)
			ret_bitmap = ratr_bitmap & (~BIT21);
		else
			ret_bitmap = ratr_bitmap & (~(BIT31|BIT21));
	}

	return ret_bitmap;
}

static u8 _rtl8821ae_get_vht_eni(enum wireless_mode wirelessmode,
			u32 ratr_bitmap)
{
	u8 ret = 0;
	if (wirelessmode < WIRELESS_MODE_N_24G)
		ret =  0;
	else if (wirelessmode == WIRELESS_MODE_AC_24G) {
		if (ratr_bitmap & 0xfff00000)	/* Mix , 2SS */
			ret = 3;
		else					/* Mix, 1SS */
			ret = 2;
	} else if (wirelessmode == WIRELESS_MODE_AC_5G) {
			ret = 1;
	} /* VHT */

	return ret << 4;
}

static u8 _rtl8821ae_get_ra_ldpc(struct ieee80211_hw *hw,
			     u8 mac_id, struct rtl_sta_info *sta_entry,
			     enum wireless_mode wirelessmode)
{
	u8 b_ldpc = 0;
	/*not support ldpc, do not open*/
	return b_ldpc << 2;
}

static u8 _rtl8821ae_get_ra_rftype(struct ieee80211_hw *hw,
			  enum wireless_mode wirelessmode,
			  u32 ratr_bitmap)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	u8 rf_type = RF_1T1R;

	if (rtlphy->rf_type == RF_1T1R)
		rf_type = RF_1T1R;
	else if (wirelessmode == WIRELESS_MODE_AC_5G
		|| wirelessmode == WIRELESS_MODE_AC_24G
		|| wirelessmode == WIRELESS_MODE_AC_ONLY) {
		if (ratr_bitmap & 0xffc00000)
			rf_type = RF_2T2R;
	} else if (wirelessmode == WIRELESS_MODE_N_5G
		|| wirelessmode == WIRELESS_MODE_N_24G) {
		if (ratr_bitmap & 0xfff00000)
			rf_type = RF_2T2R;
	}

	return rf_type;
}

static bool _rtl8821ae_get_ra_shortgi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
			      u8 mac_id)
{
	bool b_short_gi = false;
	u8 b_curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?
				1 : 0;
	u8 b_curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?
				1 : 0;
	u8 b_curshortgi_80mhz = 0;
	b_curshortgi_80mhz = (sta->vht_cap.cap &
			      IEEE80211_VHT_CAP_SHORT_GI_80) ? 1 : 0;

	if (mac_id == MAC_ID_STATIC_FOR_BROADCAST_MULTICAST)
			b_short_gi = false;

	if (b_curshortgi_40mhz || b_curshortgi_80mhz
		|| b_curshortgi_20mhz)
		b_short_gi = true;

	return b_short_gi;
}

static void rtl8821ae_update_hal_rate_mask(struct ieee80211_hw *hw,
		struct ieee80211_sta *sta, u8 rssi_level)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	struct rtl_sta_info *sta_entry = NULL;
	u32 ratr_bitmap;
	u8 ratr_index;
	enum wireless_mode wirelessmode = 0;
	u8 curtxbw_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)
				? 1 : 0;
	bool b_shortgi = false;
	u8 rate_mask[7];
	u8 macid = 0;
	u8 mimo_ps = IEEE80211_SMPS_OFF;
	u8 rf_type;

	sta_entry = (struct rtl_sta_info *)sta->drv_priv;
	wirelessmode = sta_entry->wireless_mode;

	RT_TRACE(rtlpriv, COMP_RATR, DBG_LOUD,
		 "wireless mode = 0x%x\n", wirelessmode);
	if (mac->opmode == NL80211_IFTYPE_STATION ||
		mac->opmode == NL80211_IFTYPE_MESH_POINT) {
		curtxbw_40mhz = mac->bw_40;
	} else if (mac->opmode == NL80211_IFTYPE_AP ||
		mac->opmode == NL80211_IFTYPE_ADHOC)
		macid = sta->aid + 1;
	if (wirelessmode == WIRELESS_MODE_N_5G ||
	    wirelessmode == WIRELESS_MODE_AC_5G ||
	    wirelessmode == WIRELESS_MODE_A)
		ratr_bitmap = sta->supp_rates[NL80211_BAND_5GHZ] << 4;
	else
		ratr_bitmap = sta->supp_rates[NL80211_BAND_2GHZ];

	if (mac->opmode == NL80211_IFTYPE_ADHOC)
		ratr_bitmap = 0xfff;

	if (wirelessmode == WIRELESS_MODE_N_24G
		|| wirelessmode == WIRELESS_MODE_N_5G)
		ratr_bitmap |= (sta->ht_cap.mcs.rx_mask[1] << 20 |
				sta->ht_cap.mcs.rx_mask[0] << 12);
	else if (wirelessmode == WIRELESS_MODE_AC_24G
		|| wirelessmode == WIRELESS_MODE_AC_5G
		|| wirelessmode == WIRELESS_MODE_AC_ONLY)
		ratr_bitmap |= _rtl8821ae_rate_to_bitmap_2ssvht(
				sta->vht_cap.vht_mcs.rx_mcs_map) << 12;

	b_shortgi = _rtl8821ae_get_ra_shortgi(hw, sta, macid);
	rf_type = _rtl8821ae_get_ra_rftype(hw, wirelessmode, ratr_bitmap);

/*mac id owner*/
	switch (wirelessmode) {
	case WIRELESS_MODE_B:
		ratr_index = RATR_INX_WIRELESS_B;
		if (ratr_bitmap & 0x0000000c)
			ratr_bitmap &= 0x0000000d;
		else
			ratr_bitmap &= 0x0000000f;
		break;
	case WIRELESS_MODE_G:
		ratr_index = RATR_INX_WIRELESS_GB;

		if (rssi_level == 1)
			ratr_bitmap &= 0x00000f00;
		else if (rssi_level == 2)
			ratr_bitmap &= 0x00000ff0;
		else
			ratr_bitmap &= 0x00000ff5;
		break;
	case WIRELESS_MODE_A:
		ratr_index = RATR_INX_WIRELESS_G;
		ratr_bitmap &= 0x00000ff0;
		break;
	case WIRELESS_MODE_N_24G:
	case WIRELESS_MODE_N_5G:
		if (wirelessmode == WIRELESS_MODE_N_24G)
			ratr_index = RATR_INX_WIRELESS_NGB;
		else
			ratr_index = RATR_INX_WIRELESS_NG;

		if (mimo_ps == IEEE80211_SMPS_STATIC
			|| mimo_ps == IEEE80211_SMPS_DYNAMIC) {
			if (rssi_level == 1)
				ratr_bitmap &= 0x000f0000;
			else if (rssi_level == 2)
				ratr_bitmap &= 0x000ff000;
			else
				ratr_bitmap &= 0x000ff005;
		} else {
			if (rf_type == RF_1T1R) {
				if (curtxbw_40mhz) {
					if (rssi_level == 1)
						ratr_bitmap &= 0x000f0000;
					else if (rssi_level == 2)
						ratr_bitmap &= 0x000ff000;
					else
						ratr_bitmap &= 0x000ff015;
				} else {
					if (rssi_level == 1)
						ratr_bitmap &= 0x000f0000;
					else if (rssi_level == 2)
						ratr_bitmap &= 0x000ff000;
					else
						ratr_bitmap &= 0x000ff005;
				}
			} else {
				if (curtxbw_40mhz) {
					if (rssi_level == 1)
						ratr_bitmap &= 0x0fff0000;
					else if (rssi_level == 2)
						ratr_bitmap &= 0x0ffff000;
					else
						ratr_bitmap &= 0x0ffff015;
				} else {
					if (rssi_level == 1)
						ratr_bitmap &= 0x0fff0000;
					else if (rssi_level == 2)
						ratr_bitmap &= 0x0ffff000;
					else
						ratr_bitmap &= 0x0ffff005;
				}
			}
		}
		break;

	case WIRELESS_MODE_AC_24G:
		ratr_index = RATR_INX_WIRELESS_AC_24N;
		if (rssi_level == 1)
			ratr_bitmap &= 0xfc3f0000;
		else if (rssi_level == 2)
			ratr_bitmap &= 0xfffff000;
		else
			ratr_bitmap &= 0xffffffff;
		break;

	case WIRELESS_MODE_AC_5G:
		ratr_index = RATR_INX_WIRELESS_AC_5N;

		if (rf_type == RF_1T1R) {
			if (rssi_level == 1)	/*add by Gary for ac-series*/
				ratr_bitmap &= 0x003f8000;
			else if (rssi_level == 2)
				ratr_bitmap &= 0x003ff000;
			else
				ratr_bitmap &= 0x003ff010;
		} else {
			if (rssi_level == 1)
				ratr_bitmap &= 0xfe3f8000;
			else if (rssi_level == 2)
				ratr_bitmap &= 0xfffff000;
			else
				ratr_bitmap &= 0xfffff010;
		}
		break;

	default:
		ratr_index = RATR_INX_WIRELESS_NGB;

		if (rf_type == RF_1T2R)
			ratr_bitmap &= 0x000ff0ff;
		else
			ratr_bitmap &= 0x0f8ff0ff;
		break;
	}

	ratr_index = _rtl8821ae_mrate_idx_to_arfr_id(hw, ratr_index, wirelessmode);
	sta_entry->ratr_index = ratr_index;
	ratr_bitmap = _rtl8821ae_set_ra_vht_ratr_bitmap(hw, wirelessmode,
							ratr_bitmap);

	RT_TRACE(rtlpriv, COMP_RATR, DBG_LOUD,
		 "ratr_bitmap :%x\n", ratr_bitmap);

	/* *(u32 *)& rate_mask = EF4BYTE((ratr_bitmap & 0x0fffffff) |
				       (ratr_index << 28)); */

	rate_mask[0] = macid;
	rate_mask[1] = ratr_index | (b_shortgi ? 0x80 : 0x00);
	rate_mask[2] = rtlphy->current_chan_bw
			   | _rtl8821ae_get_vht_eni(wirelessmode, ratr_bitmap)
			   | _rtl8821ae_get_ra_ldpc(hw, macid, sta_entry, wirelessmode);

	rate_mask[3] = (u8)(ratr_bitmap & 0x000000ff);
	rate_mask[4] = (u8)((ratr_bitmap & 0x0000ff00) >> 8);
	rate_mask[5] = (u8)((ratr_bitmap & 0x00ff0000) >> 16);
	rate_mask[6] = (u8)((ratr_bitmap & 0xff000000) >> 24);

	RT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,
		 "Rate_index:%x, ratr_val:%x, %x:%x:%x:%x:%x:%x:%x\n",
		 ratr_index, ratr_bitmap,
		 rate_mask[0], rate_mask[1],
		 rate_mask[2], rate_mask[3],
		 rate_mask[4], rate_mask[5],
		 rate_mask[6]);
	rtl8821ae_fill_h2c_cmd(hw, H2C_8821AE_RA_MASK, 7, rate_mask);
	_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);
}

void rtl8821ae_update_hal_rate_tbl(struct ieee80211_hw *hw,
		struct ieee80211_sta *sta, u8 rssi_level)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	if (rtlpriv->dm.useramask)
		rtl8821ae_update_hal_rate_mask(hw, sta, rssi_level);
	else
		/*RT_TRACE(rtlpriv, COMP_RATR,DBG_LOUD,
			   "rtl8821ae_update_hal_rate_tbl() Error! 8821ae FW RA Only");*/
		rtl8821ae_update_hal_rate_table(hw, sta);
}

void rtl8821ae_update_channel_access_setting(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	u8 wireless_mode = mac->mode;
	u8 sifs_timer, r2t_sifs;

	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,
				      (u8 *)&mac->slot_time);
	if (wireless_mode == WIRELESS_MODE_G)
		sifs_timer = 0x0a;
	else
		sifs_timer = 0x0e;
	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);

	r2t_sifs = 0xa;

	if (wireless_mode == WIRELESS_MODE_AC_5G &&
	    (mac->vht_ldpc_cap & LDPC_VHT_ENABLE_RX) &&
	    (mac->vht_stbc_cap & STBC_VHT_ENABLE_RX)) {
		if (mac->vendor == PEER_ATH)
			r2t_sifs = 0x8;
		else
			r2t_sifs = 0xa;
	} else if (wireless_mode == WIRELESS_MODE_AC_5G) {
		r2t_sifs = 0xa;
	}

	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_R2T_SIFS, (u8 *)&r2t_sifs);
}

bool rtl8821ae_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 *valid)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
	struct rtl_phy *rtlphy = &rtlpriv->phy;
	enum rf_pwrstate e_rfpowerstate_toset, cur_rfstate;
	u8 u1tmp = 0;
	bool b_actuallyset = false;

	if (rtlpriv->rtlhal.being_init_adapter)
		return false;

	if (ppsc->swrf_processing)
		return false;

	spin_lock(&rtlpriv->locks.rf_ps_lock);
	if (ppsc->rfchange_inprogress) {
		spin_unlock(&rtlpriv->locks.rf_ps_lock);
		return false;
	} else {
		ppsc->rfchange_inprogress = true;
		spin_unlock(&rtlpriv->locks.rf_ps_lock);
	}

	cur_rfstate = ppsc->rfpwr_state;

	rtl_write_byte(rtlpriv, REG_GPIO_IO_SEL_2,
			rtl_read_byte(rtlpriv,
					REG_GPIO_IO_SEL_2) & ~(BIT(1)));

	u1tmp = rtl_read_byte(rtlpriv, REG_GPIO_PIN_CTRL_2);

	if (rtlphy->polarity_ctl)
		e_rfpowerstate_toset = (u1tmp & BIT(1)) ? ERFOFF : ERFON;
	else
		e_rfpowerstate_toset = (u1tmp & BIT(1)) ? ERFON : ERFOFF;

	if ((ppsc->hwradiooff) && (e_rfpowerstate_toset == ERFON)) {
		RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
			 "GPIOChangeRF  - HW Radio ON, RF ON\n");

		e_rfpowerstate_toset = ERFON;
		ppsc->hwradiooff = false;
		b_actuallyset = true;
	} else if ((!ppsc->hwradiooff)
		   && (e_rfpowerstate_toset == ERFOFF)) {
		RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
			 "GPIOChangeRF  - HW Radio OFF, RF OFF\n");

		e_rfpowerstate_toset = ERFOFF;
		ppsc->hwradiooff = true;
		b_actuallyset = true;
	}

	if (b_actuallyset) {
		spin_lock(&rtlpriv->locks.rf_ps_lock);
		ppsc->rfchange_inprogress = false;
		spin_unlock(&rtlpriv->locks.rf_ps_lock);
	} else {
		if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC)
			RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);

		spin_lock(&rtlpriv->locks.rf_ps_lock);
		ppsc->rfchange_inprogress = false;
		spin_unlock(&rtlpriv->locks.rf_ps_lock);
	}

	*valid = 1;
	return !ppsc->hwradiooff;
}

void rtl8821ae_set_key(struct ieee80211_hw *hw, u32 key_index,
		     u8 *p_macaddr, bool is_group, u8 enc_algo,
		     bool is_wepkey, bool clear_all)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
	u8 *macaddr = p_macaddr;
	u32 entry_id = 0;
	bool is_pairwise = false;

	static u8 cam_const_addr[4][6] = {
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}
	};
	static u8 cam_const_broad[] = {
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	if (clear_all) {
		u8 idx = 0;
		u8 cam_offset = 0;
		u8 clear_number = 5;

		RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "clear_all\n");

		for (idx = 0; idx < clear_number; idx++) {
			rtl_cam_mark_invalid(hw, cam_offset + idx);
			rtl_cam_empty_entry(hw, cam_offset + idx);

			if (idx < 5) {
				memset(rtlpriv->sec.key_buf[idx], 0,
				       MAX_KEY_LEN);
				rtlpriv->sec.key_len[idx] = 0;
			}
		}
	} else {
		switch (enc_algo) {
		case WEP40_ENCRYPTION:
			enc_algo = CAM_WEP40;
			break;
		case WEP104_ENCRYPTION:
			enc_algo = CAM_WEP104;
			break;
		case TKIP_ENCRYPTION:
			enc_algo = CAM_TKIP;
			break;
		case AESCCMP_ENCRYPTION:
			enc_algo = CAM_AES;
			break;
		default:
			RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
				 "switch case not process\n");
			enc_algo = CAM_TKIP;
			break;
		}

		if (is_wepkey || rtlpriv->sec.use_defaultkey) {
			macaddr = cam_const_addr[key_index];
			entry_id = key_index;
		} else {
			if (is_group) {
				macaddr = cam_const_broad;
				entry_id = key_index;
			} else {
				if (mac->opmode == NL80211_IFTYPE_AP) {
					entry_id = rtl_cam_get_free_entry(hw, p_macaddr);
					if (entry_id >=  TOTAL_CAM_ENTRY) {
						RT_TRACE(rtlpriv, COMP_SEC, DBG_EMERG,
							 "Can not find free hwsecurity cam entry\n");
						return;
					}
				} else {
					entry_id = CAM_PAIRWISE_KEY_POSITION;
				}

				key_index = PAIRWISE_KEYIDX;
				is_pairwise = true;
			}
		}

		if (rtlpriv->sec.key_len[key_index] == 0) {
			RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
				 "delete one entry, entry_id is %d\n",
				 entry_id);
			if (mac->opmode == NL80211_IFTYPE_AP)
				rtl_cam_del_entry(hw, p_macaddr);
			rtl_cam_delete_one_entry(hw, p_macaddr, entry_id);
		} else {
			RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
				 "add one entry\n");
			if (is_pairwise) {
				RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
					 "set Pairwise key\n");

				rtl_cam_add_one_entry(hw, macaddr, key_index,
						      entry_id, enc_algo,
						      CAM_CONFIG_NO_USEDK,
						      rtlpriv->sec.key_buf[key_index]);
			} else {
				RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
					 "set group key\n");

				if (mac->opmode == NL80211_IFTYPE_ADHOC) {
					rtl_cam_add_one_entry(hw,
							rtlefuse->dev_addr,
							PAIRWISE_KEYIDX,
							CAM_PAIRWISE_KEY_POSITION,
							enc_algo,
							CAM_CONFIG_NO_USEDK,
							rtlpriv->sec.key_buf
							[entry_id]);
				}

				rtl_cam_add_one_entry(hw, macaddr, key_index,
						entry_id, enc_algo,
						CAM_CONFIG_NO_USEDK,
						rtlpriv->sec.key_buf[entry_id]);
			}
		}
	}
}

void rtl8821ae_bt_reg_init(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);

	/* 0:Low, 1:High, 2:From Efuse. */
	rtlpriv->btcoexist.reg_bt_iso = 2;
	/* 0:Idle, 1:None-SCO, 2:SCO, 3:From Counter. */
	rtlpriv->btcoexist.reg_bt_sco = 3;
	/* 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU. */
	rtlpriv->btcoexist.reg_bt_sco = 0;
}

void rtl8821ae_bt_hw_init(struct ieee80211_hw *hw)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);

	if (rtlpriv->cfg->ops->get_btc_status())
		rtlpriv->btcoexist.btc_ops->btc_init_hw_config(rtlpriv);
}

void rtl8821ae_suspend(struct ieee80211_hw *hw)
{
}

void rtl8821ae_resume(struct ieee80211_hw *hw)
{
}

/* Turn on AAP (RCR:bit 0) for promicuous mode. */
void rtl8821ae_allow_all_destaddr(struct ieee80211_hw *hw,
	bool allow_all_da, bool write_into_reg)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));

	if (allow_all_da) /* Set BIT0 */
		rtlpci->receive_config |= RCR_AAP;
	else /* Clear BIT0 */
		rtlpci->receive_config &= ~RCR_AAP;

	if (write_into_reg)
		rtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);

	RT_TRACE(rtlpriv, COMP_TURBO | COMP_INIT, DBG_LOUD,
		"receive_config=0x%08X, write_into_reg=%d\n",
		rtlpci->receive_config, write_into_reg);
}

/* WKFMCAMAddAllEntry8812 */
void rtl8821ae_add_wowlan_pattern(struct ieee80211_hw *hw,
				  struct rtl_wow_pattern *rtl_pattern,
				  u8 index)
{
	struct rtl_priv *rtlpriv = rtl_priv(hw);
	u32 cam = 0;
	u8 addr = 0;
	u16 rxbuf_addr;
	u8 tmp, count = 0;
	u16 cam_start;
	u16 offset;

	/* Count the WFCAM entry start offset. */

	/* RX page size = 128 byte */
	offset = MAX_RX_DMA_BUFFER_SIZE_8812 / 128;
	/* We should start from the boundry */
	cam_start = offset * 128;

	/* Enable Rx packet buffer access. */
	rtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL, RXPKT_BUF_SELECT);
	for (addr = 0; addr < WKFMCAM_ADDR_NUM; addr++) {
		/* Set Rx packet buffer offset.
		 * RxBufer pointer increases 1,
		 * we can access 8 bytes in Rx packet buffer.
		 * CAM start offset (unit: 1 byte) =  index*WKFMCAM_SIZE
		 * RxBufer addr = (CAM start offset +
		 *                 per entry offset of a WKFM CAM)/8
		 *	* index: The index of the wake up frame mask
		 *	* WKFMCAM_SIZE: the total size of one WKFM CAM
		 *	* per entry offset of a WKFM CAM: Addr*4 bytes
		 */
		rxbuf_addr = (cam_start + index * WKFMCAM_SIZE + addr * 4) >> 3;
		/* Set R/W start offset */
		rtl_write_word(rtlpriv, REG_PKTBUF_DBG_CTRL, rxbuf_addr);

		if (addr == 0) {
			cam = BIT(31) | rtl_pattern->crc;

			if (rtl_pattern->type == UNICAST_PATTERN)
				cam |= BIT(24);
			else if (rtl_pattern->type == MULTICAST_PATTERN)
				cam |= BIT(25);
			else if (rtl_pattern->type == BROADCAST_PATTERN)
				cam |= BIT(26);

			rtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L, cam);
			RT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,
				 "WRITE entry[%d] 0x%x: %x\n", addr,
				  REG_PKTBUF_DBG_DATA_L, cam);

			/* Write to Rx packet buffer. */
			rtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0x0f01);
		} else if (addr == 2 || addr == 4) {/* WKFM[127:0] */
			cam = rtl_pattern->mask[addr - 2];

			rtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L, cam);
			RT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,
				 "WRITE entry[%d] 0x%x: %x\n", addr,
				  REG_PKTBUF_DBG_DATA_L, cam);

			rtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0x0f01);
		} else if (addr == 3 || addr == 5) {/* WKFM[127:0] */
			cam = rtl_pattern->mask[addr - 2];

			rtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_H, cam);
			RT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,
				 "WRITE entry[%d] 0x%x: %x\n", addr,
				  REG_PKTBUF_DBG_DATA_H, cam);

			rtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0xf001);
		}

		count = 0;
		do {
			tmp = rtl_read_byte(rtlpriv, REG_RXPKTBUF_CTRL);
			udelay(2);
			count++;
		} while (tmp && count < 100);

		RT_ASSERT((count < 100),
			  "Write wake up frame mask FAIL %d value!\n", tmp);
	}
	/* Disable Rx packet buffer access. */
	rtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL,
		       DISABLE_TRXPKT_BUF_ACCESS);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /* packet.h: Rx packet layout and definitions
 *
 * Copyright (C) 2002, 2007 Red Hat, Inc. All Rights Reserved.
 * Written by David Howells (dhowells@redhat.com)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 */

#ifndef _LINUX_RXRPC_PACKET_H
#define _LINUX_RXRPC_PACKET_H

typedef u32	rxrpc_seq_t;	/* Rx message sequence number */
typedef u32	rxrpc_serial_t;	/* Rx message serial number */
typedef __be32	rxrpc_seq_net_t; /* on-the-wire Rx message sequence number */
typedef __be32	rxrpc_serial_net_t; /* on-the-wire Rx message serial number */

/*****************************************************************************/
/*
 * on-the-wire Rx packet header
 * - all multibyte fields should be in network byte order
 */
struct rxrpc_header {
	__be32		epoch;		/* client boot timestamp */

	__be32		cid;		/* connection and channel ID */
#define RXRPC_MAXCALLS		4			/* max active calls per conn */
#define RXRPC_CHANNELMASK	(RXRPC_MAXCALLS-1)	/* mask for channel ID */
#define RXRPC_CIDMASK		(~RXRPC_CHANNELMASK)	/* mask for connection ID */
#define RXRPC_CIDSHIFT		ilog2(RXRPC_MAXCALLS)	/* shift for connection ID */
#define RXRPC_CID_INC		(1 << RXRPC_CIDSHIFT)	/* connection ID increment */

	__be32		callNumber;	/* call ID (0 for connection-level packets) */
#define RXRPC_PROCESS_MAXCALLS	(1<<2)	/* maximum number of active calls per conn (power of 2) */

	__be32		seq;		/* sequence number of pkt in call stream */
	__be32		serial;		/* serial number of pkt sent to network */

	uint8_t		type;		/* packet type */
#define RXRPC_PACKET_TYPE_DATA		1	/* data */
#define RXRPC_PACKET_TYPE_ACK		2	/* ACK */
#define RXRPC_PACKET_TYPE_BUSY		3	/* call reject */
#define RXRPC_PACKET_TYPE_ABORT		4	/* call/connection abort */
#define RXRPC_PACKET_TYPE_ACKALL	5	/* ACK all outstanding packets on call */
#define RXRPC_PACKET_TYPE_CHALLENGE	6	/* connection security challenge (SRVR->CLNT) */
#define RXRPC_PACKET_TYPE_RESPONSE	7	/* connection secutity response (CLNT->SRVR) */
#define RXRPC_PACKET_TYPE_DEBUG		8	/* debug info request */
#define RXRPC_N_PACKET_TYPES		9	/* number of packet types (incl type 0) */

	uint8_t		flags;		/* packet flags */
#define RXRPC_CLIENT_INITIATED	0x01		/* signifies a packet generated by a client */
#define RXRPC_REQUEST_ACK	0x02		/* request an unconditional ACK of this packet */
#define RXRPC_LAST_PACKET	0x04		/* the last packet from this side for this call */
#define RXRPC_MORE_PACKETS	0x08		/* more packets to come */
#define RXRPC_JUMBO_PACKET	0x20		/* [DATA] this is a jumbo packet */
#define RXRPC_SLOW_START_OK	0x20		/* [ACK] slow start supported */

	uint8_t		userStatus;	/* app-layer defined status */
	uint8_t		securityIndex;	/* security protocol ID */
	union {
		__be16	_rsvd;		/* reserved */
		__be16	cksum;		/* kerberos security checksum */
	};
	__be16		serviceId;	/* service ID */

} __packed;

#define __rxrpc_header_off(X) offsetof(struct rxrpc_header,X)

extern const char *rxrpc_pkts[];

/*****************************************************************************/
/*
 * jumbo packet secondary header
 * - can be mapped to read header by:
 *   - new_serial = serial + 1
 *   - new_seq = seq + 1
 *   - new_flags = j_flags
 *   - new__rsvd = j__rsvd
 *   - duplicating all other fields
 */
struct rxrpc_jumbo_header {
	uint8_t		flags;		/* packet flags (as per rxrpc_header) */
	uint8_t		pad;
	__be16		_rsvd;		/* reserved (used by kerberos security as cksum) */
};

#define RXRPC_JUMBO_DATALEN	1412	/* non-terminal jumbo packet data length */

/*****************************************************************************/
/*
 * on-the-wire Rx ACK packet data payload
 * - all multibyte fields should be in network byte order
 */
struct rxrpc_ackpacket {
	__be16		bufferSpace;	/* number of packet buffers available */
	__be16		maxSkew;	/* diff between serno being ACK'd and highest serial no
					 * received */
	__be32		firstPacket;	/* sequence no of first ACK'd packet in attached list */
	__be32		previousPacket;	/* sequence no of previous packet received */
	__be32		serial;		/* serial no of packet that prompted this ACK */

	uint8_t		reason;		/* reason for ACK */
#define RXRPC_ACK_REQUESTED		1	/* ACK was requested on packet */
#define RXRPC_ACK_DUPLICATE		2	/* duplicate packet received */
#define RXRPC_ACK_OUT_OF_SEQUENCE	3	/* out of sequence packet received */
#define RXRPC_ACK_EXCEEDS_WINDOW	4	/* packet received beyond end of ACK window */
#define RXRPC_ACK_NOSPACE		5	/* packet discarded due to lack of buffer space */
#define RXRPC_ACK_PING			6	/* keep alive ACK */
#define RXRPC_ACK_PING_RESPONSE		7	/* response to RXRPC_ACK_PING */
#define RXRPC_ACK_DELAY			8	/* nothing happened since received packet */
#define RXRPC_ACK_IDLE			9	/* ACK due to fully received ACK window */

	uint8_t		nAcks;		/* number of ACKs */
#define RXRPC_MAXACKS	255

	uint8_t		acks[0];	/* list of ACK/NAKs */
#define RXRPC_ACK_TYPE_NACK		0
#define RXRPC_ACK_TYPE_ACK		1

} __packed;

/*
 * ACK packets can have a further piece of information tagged on the end
 */
struct rxrpc_ackinfo {
	__be32		rxMTU;		/* maximum Rx MTU size (bytes) [AFS 3.3] */
	__be32		maxMTU;		/* maximum interface MTU size (bytes) [AFS 3.3] */
	__be32		rwind;		/* Rx window size (packets) [AFS 3.4] */
	__be32		jumbo_max;	/* max packets to stick into a jumbo packet [AFS 3.5] */
};

/*****************************************************************************/
/*
 * Kerberos security type-2 challenge packet
 */
struct rxkad_challenge {
	__be32		version;	/* version of this challenge type */
	__be32		nonce;		/* encrypted random number */
	__be32		min_level;	/* minimum security level */
	__be32		__padding;	/* padding to 8-byte boundary */
} __packed;

/*****************************************************************************/
/*
 * Kerberos security type-2 response packet
 */
struct rxkad_response {
	__be32		version;	/* version of this response type */
	__be32		__pad;

	/* encrypted bit of the response */
	struct {
		__be32		epoch;		/* current epoch */
		__be32		cid;		/* parent connection ID */
		__be32		checksum;	/* checksum */
		__be32		securityIndex;	/* security type */
		__be32		call_id[4];	/* encrypted call IDs */
		__be32		inc_nonce;	/* challenge nonce + 1 */
		__be32		level;		/* desired level */
	} encrypted;

	__be32		kvno;		/* Kerberos key version number */
	__be32		ticket_len;	/* Kerberos ticket length  */
} __packed;

/*****************************************************************************/
/*
 * RxRPC-level abort codes
 */
#define RX_CALL_DEAD		-1	/* call/conn has been inactive and is shut down */
#define RX_INVALID_OPERATION	-2	/* invalid operation requested / attempted */
#define RX_CALL_TIMEOUT		-3	/* call timeout exceeded */
#define RX_EOF			-4	/* unexpected end of data on read op */
#define RX_PROTOCOL_ERROR	-5	/* low-level protocol error */
#define RX_USER_ABORT		-6	/* generic user abort */
#define RX_ADDRINUSE		-7	/* UDP port in use */
#define RX_DEBUGI_BADTYPE	-8	/* bad debugging packet type */

/*
 * (un)marshalling abort codes (rxgen)
 */
#define	RXGEN_CC_MARSHAL    -450
#define	RXGEN_CC_UNMARSHAL  -451
#define	RXGEN_SS_MARSHAL    -452
#define	RXGEN_SS_UNMARSHAL  -453
#define	RXGEN_DECODE	    -454
#define	RXGEN_OPCODE	    -455
#define	RXGEN_SS_XDRFREE    -456
#define	RXGEN_CC_XDRFREE    -457

/*
 * Rx kerberos security abort codes
 * - unfortunately we have no generalised security abort codes to say things
 *   like "unsupported security", so we have to use these instead and hope the
 *   other side understands
 */
#define RXKADINCONSISTENCY	19270400	/* security module structure inconsistent */
#define RXKADPACKETSHORT	19270401	/* packet too short for security challenge */
#define RXKADLEVELFAIL		19270402	/* security level negotiation failed */
#define RXKADTICKETLEN		19270403	/* ticket length too short or too long */
#define RXKADOUTOFSEQUENCE	19270404	/* packet had bad sequence number */
#define RXKADNOAUTH		19270405	/* caller not authorised */
#define RXKADBADKEY		19270406	/* illegal key: bad parity or weak */
#define RXKADBADTICKET		19270407	/* security object was passed a bad ticket */
#define RXKADUNKNOWNKEY		19270408	/* ticket contained unknown key version number */
#define RXKADEXPIRED		19270409	/* authentication expired */
#define RXKADSEALEDINCON	19270410	/* sealed data inconsistent */
#define RXKADDATALEN		19270411	/* user data too long */
#define RXKADILLEGALLEVEL	19270412	/* caller not authorised to use encrypted conns */

#endif /* _LINUX_RXRPC_PACKET_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Copyright 2006, Red Hat, Inc., Dave Jones
 * Released under the General Public License (GPL).
 *
 * This file contains the linked list implementations for
 * DEBUG_LIST.
 */

#include <linux/export.h>
#include <linux/list.h>
#include <linux/bug.h>
#include <linux/kernel.h>
#include <linux/rculist.h>

/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */

void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	WARN(next->prev != prev,
		"list_add corruption. next->prev should be "
		"prev (%p), but was %p. (next=%p).\n",
		prev, next->prev, next);
	WARN(prev->next != next,
		"list_add corruption. prev->next should be "
		"next (%p), but was %p. (prev=%p).\n",
		next, prev->next, prev);
	WARN(new == prev || new == next,
	     "list_add double add: new=%p, prev=%p, next=%p.\n",
	     new, prev, next);
	if (next->prev != prev || prev->next != next || new == prev || new == next)
		BUG();

	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
}
EXPORT_SYMBOL(__list_add);

void __list_del_entry(struct list_head *entry)
{
	struct list_head *prev, *next;

	prev = entry->prev;
	next = entry->next;

	if (WARN(next == LIST_POISON1,
		"list_del corruption, %p->next is LIST_POISON1 (%p)\n",
		entry, LIST_POISON1) ||
	    WARN(prev == LIST_POISON2,
		"list_del corruption, %p->prev is LIST_POISON2 (%p)\n",
		entry, LIST_POISON2) ||
	    WARN(prev->next != entry,
		"list_del corruption. prev->next should be %p, "
		"but was %p\n", entry, prev->next) ||
	    WARN(next->prev != entry,
		"list_del corruption. next->prev should be %p, "
		"but was %p\n", entry, next->prev)) {
		BUG();
		return;
	}

	__list_del(prev, next);
}
EXPORT_SYMBOL(__list_del_entry);

/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty on entry does not return true after this, the entry is
 * in an undefined state.
 */
void list_del(struct list_head *entry)
{
	__list_del_entry(entry);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
}
EXPORT_SYMBOL(list_del);

/*
 * RCU variants.
 */
void __list_add_rcu(struct list_head *new,
		    struct list_head *prev, struct list_head *next)
{
	WARN(next->prev != prev,
		"list_add_rcu corruption. next->prev should be prev (%p), but was %p. (next=%p).\n",
		prev, next->prev, next);
	WARN(prev->next != next,
		"list_add_rcu corruption. prev->next should be next (%p), but was %p. (prev=%p).\n",
		next, prev->next, prev);
	if (next->prev != prev || prev->next != next)
		BUG();
	new->next = next;
	new->prev = prev;
	rcu_assign_pointer(list_next_rcu(prev), new);
	next->prev = new;
}
EXPORT_SYMBOL(__list_add_rcu);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * File: pn_dev.c
 *
 * Phonet network device
 *
 * Copyright (C) 2008 Nokia Corporation.
 *
 * Authors: Sakari Ailus <sakari.ailus@nokia.com>
 *          Rmi Denis-Courmont
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#include <linux/kernel.h>
#include <linux/net.h>
#include <linux/slab.h>
#include <linux/netdevice.h>
#include <linux/phonet.h>
#include <linux/proc_fs.h>
#include <linux/if_arp.h>
#include <net/sock.h>
#include <net/netns/generic.h>
#include <net/phonet/pn_dev.h>

struct phonet_routes {
	struct mutex		lock;
	struct net_device __rcu	*table[64];
};

struct phonet_net {
	struct phonet_device_list pndevs;
	struct phonet_routes routes;
};

static int phonet_net_id __read_mostly;

static struct phonet_net *phonet_pernet(struct net *net)
{
	BUG_ON(!net);

	return net_generic(net, phonet_net_id);
}

struct phonet_device_list *phonet_device_list(struct net *net)
{
	struct phonet_net *pnn = phonet_pernet(net);
	return &pnn->pndevs;
}

/* Allocate new Phonet device. */
static struct phonet_device *__phonet_device_alloc(struct net_device *dev)
{
	struct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));
	struct phonet_device *pnd = kmalloc(sizeof(*pnd), GFP_ATOMIC);
	if (pnd == NULL)
		return NULL;
	pnd->netdev = dev;
	bitmap_zero(pnd->addrs, 64);

	BUG_ON(!mutex_is_locked(&pndevs->lock));
	list_add_rcu(&pnd->list, &pndevs->list);
	return pnd;
}

static struct phonet_device *__phonet_get(struct net_device *dev)
{
	struct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));
	struct phonet_device *pnd;

	BUG_ON(!mutex_is_locked(&pndevs->lock));
	list_for_each_entry(pnd, &pndevs->list, list) {
		if (pnd->netdev == dev)
			return pnd;
	}
	return NULL;
}

static struct phonet_device *__phonet_get_rcu(struct net_device *dev)
{
	struct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));
	struct phonet_device *pnd;

	list_for_each_entry_rcu(pnd, &pndevs->list, list) {
		if (pnd->netdev == dev)
			return pnd;
	}
	return NULL;
}

static void phonet_device_destroy(struct net_device *dev)
{
	struct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));
	struct phonet_device *pnd;

	ASSERT_RTNL();

	mutex_lock(&pndevs->lock);
	pnd = __phonet_get(dev);
	if (pnd)
		list_del_rcu(&pnd->list);
	mutex_unlock(&pndevs->lock);

	if (pnd) {
		u8 addr;

		for_each_set_bit(addr, pnd->addrs, 64)
			phonet_address_notify(RTM_DELADDR, dev, addr);
		kfree(pnd);
	}
}

struct net_device *phonet_device_get(struct net *net)
{
	struct phonet_device_list *pndevs = phonet_device_list(net);
	struct phonet_device *pnd;
	struct net_device *dev = NULL;

	rcu_read_lock();
	list_for_each_entry_rcu(pnd, &pndevs->list, list) {
		dev = pnd->netdev;
		BUG_ON(!dev);

		if ((dev->reg_state == NETREG_REGISTERED) &&
			((pnd->netdev->flags & IFF_UP)) == IFF_UP)
			break;
		dev = NULL;
	}
	if (dev)
		dev_hold(dev);
	rcu_read_unlock();
	return dev;
}

int phonet_address_add(struct net_device *dev, u8 addr)
{
	struct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));
	struct phonet_device *pnd;
	int err = 0;

	mutex_lock(&pndevs->lock);
	/* Find or create Phonet-specific device data */
	pnd = __phonet_get(dev);
	if (pnd == NULL)
		pnd = __phonet_device_alloc(dev);
	if (unlikely(pnd == NULL))
		err = -ENOMEM;
	else if (test_and_set_bit(addr >> 2, pnd->addrs))
		err = -EEXIST;
	mutex_unlock(&pndevs->lock);
	return err;
}

int phonet_address_del(struct net_device *dev, u8 addr)
{
	struct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));
	struct phonet_device *pnd;
	int err = 0;

	mutex_lock(&pndevs->lock);
	pnd = __phonet_get(dev);
	if (!pnd || !test_and_clear_bit(addr >> 2, pnd->addrs)) {
		err = -EADDRNOTAVAIL;
		pnd = NULL;
	} else if (bitmap_empty(pnd->addrs, 64))
		list_del_rcu(&pnd->list);
	else
		pnd = NULL;
	mutex_unlock(&pndevs->lock);

	if (pnd)
		kfree_rcu(pnd, rcu);

	return err;
}

/* Gets a source address toward a destination, through a interface. */
u8 phonet_address_get(struct net_device *dev, u8 daddr)
{
	struct phonet_device *pnd;
	u8 saddr;

	rcu_read_lock();
	pnd = __phonet_get_rcu(dev);
	if (pnd) {
		BUG_ON(bitmap_empty(pnd->addrs, 64));

		/* Use same source address as destination, if possible */
		if (test_bit(daddr >> 2, pnd->addrs))
			saddr = daddr;
		else
			saddr = find_first_bit(pnd->addrs, 64) << 2;
	} else
		saddr = PN_NO_ADDR;
	rcu_read_unlock();

	if (saddr == PN_NO_ADDR) {
		/* Fallback to another device */
		struct net_device *def_dev;

		def_dev = phonet_device_get(dev_net(dev));
		if (def_dev) {
			if (def_dev != dev)
				saddr = phonet_address_get(def_dev, daddr);
			dev_put(def_dev);
		}
	}
	return saddr;
}

int phonet_address_lookup(struct net *net, u8 addr)
{
	struct phonet_device_list *pndevs = phonet_device_list(net);
	struct phonet_device *pnd;
	int err = -EADDRNOTAVAIL;

	rcu_read_lock();
	list_for_each_entry_rcu(pnd, &pndevs->list, list) {
		/* Don't allow unregistering devices! */
		if ((pnd->netdev->reg_state != NETREG_REGISTERED) ||
				((pnd->netdev->flags & IFF_UP)) != IFF_UP)
			continue;

		if (test_bit(addr >> 2, pnd->addrs)) {
			err = 0;
			goto found;
		}
	}
found:
	rcu_read_unlock();
	return err;
}

/* automatically configure a Phonet device, if supported */
static int phonet_device_autoconf(struct net_device *dev)
{
	struct if_phonet_req req;
	int ret;

	if (!dev->netdev_ops->ndo_do_ioctl)
		return -EOPNOTSUPP;

	ret = dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *)&req,
						SIOCPNGAUTOCONF);
	if (ret < 0)
		return ret;

	ASSERT_RTNL();
	ret = phonet_address_add(dev, req.ifr_phonet_autoconf.device);
	if (ret)
		return ret;
	phonet_address_notify(RTM_NEWADDR, dev,
				req.ifr_phonet_autoconf.device);
	return 0;
}

static void phonet_route_autodel(struct net_device *dev)
{
	struct phonet_net *pnn = phonet_pernet(dev_net(dev));
	unsigned int i;
	DECLARE_BITMAP(deleted, 64);

	/* Remove left-over Phonet routes */
	bitmap_zero(deleted, 64);
	mutex_lock(&pnn->routes.lock);
	for (i = 0; i < 64; i++)
		if (rcu_access_pointer(pnn->routes.table[i]) == dev) {
			RCU_INIT_POINTER(pnn->routes.table[i], NULL);
			set_bit(i, deleted);
		}
	mutex_unlock(&pnn->routes.lock);

	if (bitmap_empty(deleted, 64))
		return; /* short-circuit RCU */
	synchronize_rcu();
	for_each_set_bit(i, deleted, 64) {
		rtm_phonet_notify(RTM_DELROUTE, dev, i);
		dev_put(dev);
	}
}

/* notify Phonet of device events */
static int phonet_device_notify(struct notifier_block *me, unsigned long what,
				void *ptr)
{
	struct net_device *dev = netdev_notifier_info_to_dev(ptr);

	switch (what) {
	case NETDEV_REGISTER:
		if (dev->type == ARPHRD_PHONET)
			phonet_device_autoconf(dev);
		break;
	case NETDEV_UNREGISTER:
		phonet_device_destroy(dev);
		phonet_route_autodel(dev);
		break;
	}
	return 0;

}

static struct notifier_block phonet_device_notifier = {
	.notifier_call = phonet_device_notify,
	.priority = 0,
};

/* Per-namespace Phonet devices handling */
static int __net_init phonet_init_net(struct net *net)
{
	struct phonet_net *pnn = phonet_pernet(net);

	if (!proc_create("phonet", 0, net->proc_net, &pn_sock_seq_fops))
		return -ENOMEM;

	INIT_LIST_HEAD(&pnn->pndevs.list);
	mutex_init(&pnn->pndevs.lock);
	mutex_init(&pnn->routes.lock);
	return 0;
}

static void __net_exit phonet_exit_net(struct net *net)
{
	remove_proc_entry("phonet", net->proc_net);
}

static struct pernet_operations phonet_net_ops = {
	.init = phonet_init_net,
	.exit = phonet_exit_net,
	.id   = &phonet_net_id,
	.size = sizeof(struct phonet_net),
};

/* Initialize Phonet devices list */
int __init phonet_device_init(void)
{
	int err = register_pernet_subsys(&phonet_net_ops);
	if (err)
		return err;

	proc_create("pnresource", 0, init_net.proc_net, &pn_res_seq_fops);
	register_netdevice_notifier(&phonet_device_notifier);
	err = phonet_netlink_register();
	if (err)
		phonet_device_exit();
	return err;
}

void phonet_device_exit(void)
{
	rtnl_unregister_all(PF_PHONET);
	unregister_netdevice_notifier(&phonet_device_notifier);
	unregister_pernet_subsys(&phonet_net_ops);
	remove_proc_entry("pnresource", init_net.proc_net);
}

int phonet_route_add(struct net_device *dev, u8 daddr)
{
	struct phonet_net *pnn = phonet_pernet(dev_net(dev));
	struct phonet_routes *routes = &pnn->routes;
	int err = -EEXIST;

	daddr = daddr >> 2;
	mutex_lock(&routes->lock);
	if (routes->table[daddr] == NULL) {
		rcu_assign_pointer(routes->table[daddr], dev);
		dev_hold(dev);
		err = 0;
	}
	mutex_unlock(&routes->lock);
	return err;
}

int phonet_route_del(struct net_device *dev, u8 daddr)
{
	struct phonet_net *pnn = phonet_pernet(dev_net(dev));
	struct phonet_routes *routes = &pnn->routes;

	daddr = daddr >> 2;
	mutex_lock(&routes->lock);
	if (rcu_access_pointer(routes->table[daddr]) == dev)
		RCU_INIT_POINTER(routes->table[daddr], NULL);
	else
		dev = NULL;
	mutex_unlock(&routes->lock);

	if (!dev)
		return -ENOENT;
	synchronize_rcu();
	dev_put(dev);
	return 0;
}

struct net_device *phonet_route_get_rcu(struct net *net, u8 daddr)
{
	struct phonet_net *pnn = phonet_pernet(net);
	struct phonet_routes *routes = &pnn->routes;
	struct net_device *dev;

	daddr >>= 2;
	dev = rcu_dereference(routes->table[daddr]);
	return dev;
}

struct net_device *phonet_route_output(struct net *net, u8 daddr)
{
	struct phonet_net *pnn = phonet_pernet(net);
	struct phonet_routes *routes = &pnn->routes;
	struct net_device *dev;

	daddr >>= 2;
	rcu_read_lock();
	dev = rcu_dereference(routes->table[daddr]);
	if (dev)
		dev_hold(dev);
	rcu_read_unlock();

	if (!dev)
		dev = phonet_device_get(net); /* Default route */
	return dev;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /***********************************************************************/
/**

    AudioScience HPI driver
    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation;

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\file
Functions for reading DSP code using
hotplug firmware loader from individual dsp code files
*/
/***********************************************************************/
#define SOURCEFILE_NAME "hpidspcd.c"
#include "hpidspcd.h"
#include "hpidebug.h"
#include "hpi_version.h"

struct dsp_code_private {
	/**  Firmware descriptor */
	const struct firmware *firmware;
	struct pci_dev *dev;
};

/*-------------------------------------------------------------------*/
short hpi_dsp_code_open(u32 adapter, void *os_data, struct dsp_code *dsp_code,
	u32 *os_error_code)
{
	const struct firmware *firmware;
	struct pci_dev *dev = os_data;
	struct code_header header;
	char fw_name[20];
	short err_ret = HPI_ERROR_DSP_FILE_NOT_FOUND;
	int err;

	sprintf(fw_name, "asihpi/dsp%04x.bin", adapter);

	err = request_firmware(&firmware, fw_name, &dev->dev);

	if (err || !firmware) {
		dev_err(&dev->dev, "%d, request_firmware failed for %s\n",
			err, fw_name);
		goto error1;
	}
	if (firmware->size < sizeof(header)) {
		dev_err(&dev->dev, "Header size too small %s\n", fw_name);
		goto error2;
	}
	memcpy(&header, firmware->data, sizeof(header));

	if ((header.type != 0x45444F43) ||	/* "CODE" */
		(header.adapter != adapter)
		|| (header.size != firmware->size)) {
		dev_err(&dev->dev,
			"Invalid firmware header size %d != file %zd\n",
			header.size, firmware->size);
		goto error2;
	}

	if ((header.version >> 9) != (HPI_VER >> 9)) {
		/* Consider even and subsequent odd minor versions to be compatible */
		dev_err(&dev->dev, "Incompatible firmware version DSP image %X != Driver %X\n",
			header.version, HPI_VER);
		goto error2;
	}

	if (header.version != HPI_VER) {
		dev_info(&dev->dev,
			 "Firmware: release version mismatch  DSP image %X != Driver %X\n",
			 header.version, HPI_VER);
	}

	HPI_DEBUG_LOG(DEBUG, "dsp code %s opened\n", fw_name);
	dsp_code->pvt = kmalloc(sizeof(*dsp_code->pvt), GFP_KERNEL);
	if (!dsp_code->pvt) {
		err_ret = HPI_ERROR_MEMORY_ALLOC;
		goto error2;
	}

	dsp_code->pvt->dev = dev;
	dsp_code->pvt->firmware = firmware;
	dsp_code->header = header;
	dsp_code->block_length = header.size / sizeof(u32);
	dsp_code->word_count = sizeof(header) / sizeof(u32);
	return 0;

error2:
	release_firmware(firmware);
error1:
	dsp_code->block_length = 0;
	return err_ret;
}

/*-------------------------------------------------------------------*/
void hpi_dsp_code_close(struct dsp_code *dsp_code)
{
	HPI_DEBUG_LOG(DEBUG, "dsp code closed\n");
	release_firmware(dsp_code->pvt->firmware);
	kfree(dsp_code->pvt);
}

/*-------------------------------------------------------------------*/
void hpi_dsp_code_rewind(struct dsp_code *dsp_code)
{
	/* Go back to start of  data, after header */
	dsp_code->word_count = sizeof(struct code_header) / sizeof(u32);
}

/*-------------------------------------------------------------------*/
short hpi_dsp_code_read_word(struct dsp_code *dsp_code, u32 *pword)
{
	if (dsp_code->word_count + 1 > dsp_code->block_length)
		return HPI_ERROR_DSP_FILE_FORMAT;

	*pword = ((u32 *)(dsp_code->pvt->firmware->data))[dsp_code->
		word_count];
	dsp_code->word_count++;
	return 0;
}

/*-------------------------------------------------------------------*/
short hpi_dsp_code_read_block(size_t words_requested,
	struct dsp_code *dsp_code, u32 **ppblock)
{
	if (dsp_code->word_count + words_requested > dsp_code->block_length)
		return HPI_ERROR_DSP_FILE_FORMAT;

	*ppblock =
		((u32 *)(dsp_code->pvt->firmware->data)) +
		dsp_code->word_count;
	dsp_code->word_count += words_requested;
	return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * omap-twl4030.c  --  SoC audio for TI SoC based boards with twl4030 codec
 *
 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 *
 * This driver replaces the following machine drivers:
 * omap3beagle (Author: Steve Sakoman <steve@sakoman.com>)
 * omap3evm (Author: Anuj Aggarwal <anuj.aggarwal@ti.com>)
 * overo (Author: Steve Sakoman <steve@sakoman.com>)
 * igep0020 (Author: Enric Balletbo i Serra <eballetbo@iseebcn.com>)
 * zoom2 (Author: Misael Lopez Cruz <misael.lopez@ti.com>)
 * sdp3430 (Author: Misael Lopez Cruz <misael.lopez@ti.com>)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

#include <linux/platform_device.h>
#include <linux/platform_data/omap-twl4030.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/gpio.h>
#include <linux/of_gpio.h>

#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/soc.h>
#include <sound/jack.h>

#include "omap-mcbsp.h"

struct omap_twl4030 {
	int jack_detect;	/* board can detect jack events */
	struct snd_soc_jack hs_jack;
};

static int omap_twl4030_hw_params(struct snd_pcm_substream *substream,
	struct snd_pcm_hw_params *params)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;
	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
	struct snd_soc_card *card = rtd->card;
	unsigned int fmt;
	int ret;

	switch (params_channels(params)) {
	case 2: /* Stereo I2S mode */
		fmt =	SND_SOC_DAIFMT_I2S |
			SND_SOC_DAIFMT_NB_NF |
			SND_SOC_DAIFMT_CBM_CFM;
		break;
	case 4: /* Four channel TDM mode */
		fmt =	SND_SOC_DAIFMT_DSP_A |
			SND_SOC_DAIFMT_IB_NF |
			SND_SOC_DAIFMT_CBM_CFM;
		break;
	default:
		return -EINVAL;
	}

	/* Set codec DAI configuration */
	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
	if (ret < 0) {
		dev_err(card->dev, "can't set codec DAI configuration\n");
		return ret;
	}

	/* Set cpu DAI configuration */
	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
	if (ret < 0) {
		dev_err(card->dev, "can't set cpu DAI configuration\n");
		return ret;
	}

	return 0;
}

static struct snd_soc_ops omap_twl4030_ops = {
	.hw_params = omap_twl4030_hw_params,
};

static const struct snd_soc_dapm_widget dapm_widgets[] = {
	SND_SOC_DAPM_SPK("Earpiece Spk", NULL),
	SND_SOC_DAPM_SPK("Handsfree Spk", NULL),
	SND_SOC_DAPM_HP("Headset Stereophone", NULL),
	SND_SOC_DAPM_SPK("Ext Spk", NULL),
	SND_SOC_DAPM_SPK("Carkit Spk", NULL),

	SND_SOC_DAPM_MIC("Main Mic", NULL),
	SND_SOC_DAPM_MIC("Sub Mic", NULL),
	SND_SOC_DAPM_MIC("Headset Mic", NULL),
	SND_SOC_DAPM_MIC("Carkit Mic", NULL),
	SND_SOC_DAPM_MIC("Digital0 Mic", NULL),
	SND_SOC_DAPM_MIC("Digital1 Mic", NULL),
	SND_SOC_DAPM_LINE("Line In", NULL),
};

static const struct snd_soc_dapm_route audio_map[] = {
	/* Headset Stereophone:  HSOL, HSOR */
	{"Headset Stereophone", NULL, "HSOL"},
	{"Headset Stereophone", NULL, "HSOR"},
	/* External Speakers: HFL, HFR */
	{"Handsfree Spk", NULL, "HFL"},
	{"Handsfree Spk", NULL, "HFR"},
	/* External Speakers: PredrivL, PredrivR */
	{"Ext Spk", NULL, "PREDRIVEL"},
	{"Ext Spk", NULL, "PREDRIVER"},
	/* Carkit speakers:  CARKITL, CARKITR */
	{"Carkit Spk", NULL, "CARKITL"},
	{"Carkit Spk", NULL, "CARKITR"},
	/* Earpiece */
	{"Earpiece Spk", NULL, "EARPIECE"},

	/* External Mics: MAINMIC, SUBMIC with bias */
	{"MAINMIC", NULL, "Main Mic"},
	{"Main Mic", NULL, "Mic Bias 1"},
	{"SUBMIC", NULL, "Sub Mic"},
	{"Sub Mic", NULL, "Mic Bias 2"},
	/* Headset Mic: HSMIC with bias */
	{"HSMIC", NULL, "Headset Mic"},
	{"Headset Mic", NULL, "Headset Mic Bias"},
	/* Digital Mics: DIGIMIC0, DIGIMIC1 with bias */
	{"DIGIMIC0", NULL, "Digital0 Mic"},
	{"Digital0 Mic", NULL, "Mic Bias 1"},
	{"DIGIMIC1", NULL, "Digital1 Mic"},
	{"Digital1 Mic", NULL, "Mic Bias 2"},
	/* Carkit In: CARKITMIC */
	{"CARKITMIC", NULL, "Carkit Mic"},
	/* Aux In: AUXL, AUXR */
	{"AUXL", NULL, "Line In"},
	{"AUXR", NULL, "Line In"},
};

/* Headset jack detection DAPM pins */
static struct snd_soc_jack_pin hs_jack_pins[] = {
	{
		.pin = "Headset Mic",
		.mask = SND_JACK_MICROPHONE,
	},
	{
		.pin = "Headset Stereophone",
		.mask = SND_JACK_HEADPHONE,
	},
};

/* Headset jack detection gpios */
static struct snd_soc_jack_gpio hs_jack_gpios[] = {
	{
		.name = "hsdet-gpio",
		.report = SND_JACK_HEADSET,
		.debounce_time = 200,
	},
};

static inline void twl4030_disconnect_pin(struct snd_soc_dapm_context *dapm,
					  int connected, char *pin)
{
	if (!connected)
		snd_soc_dapm_disable_pin(dapm, pin);
}

static int omap_twl4030_init(struct snd_soc_pcm_runtime *rtd)
{
	struct snd_soc_codec *codec = rtd->codec;
	struct snd_soc_card *card = rtd->card;
	struct snd_soc_dapm_context *dapm = &codec->dapm;
	struct omap_tw4030_pdata *pdata = dev_get_platdata(card->dev);
	struct omap_twl4030 *priv = snd_soc_card_get_drvdata(card);
	int ret = 0;

	/* Headset jack detection only if it is supported */
	if (priv->jack_detect > 0) {
		hs_jack_gpios[0].gpio = priv->jack_detect;

		ret = snd_soc_jack_new(codec, "Headset Jack", SND_JACK_HEADSET,
				       &priv->hs_jack);
		if (ret)
			return ret;

		ret = snd_soc_jack_add_pins(&priv->hs_jack,
					    ARRAY_SIZE(hs_jack_pins),
					    hs_jack_pins);
		if (ret)
			return ret;

		ret = snd_soc_jack_add_gpios(&priv->hs_jack,
					     ARRAY_SIZE(hs_jack_gpios),
					     hs_jack_gpios);
		if (ret)
			return ret;
	}

	/*
	 * NULL pdata means we booted with DT. In this case the routing is
	 * provided and the card is fully routed, no need to mark pins.
	 */
	if (!pdata || !pdata->custom_routing)
		return ret;

	/* Disable not connected paths if not used */
	twl4030_disconnect_pin(dapm, pdata->has_ear, "Earpiece Spk");
	twl4030_disconnect_pin(dapm, pdata->has_hf, "Handsfree Spk");
	twl4030_disconnect_pin(dapm, pdata->has_hs, "Headset Stereophone");
	twl4030_disconnect_pin(dapm, pdata->has_predriv, "Ext Spk");
	twl4030_disconnect_pin(dapm, pdata->has_carkit, "Carkit Spk");

	twl4030_disconnect_pin(dapm, pdata->has_mainmic, "Main Mic");
	twl4030_disconnect_pin(dapm, pdata->has_submic, "Sub Mic");
	twl4030_disconnect_pin(dapm, pdata->has_hsmic, "Headset Mic");
	twl4030_disconnect_pin(dapm, pdata->has_carkitmic, "Carkit Mic");
	twl4030_disconnect_pin(dapm, pdata->has_digimic0, "Digital0 Mic");
	twl4030_disconnect_pin(dapm, pdata->has_digimic1, "Digital1 Mic");
	twl4030_disconnect_pin(dapm, pdata->has_linein, "Line In");

	return ret;
}

static int omap_twl4030_card_remove(struct snd_soc_card *card)
{
	struct omap_twl4030 *priv = snd_soc_card_get_drvdata(card);

	if (priv->jack_detect > 0)
		snd_soc_jack_free_gpios(&priv->hs_jack,
					ARRAY_SIZE(hs_jack_gpios),
					hs_jack_gpios);

	return 0;
}

/* Digital audio interface glue - connects codec <--> CPU */
static struct snd_soc_dai_link omap_twl4030_dai_links[] = {
	{
		.name = "TWL4030 HiFi",
		.stream_name = "TWL4030 HiFi",
		.cpu_dai_name = "omap-mcbsp.2",
		.codec_dai_name = "twl4030-hifi",
		.platform_name = "omap-mcbsp.2",
		.codec_name = "twl4030-codec",
		.init = omap_twl4030_init,
		.ops = &omap_twl4030_ops,
	},
	{
		.name = "TWL4030 Voice",
		.stream_name = "TWL4030 Voice",
		.cpu_dai_name = "omap-mcbsp.3",
		.codec_dai_name = "twl4030-voice",
		.platform_name = "omap-mcbsp.3",
		.codec_name = "twl4030-codec",
		.dai_fmt = SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF |
			   SND_SOC_DAIFMT_CBM_CFM,
	},
};

/* Audio machine driver */
static struct snd_soc_card omap_twl4030_card = {
	.owner = THIS_MODULE,
	.remove = omap_twl4030_card_remove,
	.dai_link = omap_twl4030_dai_links,
	.num_links = ARRAY_SIZE(omap_twl4030_dai_links),

	.dapm_widgets = dapm_widgets,
	.num_dapm_widgets = ARRAY_SIZE(dapm_widgets),
	.dapm_routes = audio_map,
	.num_dapm_routes = ARRAY_SIZE(audio_map),
};

static int omap_twl4030_probe(struct platform_device *pdev)
{
	struct omap_tw4030_pdata *pdata = dev_get_platdata(&pdev->dev);
	struct device_node *node = pdev->dev.of_node;
	struct snd_soc_card *card = &omap_twl4030_card;
	struct omap_twl4030 *priv;
	int ret = 0;

	card->dev = &pdev->dev;

	priv = devm_kzalloc(&pdev->dev, sizeof(struct omap_twl4030), GFP_KERNEL);
	if (priv == NULL)
		return -ENOMEM;

	if (node) {
		struct device_node *dai_node;
		struct property *prop;

		if (snd_soc_of_parse_card_name(card, "ti,model")) {
			dev_err(&pdev->dev, "Card name is not provided\n");
			return -ENODEV;
		}

		dai_node = of_parse_phandle(node, "ti,mcbsp", 0);
		if (!dai_node) {
			dev_err(&pdev->dev, "McBSP node is not provided\n");
			return -EINVAL;
		}
		omap_twl4030_dai_links[0].cpu_dai_name  = NULL;
		omap_twl4030_dai_links[0].cpu_of_node = dai_node;

		omap_twl4030_dai_links[0].platform_name  = NULL;
		omap_twl4030_dai_links[0].platform_of_node = dai_node;

		dai_node = of_parse_phandle(node, "ti,mcbsp-voice", 0);
		if (!dai_node) {
			card->num_links = 1;
		} else {
			omap_twl4030_dai_links[1].cpu_dai_name  = NULL;
			omap_twl4030_dai_links[1].cpu_of_node = dai_node;

			omap_twl4030_dai_links[1].platform_name  = NULL;
			omap_twl4030_dai_links[1].platform_of_node = dai_node;
		}

		priv->jack_detect = of_get_named_gpio(node,
						      "ti,jack-det-gpio", 0);

		/* Optional: audio routing can be provided */
		prop = of_find_property(node, "ti,audio-routing", NULL);
		if (prop) {
			ret = snd_soc_of_parse_audio_routing(card,
							    "ti,audio-routing");
			if (ret)
				return ret;

			card->fully_routed = 1;
		}
	} else if (pdata) {
		if (pdata->card_name) {
			card->name = pdata->card_name;
		} else {
			dev_err(&pdev->dev, "Card name is not provided\n");
			return -ENODEV;
		}

		if (!pdata->voice_connected)
			card->num_links = 1;

		priv->jack_detect = pdata->jack_detect;
	} else {
		dev_err(&pdev->dev, "Missing pdata\n");
		return -ENODEV;
	}

	snd_soc_card_set_drvdata(card, priv);
	ret = devm_snd_soc_register_card(&pdev->dev, card);
	if (ret) {
		dev_err(&pdev->dev, "devm_snd_soc_register_card() failed: %d\n",
			ret);
		return ret;
	}

	return 0;
}

static const struct of_device_id omap_twl4030_of_match[] = {
	{.compatible = "ti,omap-twl4030", },
	{ },
};
MODULE_DEVICE_TABLE(of, omap_twl4030_of_match);

static struct platform_driver omap_twl4030_driver = {
	.driver = {
		.name = "omap-twl4030",
		.owner = THIS_MODULE,
		.pm = &snd_soc_pm_ops,
		.of_match_table = omap_twl4030_of_match,
	},
	.probe = omap_twl4030_probe,
};

module_platform_driver(omap_twl4030_driver);

MODULE_AUTHOR("Peter Ujfalusi <peter.ujfalusi@ti.com>");
MODULE_DESCRIPTION("ALSA SoC for TI SoC based boards with twl4030 codec");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:omap-twl4030");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
/*
 * nilfs2_ondisk.h - NILFS2 on-disk structures
 *
 * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 */
/*
 *  linux/include/linux/ext2_fs.h
 *
 * Copyright (C) 1992, 1993, 1994, 1995
 * Remy Card (card@masi.ibp.fr)
 * Laboratoire MASI - Institut Blaise Pascal
 * Universite Pierre et Marie Curie (Paris VI)
 *
 *  from
 *
 *  linux/include/linux/minix_fs.h
 *
 *  Copyright (C) 1991, 1992  Linus Torvalds
 */

#ifndef _LINUX_NILFS2_ONDISK_H
#define _LINUX_NILFS2_ONDISK_H

#include <linux/types.h>
#include <linux/magic.h>


#define NILFS_INODE_BMAP_SIZE	7

/**
 * struct nilfs_inode - structure of an inode on disk
 * @i_blocks: blocks count
 * @i_size: size in bytes
 * @i_ctime: creation time (seconds)
 * @i_mtime: modification time (seconds)
 * @i_ctime_nsec: creation time (nano seconds)
 * @i_mtime_nsec: modification time (nano seconds)
 * @i_uid: user id
 * @i_gid: group id
 * @i_mode: file mode
 * @i_links_count: links count
 * @i_flags: file flags
 * @i_bmap: block mapping
 * @i_xattr: extended attributes
 * @i_generation: file generation (for NFS)
 * @i_pad: padding
 */
struct nilfs_inode {
	__le64	i_blocks;
	__le64	i_size;
	__le64	i_ctime;
	__le64	i_mtime;
	__le32	i_ctime_nsec;
	__le32	i_mtime_nsec;
	__le32	i_uid;
	__le32	i_gid;
	__le16	i_mode;
	__le16	i_links_count;
	__le32	i_flags;
	__le64	i_bmap[NILFS_INODE_BMAP_SIZE];
#define i_device_code	i_bmap[0]
	__le64	i_xattr;
	__le32	i_generation;
	__le32	i_pad;
};

#define NILFS_MIN_INODE_SIZE		128

/**
 * struct nilfs_super_root - structure of super root
 * @sr_sum: check sum
 * @sr_bytes: byte count of the structure
 * @sr_flags: flags (reserved)
 * @sr_nongc_ctime: write time of the last segment not for cleaner operation
 * @sr_dat: DAT file inode
 * @sr_cpfile: checkpoint file inode
 * @sr_sufile: segment usage file inode
 */
struct nilfs_super_root {
	__le32 sr_sum;
	__le16 sr_bytes;
	__le16 sr_flags;
	__le64 sr_nongc_ctime;
	struct nilfs_inode sr_dat;
	struct nilfs_inode sr_cpfile;
	struct nilfs_inode sr_sufile;
};

#define NILFS_SR_MDT_OFFSET(inode_size, i)  \
	((unsigned long)&((struct nilfs_super_root *)0)->sr_dat + \
			(inode_size) * (i))
#define NILFS_SR_DAT_OFFSET(inode_size)     NILFS_SR_MDT_OFFSET(inode_size, 0)
#define NILFS_SR_CPFILE_OFFSET(inode_size)  NILFS_SR_MDT_OFFSET(inode_size, 1)
#define NILFS_SR_SUFILE_OFFSET(inode_size)  NILFS_SR_MDT_OFFSET(inode_size, 2)
#define NILFS_SR_BYTES(inode_size)	    NILFS_SR_MDT_OFFSET(inode_size, 3)

/*
 * Maximal mount counts
 */
#define NILFS_DFL_MAX_MNT_COUNT		50      /* 50 mounts */

/*
 * File system states (sbp->s_state, nilfs->ns_mount_state)
 */
#define NILFS_VALID_FS			0x0001  /* Unmounted cleanly */
#define NILFS_ERROR_FS			0x0002  /* Errors detected */
#define NILFS_RESIZE_FS			0x0004	/* Resize required */

/*
 * Mount flags (sbi->s_mount_opt)
 */
#define NILFS_MOUNT_ERROR_MODE		0x0070  /* Error mode mask */
#define NILFS_MOUNT_ERRORS_CONT		0x0010  /* Continue on errors */
#define NILFS_MOUNT_ERRORS_RO		0x0020  /* Remount fs ro on errors */
#define NILFS_MOUNT_ERRORS_PANIC	0x0040  /* Panic on errors */
#define NILFS_MOUNT_BARRIER		0x1000  /* Use block barriers */
#define NILFS_MOUNT_STRICT_ORDER	0x2000  /*
						 * Apply strict in-order
						 * semantics also for data
						 */
#define NILFS_MOUNT_NORECOVERY		0x4000  /*
						 * Disable write access during
						 * mount-time recovery
						 */
#define NILFS_MOUNT_DISCARD		0x8000  /* Issue DISCARD requests */


/**
 * struct nilfs_super_block - structure of super block on disk
 */
struct nilfs_super_block {
/*00*/	__le32	s_rev_level;		/* Revision level */
	__le16	s_minor_rev_level;	/* minor revision level */
	__le16	s_magic;		/* Magic signature */

	__le16  s_bytes;		/*
					 * Bytes count of CRC calculation
					 * for this structure. s_reserved
					 * is excluded.
					 */
	__le16  s_flags;		/* flags */
	__le32  s_crc_seed;		/* Seed value of CRC calculation */
/*10*/	__le32	s_sum;			/* Check sum of super block */

	__le32	s_log_block_size;	/*
					 * Block size represented as follows
					 * blocksize =
					 *     1 << (s_log_block_size + 10)
					 */
	__le64  s_nsegments;		/* Number of segments in filesystem */
/*20*/	__le64  s_dev_size;		/* block device size in bytes */
	__le64	s_first_data_block;	/* 1st seg disk block number */
/*30*/	__le32  s_blocks_per_segment;   /* number of blocks per full segment */
	__le32	s_r_segments_percentage; /* Reserved segments percentage */

	__le64  s_last_cno;		/* Last checkpoint number */
/*40*/	__le64  s_last_pseg;		/* disk block addr pseg written last */
	__le64  s_last_seq;             /* seq. number of seg written last */
/*50*/	__le64	s_free_blocks_count;	/* Free blocks count */

	__le64	s_ctime;		/*
					 * Creation time (execution time of
					 * newfs)
					 */
/*60*/	__le64	s_mtime;		/* Mount time */
	__le64	s_wtime;		/* Write time */
/*70*/	__le16	s_mnt_count;		/* Mount count */
	__le16	s_max_mnt_count;	/* Maximal mount count */
	__le16	s_state;		/* File system state */
	__le16	s_errors;		/* Behaviour when detecting errors */
	__le64	s_lastcheck;		/* time of last check */

/*80*/	__le32	s_checkinterval;	/* max. time between checks */
	__le32	s_creator_os;		/* OS */
	__le16	s_def_resuid;		/* Default uid for reserved blocks */
	__le16	s_def_resgid;		/* Default gid for reserved blocks */
	__le32	s_first_ino;		/* First non-reserved inode */

/*90*/	__le16  s_inode_size;		/* Size of an inode */
	__le16  s_dat_entry_size;       /* Size of a dat entry */
	__le16  s_checkpoint_size;      /* Size of a checkpoint */
	__le16	s_segment_usage_size;	/* Size of a segment usage */

/*98*/	__u8	s_uuid[16];		/* 128-bit uuid for volume */
/*A8*/	char	s_volume_name[80];	/* volume name */

/*F8*/	__le32  s_c_interval;           /* Commit interval of segment */
	__le32  s_c_block_max;          /*
					 * Threshold of data amount for
					 * the segment construction
					 */
/*100*/	__le64  s_feature_compat;	/* Compatible feature set */
	__le64  s_feature_compat_ro;	/* Read-only compatible feature set */
	__le64  s_feature_incompat;	/* Incompatible feature set */
	__u32	s_reserved[186];	/* padding to the end of the block */
};

/*
 * Codes for operating systems
 */
#define NILFS_OS_LINUX		0
/* Codes from 1 to 4 are reserved to keep compatibility with ext2 creator-OS */

/*
 * Revision levels
 */
#define NILFS_CURRENT_REV	2	/* current major revision */
#define NILFS_MINOR_REV		0	/* minor revision */
#define NILFS_MIN_SUPP_REV	2	/* minimum supported revision */

/*
 * Feature set definitions
 *
 * If there is a bit set in the incompatible feature set that the kernel
 * doesn't know about, it should refuse to mount the filesystem.
 */
#define NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT	0x00000001ULL

#define NILFS_FEATURE_COMPAT_SUPP	0ULL
#define NILFS_FEATURE_COMPAT_RO_SUPP	NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT
#define NILFS_FEATURE_INCOMPAT_SUPP	0ULL

/*
 * Bytes count of super_block for CRC-calculation
 */
#define NILFS_SB_BYTES  \
	((long)&((struct nilfs_super_block *)0)->s_reserved)

/*
 * Special inode number
 */
#define NILFS_ROOT_INO		2	/* Root file inode */
#define NILFS_DAT_INO		3	/* DAT file */
#define NILFS_CPFILE_INO	4	/* checkpoint file */
#define NILFS_SUFILE_INO	5	/* segment usage file */
#define NILFS_IFILE_INO		6	/* ifile */
#define NILFS_ATIME_INO		7	/* Atime file (reserved) */
#define NILFS_XATTR_INO		8	/* Xattribute file (reserved) */
#define NILFS_SKETCH_INO	10	/* Sketch file */
#define NILFS_USER_INO		11	/* Fisrt user's file inode number */

#define NILFS_SB_OFFSET_BYTES	1024	/* byte offset of nilfs superblock */

#define NILFS_SEG_MIN_BLOCKS	16	/*
					 * Minimum number of blocks in
					 * a full segment
					 */
#define NILFS_PSEG_MIN_BLOCKS	2	/*
					 * Minimum number of blocks in
					 * a partial segment
					 */
#define NILFS_MIN_NRSVSEGS	8	/*
					 * Minimum number of reserved
					 * segments
					 */

/*
 * We call DAT, cpfile, and sufile root metadata files.  Inodes of
 * these files are written in super root block instead of ifile, and
 * garbage collector doesn't keep any past versions of these files.
 */
#define NILFS_ROOT_METADATA_FILE(ino) \
	((ino) >= NILFS_DAT_INO && (ino) <= NILFS_SUFILE_INO)

/*
 * bytes offset of secondary super block
 */
#define NILFS_SB2_OFFSET_BYTES(devsize)	((((devsize) >> 12) - 1) << 12)

/*
 * Maximal count of links to a file
 */
#define NILFS_LINK_MAX		32000

/*
 * Structure of a directory entry
 *  (Same as ext2)
 */

#define NILFS_NAME_LEN 255

/*
 * Block size limitations
 */
#define NILFS_MIN_BLOCK_SIZE		1024
#define NILFS_MAX_BLOCK_SIZE		65536

/*
 * The new version of the directory entry.  Since V0 structures are
 * stored in intel byte order, and the name_len field could never be
 * bigger than 255 chars, it's safe to reclaim the extra byte for the
 * file_type field.
 */
struct nilfs_dir_entry {
	__le64	inode;			/* Inode number */
	__le16	rec_len;		/* Directory entry length */
	__u8	name_len;		/* Name length */
	__u8	file_type;		/* Dir entry type (file, dir, etc) */
	char	name[NILFS_NAME_LEN];	/* File name */
	char    pad;
};

/*
 * NILFS directory file types.  Only the low 3 bits are used.  The
 * other bits are reserved for now.
 */
enum {
	NILFS_FT_UNKNOWN,
	NILFS_FT_REG_FILE,
	NILFS_FT_DIR,
	NILFS_FT_CHRDEV,
	NILFS_FT_BLKDEV,
	NILFS_FT_FIFO,
	NILFS_FT_SOCK,
	NILFS_FT_SYMLINK,
	NILFS_FT_MAX
};

/*
 * NILFS_DIR_PAD defines the directory entries boundaries
 *
 * NOTE: It must be a multiple of 8
 */
#define NILFS_DIR_PAD			8
#define NILFS_DIR_ROUND			(NILFS_DIR_PAD - 1)
#define NILFS_DIR_REC_LEN(name_len)	(((name_len) + 12 + NILFS_DIR_ROUND) & \
					~NILFS_DIR_ROUND)
#define NILFS_MAX_REC_LEN		((1 << 16) - 1)

/**
 * struct nilfs_finfo - file information
 * @fi_ino: inode number
 * @fi_cno: checkpoint number
 * @fi_nblocks: number of blocks (including intermediate blocks)
 * @fi_ndatablk: number of file data blocks
 */
struct nilfs_finfo {
	__le64 fi_ino;
	__le64 fi_cno;
	__le32 fi_nblocks;
	__le32 fi_ndatablk;
};

/**
 * struct nilfs_binfo_v - information on a data block (except DAT)
 * @bi_vblocknr: virtual block number
 * @bi_blkoff: block offset
 */
struct nilfs_binfo_v {
	__le64 bi_vblocknr;
	__le64 bi_blkoff;
};

/**
 * struct nilfs_binfo_dat - information on a DAT node block
 * @bi_blkoff: block offset
 * @bi_level: level
 * @bi_pad: padding
 */
struct nilfs_binfo_dat {
	__le64 bi_blkoff;
	__u8 bi_level;
	__u8 bi_pad[7];
};

/**
 * union nilfs_binfo: block information
 * @bi_v: nilfs_binfo_v structure
 * @bi_dat: nilfs_binfo_dat structure
 */
union nilfs_binfo {
	struct nilfs_binfo_v bi_v;
	struct nilfs_binfo_dat bi_dat;
};

/**
 * struct nilfs_segment_summary - segment summary header
 * @ss_datasum: checksum of data
 * @ss_sumsum: checksum of segment summary
 * @ss_magic: magic number
 * @ss_bytes: size of this structure in bytes
 * @ss_flags: flags
 * @ss_seq: sequence number
 * @ss_create: creation timestamp
 * @ss_next: next segment
 * @ss_nblocks: number of blocks
 * @ss_nfinfo: number of finfo structures
 * @ss_sumbytes: total size of segment summary in bytes
 * @ss_pad: padding
 * @ss_cno: checkpoint number
 */
struct nilfs_segment_summary {
	__le32 ss_datasum;
	__le32 ss_sumsum;
	__le32 ss_magic;
	__le16 ss_bytes;
	__le16 ss_flags;
	__le64 ss_seq;
	__le64 ss_create;
	__le64 ss_next;
	__le32 ss_nblocks;
	__le32 ss_nfinfo;
	__le32 ss_sumbytes;
	__le32 ss_pad;
	__le64 ss_cno;
	/* array of finfo structures */
};

#define NILFS_SEGSUM_MAGIC	0x1eaffa11  /* segment summary magic number */

/*
 * Segment summary flags
 */
#define NILFS_SS_LOGBGN 0x0001  /* begins a logical segment */
#define NILFS_SS_LOGEND 0x0002  /* ends a logical segment */
#define NILFS_SS_SR     0x0004  /* has super root */
#define NILFS_SS_SYNDT  0x0008  /* includes data only updates */
#define NILFS_SS_GC     0x0010  /* segment written for cleaner operation */

/**
 * struct nilfs_btree_node - header of B-tree node block
 * @bn_flags: flags
 * @bn_level: level
 * @bn_nchildren: number of children
 * @bn_pad: padding
 */
struct nilfs_btree_node {
	__u8 bn_flags;
	__u8 bn_level;
	__le16 bn_nchildren;
	__le32 bn_pad;
};

/* flags */
#define NILFS_BTREE_NODE_ROOT   0x01

/* level */
#define NILFS_BTREE_LEVEL_DATA          0
#define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */

/**
 * struct nilfs_direct_node - header of built-in bmap array
 * @dn_flags: flags
 * @dn_pad: padding
 */
struct nilfs_direct_node {
	__u8 dn_flags;
	__u8 pad[7];
};

/**
 * struct nilfs_palloc_group_desc - block group descriptor
 * @pg_nfrees: number of free entries in block group
 */
struct nilfs_palloc_group_desc {
	__le32 pg_nfrees;
};

/**
 * struct nilfs_dat_entry - disk address translation entry
 * @de_blocknr: block number
 * @de_start: start checkpoint number
 * @de_end: end checkpoint number
 * @de_rsv: reserved for future use
 */
struct nilfs_dat_entry {
	__le64 de_blocknr;
	__le64 de_start;
	__le64 de_end;
	__le64 de_rsv;
};

#define NILFS_MIN_DAT_ENTRY_SIZE	32

/**
 * struct nilfs_snapshot_list - snapshot list
 * @ssl_next: next checkpoint number on snapshot list
 * @ssl_prev: previous checkpoint number on snapshot list
 */
struct nilfs_snapshot_list {
	__le64 ssl_next;
	__le64 ssl_prev;
};

/**
 * struct nilfs_checkpoint - checkpoint structure
 * @cp_flags: flags
 * @cp_checkpoints_count: checkpoints count in a block
 * @cp_snapshot_list: snapshot list
 * @cp_cno: checkpoint number
 * @cp_create: creation timestamp
 * @cp_nblk_inc: number of blocks incremented by this checkpoint
 * @cp_inodes_count: inodes count
 * @cp_blocks_count: blocks count
 * @cp_ifile_inode: inode of ifile
 */
struct nilfs_checkpoint {
	__le32 cp_flags;
	__le32 cp_checkpoints_count;
	struct nilfs_snapshot_list cp_snapshot_list;
	__le64 cp_cno;
	__le64 cp_create;
	__le64 cp_nblk_inc;
	__le64 cp_inodes_count;
	__le64 cp_blocks_count;

	/*
	 * Do not change the byte offset of ifile inode.
	 * To keep the compatibility of the disk format,
	 * additional fields should be added behind cp_ifile_inode.
	 */
	struct nilfs_inode cp_ifile_inode;
};

#define NILFS_MIN_CHECKPOINT_SIZE	(64 + NILFS_MIN_INODE_SIZE)

/* checkpoint flags */
enum {
	NILFS_CHECKPOINT_SNAPSHOT,
	NILFS_CHECKPOINT_INVALID,
	NILFS_CHECKPOINT_SKETCH,
	NILFS_CHECKPOINT_MINOR,
};

#define NILFS_CHECKPOINT_FNS(flag, name)				\
static __inline__ void							\
nilfs_checkpoint_set_##name(struct nilfs_checkpoint *cp)		\
{									\
	cp->cp_flags = cpu_to_le32(le32_to_cpu(cp->cp_flags) |		\
				   (1UL << NILFS_CHECKPOINT_##flag));	\
}									\
static __inline__ void							\
nilfs_checkpoint_clear_##name(struct nilfs_checkpoint *cp)		\
{									\
	cp->cp_flags = cpu_to_le32(le32_to_cpu(cp->cp_flags) &		\
				   ~(1UL << NILFS_CHECKPOINT_##flag));	\
}									\
static __inline__ int							\
nilfs_checkpoint_##name(const struct nilfs_checkpoint *cp)		\
{									\
	return !!(le32_to_cpu(cp->cp_flags) &				\
		  (1UL << NILFS_CHECKPOINT_##flag));			\
}

NILFS_CHECKPOINT_FNS(SNAPSHOT, snapshot)
NILFS_CHECKPOINT_FNS(INVALID, invalid)
NILFS_CHECKPOINT_FNS(MINOR, minor)

/**
 * struct nilfs_cpfile_header - checkpoint file header
 * @ch_ncheckpoints: number of checkpoints
 * @ch_nsnapshots: number of snapshots
 * @ch_snapshot_list: snapshot list
 */
struct nilfs_cpfile_header {
	__le64 ch_ncheckpoints;
	__le64 ch_nsnapshots;
	struct nilfs_snapshot_list ch_snapshot_list;
};

#define NILFS_CPFILE_FIRST_CHECKPOINT_OFFSET				\
	((sizeof(struct nilfs_cpfile_header) +				\
	  sizeof(struct nilfs_checkpoint) - 1) /			\
			sizeof(struct nilfs_checkpoint))

/**
 * struct nilfs_segment_usage - segment usage
 * @su_lastmod: last modified timestamp
 * @su_nblocks: number of blocks in segment
 * @su_flags: flags
 */
struct nilfs_segment_usage {
	__le64 su_lastmod;
	__le32 su_nblocks;
	__le32 su_flags;
};

#define NILFS_MIN_SEGMENT_USAGE_SIZE	16

/* segment usage flag */
enum {
	NILFS_SEGMENT_USAGE_ACTIVE,
	NILFS_SEGMENT_USAGE_DIRTY,
	NILFS_SEGMENT_USAGE_ERROR,
};

#define NILFS_SEGMENT_USAGE_FNS(flag, name)				\
static __inline__ void							\
nilfs_segment_usage_set_##name(struct nilfs_segment_usage *su)		\
{									\
	su->su_flags = cpu_to_le32(le32_to_cpu(su->su_flags) |		\
				   (1UL << NILFS_SEGMENT_USAGE_##flag));\
}									\
static __inline__ void							\
nilfs_segment_usage_clear_##name(struct nilfs_segment_usage *su)	\
{									\
	su->su_flags =							\
		cpu_to_le32(le32_to_cpu(su->su_flags) &			\
			    ~(1UL << NILFS_SEGMENT_USAGE_##flag));      \
}									\
static __inline__ int							\
nilfs_segment_usage_##name(const struct nilfs_segment_usage *su)	\
{									\
	return !!(le32_to_cpu(su->su_flags) &				\
		  (1UL << NILFS_SEGMENT_USAGE_##flag));			\
}

NILFS_SEGMENT_USAGE_FNS(ACTIVE, active)
NILFS_SEGMENT_USAGE_FNS(DIRTY, dirty)
NILFS_SEGMENT_USAGE_FNS(ERROR, error)

static __inline__ void
nilfs_segment_usage_set_clean(struct nilfs_segment_usage *su)
{
	su->su_lastmod = cpu_to_le64(0);
	su->su_nblocks = cpu_to_le32(0);
	su->su_flags = cpu_to_le32(0);
}

static __inline__ int
nilfs_segment_usage_clean(const struct nilfs_segment_usage *su)
{
	return !le32_to_cpu(su->su_flags);
}

/**
 * struct nilfs_sufile_header - segment usage file header
 * @sh_ncleansegs: number of clean segments
 * @sh_ndirtysegs: number of dirty segments
 * @sh_last_alloc: last allocated segment number
 */
struct nilfs_sufile_header {
	__le64 sh_ncleansegs;
	__le64 sh_ndirtysegs;
	__le64 sh_last_alloc;
	/* ... */
};

#define NILFS_SUFILE_FIRST_SEGMENT_USAGE_OFFSET				\
	((sizeof(struct nilfs_sufile_header) +				\
	  sizeof(struct nilfs_segment_usage) - 1) /			\
			 sizeof(struct nilfs_segment_usage))

#endif	/* _LINUX_NILFS2_ONDISK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /* Hash tables.
   Copyright (C) 2000-2017 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

#ifndef LIBCPP_SYMTAB_H
#define LIBCPP_SYMTAB_H

#include "obstack.h"

#ifndef GTY
#define GTY(x) /* nothing */
#endif

/* This is what each hash table entry points to.  It may be embedded
   deeply within another object.  */
typedef struct ht_identifier ht_identifier;
typedef struct ht_identifier *ht_identifier_ptr;
struct GTY(()) ht_identifier {
  const unsigned char *str;
  unsigned int len;
  unsigned int hash_value;
};

#define HT_LEN(NODE) ((NODE)->len)
#define HT_STR(NODE) ((NODE)->str)

typedef struct ht cpp_hash_table;
typedef struct ht_identifier *hashnode;

enum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC};

/* An identifier hash table for cpplib and the front ends.  */
struct ht
{
  /* Identifiers are allocated from here.  */
  struct obstack stack;

  hashnode *entries;
  /* Call back, allocate a node.  */
  hashnode (*alloc_node) (cpp_hash_table *);
  /* Call back, allocate something that hangs off a node like a cpp_macro.  
     NULL means use the usual allocator.  */
  void * (*alloc_subobject) (size_t);

  unsigned int nslots;		/* Total slots in the entries array.  */
  unsigned int nelements;	/* Number of live elements.  */

  /* Link to reader, if any.  For the benefit of cpplib.  */
  struct cpp_reader *pfile;

  /* Table usage statistics.  */
  unsigned int searches;
  unsigned int collisions;

  /* Should 'entries' be freed when it is no longer needed?  */
  bool entries_owned;
};

/* Initialize the hashtable with 2 ^ order entries.  */
extern cpp_hash_table *ht_create (unsigned int order);

/* Frees all memory associated with a hash table.  */
extern void ht_destroy (cpp_hash_table *);

extern hashnode ht_lookup (cpp_hash_table *, const unsigned char *,
			   size_t, enum ht_lookup_option);
extern hashnode ht_lookup_with_hash (cpp_hash_table *, const unsigned char *,
                                     size_t, unsigned int,
                                     enum ht_lookup_option);
#define HT_HASHSTEP(r, c) ((r) * 67 + ((c) - 113));
#define HT_HASHFINISH(r, len) ((r) + (len))

/* For all nodes in TABLE, make a callback.  The callback takes
   TABLE->PFILE, the node, and a PTR, and the callback sequence stops
   if the callback returns zero.  */
typedef int (*ht_cb) (struct cpp_reader *, hashnode, const void *);
extern void ht_forall (cpp_hash_table *, ht_cb, const void *);

/* For all nodes in TABLE, call the callback.  If the callback returns
   a nonzero value, the node is removed from the table.  */
extern void ht_purge (cpp_hash_table *, ht_cb, const void *);

/* Restore the hash table.  */
extern void ht_load (cpp_hash_table *ht, hashnode *entries,
		     unsigned int nslots, unsigned int nelements, bool own);

/* Dump allocation statistics to stderr.  */
extern void ht_dump_statistics (cpp_hash_table *);

#endif /* LIBCPP_SYMTAB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    INDX( 	                 (            ]                           X H         h3 oTH9 oTH9+H9                        d m a                   w3SH9SH9Q+H9                        u s e               X H         w3 h23Q+H9                        u s e               X H         w3 h23Q+H9                        u s e               X H         w3 h23Q+H9              ]         u s e                   X H         w3 h23Q+H9                        u s e                   X H         w3 h23Q+H9                        u s e                   3wRH9wRH9qx0H9                        w a n t                     3 h23qx0H9                        w a n t                     3 h23qx0H9                        w a n t                   ] ` J         3 h23qx0H9                        w a n t                         3 h23qx0H9                        w a n t                         3 h23qx0H9                        w a n t                     ` J         3 h23qx0H9                        w a n t                     ` J         3 h23qx0H9                        w a n t                           ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ] cifsfs.c:173:13:cifs_kill_sb	32	static
cifsfs.c:645:12:cifs_set_super	16	static
cifsfs.c:210:13:cifs_fallocate	48	static
cifsfs.c:508:13:cifs_umount_begin	32	static
cifsfs.c:552:12:cifs_remount	32	static
cifsfs.c:181:1:cifs_statfs	48	static
cifsfs.c:297:1:cifs_evict_inode	32	static
cifsfs.c:291:1:cifs_destroy_inode	16	static
cifsfs.c:284:13:cifs_i_callback	16	static
cifsfs.c:250:1:cifs_alloc_inode	32	static
cifsfs.c:653:1:cifs_do_mount	112	static
cifsfs.c:829:1:cifs_setlease	16	static
cifsfs.c:766:16:cifs_file_write_iter	64	static
cifsfs.c:754:1:cifs_loose_read_iter	32	static
cifsfs.c:792:15:cifs_llseek	64	static
cifsfs.c:1164:1:cifs_destroy_request_bufs	32	static
cifsfs.c:1192:1:cifs_destroy_mids	32	static
cifsfs.c:1049:1:cifs_init_once	32	static
cifsfs.c:1199:1:init_cifs	64	static
cifsfs.c:559:12:cifs_drop_inode	0	static
cifsfs.c:391:1:cifs_show_options	64	static
cifsfs.c:223:12:cifs_permission	16	static
cifsfs.c:1305:1:exit_cifs	32	static
cifsfs.c:97:1:cifs_sb_active	0	static
cifsfs.c:106:1:cifs_sb_deactive	16	static
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cmdq_sec.c:1150:9:cmdqSecServiceCall.part.2	16	static
cmdq_sec.c:66:6:cmdq_sec_lock_secure_path	16	static
cmdq_sec.c:76:6:cmdq_sec_unlock_secure_path	16	static
cmdq_sec.c:85:9:cmdq_sec_create_shared_memory	48	static
cmdq_sec.c:106:9:cmdq_sec_destroy_shared_memory	32	static
cmdq_sec.c:131:21:cmdq_session_handle	48	static
cmdq_sec.c:152:21:cmdq_mem_session_handle	48	static
cmdq_sec.c:383:6:dump_message	16	static
cmdq_sec.c:523:18:cmdq_sec_get_iwc_msg_fill_cb_by_iwc_command	0	static
cmdq_sec.c:889:22:cmdq_sec_find_context_handle_unlocked	32	static
cmdq_sec.c:916:9:cmdq_sec_release_context_handle_unlocked	16	static
cmdq_sec.c:940:9:cmdq_sec_release_context_handle	48	static
cmdq_sec.c:967:22:cmdq_sec_context_handle_create	32	static
cmdq_sec.c:989:22:cmdq_sec_acquire_context_handle	48	static
cmdq_sec.c:1024:6:cmdq_sec_dump_context_list	48	static
cmdq_sec.c:1045:6:cmdqSecDeInitialize	48	static
cmdq_sec.c:1104:9:cmdqSecRegisterSecureBuffer	48	static
cmdq_sec.c:1150:9:cmdqSecServiceCall	96	static
cmdq_sec.c:1182:9:cmdqSecUnRegisterSecureBuffer	32	static
cmdq_sec.c:1201:6:cmdq_sec_register_secure_irq	48	static
cmdq_sec.c:1233:6:cmdqSecInitialize	0	static
cmdq_sec.c:1281:6:cmdqSecEnableProfile	16	static
cmdq_sec.c:1289:6:cmdq_sec_set_commandId	0	static
cmdq_sec.c:1294:16:cmdq_sec_get_commandId	0	static
cmdq_sec.c:1299:6:cmdq_debug_set_sw_copy	0	static
cmdq_sec.c:1304:9:cmdq_debug_get_sw_copy	0	static
cmdq_sec.c:1309:6:cmdq_sec_set_sec_print_count	32	static
cmdq_sec.c:1316:10:cmdq_sec_get_sec_print_count	0	static
cmdq_sec.c:1321:9:cmdq_sec_get_log_level	32	static
cmdq_sec.c:227:16:cmdq_sec_fill_iwc_command_basic_unlocked	32	static
cmdq_sec.c:277:16:cmdq_sec_fill_iwc_command_msg_unlocked	96	static
cmdq_sec.c:249:16:cmdq_sec_fill_iwc_cancel_msg_unlocked	48	static
cmdq_sec.c:548:9:cmdq_sec_send_context_session_message	160	static
cmdq_sec.c:674:9:cmdq_sec_submit_to_secure_world_async_unlocked	160	static
cmdq_sec.c:784:9:cmdq_sec_exec_task_async_unlocked	32	static
cmdq_sec.c:806:9:cmdq_sec_cancel_error_task_unlocked	48	static
cmdq_sec.c:836:9:cmdq_sec_allocate_path_resource_unlocked	48	static
cmdq_sec.c:866:9:cmdq_sec_init_share_memory	32	static
cmdq_sec.c:1260:5:cmdq_sec_init_secure_path	32	static
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   bcmsdh.c:57:6:bcmsdh_enable_hw_oob_intr	16	static
bcmsdh.c:75:16:bcmsdh_attach	48	static
bcmsdh.c:98:5:bcmsdh_detach	16	static
bcmsdh.c:112:1:bcmsdh_iovar_op	16	static
bcmsdh.c:119:6:bcmsdh_intr_query	48	static
bcmsdh.c:133:5:bcmsdh_intr_enable	32	static
bcmsdh.c:143:5:bcmsdh_intr_disable	32	static
bcmsdh.c:153:5:bcmsdh_intr_reg	48	static
bcmsdh.c:163:5:bcmsdh_intr_dereg	32	static
bcmsdh.c:174:6:bcmsdh_intr_pending	32	static
bcmsdh.c:183:5:bcmsdh_devremove_reg	16	static
bcmsdh.c:199:7:bcmsdh_cfg_read	80	static
bcmsdh.c:235:1:bcmsdh_cfg_write	80	static
bcmsdh.c:267:8:bcmsdh_cfg_read_word	64	static
bcmsdh.c:292:1:bcmsdh_cfg_write_word	64	static
bcmsdh.c:314:5:bcmsdh_cis_read	112	static
bcmsdh.c:357:5:bcmsdhsdio_set_sbaddr_window	64	static
bcmsdh.c:388:8:bcmsdh_reg_read	64	static
bcmsdh.c:436:8:bcmsdh_reg_write	64	static
bcmsdh.c:470:6:bcmsdh_regfail	0	static
bcmsdh.c:476:1:bcmsdh_recv_buf	96	static
bcmsdh.c:516:1:bcmsdh_send_buf	96	static
bcmsdh.c:555:5:bcmsdh_rwdata	80	static
bcmsdh.c:575:5:bcmsdh_abort	16	static
bcmsdh.c:582:5:bcmsdh_start	16	static
bcmsdh.c:589:5:bcmsdh_stop	16	static
bcmsdh.c:596:5:bcmsdh_waitlockfree	16	static
bcmsdh.c:603:5:bcmsdh_query_device	0	static
bcmsdh.c:610:6:bcmsdh_query_iofnum	16	static
bcmsdh.c:620:5:bcmsdh_reset	16	static
bcmsdh.c:627:7:bcmsdh_get_sdioh	32	static
bcmsdh.c:634:8:bcmsdh_get_dstatus	0	static
bcmsdh.c:639:8:bcmsdh_cur_sbwad	0	static
bcmsdh.c:649:6:bcmsdh_chipinfo	0	static
bcmsdh.c:654:5:bcmsdh_sleep	0	static
bcmsdh.c:666:5:bcmsdh_gpio_init	16	static
bcmsdh.c:674:6:bcmsdh_gpioin	16	static
bcmsdh.c:682:5:bcmsdh_gpioouten	16	static
bcmsdh.c:690:5:bcmsdh_gpioout	16	static
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ELF                              B         @     @   { S[cksBu   @  6* R R R q T        *, 1 T@@    * 5            r @ @  @` 7    *36    qs*SA[BcCkDsE{_ R?9  q RklT        rw@@  0AB      9K { S [ck+  @6`B * R R qM T  r@  0A   q       A9qa T q, T@y*A9 R    **+@SA[BcCkD{_86q  T`@ q	 T qT   r@  0BC    R`"B   ` 4 R9K`@ q  T R~  Rb@aF@999`B@9b"@yy99
      *5a"B A){ `@b  5!@  5 R R   a@6 R R    * 6 R R    { S [ B@  R`B@ `@ 6`@   `  4 R **SA[B{_c@6   44R-                           X              8           J       J           h           z   int z                                   s8 	8   u8 	J   u16 	h   s32 	z   u32 	   s64 	   u64 	               ,  	   
>  ,      7  N  z        
Y      Y      
      
z       
0       
1       
Ge      
HN  z     	       
W       
XN      
YN      
Zz       
[z   
7                   h       p            6          {             -      6      ;      E                                                      z                 Y              1      1       1   
      P      u        u      u       {   
P  
u                      
       
      (        
  z   
                               7  )                                +  >  k   `      
k      k      +      z   z          _      z       z       z       Z      (                   *      ^       ^  (    x  0    x  8      @      H      P      X      `    0  h    J  p    0  x    n                              (      	            2      [                           6Z      ;      <       =*       k  Y    z          
      z       z       z       z       z       z       z       +         N                                  k      k      3      j  (         val                                 
           !        ">      $i      &        	>      
       Y   
      Ei      FW       G    
D   )      *       +z       ,z       -      .       #  fd $z        %V       &V    
  (	            '      /o       02	  fn G	       Y  A	  A	   
	  
2	      (      h.	      /       0M	      1      2      3	       4z   Pcpu 5z   T    6  X    7z   ` !    W      X`       Y      Z      [       \       _+       `z   (    a  0    b  8    c  @    ez   H    gz   L    iz   P    iz   T    iz   X    j   \    kI  `"se lG  h#rt mG  ($    oI  p%dl qH  x$    |   $    }z   $    ~n   $    z   ($    _I  ,$      0$    I  @$    @  H$      h$    8/  x&      #mm ,  $    ,  '       $       $    I  $    '  $    z    $    z   $    z   $    z   $       $       '       '       '       '       $       #pid   ($      ,$      0$      8$      @$      P$      `$      h$      x$    I  $      $      $    9  $    8  $    8   $    i/  $    i/  $    i/  $    i/   $    i/  ($       0$    <  8$      H$      P$       X$       `$      h$      p$      x$      $      $    <  $      $     I  $    I  $    I  $    	z   $    	z   $       #fs I  	$    I  	$    9  	$    I  	$    I  	$    0  	$    0  	$     0  	$    !@3  	$    #  
$    $^  
$    %J  
$    &   
$    'J  (
$    (  0
$    *J  8
$    ,/  @
$    -   D
$    /(6  H
$    2   X
$    3   \
&    6  `
&    9  d
$    =  h
$    >  p
$    @*J  x
$    `  
$    c5J  
$    g@J  
$    kKJ  
$    mVJ  
$    oaJ  
$    q  
$    rgJ  
$    s8  
$    rJ  
$      
$    }J  
$    J  
$      
$    J  
$    J   &      $      8$      H#rcu   P$    J  `$    $  h$    z   x$    z   |$    z   $      $      $      $      $       
	  (    
  )    M      4       4       7  *    J0      K0   +    L    +    M    @  @  	       ,i                  -    !G  %      &         'u      z       z   .               i    -       /A  0    B       @  1    -    L  '                2"b      #0   +    $    +    %    3 |      !  42   *        b   5cpu )    6pmu       *    2      4z        6z       7z       9      :       	   
  (        h=  x19 >   x20 ?  x21 @  x22 A  x23 B   x24 C  (x25 D  0x26 E  8x27 F  @x28 G  Hfp H  Psp I  Xpc J  ` *    M      N       O  h    P|  p+    Q  +    R  +    S              !.5      !/         !3  7!f      !   8    !   9    !@            z        z        "	s      #'      #(       #)   -    #+  $b      $b        	        $b      $c    !  	       $      %       %       %?-      %O8      %S-  
j      8&,      &.    "   #   $   1Q$  0     'Lz       h'\      ']       '^  `     	        @'j  x 'k    7    :        ')      '       '       p'N      'N       '  P   ^  	       '       @'      'z        'z       'z       '       	       h'  ;pcp 'i       '   @    '  A      	           ''                    !    @'G      'K       'U      '_   0    'a  8    'b  @    'h  H    '{  P    '  X    '  `    '  h    ',  p    'z   x    '      '      '      '  8    '  @8    '      '  $    '  @&    '  @&    '  $    ')  $    '  $    '   $    '  $    '  $    '    $    '   $$    'z   ($    '+  ,&    '  @@$    '  @     	   Y    	   !    @@'  8    '  @ $    '  $    'z   $    '  $    '  $    '  $    'z   &    '  &    '  $    '   $    'z   ($    '  , 
  
  
      	  
     	        '+      '+       'z    
'      H'Y      '^       'd   (    
Y    t  	       'd  <'  @  	   1    	        (      (        ()2      )4       )5      )6      )8  osq );        (*P      *Y       *      *  osq *       *%        +i      +    P      +P      +z       +O  
i        +P      +Q      +R  =    +  P    	        	          +      	  @	          +
       ,F      ,        ,       -1z       .R      .S      .`z   >                 z       x      {  8            @      P      X    z   `    +  d      h      x                        z                               z   8       
r      /td  N    ?       /      /      0#      0$       0%      0&   
      0*,      0+    
2  !    &^!      &_'       &`      &a       &c(      &g       &h  (    &i  0    &j  8;pgd &k(  @    &l  H    &m  L    &n  P    &oz   X8    &q  \8    &r  `    &t      &z      &{      &}      &~      &      &      &      &      &      &      &      &      &  $    &   #brk &  $    &  $    &  $    &   $    &  ($    &  0$    &(  8$    &3(  $    &(  $    &  &    &!  $    &  $    &(  &    &  $    &(  $    &%  $    &+  $    &!   @     1,2!  id 2        2      2   -    2!  &0*"      &1#      &8   >    #      x       ~  8                         (8      8      `      h      p      x          VJ  8                   
*"  &=<#      &>      &?      &@+   &nr#  A    &o    A    &p    A    &q      &[#      &l  4<#      &sz    &Y#   r#       &u   &K#      &V   4#      &w    &<#   #    #   &$      &d       &z       &z    &|F$  Blru &}  4#      &K$      &   (    
F$  /&$      &  Cptl &      &$      &d   (    
$      &$      &d       &       &    !     %  ;f_u        |      x       }o  (8    "  0    #  8    $   @    %  D8    &  H    'S  p    (  x    )I      *V      ,       .      1      5      6      8#   
$  7 &%  "rb &       &   D &(&  E    &%  F    &  F    & ,       &'      &       &      &'      &'  8    &       &	  8    &,  @    &Y  H    &  P8    &!%  X    &)  x    &+'      &.'      &1      &3%      &4   
(&  (    

'      @3 '      3T       3T      3U      3$U      3U       3MU  (    3bU  0    3/U  8 '  
'      &>'      &?       &@'   
'  >    8&C'      &D       &E'  8    &F       &S#(      &Tz        &U#(   z   3(  	       &YN(      &ZN(      ^(  	     (  %           
^(  
N    (  	  ) (    
(  
'  (    
(  
d      4   (    
(         51(  
(      6      6      7L       7M      7  G    8%:)      8&        8)")      9z       9+      9z       8:)      :       :      :)      :)       :  (    :z   0 (    
)  )     
)      :$)      ;)  
)  )  )   
*       ;d5*      ;e       ;f      ;g)   (    
5*      ;e:*      ;f:*      ;g:*      ;h:*      ;i:*      ;j:*      ;k:*      2*  
*  z   *  *       
*      5*      6*       7*      8z        0@+      A       B*  (     E5+      F*        +      *      '      'Rz       '      '      '      '@+      'M       'P+   
  +  +  ?   
+      'r+      <A+      <B+    
+  
+  ,         =   #,            >3.,  
,      >=M,      >>        >@4,      @=?,      =@        =A       =B       =C       =D        =E   (    =F   0    =G   8     =J,  
X,  @=S?-      =T,       =Uz       =V       =W       =X       =Y  (    =Z  0    =[  8 *    K=Rs-  rec =\s-   +    =^    K+    =_   K ,  -  ?  +     =a?-      =b      =c       =     -  	       ?-      @8      @9-  
  H       @N.                    2  !.  	   .      @U!.      @W-       A.      A	z        A
z       Az       A       An      An   <.  .  	       A.      B  $  .  	       C.      C.      Dz       D/  cap D/       /  	       D.  /      D+/      D,/      (EUi/      EVz        EW      EX       F      G"z       G#z       GQz       GRz   (        H/  H/  val H=        H/  H/  val HH        H/      X0                                                     (      0    P  8;uid /  H      P 
/  IW0  sig IX        IY0      JC      J0  
0      J      J0  
0  G    K1      Kz       K	       K
0  K9G1      K:p       K;{   K?1      K@       KAz       KB1      KC1      KDz    7  1  :   KH1      KIp       KJ{      KK1    KO2      KPp       KQ{      KRz       KS      KT   KX.2      KY       K]V    KaO2      KbY   _fd Kcz    Kg|2      Kh       Kiz       Kj    pK52      K62      K<&1      KEG1  B_rt KL1      KU1      K^2      Kd.2      KkO2   z   2  	       K0*3      K1z        K2z       K3z       Kl|2       Km2      Lz       Le3      L       L0       Lz        L3      L0       L      L0      L0        L3  ;sa Lp3        L,$  H       M4                             M424  nr M6z    ns M7(5      M8P   *    N(5      NV       NV  5rcu N  +    Nz   +    N   +    N   +    N$  (+    N   0+    N (5  8+    N" W  @+    N#W  H+    N$W  P+    N);  X+    N**  `+    N+/  +    N,z   +    N-z   +    N.    
24  Ipid PM;w5      M=       M>       M@w5  rcu MA       MB5  0 7  5  	   4  5  	        ME.5      MG5      MIP   pid MJ5   
.5      Me24      (O6      O       O       O      O6    
       Oz       PM6      Pz        PR6   (    
M6      Qz       R*6      R+e       R,e        S6      S	       S
:)       S6      S       S6   
6  H       T,6                @TlC7      Tm6       Tn:)       ToX7  (    Tp7  0    Tq  8 6  R7  R7   
6  
C7      @T7      Tq8       Tz       T       T6      T:)       T|8  (    T:)  0    T:)  8 
^7  J    @Tq8      T   cpu T       T       T       T:)      Tz       Tz       T       T  (    T  0    T:)  8    T8  @ 
7  :)  
w8  ^7  8  	   (        TI8  @     U
z   
^    8  	       V%8  z   8  8  z     8  t9   
8      @Vit9      Vk,       Vl      Vmz       Vn
      Vo8      Vp9       Vq9  (    Vr  0    Vs  8 
S       VW9      VX       VY   
8  
z9  
  
9      0W:      W       W{V      W V      W!V      W"(5       W#V  (     X W:      X!       X"z       X#z       X$W:      X%g:   /  g:  	   v:  v:  :   
/      XB:      Xg;      Xh   uid Xp/  gid Xq/      Xr/      Xs/      Xt/      Xu/      Xv/      Xw/       Xx   $    Xy/  (    Xz/  0    X{/  8    X|/  @    X}/  H    X  P    X0  X    X;  `    X;  hrcu X  p :  
/  
:    ;       ;            z         7  ;  	        ;      '            y      y  !    (_<             _<  &      &       3  o<  	  ?     <      i/       i/                     <      i/       i/       =      i/       i/          >     +E=      ,<       -z   8    .   !    ;@      <       =      >z       ?  8    A       D  8    G@3  @    Jz   X    Pz   \    Q  `    Tz   h    U   lK    `   pK    a   p    dz   t    e  x8    h6      i5      j:)  ;it q@  &    w=  $    z<  ($    |  @$    ~5  p$    z   x#tty @  &    f  $    i/  $    i/  $    i/  $    i/  $    i/  $    i/  $    <  $      $      $      $      $      $      $       $      $      $      $       $      ($      0$      8$    8  @$       @$    @  H$       H$       L$    @  P&      X$      $    V   $    V   &       o<  @  	   (    
@  c6  @  	   (    
@      /       $
A      &       '       *       +        z   L8A  F      Mrcu    N    (C      C       C      C                      (       ,       0       4       8       <       @       D       H    z   L    z   P    z   T      X       `       d       h      p    C  x    C      C      C      C      C      C      C                                                                        $        $       $      OA  $        $    C  ( 
8A  (    
C     C  	     C  :   =    C  
C    C  z    =          ,D  ;sd ,D   ;sg  2D  ;sgc !=D   
C  
C  (    
CD  
8D      8$D      %C       &C      'z       (z       )C      +  0     /D  
ID      hD      i       j        `mE      n        o       x      x      x          (       ,       0      8       @       D       H       P       X     G                                              (       0       8       @       H       P       X       `       h       p       x                                                                              !    G      D   8            (       8       @       H       P       X       `    E  h$    z   @$    G  H$    G  P$    G  X#avg D  ` 
G  (    
G      HpH                                 pH  (    pH  0    {H  8    {H  @ 
G  (    
vH  >    ;I  8                             (       0       8       @       H    z   L    z   P    z   T    z   X8    "6  ` P&_I      '+       (+   Q    %I  Mb );I  Ms *V    (    I  
I  (    
I  (    
I  '  I  	   5  I  	   
;  7  I  	   (    
I  (    
I  
E=  
<  z   J     
I  
0  (    
J  (    
%J  (    
0J  (    
;J  (    
FJ  (    
QJ  (    
\J  
*3  (    
mJ  (    
xJ  (    
J  (    
J  J  J  	   
J  (    (    
J      5      X	  R     @Z	J  F    [	X	  F    \	J     K  ?       i	J      j		      l	2      %I      8YK      Y   end Y      Y,      Y      YK       YK  (    YK  0 
?K      Y?K      Y?K   Z#K      Z%8      Z&   *    0Z!L      Zz        Z z   ary Z!!L  +    Z"z   OK   1L  1L  	   
K  Sidr (Z*L      Z+1L   top Z,1L      Z-z   cur Z.z       Z/      Z0z       Z11L        ZL      ZY       ZL     L  	   Sida 0ZL  Tidr Z7L       ZL  ( 
L      [J-M      [K       [M      [SM       p[M  kn [FN       [       [L      [P  @    [  H    [  X 
-M      [VM      [WFN        x[jFN      [k       [l      [vFN      [w,  Trb [y  ns [{6O  0    [|   8 O  @    [  `    [h   h    [
  jino [   l    [BO  p 
M       [ZN  ops [[N       [\O      []S      [^FN       @[N      [UQ       [oQ      [Q      [Q      [Q       [^  (    [Q  0    [Q  8 N  
N  (    
O   [}6O  Bdir [~L      [M      [LN   
<O  U(    
=O      ([O      [O       [hP      [P      [P      [P    z   O  M  8     
O  z   O  O  M   
O      \hP  buf \       \^      \^      \^      \^       \S  (    \S  0    \   8    \  @op \]  h    \z   p    \!  x 
O  z   P  FN  ,  
   
nP  z   P  FN   
P  z   P  FN  FN  ,   
P  
HO      p[AQ  kn [FN       [%      [      [      [z   @    [  H    [^  X    [+  `    ['  h z   UQ  O     
AQ    oQ  O  t9   
[Q    Q  O    t9   
uQ  Q  O     
Q  i  Q  Q    ^  S   
P  
Q  z   Q  Q  '   
Q  H       ]R                    0](gR      ])Q       ]*qR      ]+|R      ],R      ]-R       ].+  ( R  +  
lR    
wR  6O  R  R   
R  (    
R  6O  
R      ^
z       ^z        _ S      _       _      _  nid _z        @_0aS      _1S       _3S      _6z       _7Y      _8       _;  (    _=S  8   uS  uS  {S   
 S  
R  
aS  
      `S      `	qR       `
       3.      38      39      3:z       3=z       3C       3D       3Ez       3H       3I       3Jz       3U      3V      3Xz       3Yz       3Z      3r$  Y  }T  	       3mT      03T      3        3      3      3d      3   pte 3T  ( 
C  T  '   
T  z   U  '  U   
T  
T  $U  '  U   
U  z   MU  '      z   z    
*U  ,  bU  '   
SU  z   U  '         
hU  U  d       az   *    aU      aU      U  	  5     aU      ao  2  U   U      a U      3z       3      3      3z       3z       3z       3z       3      3S      3S  (    
vV  (    
V  (    
V  6net 
V      W%9      bV      b        NV      N       N   V  V  	   (    
V      cmW      co        cp5      cqt      crW      csu       ctx  0    cvo  8    cyiu  X    czVy  `    c{{  h    c|  p    c}  x    c      c      c  d_u cFv   W  
W      %       hdX  ino d    dev d      d
      d   uid d/  gid d/      d      dS       d  (    d  8    d   H    d!  X    d"   `     eX      e,       e
        e<X      e=,       e>Y      e@Y      eA,Z   X  
  Y  Y  Y  z    
Y      @f?Y      f@,       fA      fBY      fCL[       fD[  (sd fEFN  0    fFV  8A    fJ   <A    fK   <A    fL   <A    fM   <A    fN   < 
X  
X  
Y      8e,Z      eX       e^      e      e`Z       e`Z  (    eZ  0 
2Z  
Y  i  `Z  %  Y  2Z    S  ^   
8Z  z   Z  %  Y  2Z  '   
fZ      eZ      eZ       eZ   Z  i  Z  Y  Y     
Z  i  Z  Y  Y  ,  ^   
Z      f%      f)       `fL[      f       f      fY      f]  X 
[      (fs[      ft[       fu[      fvY      fw[      fx[    
R[  [  Y   
[  
Z  [  [  Y   
gR  
[  6O  [  Y   
[  *     	f{5\      f|5\       f}E\  +    f~z   5buf fU\  +    fz   	   E\  	     U\  	   7  f\  ?       f\      f\       f\      f\   f\  z   \  L[  Y   
\  \  ,  \  L[  Y   
\  \  z   \  L[  Y  \   
[  
\  \      fZ  
\      fY      fY      fY      fY      fY       g'}]      g(       g)      g*V        \$]      \%oQ       \&Q      \'Q      \(UQ   }]  
]       h ^  p h^       h^      h ^      h!^   (    
 ^  (    
^      i"      i#      i9k      i>P^      i?z         i@7^      i'_      i(a       i)a      i*a      i+a      i,a       i-a  (    i.a  0    i/a  8    i0a  @    i1a  H    i2a  P    i3a  X    i4a  `    i5a  h    i6a  p    i7a  x    i8a      i9a      i:a      i;a      i<a      i=a      i>a   [^  z   _  _   
_  !    ja      j_   ;p j1l      jY      j,  P    ji  X8    j  `;bus jf      j.h      j      j  8    jlb  $    j7l  $    j=l  $    jCl  $    j   $    j  $    j Il  $    j  $    jTl  $    jf  $    j_l  $    j#l   $    j   #id j   $&    j  ($    j  0$    jL]  @$    jk  `$    jh  h$    ja  p$    jjl  x'    j+  '    j+   
_  a  _   
a         ia                           ia                            i"b      i   ;dev i _   >     i#fb  8    i$       i%       i'      i*fb   
a  !     i.e      i/P^   K    i0   K    i1   K    i2+  K    i3+  K    i4+  K    i5+  K    i6+  K    i7+   K    i8+  8    i9      i;  8    i<       i=e  @K    i>+  HK    i?+  H    iDf)  P    iE      iF*  8    iG      iH      iI  K    iJ   K    iK   K    iL   K    iM   K    iN   K    iO   K    iP   K    iQ   K    iR   K    iS   K    iT       iUa      iVa      iWz       iXz       iY      iZ      i[  $    i\   $    i^e  $    i_e  #qos i`	f       k.e      k/,       k0      k1      k2f)       k3  X    k4:)  `    k5:)  h    k6:)  p    k7:)  x    k8:)      k9      k:      k;      k<      k=  A    k>+  A    k?+   
e  
"b  e  _      
e  (    
f      il7f  ;ops im[^       inGf   Gf  _  +   
7f       l
f      l       lz       lz       lz       lz       l       l'Mf      mf      mf    (    
f  
f      jhg      ji,       jj,      jk_      jlh      jmh       jnh  (    joh  0    jqh  8    jri  @    jsa  H    jta  P    jua  X    jwa  `    jxa  h    jz&i  p    j{a  xpm j},i      j<i  p jGi      j        jh      jX       jk      jk   
g  
h  
X  z   .h  _  .h   
4h      xjh      j,   bus jf      j(      j,      j+       ji  (    ji  0    ja  8    ja  @    ja  H    j&i  P    ja  X    jh  `pm j,i  hp ji  p 
h  z   i  _  \   
h  z   &i  _  P^   
i  
_  (    2i  
7i  (    
Bi      0ji      j,       jh      ji      jk      ja   ;pm j,i  ( Mi  
i  (    i  
i  (    i  
i  (    
i      xj`j      ja,       jb(      jdj      jeh      jfY       jhi  (    jik  0    jkk  8    jla  @    jn&i  H    joa  P    jq[  X    jr-k  `;pm jt,i  h;p jvGi  p      jj      jX       jdk      jk   
j    j  _  j   

  
j  k  k   
i  
k  6O  -k  _   
k      j~Y      jY  i  dk  k  j     
Kk  i  k  k  j  ,  ^   
jk    k  _  j  k  v:   
/  
k  i  k  _  h     
k  i  k  _  h  ,  ^   
k      j#l      j        j   .     j(    
,l  
f  
]  
   
k  (    
Ol  (    
Zl  (    
el      ja      ja  J    @n^\n      n_z    id nbI      ncI      ndbn  $    nern  D    nfrn      ngn  +    ni(  h+    nk  p+    nln  x+    nn  +    np   V    nq  +    nr'  +    nsz   +    ntz   +    nu  +    nv  V    nw  +    nzVo  +    n{Vo   +    n|ao  (+    n~  0+    nlo  @V    n  H+    nz   L+    n9  P5dev n_  XV    n_  `+    n+  +    n   V    n  V    n  +    nwo  0+    nz   8 
l  7  rn  	   7  n  	  O 7  n  	   n  \n   
n      oIVo      oJ,       oK
      oLY      oMh   c oQ^       oRVo  0    oS\n  8    oT(  @    oU  H    oV  Pp oWao  X    oX  `    oY      oZ   
n  (    
\o  (    
go  (    
ro  
Z      nz       nz       nk  \n  o  	       no  z   o  \n  z        no  
o      p
   J   p  	   
      qJ       q7p      qJ        qJ        q\p      qp       qp       qp      qJ        qJ       qJ       qJ       q        qp      qJ        qJ       qJ       qJ       q       qz        qq  d qq    J   !q  	       q8q  d qC        q]q  len q    ptr q       qq      qz        qz        qq      q        q        q   G    qq      qq      qq       qq      q        q    qGr      qz       qq      q   F    q q  Md32 qGr  Md8 qWr      Wr  	   J   gr  	       qr      qJ    pad qr      qq   J   r  	       qr      qp       q	h       q
Ts       qTs      qp       qJ   ;tag q7      qJ       qq      qp      qp      q'Zs   
r  Lqs  F    q\p  F    qp  F    qp  F    q!q  Mext q 8q  F    q!gr  F    q"q  F    q#p  F    q$7p  F    q%]q  F    q&r        r=t      r z        r!z       r"z       r%p      r&      r+z        sz       t4+  ,@@uut      u        uut      t  	   -    uSt  @<t  @t       vt      w  2  t  	  	 t      wt      w      x!t      x"u        x%u      x&u       x&$u   
t  
u  ,yMu      y       yz    /yiu  0    y   W*u       y~u  1Mu    c/u      c0    len c0    c.u  4~u      c2        c-u   u       c4u   u  
Q       0c<+v      c=Y       c>Y      c?Y      c@Y      cA+v    Y  ;v  	       cCu  cev      cP      c   !    0x      
       h       /       /      !       $z      %z      (       ){  (    *#  0    -  8    1  @   H    =  L    >S  P    ?  X    @  h    A  x8    B      Ch       D       E      L  8    M      O      QP      R      S  $    T  O  $    Y   ($    Z  0$    [  4$    \  8$    `}o  @$    a  H&    b*"  P$    f   O<  $    m   $    p   $    q7   $    t  ( 
ev      @cQy      c|       c|      c*|      cY|      cn|       c|  (    c|  0    c|  8    c|  @    c|  H    c}  P    c-}  X    cI}  ` x  
Qy  !    @@{                   J             S         (      0      8      @      H      P      X    W  `8      h    z                               t                  VJ            P  8      &       $    bn  $    
  $      $       $      $       &      $       $      ($    Vy  0$    z   8$     S  @$      $    z   $    :*  $    7  &    }  @&    }  @ #rcu   $    
z     
\y  z   |  W      
{  z   |  |  $|   
W  
u  

|  z   S|  |  |     ,  S|   
u  
0|  z   n|  |   
_|  |  W   
t|  |  W  x   
|    |  W    z    
|   W  |  |   
|      z|  mnt z W       z	W   |  
|  z   }  W  +   
|  x  -}  W      
}  C}  C}  |   
|  
3}      cf      cz       @@{}      {       {      {Y       {}      { }       {!   
f}  
  |[}      |]<~       |_   *    @|W<~      |X        |Y    B~      |e      |f[~  (+    |gk~  ( 
}  |Z[~  4}      |b     k~  	  ?   ~  	  	        |k~      |l        |m      |n<~       8}      }        }       }       }      }   (    }  ,      	      '  	   H       ~
K                    1|      2       3      4       87      8Y       9Y      :   Y    	       9K      ;z       <|      =z       =z       >z       ?z   
  (        P              
      /      /      S              (      8     %  H                                        P\      -        ]       -                       8    o   <    o   @    o   D    ]   H    ]   J                                         B      -        ?       ]              \      \       \  8    o   P    o   T    o   X    ]   \    ]   ^    B  `    R  	   
X  >          P                      08      @      h8      p    {            S             !       {  %  val               m                                H       5                    <   ?  Buid @/  Bgid A/      B%       >          Dm             Hi                                        (      0    t  8    t  @     H      $       z                       (       ,      0      8      @      z$      {z        |      }(      ~$   
  J    `R      R       b    z   b  	   <5  s  	       ~  
*      *      8%      &       '      (      )      *&       +&  (    ,&  0   z     {  z    
  z   &  R   
      @0      1&       2      3      4&      5&       6&  (    7  0    :  8 ,  R    {  z    
    R   
      x   
  
      x@      Az        B       C       D       E        F   (    G   0    H   8    J   @    Kz   H    Lz   L    M   P    N   X    O   `    P   h    Qz   p     `ku      l       m      n      o      p       q  (    r  0    s  8    t!  @    u@  H    v`  P    wz  X   z     {  z   z   |   
z  z     {  z   z    
  z     {  z      
0  
  z     {       
  
  z     {     
  
  z   @  {     z    
'  z   Z  {  Z   
  
F  z   z  {      
f  
  !              8      8      0      X      h;ops    x    	   i    	       	       PB      Qf       R      U      X      Z       ]  (    `9  0    eS  8    fn  @    g  H    h  P    i  X    j  `    p
  h    r$  p    s  x    t      uC      wd      x~      {      }     z   [  d  [   
a  (    
G  z     %  d   
l  z     #  [   
  z     d   
  z     %  #  1      
  z     %  #  S        (  p   
  z   9  %  #  S        d     
    S  #     
?  n  d         
Y  z     d     
t  
U  i    z   
    S   
  (    
  z     #    z   p  +   
  z   
  #  d  d  '   
  +  $  d  ^   
  z   C  d       
*  ^  d  ^  ^   
+  
I  z   ~  #  d   
j  z       %     
  (    
  
    %   
      B  
B  (    
  (    
  (    
  L9  F    :   F    ;    LU<  F    V7  F    W   Lgj  F    hJ  F    i  F    jo   (    
j  (    
u  !     @                         5      T       o  (      0      8      @      H    
  P      X    .  `     R  h    {  p      x                      ,      	F      
p                  
           
  >                 P              (       0    J   4       8    z   <    5  @8      H    %  `    S  h    S  p    e  x                k      q         
       V      '   ;pid 5      3  ;uid /      /      z                                                   S   L  F    +  F       =    g      i      j       k.            
  .     
#      Hn      o       p      q      r.      s.       t  (    u  0    v9  8    wO  @ 4  z          
         
  z       z    
  +       
  z   3  3  z   1   
  
  O    p   
?       	      
                 (    
                (    
  P             z    L   F    U  F      Mafs    >    0le  8    m       nz       oz       pe      q%      r    
  
  
              >      8       8      x    z   8       <5    	       8      ,       z       G      X      	(       
  (    7  0      8      8      8    M  8      8      8      8 
      "      #       $      &      '2      (G       )  (    *X  0    +  8    ,m  @    -m  H    .  P    /  X    0X  `    2  h    3  p    4  x    5      :      ;      <#     
  
  
u  (      
  (      
  
  (    
       	       \                            \   
~  =    s  b  
y  z       ,  z   S                   n   ;pos S   S    %  S  z    
  i    %    ^  t9   
  i  *  %  ,  ^  t9   
  i  N  
  N    S   
Y  (    T  
0  i  x  
     
d  z     %     
  
~       %     
      %      &       '   
  Y    %        
  z     %  '   
  z   0  x  %   
  z   J  %     
6  z   n  %  S  S  z    
P  z     
  z    
t  z     z   %  z    
  z     %  z      
  i    %  d  z   ^  t9  z    
  z   	  z    
  i  2  J  %  t9  ^      
  i  [  %  t9  J  ^      
8  z     %  Y  3  p   
a  Y    %  z   S  S   
  z     O  %   
  W    x  W      
      W     
  (    
  z     x  z    
  z  5  x  z    
!  z   T  W    z    
;  o  W       
Z  z     x  W  
  +   
u  z     W  x  W   
  z     x  W   
  z     x  W  ,   
  z   
  x  W  
   
  z   .  x  W  
     
  z   R  x  W  x  W   
4  z   {  x  W  x  W      
X  z     W     
  
  z      W  W     
W  
  z     W  ,  6O  ^  z    
  i    W  ,    ^   
  i  ,  W    ^   
  z   F  W  ,   
2  z   j  x  j         
  
L  z     x  >  z    
v  z     x  W  %     
  8   
  z     x  z  z    
  x    {   
    x   
    x  z    
  z   2  x  [   
  z   G  x   
8  X  {   
M  z   m  {   
^  z     W     
  (    
s  z     {  8     
  z     O  W   
  z     {  d     
  Y    {  z    
  Y  #  {  Y  z    

  W  G    z   ,     
)    ]  	       hY      2$      pZ      qZ      rZ      
Z      
      S
Qy      W
Z      X
  8                 
    %           (       oq      o       o       o   len o        o!z       o"z        o*      o+       o-     Vo     
  
      @o1      o28       o4W      o6      o9      o<       o?  (    oB/  0    oDX  8 z   8  Vo  h   p   
  z   W  Vo  h      
>  i    Vo    %    ^  S   
]  i    Vo    %  ,  ^  S   
  S    Vo    %  S  z    
        Vo    %      
  
  z   /  Vo    %        
  z   X  Vo    x  %  '   
5  oN}      oOq  Bops oP}   
    Vo   
      ohVo      ojVo      5       6       <      =z    vel =z        @CE  arg Ds   ch EE       FP  (    Gz   0    Hz   4    Iz   8    Jz   < 
  (    
K  *    HR      Tz        Uz       Vz       Wz       Yp      [z       \z       _z       bz        c  (+    dz   (+    gw  0+    j  8+    mi  @      	       8w  dp        z              z       !      "  0 
       H  q         !z       "z       #z       #z       $      %       &  (    '  @ 
}      (i  dp               !z       "z       #z   ppq #z       $z       $z     
  G    \  Bs ]  Bn ^(  Bl _  Bv `v  Bt ae  Be b  Bx c      d   Bc eWr   
o  
V  J     	        (      !J        "J   dev #J       $J        (e      )J    chn *J       +J   vel ,J        0      1J    cmd 2J       3J       3J       4        8      9J    cmd :J   dev ;J   chn <J   p1 =J   p2 =J   p3 =J   p4 =J        Av      BJ    dev CJ   cmd DJ   chn EJ   p1 FJ   p2 FJ   val Gh        K      LJ    dev MJ   cmd NJ   chn OJ       PJ       PJ       Qh        U      VJ    dev WJ   buf X   z     	       f  X                        Ydp       Z    %      Z           [       d\          \           ]    z     ^dp   ^rec   ^opt %  _rc z   `    r   X    `z           D      O  Ydp `      Ybuf `,      Z    `z       Yopt `%      [    bz   daerr bz   eb    cz       _fmt cz   arec do  \c(                dM  dB  d8  eV        fW  gc      go      hS                \           c                d  d  d  i    g      j  dc]              Q  d  d}  ds  di   k                   d  d  d  d  \           \          \          \          \            c(              jA  dM  dB  d8  lV                 3  fW  gc      go      mS                   \           \           X    ,z                 A  Ydp ,      Ybuf ,      Z    ,z       b    .      b    /z       aerr /z   c`    0z   arec 1o  xb    2      n  `    8  `    8   n'  `    >  `    >   k                 8H  d   k                 <{  d  d  \           oS                 ?k}                 ?  d  p                 Cd  d  p'                 )dA  d7  q_                 [dy  do      k                 JN  d  d  \           k                 N  d  d  \           c              O  d  d  d  e        f  g      g      mS                 	 \           \          \          \          \          \          \        %   ]    7  ]  r    7i   s      ^dp   ^ev Ts  r    z   r    z    ]    z     ^dp   ^ev Ts  r    z   ^hop z    t      (  uto   v    6O  un   wx    	  x    	  x    	    ]      }  ^to   r    6O  ^n   wx       x       x         t    Az     up A   t    'z     utsk '  v    'z    y    l  v    l}  v    l  wx    n  x    n    t    *!  !  v    *}   
  ]    Yz   M  ^ti YM  r    Yz    
X	  z    TM  ]    gz     ^nr gz   r    g   
  {        b{        -{        {        T{        l{        k{        _{        `{        &{        +{        {         {        3{        4{        5 %   :;I  $ >  & I  $ >  5 I   :;I  I  	! I/  
 I  '   I  :;   :;I8  :;  4 :;I?<      'I   '  !   :;   :;I8  4 :;I?<  :;   :;I8  'I  >I:;  (    :;I8  :;   :;I    I8  !:;  " :;I8  # :;I8  $ :;I8  % :;I8  & :;I8  ' :;I8  ( <  )4 :;I?  *:;  + :;I8  ,:;  - :;I  . :;  /:;  0 :;I  1 I8  2:;  3:;  4 I  5 :;I8  6 <  7:;  8 :;I8  9 :;I  :! I  ; :;I8  <I  = :;I  >:;  ?! I/  @ :;  A :;I8  B :;I  C :;I  D:;  E :;I  F :;I  G:;  H>I:;  I:;  J:;  K :;I8  L:;  M :;I  N:;  O I8  P:;  Q:;  R:;  S:;  T :;I8  U&   V :;I8  W I  X.?:;'I@B  Y :;I  Z :;I  [4 :;I  \ 1  ].:;'I   ^ :;I  _4 :;I  `4 :;I  a4 :;I  b4 :;I  c1RUXY  d 1  e1U  f4 1  g4 1  h 1RUXY  iU  j4 1  k1XY  l1  m 1XY  n  o 1XY  p1XY  q1XY  r :;I  s.:;'   t.:;'I   u :;I  v :;I  w  x4 :;I  y.:;'   z. :;'I   {. ?<n:;                P      4       c@      X       c                      ,       Q,      8       e8      @       Q@      X       e                      ,       R,      8       f8      @       R@      X       f                             P      l       c             c                             Q      `       g`             Q             g             Q                             R      `       h`             R             h             R                             S             j             S                      x       i             i                             S`             S             S                             P`      d       P             P                      p       e      X       eX             P             e                             R`             R                      $       P`      d       P                        ,        P,               j             j                                Q              i             Q                                R              h             R                                e             e                D               d             d                `               g      H       g                              R\      d       R             R                               PP      l       P             P                ,                     X                      <      D      H      p                      <      D      H      \                                                                                                                                                                                                                                      $      (      ,      4      8      <      @      D                                        (                      I
           ../sound/core/seq/oss ../include/linux ../arch/arm64/include/asm ../include/asm-generic/bitops ../include/uapi/asm-generic ../include/asm-generic ../include/uapi/linux ../arch/arm64/include/uapi/asm ../include/clocksource ../include/linux/pinctrl ../include/sound ../include/uapi/sound ../sound/core/seq/oss/..  seq_oss_rw.c   spinlock.h   thread_info.h   sched.h   non-atomic.h   uaccess.h   seq_oss_device.h   int-ll64.h   int-ll64.h   posix_types.h   types.h   init.h   cachetype.h   printk.h   fs.h   notifier.h   kernel.h   memory.h   thread_info.h   time.h   compat.h   poll.h   hwcap.h   ptrace.h   spinlock_types.h   lockdep.h   spinlock_types.h   rwlock_types.h   fpsimd.h   hw_breakpoint.h   processor.h   atomic-long.h   seqlock.h   time.h   wait.h   nodemask.h   pgtable-types.h   mm_types.h   mmzone.h   osq_lock.h   mutex.h   rwsem.h   cpumask.h   completion.h   rcupdate.h   rcutree.h   pgtable.h   rbtree.h   uprobes.h   mmu.h   mm.h   cpufeature.h   arm_arch_timer.h 	  timex.h   jiffies.h   ktime.h   timekeeping.h   timer.h   workqueue.h   llist.h   smp.h   smp.h   percpu.h   percpu.h   topology.h   gfp.h   slab.h   capability.h   plist.h   cputime_jiffies.h   highuid.h   uidgid.h   signal.h   signal-defs.h   siginfo.h   signal.h   pid.h   pid_namespace.h   percpu_counter.h   seccomp.h   rtmutex.h   resource.h   timerqueue.h   hrtimer.h   task_io_accounting.h   sysctl.h   nsproxy.h   cred.h   ioport.h   idr.h   kernfs.h   seq_file.h   kobject_ns.h   debug_locks.h   shrinker.h   page_ext.h   vmstat.h   kref.h   dcache.h   stat.h   sysfs.h   kobject.h   klist.h   devinfo.h 
  pm.h   device.h   pm_wakeup.h   ratelimit.h   device.h   core.h   info.h   ioctl.h   asequencer.h   seq_oss.h   irqnr.h   jump_label.h   hardirq.h   irq_cpustat.h   interrupt.h   list_bl.h   lockref.h   path.h   list_lru.h   radix-tree.h   fiemap.h   migrate_mode.h   fs.h   dqblk_xfs.h   quota.h   projid.h   quota.h   nfs_fs_i.h   poll.h   seq_oss_writeq.h   seq_oss_readq.h   seq_oss_timer.h   seq_oss_event.h   seq_clientmgr.h   seq_kernel.h   seq_oss_synth.h   spinlock_api_smp.h     	        ,u& .J~ .o //!=/J}</<.j.V #L }</h6K2.}<x. g~J$!!)e.,. .X  5n..~f0  <~J$>4&]" .BV.. R  g<* Kl !!s.@."u  u  u .t  u  3?!/_<$X/LW ).@fj. .X2+	  ./Y1 uX// sched_entity long long int __u64 audit_context notifier_call line link console_printk vm_page_prot init_pid_ns shared_vm max_synthdev vm_stat_diff si_errno tasks read file_ra_state setattr long unsigned int if_dqinfo ino_ida compact_cached_migrate_pfn atomic_notifier_head fs_overflowgid ___assert_task_state pi_lock tmpfile private lowmem_reserve state_remove_uevent_sent personality error_remove_page jiffies map_count system_freezable_power_efficient_wq version target_kn mmap_rnd_bits release mmap_base restart_block sibling nr_migrations delta_us layer file_lock_operations s_id channel stack_guard_gap fe_logical ioac rcu_read_lock_nesting lb_imbalance timer_expires dentry_stat_t request_pending s_qcop dl_period __kernel_gid32_t kstat poll_table vm_rb kernfs_elem_symlink mnt_namespace vfsmount dirty_inode request_queue rt_priority copy_to_user ngroups seccomp_filter height alloc_inode smt_gain umode_t exit_state offline nr_dirtied addr_limit self_exec_id dumper dqonoff_mutex stime num_poisoned_pages list position name section_mem_map page_frag dqb_ihardlimit task_rss_stat seq_oss_synth_sysex k_sigaction skew total_vm fs_flags subdirs qs_itimelimit task_list id_lock loff_t ratelimit_state fl_owner sysctl_nr_open mmap_rnd_compat_bits_max work overflowgid __security_initcall_start nanosleep result sysex system_highpri_wq vmstat_text block_device n_ref totalram_pages seeks i_bytes iowait_sum device_attribute exec_domain dev_groups tty_audit_buf perf_event_mutex nameidata iattr resume magic kptr_restrict load_weight snd_seq_oss_readq_pick remap_pages snd_ecards_limit per_cpu_pageset kset_uevent_ops thread_struct sched_reset_on_fork app_index suspend d_seq splice_write lb_failed child_ns_type live mapping rb_root qsize_t sendpage group_info root_user list_lock high async_suspend sa_restorer cap_effective net_ns reclaim_stat s_magic vm_fault node_id pcpu_chosen_fc s_flags uidhash_node max_mapnr sched_domain_topology qs_incoredqs cur_tick sigaction uevent_suppress group_stop_count destroy_dquot _pad1_ sender generic_ro_fops s_stack_depth remove sival_int nr_dirtied_pause idle_idx connect jobctl kprojid_t pushable_dl_tasks qs_rtbtimelimit _call_addr pcpu_fc_names unused1 unused2 unused3 cmaxrss seq_oss_timer _pad2_ rmdir pi_state_list panic_on_oops _softexpires segment_boundary_mask __cap_empty_set fl_wait pdeath_signal thaw releasepage fi_extents_max KOBJ_NS_TYPES i_cdev __security_initcall_end wait_lock _pad3_ s_remove_count expires proc_id highest_vm_end pfmemalloc static_prio acpi_node snd_seq_ev_ext brk_randomized freeze_late nr_failed_migrations_affine rb_node lb_balanced subsys_data disable_depth pid_gid irq_cpustat_t ksoftirqd inv_weight iomem_resource parm i_lru runtime_resume backing_dev_info pteval_t end_data poweroff_noirq poll_queue_proc panic_timeout fsync actor running_avg_sum cnvcsw lruvec last_queued pid_type plist_node bool _addr sysctl_legacy_va_layout files_list dl_throttled inodes_stat dentry_operations timer_list dq_hash quota_on max_segment_size _status cpu_itimer qstr frozen aio_write sysctl_vfs_cache_pressure sched_info kiocb sbe_balanced mount dqb_curinodes last_balance s_bdi preempt_count size proc_work pending compat_elf_hwcap event_passing midi_sleep nohz_idle check_flags s_op pm_power_off_prepare percpu_counter in_iowait first prefix mtime compact_blockskip_flush get_reserved_space active_mm zone_reclaim_stat id_free_cnt user_fpsimd_state compat_timespec seq_next simple_dir_inode_operations time_slice ia_ctime running cpu_possible_mask burst boot_command_line posix_timer_id task_size objects nr_busy active_nodes wakeup_count block_max seq_oss_synthinfo size_t atomic_flags blocking_notifier_head kref sched_statistics page_tree fl_type export_operations __smp_cross_call statfs curr __dummy2 newidle_idx fl_break_time stop s_dev seq_oss_chinfo mm_count kernfs_syscall_ops hiwater_vm poll fl_nspid perf_event_ctxp event time_t dest seqcount show_path dq_sb ttwu_move_affine idle_state mmap_sem qfs_nblks d_rt_space cpumask_var_t bd_dev seqlock_t resume_noirq snd_card layers setup_max_cpus snd_seq_kernel_client_enqueue_blocking prev_pos is_suspended current_may_mount sa_flags callback_head user_namespace sleep_start anon_name user_fpsimd _arch kobj_sysfs_ops dquot_operations init_task last_siginfo is_midi private_data use_autosuspend stat_threshold system_freezable_wq make_it_fail core_id acpi_dev_node s_subtype page_ext_operations probe panic_on_io_nmi need class_attribute page_group_by_mobility_disabled attr RPM_SUSPENDING close free_bitmap s_time_gran dqi_dirty_list mmlist security thread_id sleep_state dquot bd_mutex evict_inode card elf_hwcap s_fs_info uprobes_state f_cred cpu_base PIDTYPE_SID lock_key iowait_count hotplug_down_time get_time f_flags sysctl_stat_interval nr_threads preempt_disable_ip snd_seq_ev_raw8 buflen debug_locks_silent hd_struct readpages ignore_children shared debug cap_ambient i_mtime qs_uquota PCPU_FC_AUTO device _qproc group_node evrec_short css_set _uid suspend_late mmap_rnd_compat_bits_min RPM_REQ_AUTOSUSPEND priority nr_files dqb_curspace check_quota_file stats_lock s_mem d_space usage port s_mtd _mapcount prio_list lock devt seq_client_load sd_flags rb_left fsgid tree_lock alloc_lock gtime timespec bio_list printk_disable_uart dqi_bgrace trace_recursion thread_sibling fs_quota_stat fl_owner_t boot_tvec_bases wakeup_source f_tfile_llink snd_info_entry_ops qs_btimelimit map_pages i_sb_list system_unbound_wq snd_mixer_oss mm_context_t HRTIMER_NORESTART seq_oss_writeq cap_permitted fl_u __s8 ZONE_MOVABLE bd_block_size pushable_tasks i_mutex quota_format_type d_name lru_lock fault_address vfork_done seqcount_t f_op read_file_info root nrshadows list_lru_node direct_complete update_time nr_wakeups_affine start_code kobj_ns_type dma_parms wakee_flips sock start_time hrtimer_clock_base notifier_block oom_flags vm_file super_operations flag mtd_info hmp_last_up_migration set_child_tid ia_uid __u8 i_rdev nr_dentry next_decay_max_lb_cost sched_group hotplug_down_lat_max notifier_fn_t mmap_legacy_base s_active dest_client real_timer access accounting_timestamp max_pgoff origin ttwu_wake_remote read_dqblk qf_owner d_compare imbalance_pct evrec_sysex dqi_valid _overrun hex_asc_upper dqb_isoftlimit hint bitset tgid f_ra cputime s_writers_key bd_inodes snd_seq_oss_dispatch zone_start_pfn thread_group_cputimer sa_handler notifier_mask freepage d_manage super_block unfreeze_fs span_weight system_wq fl_pid fe_flags ev_len leader_pid snd_info_buffer sighand_struct s_vfs_rename_mutex swap_info_struct dqi_format i_blocks registered level rename_lock bd_contains module free_area qs_pad1 qs_pad2 state_add_uevent_sent exe_file persistent_clock_exist forkexec_idx set_info upid kernfs_open_node uts_ns processes fl_end suspend_timer dqb_bsoftlimit snd_seq_oss_fill_addr fl_release_private mmapped run_list fe_reserved func core_sibling pcount expire_count autosleep_enabled maj_flt i_default_acl release_dqblk small_block owner snd_cards first_page user_ns s_bdev controls_count i_rcu qf_ops files_lock epoll_table synths USRQUOTA __per_cpu_offset evrec_voice fs_qfilestat_t addr runnable_avg_sum start_prevent_time active_jiffies quota_on_meta rb_subtree_gap fl_copy_lock d_rt_spc_timer sysctl_memory_failure_recovery wps_disabled write fl_file poweroff_late atime restore_early get_xstatev power_state stimescaled hrtimer_restart snd_seq_oss_readq_wait scan_objects cputime_expires mod_name pte_t dev_name HRTIMER_RESTART write_dquot kernfs_open_file fu_llist inactive_age address_space_operations alb_failed filter show_unhandled_signals sysctl_memory_failure_early_kill domain_data vm_prev snd_seq_event seq_operations policy a_ops cnivcsw driver_private trace sigset_t seq_show set_acl hotplug_down_lat_min nr_wakeups_passive ptrace_entry real_blocked __con_initcall_start on_cpu SYSTEM_POWER_OFF private_list abstime_t compat_rmtp rb_subtree_last evrec sched_domain_mask_f pre_event_timeout snd_seq_addr readlink i_writecount prepare compat_time_t nr_failed_migrations_running d_iname oom_score_adj_min files_stat_struct oublock irq_default_affinity function inode_operations PIDTYPE_PGID controls s_shrink lb_gained prevent_sleep_time power_lock dev_pm_ops free_cached_objects sched_rt_entity sleep_max zlcache_ptr mmap_miss timestamp_enable state_initialized fmode_t qc_dqblk __kernel_timer_t busy_idx seq_oss_readq uaddr2 bd_write_holder i_fsnotify_marks simple_dentry_operations vmacache mixername tail env_end kernel_cap_struct mm_kobj s_options wait_queue_head_t d_prune mark_dirty sync_lock snd_seq_kernel_client_write_poll core_thread raw_notifier_head last_runnable_update nr_voices snd_seq_timestamp incr_error shortname __i_nlink queue env_start sched_avg rlim_max linux_proc_banner next sched_domain dma_pfn_offset f_path nfs4_fl total_cpus nrpages partno d_lru nr_wakeups_local percpu_counter_batch nr_free SYSTEM_HALT tick_cpu_device back _Bool min_free_kbytes netlink_ns freelist i_atime zone free_list linear parent snd_seq_event_type_t rlock dirtied_when s_vfs_rename_key deactivate_waitq cg_list cap_bset total_forks task_cputime system_states put_super attrs utime alb_count drv_groups softirq_time nr_normal_prio s_export_op _sigval isolate_page d_flags group_leader pi_waiters __sched_text_start is_late_suspended hash_len names_cachep nr_forced_migrations node_zones longname mixer_oss_change_count min_interval runtime_idle migrate_mode is_dirty_writeback setlease subsys_private age_limit snd_seq_ev_raw32 my_q siginfo_t fa_lock wait_table_bits nr_events lock_count detach store fpsimd_state nr_deferred kmalloc_dma_caches i_op exec_start hrtimer_cpu_base journal_info min_flt avg_period tv_nsec set_dqblk mask rcu_blocked_node bd_claiming jiffies_64 s_writers bps_disabled is_noirq_suspended hres_active fiemap_extent arch_spinlock_t saved_auxv hbp_break free_file_info secondary_data fl_lmops release_dquot kmsg_fops clear_child_tid seq_oss_devinfo s_dquot load s_type rcutorture_testseq ioctx_lock inactive_ratio _pad dq_count fiemap blocks grab_current_ns audit_tty zone_type cred pgd_t dqi_igrace iommu_group anon_vma_chain compact_considered index prove_locking clock_base dev_pm_qos qlen start_data id_free thaw_noirq insert_queue list_node ipc_ns notify_count init_user_ns radix_tree_root task lm_setup rwlock_t vm_event_states cgtime recent_rotated workqueue_struct empty_aops inotify_devs tv64 slab_cache i_sb platform_notify devnode sbf_balanced vm_end error nsproxy nlm_lockowner swap_deactivate evrec_long i_devices parent_exec_id snd_mixer_oss_notify_callback loginuid sched_dl_entity hex_asc inode pipe_inode_info dqio_mutex sbe_pushed d_weak_revalidate mknod cmaj_flt create tick_nsec swapper_pg_dir match ipi_irqs fe_reserved64 timer dma_coherent_mem oss_timebase max_time dl_bw lb_nobusyq raw32 lm_change siginfo pfmemalloc_wait _stime rw_semaphore i_ino tasklist_lock file_operations snd_seq_kernel_client_dispatch s_lock_key midi_mapped snd_info_entry_text s_security has_timeout pid_chain radix_tree_node files_struct llseek file_lock lock_class_key fiemap_extent_info sa_mask page fpcr sched_task_group zone_idx runtime lookup sighand_cachep invalidatepage persistent_clock_is_local kernel_kobj sbf_count kernfs_elem_dir d_child f_pos_lock snd_seq_oss_timer_cur_tick gid_t compact_cached_free_pfn short unsigned int refcount device_node tick_usec sync_fs per_cpu_pages dev_pm_info state_in_sysfs PCPU_FC_EMBED active_bases lb_hot_gained panic_on_unrecovered_nmi rt_rq s_umount group_exit_task bd_private pid_namespace destroy_inode _pid dummy2 private_lock i_blkbits dev_archdata is_child_subreaper poweroff snd_shutdown_f_ops dq_wait_unused sys_tz deadline host sched_domain_topology_level s_xattr cpu_timers getxattr inotify_watches it_real_incr f_ep_links coublock rm_xquota need_qs rwsem dqb_bhardlimit s_root iov_iter remount_fs sysctl_protected_symlinks nr_retries atomic_write_len ida_bitmap qfs_nextents deferred_resume wait_queue compact_defer_shift vm_ops base s_inodes seq_file regs_on_excp hotplug_up_lat_max kobj sum_sched_runtime cpu_hwcaps is_prepared page_symlink_inode_operations timestamp_us cpu_online_mask wait show_fdinfo audit_tty_log_passwd pgoff s_f_ops alb_pushed test_tsk_thread_flag exec_vm cpu_all_bits interval ctl_table_poll unix_inflight poll_event nr_isolate_pageblock default_timer_slack_ns nodemask_t max_files printk_delay_msec pcpu_fc nvcsw def_blk_fops completion vdso vm_area_struct signal d_rt_spc_warns maxlen pglist_data super_blocks __copy_to_user gfp_mask ia_valid PRJQUOTA pgprot_t direct_IO default_exec_domain show idr_layer atomic_open ipc_namespace d_spc_hardlimit get_dqblk pcpu_base_addr utilization_avg_contrib virtual_address thread_info proc_root_link wait_table_hash_nr_entries __count unsigned char rdev file_caps_enabled uts_namespace snd_seq_oss_readq_free umount_begin _kill bd_list sigval_t incr dq_op fu_rcuhead dl_new quota_off fa_next pid_cachep hotplug_up_time snd_seq_queue_skew d_rcu __rb_parent_color page_mkwrite tlb_flush_pending hotplug_down_lat_us projid __kernel_clockid_t class _raw_spin_unlock_irqrestore uevent_helper watchdog_stamp rename euid sysctl_protected_hardlinks read_iter hrtimer flock bin_attribute freeze_noirq process_counts phys_addr_t drop_ns vm_stat files_stat i_hash sigcnt envp client run_delay evrec_note snd_major RPM_REQ_NONE notify_next cap_inheritable rlim_cur sysctl_overcommit_kbytes /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out platform_data dev_pm_domain kswapd_wait write_inode __sighandler_t __kernel_pid_t snd_seq_oss_process_event cfs_rq tz_dsttime task_frag cpu_topology bd_holder_disks snd_seq_oss_write arch_timer_read_counter sysctl_lowmem_reserve_ratio begin i_mmap_nonlinear last_pid usage_count debug_info sas_ss_sp mt_need_uart_console type s_umount_key mem_section qfs_ino lm_get_owner resource_size_t sighand span cmin_flt in_execve d_dname fs_struct dq_lock child_count i_mmap quota_format_ops kmem_cache mem_dqblk hotplug_up_lat_min real_cred proc_inum pi_state_cache wait_unfrozen numbers si_code s_readonly_remount mm_struct done nlink d_parent nfs4_lock_state atomic_t path sysctl_user_reserve_kbytes anon_vma release_completion restore lm_compare_owner runtime_auto init i_lock_key init_nsproxy present_pages current_stack_pointer i_security rmtp group_exit_code d_lockref active_count info perf_event_list robust_list_head last_arrival permission zone_padding put_link cred_guard_mutex dummy1 migratepage printed memalloc_noio fl_start core_state snd_seq_oss_read show_devname ia_gid debug_guardpage_ops wakeup pinctrl_state value RPM_REQ_RESUME kobj_uevent_env devres_head mnt_ns suid d_ino_warns snd_seq_oss_poll init_groups slab uevent_seqnum prev_cputime suspend_noirq nr_balance_failed fs_supers sync_event_put kgid_t watermark test_ti_thread_flag thread SYSTEM_RESTART class_release linux_binfmt fpsr __dummy ctl_files_rwlock RPM_REQ_SUSPEND perf_event i_flock attribute ioctx_table vm_pgoff sb_lock reboot get_unmapped_area units fe_physical cpu_active_mask ia_size poll_table_struct pm_domain_data __kernel_loff_t wait_sum initial_ns suppress_bind_attrs wait_chldexit pid_link pm_subsys_data page_table_lock stack plug quota_info wakeup_path counter __copy_from_user set_page_dirty vm_private_data node_states count power_kobj list_head nr_to_scan nr_cpus_allowed epoll_watches pprev last_time snd_seq_result i_generation oss_tempo fasync_struct f_owner timerqueue_node rec_idx _zonerefs ia_file fl_fasync quota_sync bus_groups ctime fl_downgrade_time init_thread_union rpm_status RPM_RESUMING dma_mem d_ino_hardlimit rcu_node sessionid ttwu_move_balance device_type def_flags uid_t f_version slab_page freeze quota_type dqstats system_power_efficient_wq nr_irqs swap_in sysctl_drop_caches nr_dequeuing_low_prio drop_inode signum dentry print_fatal_signals default_attrs no_callbacks d_rt_spc_hardlimit fs_quota_statv dest_port rcutorture_vernum arg_end resume_early fa_rcu power_sleep tty_old_pgrp arch_rwlock_t copy_from_user i_nlink dl_boosted d_fieldmask suspended_jiffies ptrace_message late_time_init proc_handler balance_interval lists of_node normal_prio seq_start of_match_table fl_link atomic dmesg_restrict signal_pending signalfd_wqh action bd_part_count d_spc_timer compat_robust_list_head spanned_pages memstart_addr nr_wakeups_affine_attempts sched_class request devices i_mutex_key statistics thread_node __restorefn_t qs_bwarnlimit user_struct exit_code dqstats_pcpu i_pipe wake_entry ktime_t compat_robust_list text nr_ptes blkcnt_t xattr_handler device_driver source kqid suspended_step tags thread_union __kernel_time_t sector_t PCPU_FC_NR write_begin sysfs_dev_block_kobj fs_kobj from ctl_table GNU C89 7.3.1 20180522 -mlittle-endian -mgeneral-regs-only -mpc-relative-literal-loads -mabi=lp64 -g -Os -std=gnu90 -fno-strict-aliasing -fno-common -fstack-usage -fno-delete-null-pointer-checks -fno-PIE -fno-store-merging -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -fno-strict-overflow -fstack-check=no -fconserve-stack --param allow-store-data-races=0 dma_pools d_automount futex_pi_state dma_map_ops sync_sleep posix_acl dq_inuse proc_root start_brk system_state hbp_watch echo fl_block device_private inblock __softirq_pending prev_sum_exec_runtime dq_dirty dqi_max_spc_limit dqi_flags mm_rss_stat snd_seq_root qs_iwarnlimit MIGRATE_SYNC max_hang_time KOBJ_NS_TYPE_NONE compat_ioctl slots f_mapping ns_type early_boot_irqs_disabled snd_seq_connect shutdown reltime_t i_data nblocks note1 note2 note3 note4 async_size node _tid realtime cad_pid i_mmap_mutex sched_contributes_to_load total_time slice_max ctl_files PIDTYPE_PID i_ctime hypervisor_kobj runtime_status s_count readq fl_flags dev_release nr_wakeups_sync reboot_notifier_list kstatfs sysctl_overcommit_ratio lock_manager_operations count_objects tick i_mode linux_banner dummy entry __int128 unsigned root_mountflags mm_rb __kernel_size_t splice_pipe dev_pin_info avenrun _band bits numa_level dl_timer __con_initcall_end short int __kernel_dev_t current_thread_info cpu_power firmware_kobj notifier sched_group_capacity si_signo hotplug_timestamp_lock max_newidle_lb_cost active set_latency_tolerance commit_dqblk vregs s_inode_lru i_opflags file ia_mtime klist_node vm_area_cachep i_gid nr_cpu_ids bin_attrs __PIDTYPE_TGID nr_zones dq_flags dev_uevent pm_message atomic_long_t archdata sysfs_ops f_security cstime nr_migrate_reserve_block sb_writers evrec_extended sched_domain_flags_f preset_lpj curr_target sbe_count io_context dl_deadline namespace fl_link_cpu kernfs_root wake_cpu _key sas_ss_size is_partially_uptodate unlink sysfs_dev_char_kobj thread_group on_rq fs_overflowuid write_info lm_owner_key s_maxbytes ioctl qs_pad hlist_bl_node qf_fmt_id dirty_balance_reserve _raw_spin_lock_irqsave sbf_pushed timer_slack_ns total_link_count kset group_rwsem i_count gfp_allowed_mask revents s_anon duration long int zonelist sigpending mmap_pages_allocated snd_oss_root counters shrink_control start perf_event_context arg_start s_blocksize_bits compact_order_failed recent_scanned panic_notifier_list startup bd_queue pinned_vm tty_struct idmap_pg_dir initcall_t hotplug_up_lat_us power proc_mnt uevent_ops dev_attrs coherent_dma_mask address_space writepages optimistic_spin_queue symlink fi_extents_mapped dl_runtime dev_kobj read_pos test_bit wait_count ktype bd_fsfreeze_count nfds KOBJ_NS_TYPE_NET kernfs_node state kernfs_iattrs pinctrl protection_map softirq_to_name proc_self f_mode can_wakeup run_wake dq_id kuid_t wait_max expires_next cdev nr_pending decay_count nr_hashed syscore files reclaim_state write_file_info cache_nice_tries batch mem_map overflowuid s_instances node_start_pfn weight bdev_try_to_free_page nr_wakeups bd_openers locked_vm writeback_control s_pins real_start_time pad_until list_lru get_xstate i_bdev fi_extents_start f_inode nr_free_files futex blk_plug readpage _utime time cluster_id prev seccomp spinlock_check cleancache_poolid ufds __kernel_clock_t code snd_seq_ev_quote dentry_stat s_dio_done_wq _sigfault getattr event_count fe_length nr_wakeups_remote sysctl_panic_on_stackoverflow fault_code fown_struct kernfs_ops bd_disk d_revalidate iterate snd_seq_tick_time_t removexattr mm_segment_t load_avg_contrib want_pages device_dma_parameters context node_zonelists printk_ratelimit_state bd_invalidated locked_shm n_klist get_acl last_wakee oops_in_progress hiwater_rss hide_pid proc_dir_entry nfs_lock_info ZONE_NORMAL runtime_suspend _sys_private d_fsdata dma_ops fl_ops bad_sock_fops busy_factor rcu_expedited __icache_flags launder_page setxattr seq_mode robust_list initcall_debug sysctl_admin_reserve_kbytes timezone nodes_to_scan children pi_blocked_on input_time writeback_index dq_data_lock mach_panic_string _sifields dqb_rsvspace acpi_match_table zone_pgdat unlocked_ioctl nivcsw param platform_notify_remove timerqueue_head prio atomic64_t priv tv_sec dqi_fmt_id swap_activate max_lock_depth proc_thread_self snd_seq_kernel_client_enqueue qs_gquota number pages task_works nr_inodes relax_count offset saved_command_line init_mm offline_disabled note work_func_t listxattr s_mode cpu_vm_mask_var timekeeping_suspended __signalfn_t system_long_wq events d_release uevent acpi_device_id complete sysctl_overcommit_memory splice_read max_interval d_op _sigpoll notifier_data snd_seq_oss_arg groups hash cpu_stats clockid_t nr_items zonelists_mutex snd_seq_ev_ctrl cputime_t dl_yielded pm_power_off RPM_ACTIVE wakee_flip_decay_ts i_state lockref rb_right sched_domain_level_max SYSTEM_BOOTING s_mounts cinblock rnode signed char i_fop def_chr_fops pidmap pids user_ctl_lock dqb_btime zonelist_cache control quote thread_head mmap_rnd_compat_bits kill_sb private_free nr_cached_objects _timer vm_start quotactl_ops components init_name mmap sequence nr_unused d_subdirs i_private knode_class posix_timers f_pos hlist_node siglock mutex _sigchld d_sb slack snd_seq_oss_synth_load_patch page_poisoning_ops comm i_version cpu_excp mm_users _addr_lsb sigval vruntime i_wb_list _syscall ktime supers reset_devices roksum pageblock_flags dq_off isolate_mode_t inuse ia_atime dirty_paused_when init_struct_pid writeq head securebits SYSTEM_RUNNING pid_t alloc_dquot qf_next perf_ops_bp show_options long long unsigned int egid cpu_context nonlinear thaw_early __kernel_uid32_t numa_zonelist_order d_spc_softlimit pipe_bufs wait_table filldir_t debug_locks sound_class real_parent leases_enable ia_mode cpu_present_mask snd_seq_ev_queue_control wait_start fa_file lm_notify lease_break_time s_d_op restore_noirq hang_detected __wait_queue_head static_key_initialized i_mmap_writable dev_root nfs_fl s_dentry_lru clock_was_set opened tp_value depth s_uuid fa_fd vm_event_state timer_autosuspends ioport_resource kernel_cap_t i_size d_ino_count nr_hangs parm1 parm2 mem_dqinfo iommu_ops spinlock_t node_list exit_signal high_memory pobjects shrinker work_struct kobject velocity i_mapping evrec_timer lb_nobusyg end_code gfp_t sync_time kobj_type run_node argv mmlist_lock flags lb_count binfmt last_numid seq_stop user leader hlist_bl_head wake_idx irq_safe file_mode __kernel_long_t spinlock empty_zero_page fallocate fsuid oom_score_adj dqb_itime vmacache_seqnum RPM_REQ_IDLE MIGRATE_SYNC_LIGHT cpumask __kernel_ssize_t pins __s32 block_start pending_load __addr char kioctx_table dq_free sum_exec_runtime nr_wakeups_migrate d_spc_warns freeze_fs uaddr dq_dqb spin_unlock_irqrestore vm_next fs_qfilestat GRPQUOTA cpu_bit_bitmap driver_data qs_version maxrss mkdir sgid syscall_ops pm_message_t vm_operations_struct swap_out ev_size rcu_special utimescaled s_list power_group_name irq_stat extra1 extra2 task_struct nr_migrations_cold autosuspend_delay f_count fasync buffer procname bmap child_reaper mmap_rnd_bits_max profile_cpu_stats d_inode follow_link pgdval_t PCPU_FC_PAGE bd_holders _sigsys fi_flags aio_read cpus_allowed ptraced RPM_SUSPENDED rename2 dir_context hmp_last_down_migration rlim online oom_flags_t d_iput bd_super cputimer task_group clockid rss_stat shared_pending node_present_pages d_time d_delete __kernel_ulong_t fs_qfilestatv data sd_data rcu_scheduler_active projid_t ../sound/core/seq/oss/seq_oss_rw.c tz_minuteswest qs_pquota bitmap nfs4_lock_info i_fsnotify_mask d_ino_timer resource open kmalloc_caches d_alias writepage lock_stat MIGRATE_ASYNC blksize timestamp_rec kernfs_elem_attr pi_waiters_leftmost qs_flags bd_holder flush get_xip_mem mode snd_seq_real_time bus_type saved_sigmask i_lock nr_failed_migrations_hot panic_blink dqi_priv lm_put_owner pageset attribute_group idle_notification rpm_request card_dev classzone_idx loadwop_avg_contrib i_flags devres_lock resolution is_visible max_mididev d_ino_softlimit i_dentry fl_next rcu_node_entry gendisk wait_list n_node kobj_ns_type_operations aio_fsync content nr_wakeups_idle start_stack cseq PIDTYPE_MAX d_rt_spc_softlimit exec_max raw_lock envp_idx __sigrestore_t bd_fsfreeze_mutex s_blocksize timeout raw_spinlock_t tvec_base fm_flt snd_seq_oss_readq_poll compat_elf_hwcap2 stat show_stats contig_page_data signal_struct __cap_init_eff_set link_count pid_ns_for_children snd_info_entry i_acl write_end d_hash set_xstate child stack_vm cpu_chain _count pm_domain missed __sched_text_end pollfd __invalid_size_argument_for_IOC __u16 d_select_inode putback_page task_io_accounting llist_node pcpu_unit_offsets has_child_subreaper i_uid vm_flags snd_seq_oss_process_timer_event kswapd_max_order fault rcu_read_unlock_special blocked get_info sival_ptr tempo raw_spinlock sum_sleep_runtime mmap_rnd_bits_min write_iter randomize_va_space hotplug_ts_rec synth_opened snd_seq_ev_note kswapd mixer_oss percpu_drift_mark clock_list ssize_t default_state rlimit ra_pages dev_t cgroups zoneref __u32 cpumask_t iovec of_device_id lm_grant node_spanned_pages bd_part s_max_links simple_dir_operations acquire_dquot class_attrs rt_mutex_waiter _unused_nodemask_arg_ controls_rwsem lm_break file_system_type __MAX_NR_ZONES d_canonical_path page_cluster cutime i_dio_count ptrace dma_mask runtime_error root_task_group qfs_pad raw8 managed_pages last_busy inodes_stat_t user_ctl_count bd_inode f_lock dqi_max_ino_limit driver unsigned int movable_zone hlist_head vm_mm ZONE_DMA early_init off_velocity tick_device i_mutex_dir_key  GCC: (Linaro GCC 7.3-2018.05~dev) 7.3.1 20180522     x L                     ApAE
	y
 A      L               D      AAAE
	r
 A       <                      A0AABT
 A                                                                                                                                                              (                    5                    B                    O                    \                    i                    v                         	                    
                                                                                                                                                                                                                     *                   8                   F                   T                   b                   p                   ~                                                                                                                                                                                           	                                                                                                                                                                                                                                      "                     9                     P                     _          D      q                                                                                                                                                   =                 N                     o                      seq_oss_rw.c __reg_num_x0 __reg_num_x1 __reg_num_x2 __reg_num_x3 __reg_num_x4 __reg_num_x5 __reg_num_x6 __reg_num_x7 __reg_num_x8 __reg_num_x9 __reg_num_x10 __reg_num_x11 __reg_num_x12 __reg_num_x13 __reg_num_x14 __reg_num_x15 __reg_num_x16 __reg_num_x17 __reg_num_x18 __reg_num_x19 __reg_num_x20 __reg_num_x21 __reg_num_x22 __reg_num_x23 __reg_num_x24 __reg_num_x25 __reg_num_x26 __reg_num_x27 __reg_num_x28 __reg_num_x29 __reg_num_x30 __reg_num_xzr $x snd_seq_oss_read _raw_spin_lock_irqsave snd_seq_oss_readq_pick _raw_spin_unlock_irqrestore snd_seq_oss_readq_wait snd_seq_oss_readq_free __copy_to_user snd_seq_oss_write __copy_from_user snd_seq_oss_synth_load_patch snd_seq_oss_process_timer_event snd_seq_oss_process_event snd_seq_kernel_client_dispatch snd_seq_kernel_client_enqueue snd_seq_kernel_client_enqueue_blocking snd_seq_oss_poll snd_seq_kernel_client_write_poll snd_seq_oss_readq_poll   T         1           d         2                    3                    4                    1                    2                    3           ,        5           8        3           l        6           $        8           X        9                   8                   :           P        ;                   <                   =                   >                   @           H        A                    '                    ,   ,A               ,   [^               ,   C4                          )         +           .         ,         ;         ,   PT      @         ,   2      M         ,   1      Y         ,   oF      ^         ,   b      k         ,   ,      p         ,   Z               ,   d               ,   3f               ,                   ,                   ,   V      	        ,          :        ,   [      O        ,   UZ      \        ,   I      f        ,   ^      q        ,   4      |        ,   /W              ,                 ,   F              ,   Z              ,   :              ,   @              ,   N              ,                  ,   2              ,   yF               ,   rd              ,                 ,   V      !        ,   S      ,        ,   >      9        ,   "      >        ,   =      I        ,   +      T        ,         _        ,   6      j        ,   Ld      u        ,   @              ,   @              ,   ~@              ,   Y              ,   w               ,   ]              ,   3              ,   6              ,   j;              ,   &7              ,   j;              ,   Q              ,   ;              ,   ("      %        ,   M      8        ,   Mf      D        ,         Q        ,   uU      ]        ,   ("      i        ,   ;              ,   B              ,   ("              ,                 ,   \P              ,   J              ,   y              ,   \F      	        ,                 ,   d	      *        ,         5        ,   QR      @        ,   -V      K        ,   >      V        ,   P      q        ,   E      |        ,   "              ,                 ,   5              ,   G               ,   50              ,   +?              ,                 ,   m*              ,   6              ,   +              ,                  ,   l              ,   :]      "        ,         /        ,   V3      <        ,   c      I        ,   N      V        ,         c        ,   \Q      p        ,   
D      }        ,   *U              ,   ^              ,   ^_              ,                 ,   
              ,   `              ,   \              ,   #              ,                 ,   }:              ,                 ,   h3              ,         &        ,   *S      3        ,   $      @        ,   ~Z      M        ,   _/      `        ,   &      l        ,          y        ,   #              ,   V              ,   J              ,   _              ,   O              ,   
              ,                 ,   ,              ,   M              ,   N              ,   E              ,   /D              ,   #      0        ,   )T      6        ,   V      <        ,   "      B        ,         H        ,   9      O        ,   -C      [        ,   M)      g        ,   H      s        ,   Q              ,   ?              ,   n[              ,   Y              ,   j              ,   M              ,                  ,   ]              ,   7              ,                 ,   	              ,   o      &        ,   Q      2        ,   %      E        ,   \      Q        ,   Q      ]        ,   %      x        ,   N              ,   K              ,   *              ,   Q              ,   %              ,   b              ,   R              ,   I              ,   M              ,         		        ,         	        ,         N	        ,   O      Y	        ,   1      e	        ,   Y      q	        ,         }	        ,   (      	        ,         	        ,         	        ,   L      	        ,   .      	        ,   U      	        ,   n\      	        ,   K      	        ,   H;      	        ,         
        ,   Y      
        ,   e      "
        ,   K@      /
        ,         <
        ,   O      I
        ,         V
        ,   S      c
        ,   H      p
        ,   H      }
        ,   Q      
        ,   	      
        ,   >      
        ,   =      
        ,   ?      
        ,   J+      
        ,                 ,   ;              ,   C]              ,   p      ,        ,   jc      :        ,   `      H        ,   %      V        ,         d        ,          r        ,                 ,   T              ,   "              ,   	              ,   Z              ,                  ,   ]              ,                 ,   -@              ,   PY              ,   !	              ,   C      +        ,   u      9        ,   46      J        ,         [        ,   a      l        ,   D      }        ,   =              ,   q              ,   W              ,   #              ,   P              ,   	              ,   $              ,   P]              ,   _      	        ,   vT              ,   H      %        ,   ?      3        ,         A        ,         O        ,   &      ]        ,   #      k        ,         y        ,   3\              ,                 ,   i              ,   F              ,   r9              ,   O0              ,   kQ              ,                 ,   XM              ,   %              ,                 ,   a      !        ,   s=      /        ,   \      =        ,         K        ,   -      Y        ,   6      g        ,   F'      u        ,   U              ,   b              ,   I              ,   9              ,   L              ,   (              ,   0              ,   6              ,   c               ,   l              ,   _              ,   i      *        ,   5      8        ,   H      F        ,   F      T        ,   QS      b        ,         p        ,   )R      ~        ,   !               ,   4)              ,   <              ,   M              ,   )              ,                 ,   ^              ,   5              ,   $              ,   7_              ,   P              ,   %      (        ,   x      6        ,   N;      D        ,   L      R        ,   
      `        ,   bH      n        ,   >      |        ,                 ,   k              ,   xd              ,   `#              ,   P              ,   ^@              ,                 ,   6              ,   *              ,         	        ,   8              ,         3        ,   F      A        ,   5      O        ,         ]        ,         k        ,   !      y        ,   wV              ,   I              ,   	0              ,                 ,                 ,                 ,   7              ,   q              ,   a              ,                 ,   J      
        ,   0G              ,   :      #        ,   E+      C        ,   E      Q        ,   6      ]        ,   ("      j        ,   A&      ~        ,   #              ,   _>              ,   '              ,   ^              ,   +              ,   c              ,   3a              ,   za              ,   +#              ,   eZ              ,   ;Y              ,   3a      (        ,   -(      <        ,   0G      H        ,   :      U        ,   E+      l        ,   u      }        ,   Q%              ,   V              ,   5              ,   @              ,   &              ,   _              ,   \&              ,   :C              ,   <:              ,   W              ,   S              ,   W              ,   X              ,   Q%              ,                 ,   N              ,                 ,   G              ,   L      )        ,   /U      6        ,         K        ,   L      X        ,   #      g        ,         t        ,   P              ,   ~^              ,   5              ,   v-              ,   8X              ,   #              ,                 ,   5!              ,   CF              ,    0              ,   e      "        ,   ;      .        ,   
      9        ,   ]      D        ,         O        ,   K'      Z        ,   0      k        ,   @+      x        ,   Y              ,   r              ,                 ,   "              ,   "              ,   G8              ,   ,              ,   M(              ,   J      *        ,         6        ,   >      B        ,   +      _        ,   YV      j        ,   W,      v        ,   ;              ,                 ,   L              ,   >              ,   3              ,                 ,                  ,   <'              ,   ^f              ,   O              ,         !        ,   Ze      (        ,   "      7        ,   9      D        ,   M      Q        ,   &      ^        ,   QQ      k        ,   _      x        ,   PI              ,                 ,   e              ,   ?              ,   7              ,                 ,   G              ,   /              ,   nW              ,   1              ,   %              ,                 ,   #      #        ,         0        ,   Y      >        ,         M        ,         \        ,         j        ,   R      x        ,   /d              ,   ,              ,                  ,   w'              ,   .              ,   uJ              ,                 ,   	              ,   3              ,   0      '        ,   p$      5        ,   UO      C        ,   G      Q        ,   L      _        ,   ]      m        ,   d      {        ,   I              ,   4              ,   5*              ,   d              ,   Sc              ,   `              ,   d              ,   "              ,   [+      2        ,   I      ?        ,   >       L        ,   V<      Z        ,   T      u        ,   L              ,   LK              ,   !              ,   U              ,   ;              ,   |	              ,   `              ,   6              ,   L*              ,   ;              ,   `      +        ,   |	      D        ,   6      Q        ,   Z      ]        ,   CF      o        ,   d      z        ,   zG              ,                 ,   J/              ,   W              ,   :              ,                 ,   /              ,   [               ,   b0      -        ,   7      9        ,   Z/      G        ,   NP      R        ,   &      ]        ,   >      h        ,   =^      s        ,   F              ,                 ,   *M              ,   
f              ,   ]              ,                 ,                 ,   %              ,   T_              ,   ]              ,                  ,   /5              ,                 ,         +        ,   d      8        ,   ]?      E        ,   {O      R        ,   N      _        ,   J      l        ,   2      y        ,   ,              ,   K              ,   Ta              ,   nZ              ,   )              ,   J              ,   "
              ,   2              ,   	T              ,   F              ,                  ,   "
      3        ,   6      B        ,   *U      O        ,   F      \        ,   Z      i        ,   }:      v        ,                 ,                 ,                 ,   	              ,   U              ,                 ,   v@              ,                 ,   8;              ,                  ,                  ,   O      !         ,         .         ,   d      ;         ,   5M      H         ,   J      U         ,   o       b         ,   /      o         ,   [b      |         ,   =               ,   v               ,   Y               ,   '               ,   
               ,   #C               ,   `               ,   ZJ               ,   *>      !        ,   !      !        ,   	!      !        ,   Q&      -!        ,   ]      ;!        ,   Z      I!        ,   R      W!        ,   MO      f!        ,   Y      t!        ,   8      !        ,   &      !        ,   Y:      !        ,         !        ,   2      !        ,   -      !        ,   -      !        ,         !        ,   m0       "        ,   Y      "        ,         "        ,         +"        ,   3K      9"        ,   -      F"        ,   w      S"        ,   T      a"        ,   aX      n"        ,   d6      {"        ,   5      "        ,   D      "        ,   c"      "        ,   0      "        ,   P      "        ,         "        ,   Y      "        ,   
      "        ,   -      "        ,         "        ,         #        ,   '      &#        ,   "      1#        ,   	      E#        ,   hV      T#        ,         c#        ,         {#        ,         #        ,   :      #        ,   nb      #        ,   )J      #        ,   G      #        ,   ("      #        ,   #R      $        ,   hY      0$        ,   -=      ;$        ,   B      G$        ,   _9      [$        ,   E      r$        ,   (      }$        ,   F      $        ,   |6      $        ,         $        ,   @+      $        ,   JR      $        ,   Z      $        ,   LG      $        ,   I"      $        ,   M      $        ,         %        ,   f      %        ,   \      #%        ,         0%        ,   ,L      =%        ,   +      K%        ,   oU      X%        ,   6<      e%        ,   ;      r%        ,   v      %        ,   #=      %        ,   G      %        ,         %        ,   -      %        ,         %        ,   D      %        ,         &        ,   #      &        ,   W      &        ,   k      )&        ,   r0      6&        ,   T      B&        ,   (      N&        ,   [      Z&        ,         f&        ,         t&        ,         &        ,   Xf      &        ,   V       &        ,   *c      &        ,         &        ,   h'      &        ,   O7      &        ,   .      &        ,   e:      &        ,         &        ,   ;      '        ,   O7      '        ,   \      #'        ,   ^      0'        ,         ='        ,   dc      J'        ,   %      W'        ,   2      d'        ,         q'        ,         ~'        ,         '        ,   !      '        ,   (      '        ,   ("      '        ,   8      '        ,         '        ,         '        ,   J      '        ,   1      	(        ,   R      (        ,   ;      4(        ,   C      A(        ,   ;      (        ,   :      (        ,   [      (        ,   /      (        ,         (        ,   Q5      (        ,   E,      (        ,   )      )        ,   %      )        ,         )        ,   AH      #)        ,    V      /)        ,   (      ;)        ,   V@      F)        ,   R      Q)        ,         \)        ,   +      g)        ,         s)        ,   E      )        ,   	      )        ,   .      )        ,         )        ,   0^      )        ,   U      )        ,   a      )        ,         )        ,   R      *        ,   zY      *        ,   0^      *        ,   E      )*        ,         6*        ,   \(      A*        ,   $      M*        ,   (      Y*        ,   R      e*        ,   9      q*        ,         }*        ,   Q=      *        ,         *        ,         *        ,         *        ,   /       *        ,   ("      *        ,         *        ,   J      +        ,   .      +        ,   V      +        ,   !      )+        ,   V      6+        ,   db      A+        ,   dE      L+        ,   S      X+        ,   @f      d+        ,   i5      p+        ,   @W      |+        ,   a      +        ,   5      +        ,         +        ,   BV      +        ,   5      +        ,   b      +        ,   ("      	,        ,   X"      $,        ,         5,        ,   u&      A,        ,   H;      N,        ,   u&      Y,        ,   \      e,        ,   h2      q,        ,   m      },        ,   J      ,        ,   2      ,        ,   .      ,        ,   k      ,        ,   6      ,        ,   7      ,        ,   {S      ,        ,         ,        ,   =       ,        ,   =/      -        ,         -        ,   zD      -        ,   D      '-        ,   D      3-        ,   D      @-        ,   _      Y-        ,   N<      f-        ,         -        ,   c      -        ,   F      -        ,   T       -        ,         -        ,         -        ,   K1      -        ,   b      -        ,   G0      -        ,   <      -        ,   ,      .        ,   ]      .        ,   @      '.        ,         2.        ,   Q      =.        ,   "5      I.        ,         U.        ,         a.        ,   M      m.        ,   k"      y.        ,         .        ,         .        ,   "5      .        ,   I      .        ,   ^      .        ,   j%      .        ,   1      .        ,   !      /        ,   X      #/        ,   		      ./        ,   a      9/        ,   3      E/        ,   Q      Q/        ,         ]/        ,   FY      j/        ,   S      u/        ,   L      /        ,         /        ,   H      /        ,         /        ,   P      /        ,   (      /        ,   ML      /        ,   9      /        ,   !@      /        ,   1      0        ,   Z      0        ,   I      %0        ,   -      20        ,   x(      ?0        ,   ;      L0        ,   O      Y0        ,   /      f0        ,   dW      s0        ,   h      0        ,   5M      0        ,         0        ,   R      0        ,   4      0        ,   @      0        ,   Ea      0        ,   U      1        ,         1        ,   c      1        ,   %2      /1        ,   -      ;1        ,   v      P1        ,   D      \1        ,   ?      h1        ,   '      t1        ,   #      1        ,   P      1        ,   -      1        ,   v      1        ,   #      1        ,   -      1        ,   v      1        ,         1        ,   M      2        ,   E*      2        ,   C      "2        ,   U      72        ,   =F      X2        ,   v      d2        ,   V      p2        ,         2        ,   '      2        ,   2      2        ,   T      2        ,   U      2        ,   WN      2        ,   HS      2        ,   )]      2        ,   -*      2        ,   F      3        ,          3        ,   6      3        ,   )Q      +3        ,   %      63        ,   =      A3        ,   I      M3        ,         Y3        ,   0      f3        ,         q3        ,         }3        ,         3        ,   9      3        ,   
      3        ,   8+      3        ,   S      3        ,   s+      3        ,   *      3        ,   D      3        ,         3        ,   K      3        ,   a      3        ,   G      4        ,   =      &4        ,   *      34        ,   ,      @4        ,   a      L4        ,   oT      e4        ,   5      r4        ,   L      4        ,   \      4        ,   ]2      4        ,         4        ,   #      4        ,   K      4        ,   "L      4        ,   Q      4        ,   Q      4        ,   _      4        ,   P
      5        ,   O      5        ,   v:      5        ,   6      ;5        ,   ;      G5        ,         S5        ,          k5        ,   6      5        ,   V      5        ,    ;      5        ,   D      5        ,   c       5        ,         5        ,   #      5        ,   ;      5        ,         6        ,   )J      6        ,   "      )6        ,   M      56        ,   p_      A6        ,         N6        ,   ^      Y6        ,   Q      d6        ,   bd      p6        ,   !4      |6        ,   "      6        ,   ><      6        ,   D      6        ,   	      6        ,   Q      6        ,   V      6        ,   ("      6        ,         6        ,   f      6        ,         6        ,   `3      7        ,   D      7        ,         7        ,         +7        ,   .      77        ,   K      _7        ,         k7        ,   B      w7        ,   '      7        ,   ]      7        ,   G      7        ,   U`      7        ,         7        ,   #      7        ,   JR      7        ,   %      7        ,   #      7        ,   ,      8        ,   X      8        ,   ]L      8        ,   '&      )8        ,   *X      58        ,   /%      A8        ,   P.      M8        ,   Y      Y8        ,   C      e8        ,   '      8        ,   f      8        ,   "      8        ,   b      8        ,   >      8        ,   "A      9        ,   \      9        ,   0^       9        ,   0      ,9        ,   p_      89        ,   Ub      D9        ,   >      P9        ,         \9        ,   `\      h9        ,   g\      {9        ,   /      9        ,   :      9        ,   Z/      9        ,   (      9        ,   ;      9        ,   S      9        ,   '      9        ,   *9      9        ,   b      :        ,   $      :        ,         :        ,         ':        ,   V      3:        ,   rD      ?:        ,   *      K:        ,   '      }:        ,   S9      :        ,   F'      :        ,         :        ,   19      :        ,   [      :        ,   63      :        ,   	W      :        ,   Z      :        ,   N       ;        ,   V      ;        ,   4      ;        ,         $;        ,         0;        ,   h#      <;        ,         H;        ,         T;        ,   Z      `;        ,   Q      l;        ,         ;        ,   5F      ;        ,   q#      ;        ,         ;        ,   3      ;        ,          ;        ,   _*      ;        ,   Y       <        ,    $      <        ,   b      <        ,   `      '<        ,   ;      4<        ,   V?      A<        ,   U      P<        ,   I?      p<        ,         }<        ,   	      <        ,   .2      <        ,   (      <        ,   !      <        ,   {      <        ,   #      <        ,         <        ,   }#      <        ,   #      <        ,         =        ,   4[      =        ,         =        ,   {      *=        ,         7=        ,   #      F=        ,   a      U=        ,   3      b=        ,         o=        ,         |=        ,   T      =        ,   ;      =        ,   LH      =        ,   ]      =        ,   7      =        ,   '      =        ,   ,      =        ,         =        ,   Y      =        ,   8-      >        ,   c      >        ,         >        ,   bU      ,>        ,         :>        ,   E      G>        ,   -      `>        ,   ]      o>        ,         }>        ,   -      >        ,   R>      >        ,   $Z      >        ,         >        ,   #      >        ,         >        ,   e      >        ,   G      >        ,   i      
?        ,   F(      ?        ,   r9      &?        ,   O0      4?        ,   kQ      B?        ,         P?        ,          ^?        ,   %      l?        ,         z?        ,   +6      ?        ,   )      ?        ,   aC      ?        ,         ?        ,   AT      ?        ,   -      ?        ,   [      ?        ,         ?        ,   k      ?        ,   .      @        ,   ]      @        ,   2'      "@        ,   k/      0@        ,         >@        ,   I      M@        ,         [@        ,   Z      i@        ,   c      w@        ,   ]8      @        ,   J      @        ,         @        ,         @        ,         @        ,         @        ,   3      @        ,   /8      @        ,         A        ,   T       A        ,   E      9A        ,   -"      GA        ,   #      TA        ,   Ub      aA        ,   oS      nA        ,   $      {A        ,   6S      A        ,   BP      A        ,         A        ,   L      A        ,          A        ,   2      A        ,         A        ,   9Z      A        ,   '      A        ,         A        ,         
B        ,   Y      B        ,         $B        ,   9      1B        ,   >      >B        ,   9      KB        ,   F      XB        ,   H      eB        ,   Y      rB        ,         B        ,   *
      B        ,         B        ,         B        ,   ,      B        ,   Y      B        ,   *      B        ,   #      B        ,   x      B        ,   /      B        ,   XH      C        ,         C        ,   v)      C        ,   +      (C        ,   (      5C        ,   }I      BC        ,         OC        ,   e      ]C        ,   <      kC        ,         C        ,         C        ,   &6      C        ,   _      C        ,         C        ,   ,H      C        ,   5^      9D        ,   F      JD        ,   -      WD        ,   %      dD        ,   =      qD        ,   Y      ~D        ,   HF      D        ,   0^      D        ,         D        ,         D        ,         D        ,   M      D        ,   p
      D        ,   "      D        ,   !      D        ,   zL      E        ,   O      E        ,   Z1      !E        ,   -`      .E        ,         ;E        ,   %      HE        ,          UE        ,   [      bE        ,   oL      oE        ,   =      |E        ,   #      E        ,         E        ,   z]      E        ,   f      E        ,   W      E        ,   TL      E        ,   K      E        ,   :      E        ,   `      E        ,   v      E        ,   _      F        ,   4       F        ,   c      &F        ,   Z      3F        ,         @F        ,   *a      MF        ,   D      ZF        ,   z\      gF        ,   
      tF        ,   >      F        ,   _      F        ,   [$      F        ,   M      F        ,   TE      F        ,   E[      F        ,   x"      F        ,   N      F        ,   d      F        ,   ?      F        ,   L      G        ,   `      G        ,            G        ,   &      -G        ,   Y      ;G        ,   W      HG        ,   H      UG        ,   %      bG        ,   4[      oG        ,   V      |G        ,   {C      G        ,         G        ,   ?      G        ,   X      G        ,   #      G        ,   5      G        ,   %      G        ,   5      G        ,   $       H        ,         H        ,   ra      "H        ,    3      /H        ,         <H        ,   "      IH        ,   #      VH        ,   ,      cH        ,   %      wH        ,   ,      H        ,   =)      H        ,   "
      H        ,   |K      H        ,   mH      H        ,         H        ,   *      H        ,   d+      H        ,   }-      H        ,   Y      H        ,   l      I        ,   D2      I        ,   >       I        ,   S      -I        ,   SF      EI        ,   c      RI        ,   -      `I        ,   '\      I        ,   ?      I        ,   ]      I        ,   <      I        ,   F6      I        ,   *      J        ,   !       &J        ,   e      1J        ,   x      <J        ,   M      GJ        ,   L      RJ        ,   
      ]J        ,   bH      nJ        ,   n      yJ        ,   8      J        ,   w?      J        ,   B      J        ,   GJ      J        ,   [)      J        ,   D      J        ,   0      J        ,   @      J        ,   1      J        ,   H;      K        ,   <      K        ,         (K        ,   dR      4K        ,   e      @K        ,   ^      LK        ,   AJ      dK        ,         pK        ,   Y      |K        ,   #      K        ,   	      K        ,   Ub      K        ,   X      K        ,   {
      K        ,   ^      K        ,   B      K        ,   1      K        ,         K        ,   (      L        ,   ;      EL        ,   e      ]L        ,         uL        ,   #      L        ,   >      L        ,   '      L        ,   l.      L        ,         L        ,   ^      L        ,         L        ,   +      	M        ,   v      M        ,   P      !M        ,   +      .M        ,   H      FM        ,   Y      RM        ,          _M        ,   [      kM        ,   &V      wM        ,   O#      M        ,         M        ,         M        ,   K      M        ,   ;      M        ,   G      M        ,   #      M        ,         M        ,   vS      
N        ,   Q      N        ,   Y      "N        ,   p_      :N        ,         MN        ,   &_      eN        ,   ^      qN        ,   Z      }N        ,   4      N        ,   N      N        ,   &      N        ,   ?      N        ,   l      N        ,   Z      N        ,          N        ,   [.      N        ,   l      N        ,   *U      O        ,   B       O        ,   bK      +O        ,         >O        ,   K      IO        ,         UO        ,   +.      aO        ,   V      mO        ,   [      yO        ,         O        ,   /3      O        ,   .      O        ,   Z      O        ,   A      O        ,   ;      P        ,   hM      P        ,   '       P        ,   K      ,P        ,         8P        ,   #      PP        ,   /      \P        ,   E      P        ,   8      P        ,   LG      P        ,   Q      P        ,   U      Q        ,   :      Q        ,         Q        ,   [.      )Q        ,         5Q        ,   .      Q        ,          R        ,   C      R        ,   K      R        ,   O	      R        ,   `      R        ,   5      +R        ,   '      7R        ,   "'      CR        ,   "      OR        ,   :      [R        ,   3      R        ,         R        ,   W      R        ,         R        ,   2J      R        ,   0      R        ,   ;      R        ,   P      S        ,   qY      S        ,   E      S        ,         %S        ,   h      1S        ,   L      =S        ,   Y      IS        ,         US        ,   ^%      S        ,   3      S        ,   ]      S        ,   7      S        ,   u      S        ,   Y      S        ,   \Y      S        ,   ze      S        ,   I      S        ,   c      S        ,   \       T        ,         T        ,         T        ,         !T        ,   T      ,T        ,   47      7T        ,   P      BT        ,   S      MT        ,   E      XT        ,   *4      cT        ,   eG      ~T        ,   L      T        ,   @      T        ,   Y      T        ,   /      T        ,   r1      T        ,   @+      T        ,         U        ,         U        ,   X      U        ,   :      U        ,   6(      U        ,   3      U        ,   :      U        ,   "      V        ,   J      V        ,   P      #V        ,   {=      /V        ,   c      ;V        ,         GV        ,   @      SV        ,         _V        ,   8      kV        ,   U      wV        ,   1      V        ,   #1      V        ,         V        ,   7      V        ,   a      V        ,   0,      V        ,   oT      V        ,   "      V        ,   @+      V        ,         W        ,   =      W        ,    $       W        ,         ,W        ,   Cb      8W        ,   7      DW        ,         PW        ,   \      \W        ,   [      hW        ,   7      uW        ,   CS      W        ,   U      W        ,   ^      W        ,   P      W        ,   r"      W        ,   +      W        ,   BU      W        ,   0      W        ,         X        ,   p_      X        ,   7      @X        ,   1      LX        ,   Z      XX        ,         dX        ,         pX        ,   <      |X        ,   _      X        ,   '      X        ,   O:      X        ,         X        ,   p_      X        ,   _      X        ,         X        ,   ``      X        ,   #      X        ,   G      Y        ,   Y      'Y        ,         3Y        ,   E      ?Y        ,   #      KY        ,   I      WY        ,   K      nY        ,   a      zY        ,   e       Y        ,   q,      Y        ,         Y        ,   \      Y        ,         Y        ,   n3      Y        ,         Y        ,   Z      Y        ,   E      Z        ,          Z        ,   l       Z        ,   *U      Z        ,   G      Z        ,   1      Z        ,   K%      Z        ,   3      [        ,   d9      [        ,   I      [        ,         '[        ,         4[        ,   .      @[        ,   K      S[        ,   Y      _[        ,         k[        ,   G      w[        ,   =      [        ,         [        ,   yH      [        ,   9      [        ,   Y      \        ,   3      \        ,   <a      (\        ,         g\        ,   C      s\        ,         \        ,         \        ,   R      ]        ,         ]        ,   +      !]        ,   #!      ,]        ,   E      7]        ,   ;      B]        ,   F      M]        ,   ZG      Y]        ,   O      e]        ,   `      q]        ,   S      ~]        ,         ]        ,   AJ      ]        ,         ]        ,   ("      ]        ,   1      ]        ,   (F      ]        ,   Td      ]        ,         ]        ,   v      ^        ,   K      ^        ,   8      ^        ,   S      "^        ,         -^        ,   F\      8^        ,   G      D^        ,   :      Q^        ,   [      \^        ,          i^        ,   (      v^        ,   S      ^        ,         ^        ,         ^        ,   7=      ^        ,   /	      ^        ,   K-      ^        ,   k7      ^        ,   {      ^        ,   2>      ^        ,   	      ^        ,   $W      _        ,   z      _        ,         _        ,   9      ,_        ,         9_        ,   |3      F_        ,   '      S_        ,   
      `_        ,   X      m_        ,   O      z_        ,   
      _        ,   $      _        ,   I      _        ,   #      _        ,   .      _        ,    U      _        ,   5      _        ,   U      `        ,   ,f      %`        ,   4      2`        ,   [      ?`        ,   J      M`        ,   ub      [`        ,   Z      i`        ,   e      w`        ,   !K      `        ,   :"      `        ,         `        ,   B      `        ,   <      `        ,   G      `        ,   >      `        ,   	      `        ,   (      a        ,   I`      a        ,   9      a        ,   VU      -a        ,   2      ;a        ,   oS      Ia        ,         Wa        ,   \'      ea        ,   lR      va        ,         a        ,   <      a        ,   S      a        ,   <      a        ,   X]      a        ,         a        ,   
`      a        ,   3      a        ,   Z      a        ,   ,:      a        ,         a        ,   8      a        ,   :      b        ,   '      #b        ,   );      1b        ,   #      ?b        ,   0,      Lb        ,   Ad      Yb        ,         mb        ,   e,      |b        ,         b        ,   3L      b        ,         b        ,   /      b        ,         b        ,   &      b        ,   3$      b        ,         b        ,   gf      	c        ,   H      c        ,   #      'c        ,   E      4c        ,   b0      Bc        ,   8      Oc        ,   ^;      _c        ,   L      oc        ,   k      |c        ,         c        ,         c        ,   .      c        ,   5      c        ,   X6      c        ,   B
      c        ,   _      c        ,         c        ,   .      c        ,   >L      d        ,   7      d        ,   =      .d        ,   BZ      >d        ,         Nd        ,   X      ^d        ,   8      nd        ,   ?      {d        ,   "E      d        ,   e      d        ,   \      d        ,   e      d        ,         d        ,   >      d        ,         d        ,   6
      d        ,   G      e        ,         e        ,         e        ,   E      'e        ,   #      4e        ,   )      @e        ,         Le        ,   D      Xe        ,   *      de        ,   ;      pe        ,         |e        ,         e        ,   iN      e        ,   7      e        ,   >R      e        ,         e        ,         e        ,   G      e        ,         f        ,   '      f        ,   4      *f        ,   D%      Nf        ,         [f        ,   #      hf        ,   /      tf        ,         f        ,   8      f        ,   b      f        ,   5      f        ,   dO      f        ,   +-      f        ,   %P      f        ,   B      f        ,   _      f        ,         f        ,         f        ,   qX      
g        ,   K      g        ,   }<      "g        ,         .g        ,   #      :g        ,   )      Fg        ,   R      Rg        ,   G      ^g        ,         jg        ,   XD      vg        ,   ]      g        ,         g        ,         g        ,         g        ,   1Y      g        ,   W      g        ,         g        ,         g        ,   1      g        ,   K%      5h        ,   @      Ah        ,         Yh        ,   6      eh        ,         qh        ,   :      }h        ,   ?      h        ,   @Q      h        ,   G      h        ,         h        ,   XD      h        ,         h        ,         h        ,   oS      3i        ,   1Y      Ci        ,   $      Ni        ,   =      [i        ,         hi        ,   oS      ui        ,   R      i        ,   (      i        ,         i        ,   d      i        ,   R      i        ,         i        ,   2      i        ,         i        ,   6      j        ,   d      j        ,          j        ,   K      -j        ,   G      :j        ,   (      Gj        ,   9      Tj        ,   HE      aj        ,         nj        ,         {j        ,   'D      j        ,   yH      j        ,   b      j        ,         j        ,   1      j        ,   K%      4k        ,    A      @k        ,   H      k        ,   7O      	l        ,         l        ,         $l        ,         -l        ,   RC      Pl        ,   )      [l        ,   9,      fl        ,   \'      ql        ,   (      }l        ,   xQ      l        ,         l        ,   R      l        ,   ,f      l        ,   !      l        ,   {$      l        ,          l        ,   U      l        ,         l        ,         m        ,   T      m        ,   ?      m        ,   Z      +m        ,   1e      9m        ,   :      Fm        ,   `      Sm        ,   e      `m        ,         mm        ,   D      zm        ,   {T      m        ,   C      m        ,   	      m        ,   1      m        ,   a      m        ,   /      m        ,   |      m        ,   XD      m        ,   X7      m        ,   `      n        ,         n        ,         &n        ,         4n        ,   F>      Bn        ,   %d      On        ,   $      n        ,   $b      n        ,         n        ,   p_      n        ,   Z      n        ,   `      n        ,   #      n        ,         o        ,         o        ,         o        ,   T      1o        ,         >o        ,   P      Jo        ,         ]o        ,   O      ho        ,   T-      so        ,   K      o        ,   3      o        ,   "      o        ,   W      o        ,   <      o        ,   )      o        ,   b      p        ,   #      p        ,         p        ,   3      +p        ,         8p        ,   HD      Dp        ,         Pp        ,   G      ]p        ,   d      ip        ,   H      up        ,   }R      p        ,   Y      p        ,   rf      p        ,   I      p        ,   S      p        ,   H      p        ,         p        ,         p        ,         p        ,   rQ      p        ,   8      p        ,         "q        ,   $      9q        ,   	      ^q        ,   <      jq        ,   :      vq        ,         q        ,   u_      q        ,   Q      q        ,   %      q        ,   N      q        ,   !      q        ,   E      q        ,   M      q        ,   x2      q        ,   8      q        ,   .      r        ,   8      r        ,   M      r        ,         $r        ,   _      hr        ,   W      tr        ,   !      r        ,   rQ      r        ,   ,N      r        ,         r        ,   8      r        ,   :      r        ,         r        ,   5      r        ,   Y      s        ,   !       s        ,   M      -s        ,   @      :s        ,   G      Gs        ,   0^      ds        ,   }R      ps        ,   T      |s        ,   e      s        ,   *      s        ,   !      s        ,   M      s        ,         s        ,   ;      s        ,         s        ,   T      s        ,   _S      s        ,   u      t        ,   KZ      t        ,   P      t        ,         %t        ,         1t        ,         >t        ,   k=      It        ,   JX      ]t        ,   iC      it        ,   )      t        ,   X
      t        ,   W\      t        ,         t        ,   L      t        ,   f
      t        ,   +Z      t        ,         t        ,   8I      u        ,   ("      u        ,   ;      4u        ,   #      Au        ,   ;      Wu        ,   9%      ju        ,   T      u        ,   vS      u        ,   E$      u        ,         u        ,         u        ,         u        ,   >      u        ,   8U      v        ,   $      v        ,   ,O      v        ,   E      <v        ,   =N      Ov        ,   ^      Zv        ,   2      fv        ,   U)      uv        ,   E      v        ,   BG      v        ,   $c      v        ,   tG      v        ,   A`      v        ,   3b      v        ,         v        ,   }%      v        ,   (      v        ,   Y      v        ,   7      w        ,   Y*      w        ,   7      $w        ,   X      1w        ,   "      >w        ,   *      Kw        ,   
E      Xw        ,   _      fw        ,   n      sw        ,   !-      w        ,         w        ,   S      w        ,         w        ,   1#      w        ,   3      w        ,   V      w        ,   
      w        ,   /      w        ,   U      w        ,   I      x        ,   e      x        ,         )x        ,   \T      7x        ,   G:      Ex        ,   kD      Tx        ,   (      ix        ,   <      wx        ,   ^      x        ,          x        ,   LU      x        ,         x        ,   N      x        ,   )      x        ,   Cb      x        ,         x        ,   ^      x        ,   R      x        ,   G!      	y        ,   ]      y        ,   >6      !y        ,   B      -y        ,         9y        ,   b      Ey        ,   ie      ]y        ,          ly        ,   ?\      yy        ,         y        ,   dJ      y        ,   fa      y        ,    I      y        ,   &      y        ,         y        ,   32      y        ,         y        ,   #      y        ,   `      y        ,   8      z        ,   .      z        ,   ,      #z        ,   1E      0z        ,         =z        ,   *      Jz        ,   -      Wz        ,   .      dz        ,   I      qz        ,   8T      ~z        ,   Y      z        ,   F      z        ,   	      z        ,   L      z        ,   &      z        ,   %      z        ,   C      z        ,   X      z        ,   #      z        ,   d      {        ,   R      {        ,         #{        ,   o      2{        ,   )      @{        ,   +!      N{        ,   X      \{        ,   M      j{        ,         x{        ,   	      {        ,   6      {        ,   IN      {        ,   QM      {        ,   X      {        ,   6G      {        ,         |        ,   /7      |        ,   =      P}        ,         [}        ,         g}        ,   :      t}        ,   #      }        ,         }        ,   S      }        ,   rM      }        ,   D      }        ,          }        ,   #      }        ,         }        ,   *      }        ,   /7      ~        ,   ;      ~        ,         #~        ,   D      /~        ,   @      P~        ,   B      ~        ,   (      ~        ,   m      ~        ,   0      ~        ,   JT      ~        ,   3&      ~        ,   `      ~        ,   :      ~        ,   uN      ~        ,   )      ~        ,   5      ~        ,         (        ,   $      9        ,   _      ?        ,   Z      E        ,   C      L        ,   u      X        ,         d        ,   M      p        ,   +0      }        ,   e              ,   4R              ,   8U              ,   E              ,   3              ,                 ,   y              ,   W              ,   X              ,   6.               ,   ;3              ,                 ,         "        ,   0      .        ,   W      :        ,   +      F        ,   8      R        ,   :      ^        ,   nV      j        ,   QG      v        ,                 ,   `<              ,   [              ,   5              ,                 ,   w.              ,                 ,                 ,   [              ,   K_              ,   1I              ,   2              ,   R              ,                  ,         ,        ,   ~      8        ,   f      D        ,   @      P        ,   C      ]        ,   "^      i        ,   5      u        ,                 ,   w.              ,   e              ,   =              ,   [              ,                 ,   K_              ,                 ,   2              ,   R              ,   ^              ,                 ,   ~              ,   f              ,   @      *        ,   C      6        ,         Y        ,         g        ,         t        ,   C              ,   ,[              ,   C              ,   P6              ,   '              ,   g-              ,   _              ,   GL              ,   RV              ,   G              ,   t[              ,   R^      &        ,   J      1        ,          =        ,         I        ,   Q'      U        ,   C      a        ,   5      n        ,   >=              ,                 ,   [              ,   0              ,                 ,   2              ,   @              ,   5              ,   
Q              ,   6              ,   .      	        ,   y              ,         !        ,   3Q      -        ,   "      9        ,   V      E        ,   +      Q        ,   T      ]        ,   Z      j        ,   &Y      v        ,                 ,   Q              ,                 ,   C              ,                 ,   Q'              ,   C              ,   f              ,   _              ,                 ,   FI              ,   u      
        ,                 ,   V      +        ,   I=      9        ,   a      E        ,   j;      t        ,   7@              ,   I=              ,   k6              ,                 ,                 ,   L              ,   f&              ,                 ,   #G              ,         -        ,         :        ,   ,      G        ,   V      T        ,         a        ,   d      n        ,   &      {        ,   O!              ,   I              ,                 ,                  ,   >              ,   11              ,   TW      "        ,   <      /        ,   w`      <        ,         I        ,   Y      V        ,   ^      c        ,   k?      p        ,   69      }        ,   X[              ,   =              ,   a              ,                 ,   1              ,   0              ,   U              ,                 ,                 ,   K2               ,   r<              ,   c              ,   4      '        ,   A1      4        ,   %      A        ,   {M      N        ,   Jb      [        ,         h        ,   -              ,   S;              ,   Y              ,   k)              ,                 ,   L              ,   	8              ,   _      $        ,   ^      1        ,   M      >        ,   AK      K        ,   ;      X        ,         e        ,   @      r        ,   9b              ,   \              ,   +              ,   4	              ,                 ,   0              ,   d_              ,   u8              ,   #              ,   b              ,   kP              ,   H              ,   $              ,         (        ,   Q      5        ,   (      b        ,   ?M              ,   ".              ,                 ,   m(              ,                 ,   `              ,   /              ,   |>              ,   !      $        ,   `      0        ,   o      F        ,   D@      R        ,   M      ^        ,   ]	      k        ,   jL      v        ,   C              ,                 ,   l+              ,   \              ,   <8              ,   O              ,                 ,   T8              ,   )              ,   B               ,   H              ,   bK              ,   [              ,         ,        ,   )      9        ,   /3      F        ,   f]      S        ,          `        ,   aN      m        ,   xP      z        ,   -              ,   R              ,   O              ,   '              ,   X              ,   1              ,   =              ,   /              ,   +              ,   `      	        ,   ?              ,   IC      #        ,         0        ,   ?E      =        ,         J        ,   .      W        ,   H      d        ,   !      q        ,   	              ,   r              ,   8              ,   d              ,   h<              ,                 ,   <              ,   -P              ,   &              ,                 ,   N              ,   #      "        ,   *      <        ,   63      I        ,   =      W        ,          d        ,   AJ      q        ,   Z      ~        ,   D              ,   id              ,   J               ,                 ,   I              ,   92              ,                 ,   .              ,   $              ,         5        ,   E      B        ,   s7      O        ,   I      \        ,   6      i        ,   _      v        ,   W              ,   d              ,   @e              ,   #*              ,   $(      V        ,   O      b        ,   K      n        ,   6      z        ,                 ,   (              ,   ^              ,   6              ,   7              ,   B               ,   K              ,   zX              ,   P"              ,   (<              ,   %      $        ,         1        ,   X      >        ,   U2      K        ,   W      X        ,   ?>      x        ,   0              ,   n:              ,   H              ,   j;              ,   Z/              ,                 ,   6              ,   Ie              ,                 ,   m              ,   %              ,   T      (        ,   6      5        ,   ("      B        ,   9      O        ,   *      \        ,   5      i        ,   >#      v        ,                 ,   7              ,   ?              ,   f              ,                 ,   t              ,   ,              ,   #              ,   4              ,   =              ,                 ,   #              ,   O,      &        ,   d[      3        ,         @        ,         M        ,   +.      Z        ,   
2      g        ,   V      t        ,   8              ,   U              ,   a              ,   	M              ,   T              ,                  ,                 ,   @               ,                 ,   %+      (        ,   1]      5        ,   jK      B        ,   @	      O        ,   M      c        ,   yW              ,   n]              ,   
      U        ,   d              ,   :              ,   P              ,   H              ,                 ,   yE      ^        ,   A      j        ,   N$      v        ,   U0              ,   bT              ,   4P              ,                 ,   /              ,                  ,   d              ,   u              ,                 ,   
              ,                 ,   P      )        ,   \      5        ,         A        ,   Z      Y        ,         e        ,   (      r        ,   *      ~        ,                  ,   l              ,                 ,   ^              ,                 ,                  ,   l              ,   +              ,                 ,   +I              ,   *U      g        ,   q@              ,   C              ,   J              ,   aD              ,                 ,                 ,   }R              ,   $      	        ,   "              ,   !      !        ,   X      -        ,         9        ,   *      L        ,   ?      W        ,   &      d        ,   '      p        ,   a      |        ,                 ,   !              ,                 ,   P              ,   KZ              ,   k`              ,   y               ,                 ,   d              ,   V              ,   9E              ,   )      !        ,   x      9        ,   0      E        ,   Y      Q        ,   9      ]        ,   B      j        ,   Z!      ~        ,                  ,   '              ,   0              ,   V              ,   !              ,                 ,   P              ,                 ,   #              ,                 ,         !        ,   D      -        ,         9        ,   c      Q        ,   <      ]        ,   )      p        ,                 ,   DC              ,   b              ,   'N              ,   Y              ,    Y      )        ,   3      5        ,   'N      M        ,   }R      f        ,   Y      r        ,   'N              ,   n8              ,   -              ,   M              ,   H              ,   'N              ,   (      $        ,   'N      w        ,                 ,   'N              ,   }R              ,   
              ,   E              ,   )              ,   'N              ,   -      $        ,   B9      .                 N        (           S        ,   LG      ]        (   I       b        ,   Z/      l        (          q        ,   %      ~                             L              ,   '              ,   :              ,   ?5                       	        (                 (   J              ,   ;      '        (         6        (   (      ;        ,         U        ,   \      _        (   q                               *   `               *                  (                 (                                  *                                                    *                  *                  (   9      *                 2        *   P      V           x                                                   T                                                                 *                                  (                 (                          4           (      B           \      P        ,   8      Z                   z        (                 (   J              ,   ;              (                 ,   9E              (                 ,                 (                 ,   >              ,   Y              (   H              ,   :               ,                 ,   :              ,         ,           8       M                  n                                                                                                                               A                  S           0      t           <                 <              *                   *   0               (   ~              (                    <                 p                 X                   h                                           '                  4           0      B        ,   +      R        ,   )      ^        ,         ~        ,                 ,   >              ,                 ,   $?              ,   I              ,   A              ,   [              ,                 ,   ;V      )        ,   m>      C        ,   A      X        ,   [      d        ,         p        ,   ;V      ~        ,   :?              ,   /              ,                 ,   {[              ,   #              ,   Y              ,   :              ,                 ,   M              ,   #      (        ,   9      B        ,         T        ,   F      `        ,   K      z        ,                 ,   d!              ,   d!              ,   a              ,   a              ,   r;              ,   r;              ,   }*              ,   }*              ,   3c              ,   3c              ,   4              ,   4              ,   Q              ,   Q              ,                 ,                 ,   U              ,   U              ,   2              ,   2              ,   0              ,   0              ,   fI      	        ,   fI              ,                 ,                 ,                 ,         &        ,   1      *        ,   1               &                                                           .                               d         .           h                           .                              .symtab .strtab .shstrtab .rela.text .data .bss .rela.debug_info .debug_abbrev .debug_loc .rela.debug_aranges .debug_ranges .rela.debug_line .debug_str .comment .note.GNU-stack .rela.debug_frame                                                                                           @       X                                   @               @@                               &                                                          ,                                                          6                            1                             1      @                B                               B                                                         P                      ^                                   `                      n      0                              [      @               @     0          	                 o                                                                               ~      M
                             }      @                A                                      0                     f                                  0               f5     2                                                   5                                                          5                                         @               8A                                                      6     0         0                 	                      <                                                        A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ELF                                       @     @   {? q   T R   {_   { q   T* R*   {_ |{      @ 7  !@A  6 ~_   R`  *_{ B    *{_ R * _ ka  T_{ B    _ k AT{_{  * Rb~{s Q    s{ hs   `h3@{_{ S  *! R       @     !L!n.  LtV)   a@!@  ` SA@{_{ S [c  @  7 QB *~{d@  5 SA[BcC{_ k Thx**~ Kd B  5? R** { RR   c     {_|  4{ cX QS[ k*s**{ k T**Ks *o *`?o@    @  )`   ***   @ ) |)`~  @j95 Q{`jt   `j4  RSA[BcCkDsE{_ _{*    S   R    *  4   Rc  R   *SA{_{h S  [f@  cL*nm$ R* * k T    * 5@gm
 R R@? k T*SA[BcC{_@ @c   cC Cc| |    !b@D  N$BLBnB k TAykk c zacC! !Cc|!|!    T 
KZj @*!LS! B@w@ T  "Rc       !        @*]R   B    ,)   *  ) _@a  5  R_ @ {  @A@  @   R@ @ @C@A)! !?!|S kb  T  R  a KA    A@@  ! QA A  4  R{_<@& 5 {       r T(@@A  5F@8 0@A)    K &@&  <   R{_  R_  R{r S | *| )|    T   9R      tB SA{_{ S @ @?    T   HR      `@ aG)b@  K! a)`B@` 6a@! @@ 6  r P@ 5 B;@87  @9  5aJR           R 9  R     rP@  5  @ r@  T   ~ ~SA{_{ S        RSA{_ r@ TG)*  B  !  Ks )  R{ S [    u r@ T  @@  @v!L ~!nm3  *@ Cs L|>@B@b  6  R   @ L n LgZs C |`2 :@     RSA[B@{_@gZ! @L n L C | 0   R{ c#  R rc Rc *S c[   c    r T5B;B Rc*    r`  Tc Tc   5B#@SA[BcC{_7@ 3@~@  4     { R  {_{% R  {_{ R {_{% R {_sg_assign_page  ../include/linux/scatterlist.h BUG: failure at %s:%d/%s()!
 ../lib/scatterlist.c 9       x                    
          $    -   F-   F4   U   C   $    N   -   j   -    $    Fj   j   	    
   $    	    
   $       $    	    
   $    	    
   yint    	    
j   $    	    
   $    2s8    2u8    2u16    2s32    2u32 j   2s64    2u64    zj   {	]            h      	    s  $    Fs  	    -   	       	    0j   	    1j   	    G  	    Hh       -    	    Vh  	    W   	    Xh  	    Yh  	    Z   	    [   N   	       	      	       	      	      	      	    f  $    	      	       	    -  	    6  	    ;  	    E  	    -   	    -   	    8  	    j   	    j   	    j   	    8             	      1      s    	          a      a       a   <                                                                     {	         G     |    3                         N   N  3     C            j             [      (-   U     3       
            [              3     _                                 (       7u      [u      u      u       u  (    u  0    u  8    u  @    v  H    1v  P    1v  X    Kv  `    ev  h    v  p    ev  x    v      v      v      v      )w      (      >w      v      gw      w      w      w      w     
    6      ;      <       =b*         s                
       
       
       
       
       
       
       
    [  a    j   ~                        
    M  
      
      
    3      j  (
      
   val "      "      "      8      
    "    I      !P       "n      $      &8       	n      
       s   I      E      FY       G   t   )      *       +       ,       --       .-          )(	            '      /       07	  fn L	   %   s  F	  F	   	  7	  	    (-       h.	      /-        0R	      1      2      3	       4   Pcpu 5   T    6  X    7   ` &    W      Xz       Y      Z      [j       \j       _|+       `   (    a  0    b-   8    c-   @    e   H    g   L    i   P    i   T    i   X    jj   \    kW  `bse l@U  h-rt m*V  (    oW  p}dl qV  x    |j       }       ~K          (    W  ,    <  0    W  @    N  H    <  h    >  x      -mm 9      9  ?    j       "      W      (                                   j       j   ?    j   ?    j   ?    j   ?    j       -    -pid E  (    E  ,      0      8    <  @    <  P      `    <  h    <  x    W      <      <      G      G      G       >      >      >      >       >  (       0    J  8    -   H    -   P    8  X    8  `    -   h    -   p    -   x    -       -       K             W      W      W      	       	          -fs X  	    X  	    G  	    $X  	    *X  	    ?  	    ?  	     ?  	    !B  	    #-   
    $  
    %?X  
    &   
    'EX  (
    (  0
    *PX  8
    ,?  @
    -j   D
    /rE  H
    2"  X
    3"  \
    6  `
    9  d
    =   h
    >  p
    @[X  x
    `  
    cfX  
    gqX  
    k|X  
    mX  
    oX  
    q-   
    rX  
    sG  
    X  
    <  
    X  
    X  
    <  
    X  
    X             <  8    -   H-rcu   P    X  `    $  h       x       |           -       -       -       -       -    	        ~    M-       4j       4j       7-   0    J5      K5       L        M    E  E  -    $    Hn                7    !L  %      &q     	    'z                               n    7       UA  c    B       @  V    7    L  ,          	      "h      #5       $"       %"          !  87   0       %h   dcpu )j    epmu        0    !2      !4        !6       !7       !9      !:       -              h!=  x19 !>-    x20 !?-   x21 !@-   x22 !A-   x23 !B-    x24 !C-   (x25 !D-   0x26 !E-   8x27 !F-   @x28 !G-   Hfp !H-   Psp !I-   Xpc !J-   ` 0    !M      !N       !O-   h    !P  p    !Q-       !R-       !S   	    "1      #'J      #(       #)<   7    #+#      $.o      $/j     	    $3V  f$      $V       $       $z  %b      %b    -     -     	    %b      %c      -    
    %  	    &8  	    &8  	    &?  	    &O  	    &S  B      8',u      '.-    %"  %#  %$$   V^$  0 B      (L       h(\      (]       (^-   ` <    -         @(j  x (k    N     I-         (      (Z        (Z        p(+      (+       (  P <  ;  -    	    (j       @(      (        (       (       (   <    -        h(  "pcp (F       (   @    (  A      -     a    j   (                    &    @(G      (K       (U      (_j   0    (a  8    (b  @    (h-   H    ({-   P    (-   X    (-   `    (-   h    (C   p    (   x    (-       (      (-       (-       (  @    (      (      (-   @    (  @    (      (      (      (-        (-       (Z       (j        (j   $    (   (    ([  ,    (  @@    (  @ -     -    s    -    &    @@(      (]  @     (n      (       (-       (-       (-       (       (J      (J      (       (   (    (  ,     J      -   
     -         (      (       (          H(6      (;       (A       6    Q  -    
    (<  J  @n  -      ~  -         )      )        (*2      *4       *5      *6<      *8  osq *;~        (+-      +s       +<      +  osq + ~      +%        ,F      ,    -  	    ,-      ,       ,Or  F  l      ,Pr      ,Qr      ,Rr  @    ,  -    -     4     -       
    ,  4     -   @-       
    ,
       -#      -j        -J       .1       /R-       /S-       /`       t                      0	O  .          $              79      <            <  @      P      X       `    [  d    <  h      x    j       +k      j              6k      Ak      <      -                       1t<  &    K-    
    1  
    1      2#      2$-        2%      2&         2*9      2+    ?  &    '^!      '_'       '`       'a"      'c(      'g-        'h-   (    'i-   0    'j-   8"pgd 'k(  @    'l  H    'm  L    'n  P    'o   X    'q  \    'r  `    't<      'z-       '{-       '}-       '~-       '-       '-       '-       '-       '-       '-       '-       '-       '-       '-    -brk '-       '-       '-       '-        '-   (    '-   0    '(  8    'C(      '(      '      '"      '-       '(      '      '(      '%      '[      '!   g     3H4"  id 4j        4      4   7    4!  )'07"      '1#      '8   .    #      79       [                          <  (      8    -   `    -   h    -   p     k  x    -       X            <         7"  )'=I#      '>-       '?      '@[   'n#  W    'oj    W    'pj    W    'qj      )'[#      'l  8I#      's    'Y#  %#       'u   )'K#      'Vj   8#      'wj    '<#  %#   %#   '$$      '<       '       '    )'|S$  Llru '}<  8#      'X$      '       S$  U'$      '-   ptl '      '$      '<       $      '$      '<       '       '    &     %  "f_u o       =      79       <m  (    "  0    #  8    $j   @    %  D    &  H    '  p    (On  x    )W      *n      ,8      .      1      5<      6<      8#   $  f '&  brb '       '-     '8&      '%      '<      ' C        ''      '-        '-       ''      ''      '       '	-   8    '9  @    '1  H    '-   P    '!&  X    ')<  x    '+'      '.'      '1-       '3%      '4   8&      '      @	 '      	0       	0      	1      	1      	1       	A1  (    	V1  0    	/z1  8 %'  '      '>'      '?       '@'   '  .    8'C(      'D       'E'      'F       'S3(      'T        'U3(      C(  -        'Y^(      'Z^(      n(  -    -   (  %  -   -   -   -    n(  &  -   (  -   )     (  '      (  <      5       (  G8      61(  (      7-       7-       8L8      8M9       8-   h    9%J)      9&-   	    9)2)      :       :[      :           ;$v)  	    <)  )  )  )   )       <d)      <e       <f<      <g)       )  
    <e)  
    <f)  
    <g)  
    <h)  
    <i)  
    <j)  
    <k)  	    2C*  I*     b*  b*  -      h*      5*      68*       7b*      8        0@*      A       Bb*  (     E*      Fb*        *      *  
    (  
    (R   
    (  
    (C  
    (      (@S+      (M-        (PS+   -   j+  j+  K-    ++  
    (rY+      =A+      =B+    |+      >j   +  l  j        ?3+  +      ?=+      ?>        ?@+      @>?X,      >@8       >A8      >B8      >C8      >D8       >E8  (    >F8  0    >G8  8     >Jc,  +  @>S,      >TC        >U       >V       >W       >X-        >Y-   (    >Z-   0    >[-   8 0    K>R-  rec >\-       >^j    K    >_j   K i,  -  K-   +     >a,      >b      >cj       >j   -   S-  -        @C-      A8      A9t-  4   9    j   AN-                    I   -  -    -      AU-      AWz-       B$.      B	        B
       B       Bj       BK      BK   -  4.  -        B$.  
    C  $  [.  -        K.      K.      D
       D        E.      E       E-       E  nid E        @E0%/      E1E/       E3E/      E6       E7s      E8-        E;<  (    E=K/  8 -   9/  9/  ?/   .  .  %/        F*v/      F+       F,       G/      G	/       G
   G[  /      	.-       	8-       	9      	:       	=       	C       	D       	E       	H       	I       	J       	U-       	V-       	X       	Y       	Z-       	r$  1  q0  -        	a0      0	0      	j        	-       	      	<      	-    pte 	0  (   0  '   0     0  '  0   |0  0  1  '  0   1     A1  '  -            1  C   V1  '   G1     z1  '  -   -   -    \1  9    j   HJ@2                                           	    
                                                                         K2  <       I   0    Ip2      Ip2    -   2  -   5     IV2      Io  I   2  3 2  
    I 2  
    	   
    	  
    	-   
    	   
    	   
    	   
    	   
    	  
    	v/  
    	v/       Js3      J
-        Jj       Jj       J      Jj        3  sgl 3       j       j    *3  	    3  3  3  j      	    3  3  3  j        %4  "sg 3       j       j               HL4      N<       O      P      Q      R3       Uj   8    Vj   <    Wj   @     K!4      K"4        K%4      K&4       K&4   4  4  HL5      L       L    UL%5  c    L   4       L:5  V5    M/[5      M0"   len M0"   )M.t5  8:5      M28       M-5  %[5       M45   t5         0M<5      M=s       M>s      M?s      M@s      MA5    s  5  -        MC5  )M!6      M      M       Mm6      Moj        Mpo      Mq4      Mr6      Mst5       Mt79  0    Mv=9  8    My%5  X    Mz9  `    M{<  h    M|-   p    M}  x    M<      M<      M<  d_u M6   !6  !6  &    079      /              ?       .?      !j       $k      %k      (6m       )<  (    *#  0    -  8    1-   @%Gk  H    =$  L    >  P    ?I  X    @I  h    AI  x    B      C       Dj       E      L-       M      O-       Q      R<      S<      T<  Xik      Y8  (    Z  0    [  4    \  8    `<m  @    aIn  H    b7"  P    f<   Xk      m       p       qg       t  ( 6     M9  -        @M9      M<       M<      M<      M<      M=       M%=  (    M%=  0    M;=  8    MZ=  @    M=  H    M=  P    M=  X    M=  ` M9  9  &    @@<      <       $             -              r  (    t  0    "t  8    (t  @    8t  H    -   P    -   X    6  `      h                       Ht      <      4      <            X      Yt            f      q       >      _t            j             "                     (    9  0       8    .  @                 )      g      Z  @    Z  @ -rcu       
     :     <  6  j    <     <  <  <   6  t5  <     <  <  <  j   C   <   5  <     =  <   =  %=  6   =  ;=  6  79   +=    Z=  6        A=      t=  t=  z=   `=  =      N=  mnt Nt=       N	6   =  e=     =  6  [   =  79  =  6  j    =  =  =  z=   =  =      M  
    M   N   '>  -        O       OK>  cap OK>       [>  -    	    O2>  [>      O+f>      O,f>      (PU>      PV        PW<      PX<   	    Q-       R"       R#       RQ       RR           S>  S?  val Sm    	    S>  S.?  val Sx    	    S?      X?                                            -        -   (      0      8"uid ?  H      P 9?  TW?  sig TX    	    TY?  	    U]  	    U@  	@  	    U  	    U;@  %@  h    Vd@      V       V	   	    V
A@  V9@      V:       V;   V?@      V@       VA       VB@      VCd@      VD    N   @  I-    VHA      VI       VJ      VKd@    VOVA      VP       VQ      VR       VS      VT   VXwA      VY       V]    VaA      Vbs   _fd Vc    VgA      Vh       Vi       Vjj    )pV5&B      V6&B      V<o@      VE@  L_rt VL@      VUA      V^VA      VdwA      VkA      6B  -        V0sB      V1        V2       V3       VlA   	    Vm6B      W       WB      W<       W?       W        WB      W@       W-       W0@      W?        WC  "sa WB    
    W,$  9    j   XLC                             X4{C  nr X6    ns X7qD      X8   0    YqD      YY       YY  drcu Y      Y       Yj       Y       Y$  (    Yj   0    Y qD  8    Y"t=  @    Y#6  H    Y$6  P    Y)I  X    Y*)  `    Y+.?      Y,       Y-       Y.j    {C  pid PX;D      X=       X>j       X@D  rcu XA       XBD  0 g  D  -    LC  D  -         XEwD      XGE      XI   pid XJE   wD      Xe{C      (ZaE      Z       Z-      Z<      ZaE          Z       [E      [        [E       E      \        ]E      ]	       ]
J)       ]E      ]        ]E   E  9    j   ^,F                @^lhF      ^mE       ^nJ)       ^o}F  (    ^pF  0    ^q-   8 E  wF  wF   F  hF      @^F      ^G       ^       ^P      ^E      ^J)       ^G  (    ^J)  0    ^J)  8 F  i    @^G      ^   cpu ^j       ^j       ^j       ^J)      ^       ^       ^-        ^-   (    ^-   0    ^J)  8    ^G  @ F  GJ)  G  F  G  -        
    ^IG  g     _       G      0`=H      `       `vY      ` Y      `!Y      `"qD       `#Y  (     a H      a!       a"       a#       a$H      a%H   .?  H  -    H  H  I-    .?      aB=H      agI      ah   uid ap?  gid aq.?      ar?      as.?      at?      au.?      av?      aw.?       axj   $    ay[>  (    az[>  0    a{[>  8    a|[>  @    a}[>  H    a  P    a?  X    aI  `    aI  hrcu a  p H  >  =H  -   I  3     I      -              -   N   J  -         I  
    ,  
      
    yC  
    yC  &    (J             J            J   B  J  -   ?     J      >       >      "      "       K      >       >       =K      >       >          .     +tK      ,K       -       .   &    ;N      <       =      >       ?<      AJ       D  8    GB  @    J   X    P   \    Q  `    T   h    Uj   lj    `j   pj    aj   p    d   t    e<  x    hF      iE      jJ)  "it qN      w=K      zK  (    |  @    ~E  p       x-tty N            >      >      >      >      >      >      J      -       -       -       -       -       -       -        -       -       -       -        -   (    -   0    -   8    G  @       @    N  H    j   H    j   L    N  P      X                           J  N  -        N  Q/  N  -        N  
    9?       $9O      &-        '       *       +    
       :gO        Mrcu        (Q      Q       Q      Q      -       -        j   (    j   ,    j   0    j   4    j   8    j   <    j   @    j   D    j   H       L       P       T    -   X    j   `    j   d    8  h    -   p    Q  x    Q      Q      Q      Q      Q      Q      Q      j       j       j       j       j       j       j       j       j       j       j        j         XEO      j        Q  ( gO      Q  j   Q  -    -   Q  I-    @    R  R  l  R      @          \R  "sd \R   "sg  bR  "sgc !mR   Q  Q      sR  hR      8$R      %Q       &R      '       (       ))R      +  0 
    /R  yR      hS      i-        j"       `mS      n8       o-      x-       x-       x-        "  (    "  ,    "  0    -   8    "  @    "  D    "  H    8  P    8  X     @U      8       8      8      8      8       8  (    8  0    8  8    -  @    8  H    8  P    8  X    8  `    8  h    8  p    8  x    8      8      8      8      8      8      8      8      8      8      8   &    V      R             <  (    j   8    8  @    8  H    8  P    8  X    8  `    S  h       @    V  H    $V  P    $V  X-avg S  ` @U      V      HV      <       -       -       j        V  (    V  0    V  8    V  @ *V      V  .    kW             8      8       8  (    8  0    -  8    8  @    j   H       L       P       T       X    "F  ` k&W      '[       ([       %W  Mb )kW  Ms *        W  W      W      W  '  W  -    D  W  -    I  N   X  -        X      X  tK  FJ     ?X     0X  ?      KX      VX      aX      lX      wX      X      X  sB      X      X      X      X  X  X  -    X          X  
    E  
    X	       @Z	0Y      [	]	      \	0Y   -   AY  K-    
    i	Y  
    j		  
    l	?  
    %W      qY      |Y      Y  enet Y      `%G      bY      b        YY      Y       Y   Y  Y  -    	    %      hcZ  ino c8   dev c$      c/      cj   uid c?  gid c.?      c$      c       cI  (    cI  8    c I  H    c!-   X    c"   `     @@dZ      d       d<      ds       d[      d [       d!   Z  e[)[      e]z[       e_   0    @eWz[      eXj        eYj   %[      ee<      ef[  (    eg[  ( )[  )eZ[  8[      eb     [  -   ? -   [  -   -         ek[      elj        em      enz[       8fE\      f        f       f       fE\      f   (    fU\  ,    U\  -       e\  -    9    j   g
\                    h
j       i1\      i2-        i3-       i4-        8i7\      i8s       i9s      i:\   s  ]  -        9\      ;       <\      =       =       >       ?   Y]          P]      j        /      ?      .?            I      I  (    I  8     %  H     j	^      j        j       j    	    j]      Pj^      j{        j       j{       j	^      j	^       j   8    j   <    j   @    j   D    j   H    j   J     j^      j        j       j       j        j_      j{        j       j       j       j^      j^       j^  8    j   P    j   T    j   X    j   \    j   ^    j_  `    _  -    _  .    kN`      k       k<      k<       k<  0    k  @    k  h    kJ  p    k<      ka      k      k -       k!9a   	    l  ln`  val lN`    	    lY`      m`      m        m       m       m    9    j   k5`                	    k<   )k?a  Luid k@?  Lgid kA.?      kBn`       k>.a  %`       kD`       k      Hka      k`       k`      k`      k`      k`       k`  (    k`  0    k  8    k  @     Hk+b      kmb       k       k<      k-        kj   (    kj   ,    k`  0    k`  8    k  @      kzmb      k{        k|f      k}(      k~mb   +b  i    `kb      kb       kb       b  -    J"E  b  -        kb  sb      ksb      8k%Ac      k&Zc       k'Zc      k(Zc      k)Zc      k*oc       k+oc  (    k,oc  0 b     Zc  <      Fc     oc  _   `c      @k0c      k1oc       k2d      k3d      k4oc      k5oc       k6oc  (    k7Zc  0    k:0d  8 uc  _  d  <      c  d  _   
d  *d  *d  79   `  d      xk@e      kA        kB8      kC8      kD8      kE8       kF8  (    kG8  0    kH-  8    kJ-  @    kK   H    kL   L    kM8  P    kN8  X    kO8  `    kP-  h    kQ   p     `kke      kle       km f      knZc      koZc      kp%f       kq%f  (    krJf  0    ksJf  8    ktjf  @    kuf  H    kvf  P    kwf  X e     e  <        z=   e      f  <         e     f  <     f   y`  f     Df  <  a  Df   6d  +f     df  <  df   ^  Pf     f  <  j       pf     f  <  f   ^  f     f  <  j    f  Ac  &    k/g      kj        k      k  0    k/g  X    k?g  h"ops kOg   79  ?g  -    a  Og  -    f  _g  -        Ph      Qh       Rh      Uh      Xh      Zi       ]Ui  (    `i  0    ei  8    fi  @    gi  H    hi  P    ij  X    j5j  `    pYj  h    rsj  p    si  x    th      uj      wj      xj      {j      }k   _g     h  <  h   h      h     h  %  <   h     h  #  h   h     h  <   h     i  %  #  a  j    h     Oi  %  #    j   j   (  Oi     "i     i  %  #    j   j   <     [i    i  #     i  i  <  j   j    i     i  <     i  @2    j     S]  j     j      i     5j  #  -      Oi  S+   j     Yj  #  <  <  e\   ;j  [  sj  <  ;   _j     j  <  -   -    yj  j  <  j  j   [  j     j  #  <   j     j  j  %  j   j        j  k  %   k  
    h  h      &k      1k      <k  :9ik      :v       ;j    :Uk      Vg      W   :gk      hX      i      jk       k      k  &     @1m      x       Ax      [x      ux      x       x  (    x  0    x  8    y  @    +y  H    Jy  P    y  X    ny  `     y  h    y  p    y  x     z      1z      Uz      tz      	z      
z      z      {      Jy      ${   k  1m    .    In      In             <      )o  (    j   0       4    j   8       <    E  @    J  H    %  `      h      p    q  x    -       -       q      q      .q   Bm       n      ,   "pid E      C  "uid ?      ?                o      -        j       j       j       j          :)o      |+         @    g      i]o      jro       ko   5o  ro  In  In   bo  o  In   xo      Hnp      o%p       p:p      qro      ro      so       tTp  (    uip  0    vp  8    wp  @ o     %p  In  In   p  -   :p  In   +p     Tp  In      @p  [  ip  In   Zp     p  p     a   In  op  p  In  Oi   p       n	p      n
"       np      n<       p      np      nq        p  k.q      <           : \q      p      p  Mafs 
q   .    0lq      m       n       o       pq      q%      r    \q  ]o  p  
    <  
      .    *r      *r       J  x           J   J"E  ;r  -        8r      C               |      {      	(       
r  (    g  0      8      8      8    |  8      8      8      8 ;r      "t      #9{       $J{      &`{      'z{      ({       )J{  (    *{  0    +Zc  8    ,{  @    -{  H    .{  P    /{  X    0{  `    2|  h    3|  p    4|  x    5|      :2|      ;L|      <k|   s  t  c  e      .t  3t      >t  Nt  Ct      Tt    ot  -        t      j        j       j       t   [  @    t  t  t     t    C        8  j        u      t   "pos      7u  %        u    [u  %      G   =u    u  %  C     G   au    u  S]  u  -      u      u  u    u  S]  j   u     u  %  u   t  u  j   v  %  v   v      u  s  1v  %  j   -    v     Kv  %  '   7v     ev  79  %   Qv     v  %  )o   kv     v  %          v     v  S]      v     v     %      v     v  %     In   v    )w  %  <       G      w     >w      /w    gw  X  %  G    j    Dw    w  %  G  X    j    mw     w  %  s  p  Oi   w  s  w  %          w     w  w  %   w      w  6  x  79  6  j    x    6x  6  6x   <x      "x     [x  79      Gx  k  ux  79      ax     x  6        {x  x  6  6x     x     x  79  6  /  [   x     x  6  79  6   x     y  79  6   x     +y  79  6  C    y     Jy  79  6  /   1y     ny  79  6  /  $   Py     y  79  6  79  6   ty     y  79  6  79  6  j    y     y  6  y   ^]  y     y  t=  6  y   Z  y     )z  6  C   )z        /z  z    Uz  6  C        7z    tz  6       [z     z  6  C    zz     z  79  z  8  8   ot  z     z  79  n      z     {  79  6  %  j   /  G   z     ${  79  k      {  79  9{  <   *{  J{  79   ?{  `{  79      P{     z{  79  h   f{     {  79   {  {  <   {     {  <   {     {  6  {   {      {     {  <  G     {     |  w  6   {     2|  <  <     |  s  L|  <      8|  s  k|  <  s      R|  6  |  r     C      q|    |  -        
    h|  |  
    2$  
    p  
    q  
    r  
    
  
    
1m  
    S
9  
    W
  
    X
1m      o4[  H@@pU}      pj        pU}   j   e}  -    7    p3}  @Je}  @}}  3     qq}  ;                     ~  'sgl 3          j       'buf                     :              h   ;                     ~  'sgl 3          j       'buf                     :              h   ;                     ~  'sgl 3          j       'buf                         h   ;                     h  'sgl 3          j       'buf                         h       m                   'sgl m3          mj       'buf n          n          n:          o[      N    qj       l    r%4      s-       tj   4A      -       -    +        <         Olen j   +                                         4      -       -    4      -       -    4      -       -    <                 0  P               /        <b                 R  n           v          t          V             m    E               P      EP      +                      G              +        <         l    S[  	            S   +                     S-   4Z      S-       S-    4x      S-       S-    Az                 SP               /         +                     S              A                 Sn                 
  4(      T[      T <                 Ol    1                 H6  ,    A           (       T,  1          (       rKB                 $3  B                 O  n                 
 1                 O    1                 [6  ,                            %4  Y     [  t        P   ;    [          h       %      P          :      +        <              :  +               	      :  N    :               %              =    [  v       P  QOsg 3      -   Q    -       -      m            T       %      P      'sgl 3          j           j       Z                        Ag                       u    Y    [  C       C   3  =       g  sg 3              C       3       j        -    ;    l                 ?  'sgt l?          m(          mj           n-           n-           o      N    qj       Oi rj       sj   ret t   Vos u3      Z    $  N    -       oj j       +                     -       -    p[                |  q  g  q              Z    [    /                            E             s3  Y    K          K?       Kj        K  Oret M                 ?      j       j       3              Csg 3  Cprv 3  D    j   Q    
j       
j     3  \            $       U  ,    ?              U                        ,    ?      ,    j       ,    [      ,          Csgl 3  ]    3      [    ]    j       ]    j         3              (       J  5sg 3      ,    j                                3          4         ,    j       ,          +                 rptr   P        
   1"                 ?  3              \    }                 5sg }3      5buf })z      ,    }j       B          L         4  )    q[              u  |  q  g  1                 Z    P               R  Q               \    h        D       9  5sgl h3      ,    hj       B                 r+             "   ^    J3          P         5sgl J3          Jj   QCsg O3  Cret O3  ri Pj   R           ^    2           0         5sg 23          4   R           ^    3          (          5sg 3       *    rI8      rI   #    rB  T      rB<   *    r>l      r><   #    r8        r8<   *    r      r<   s    s    =    <         C   *      !sg 3   *      !prv 3      j   !sgl 3   *    o@  !sg o3  !buf o)z      pj    #    _<  [  !sg _3   *    W  !sg W3      W<  !len Xj       Xj    *    9  !sg 93      9<  D    ;-   t           U     -      =    	          	    u  #    H   "      H    =      Z                Q         =    a         a       a      cj    #               t           U     -      *    sO  !ptr sO)z   *    sB  !ptr sB)z      sB      sB   !gfp sC   #    t   F      t-   D    t    #    X   b      X-    *    Oz      O-    #    A-     D    C-    #    -     D    -    _    M[  _       #    Y     !ti Y      Y    ]	  _    T  #    u"     !n u"8   #    g   B  !nr g       gB   >   #    v   b  !x v    #    w
-   ~      w
-              (        (      (      (      (      (      (      6  6  6  u                  [    R  c/      R  fu      /      /      v              /e         <                 7                   EE          X       1  (V      (b      (n      Rz  cE                 #  b  n  V  P               6          U               Eg                 i  Su  PS  QS  RS  S E%                   (6      T%          d       6  <I                   Z  Z               E%          x         (6      Z    "  6C  6N          %   T%          <       6  T          <       /
      6  TZ                 /[      /g          EV                  (g      V        g  v              +    p@               P    <8          ,       /a  H  B                 rDC          1   1          $       rE    Al          (       1|  1          (       r;                       %   w        z     >        xP>        y>        S>        `        C>        `        Cu`        "w        z     >        y  :;I8   :;I8   I   I   :;I8  4 :;I?<  'I  I  	 :;I  
4 :;I?<  :;  ! I/   <  (    1   :;I8  & I  :;   1   :;I8  4 :;I   :;I  :;   :;I   :;I8   :;I  '   :;I8  :;   :;I8   :;I    :;I  ! :;I  " :;I8  #.:;'I   $$ >  % I8  &:;  ' :;I  ( 1  ):;  *.:;'   +  , :;I  - :;I8  .:;  /4 1  0:;  11XY  2 :;I  3!   4  5 :;I  64 1  7 :;I  8 I  9>I:;  ::;  ;.?:;'I@B  <1XY  =.:;'I   >. ?<n:;  ? :;I8  @ :;I  A1XY  B1XY  C4 :;I  D4 :;I  E.1@B  F5 I  G 'I  H:;  I! I  JI  K! I/  L :;I  M :;I  N4 :;I  O4 :;I  P  Q  R4 1  S 1  T1  U:;  V I8  W :;I8  X I8  Y.?:;'I   ZU  [U  \.?:;'@B  ]4 :;I  ^.?:;'I@B  _. :;'I   `. ?<n:;  a>I:;  b :;I8  c :;I  d :;I8  e <  f:;  g :;  h:;  i:;  j :;I8  k:;  l4 :;I  m.?:;'@B  n 1XY  o4 :;I  p1RUXY  q1RUXY  r4 :;I  s. :;'   t4 I4  u1U  v1RUXY  w. ?<n:;n  x%  y$ >  z>I:;  {   | '  } :;I8  ~4 :;I?   :;  :;  :;   :;I   :;I  :;   :;I   I  :;  :;  :;  :;  &   .:;'I@B  . ?:;'<   :;I  .?:;'   4 :;I  .?:;'I   .?:;'@B  .:;'@B  .:;'I@B   :;I  4 :;I  .1@B  1  1U   
      
       P                
      
       Q                
      
       R                
      
       S                
      
       T                
      
       P                
      
       Q                
      
       R                
      
       S                
      
       T                
      
       P                
      
       Q                
      
       R                
      
       S                
      
       P                
      
       Q                
      
       R                
      
       S                	      	       P                	      	       Q                	      	       R	      H
       hP
      
       h                	      	       S	      H
       gP
      
       g                	      	       T	      
       c
      
       c                	      	       U	      <
       iP
      
       i                
      D
       fP
      
       f                
      D
       eP
      
       e                P      h       Ph              c                             P             P                (      ?       P?      L       dT             d                (      ?       Q?      L       cT             c                l      t       P                      @       P@      H       cH      P       P                      8       Q@      P       Q                      ?       R@      P       R                      @       S@      H       dH      P       S                      8       P8             f             f                      ,       Q,             e             e                      \       R\             d             d                             S             g                      T       TT             h             h                      {       U             R                h      {       Q             Q                             P             P             P                t             Q             Q                             T             T             T                x             R             R                `      {       P                             P             c      `       c                             Q      `       d                      C       RD      `       R                             S      `       f                             e      (       e4      `       e                      C       QD      `       Q                      C       SD      `       S                                P        #        P                                Q        #        Q                (       D        PP       T        P                (       @        Q@       G        RP       W        Q                H      k       Pk             c                H      h       Qh             d                H      k       Rk             e                      #       P(      H       S                             Q              c                               P              S                               P               P               P                \       d        Pd       p        Qx               Q                              P              e             e             P                              Q              f             f             Q                              R              l             l             R                             S             P             c             c             S                              T              j             j             T                              U              k             k             U                             g             g                      h       d             d             d                             R$      7       R                             P             d                             Q                             R                             P              P             R                             P             U             P             U                             R                             P                             V                             P      h	       dx	      	       d                ,                     
                                                                                `                                                                                                        |                                                          H      `                                                                                                              `      h      t      x                                                                      `      h      t      x                                                                                                                           ,      @                            d	      x	      	                            	      	       	                                                                             \        ../lib ../include/linux ../include/asm-generic/bitops ../arch/arm64/include/asm ../include/asm-generic ../include/uapi/asm-generic ../include/uapi/linux ../arch/arm64/include/uapi/asm ../include/clocksource  scatterlist.c   slab.h   scatterlist.h   non-atomic.h   thread_info.h   irqflags.h   uaccess.h   preempt.h   mm.h   int-ll64.h   int-ll64.h   posix_types.h   types.h   init.h   cachetype.h   printk.h   fs.h   notifier.h   kernel.h   memory.h   thread_info.h   time.h   compat.h   sched.h   hwcap.h   ptrace.h   spinlock_types.h   lockdep.h   spinlock_types.h   rwlock_types.h   fpsimd.h   hw_breakpoint.h   processor.h   atomic-long.h   wait.h   seqlock.h   nodemask.h   pgtable-types.h   mm_types.h   mmzone.h   osq_lock.h   mutex.h   rwsem.h   cpumask.h   completion.h   rcupdate.h   rcutree.h   time.h   pgtable.h   rbtree.h   uprobes.h   mmu.h   cpufeature.h   arm_arch_timer.h 	  timex.h   jiffies.h   ktime.h   timekeeping.h   timer.h   workqueue.h   llist.h   smp.h   smp.h   percpu.h   percpu.h   topology.h   gfp.h   debug_locks.h   shrinker.h   resource.h   page_ext.h   page-flags.h   vmstat.h   scatterlist.h   list_bl.h   lockref.h   dcache.h   path.h   capability.h   plist.h   cputime_jiffies.h   highuid.h   uidgid.h   signal.h   signal-defs.h   siginfo.h   signal.h   pid.h   pid_namespace.h   percpu_counter.h   seccomp.h   rtmutex.h   timerqueue.h   hrtimer.h   task_io_accounting.h   nsproxy.h   cred.h   kref.h   stat.h   list_lru.h   radix-tree.h   fiemap.h   migrate_mode.h   ioctl.h   fs.h   dqblk_xfs.h   quota.h   projid.h   quota.h   nfs_fs_i.h   jump_label.h   hardirq.h   irq_cpustat.h   highmem.h   kmemleak.h   getorder.h   log2.h   fls64.h   builtin-__fls.h   bug.h   preempt.h   <built-in>    stddef.h     	        !!"1-!g !!
.A.|<$1!/#y .1) 1 1<y 2#	.p. 5 = 	<<<!6x 6< EJ<X/v.g FJ.;.2Ji.uX.!nX/",(/#y.f!;!!."z <    $>$"$L"'!>.V.<=B~ !&J!~.J!ttP.<  #91#>!iJ
 v.
.v 
.v<
 v 
 v 
 v 
 w 
.," 2= z &y<!& z<<ef!<= ;0=!-!-2} z  }. }. }. }  }   .%	 /  r ;2K0u.J5z./!!xJ .;%%@#>=y-!s p.$.!!T . 1   K ! <<! J M0!!" / |  | . {.    	< {f 3. x.. <""<</" !v<MK!!*.g&}J~  ~J ~< 0}  #{ 3	|M	X| .Xy  u< u  u  "{X.  X.{. rtv!0",t.#.!-!!.!-!!.!!!.!!! sched_entity long long int __u64 audit_context notifier_call line link console_printk vm_page_prot init_pid_ns shared_vm vm_stat_diff si_errno tasks read lowmem_page_address file_ra_state setattr long unsigned int if_dqinfo compact_cached_migrate_pfn atomic_notifier_head fs_overflowgid ___assert_task_state pi_lock sg_kmalloc tmpfile private lowmem_reserve personality error_remove_page jiffies map_count system_freezable_power_efficient_wq mmap_rnd_bits release mmap_base restart_block sibling nr_migrations delta_us file_lock_operations s_id __builtin_memcpy stack_guard_gap sg_page_count ioac rcu_read_lock_nesting PG_reclaim lb_imbalance __ret_warn_on d_rt_space memset dentry_stat_t s_qcop dl_period __kernel_gid32_t kstat vm_rb info mnt_namespace dirty_inode request_queue rt_priority ngroups seccomp_filter height alloc_inode smt_gain umode_t exit_state s_bdi nr_dirtied addr_limit self_exec_id dumper dqonoff_mutex stime num_poisoned_pages list ia_size name section_mem_map page_frag dqb_ihardlimit task_rss_stat k_sigaction total_vm fs_flags qs_itimelimit task_list id_lock loff_t PG_fscache sysctl_nr_open overflowgid __security_initcall_start nanosleep system_highpri_wq vfsmount block_device totalram_pages seeks i_bytes iowait_sum watchdog_stamp exec_domain tty_audit_buf perf_event_mutex nameidata iattr magic kptr_restrict load_weight remap_pages per_cpu_pageset thread_struct sched_reset_on_fork d_seq splice_write i_writecount __kunmap_atomic mapping rb_root qsize_t sendpage group_info root_user high sa_restorer cap_effective net_ns reclaim_stat vm_fault node_id pcpu_chosen_fc s_flags uidhash_node max_mapnr sched_domain_topology qs_incoredqs sigaction group_stop_count destroy_dquot _pad1_ generic_ro_fops s_stack_depth sival_int nr_dirtied_pause idle_idx skip scatterlist jobctl kprojid_t pushable_dl_tasks qs_rtbtimelimit _call_addr pcpu_fc_names fown_struct cmaxrss _pad2_ rmdir false pi_state_list panic_on_oops dquot_operations _softexpires __cap_empty_set fl_wait pdeath_signal releasepage fi_extents_max __security_initcall_end wait_lock _pad3_ s_remove_count expires highest_vm_end pfmemalloc static_prio brk_randomized _min2 kmalloc preempt_count_sub nr_failed_migrations_affine rb_node lb_balanced pid_gid nlm_lockowner inv_weight i_lru backing_dev_info pteval_t end_data panic_timeout fsync actor running_avg_sum cnvcsw lruvec last_queued pid_type plist_node bool _addr sysctl_legacy_va_layout dl_throttled inodes_stat dentry_operations dq_hash quota_on PG_pinned _status cpu_itimer qstr frozen aio_write sysctl_vfs_cache_pressure sched_info prv_nents kiocb sbe_balanced mount __sg_alloc_table dqb_curinodes last_balance preempt_count size proc_work pending compat_elf_hwcap nohz_idle check_flags first_chunk percpu_counter in_iowait first mtime PG_referenced compact_blockskip_flush get_reserved_space active_mm zone_reclaim_stat user_fpsimd_state compat_timespec mmap_rnd_compat_bits_max simple_dir_inode_operations time_slice alloc_size ia_ctime running cpu_possible_mask boot_command_line posix_timer_id task_size objects active_nodes chunk_size PG_uptodate size_t atomic_flags blocking_notifier_head kref sched_statistics page_tree fl_type export_operations __smp_cross_call statfs __dummy2 newidle_idx alloc_fn sg_alloc_table fl_break_time s_dev mm_count hiwater_vm poll fl_nspid perf_event_ctxp event time_t seqcount live show_path dq_sb ttwu_move_affine mmap_sem qfs_nblks cpumask_var_t bd_dev seqlock_t flush_kernel_dcache_page setup_max_cpus prev_pos sa_flags callback_head user_namespace sleep_start anon_name user_fpsimd _arch orig_nents s_subtype real_timer last_siginfo private_data stat_threshold system_freezable_wq make_it_fail core_id pageflags sg_pcopy_from_buffer __kmalloc panic_on_io_nmi need page_group_by_mobility_disabled close dqi_dirty_list mmlist security thread_id dquot bd_mutex evict_inode elf_hwcap s_fs_info uprobes_state f_cred cpu_base PIDTYPE_SID PG_reserved iowait_count miter hotplug_down_time get_time f_flags sysctl_stat_interval PG_owner_priv_1 nr_threads preempt_disable_ip buflen debug_locks_silent hd_struct readpages shared debug cap_ambient i_mtime qs_uquota PCPU_FC_AUTO group_node vmstat_text _uid mmap_rnd_compat_bits_min priority nr_files dqb_curspace check_quota_file stats_lock s_mem d_space usage s_mtd _mapcount prio_list lock sd_flags rb_left fsgid tree_lock alloc_lock gtime timespec sg_miter_start bio_list printk_disable_uart dqi_bgrace trace_recursion thread_sibling fs_quota_stat fl_owner_t boot_tvec_bases f_tfile_llink qs_btimelimit map_pages i_sb_list system_unbound_wq want_pages mm_context_t HRTIMER_NORESTART cap_permitted fl_u __nents __s8 ZONE_MOVABLE bd_block_size pushable_tasks quota_format_type __get_order static_key_initialized d_name lru_lock fault_address vfork_done seqcount_t f_op PG_active read_file_info nrshadows list_lru_node word update_time nr_wakeups_affine start_code wakee_flips arch_local_save_flags start_time hrtimer_clock_base notifier_block oom_flags vm_file super_operations flag mtd_info hmp_last_up_migration __fls set_child_tid ia_uid __u8 i_rdev nr_dentry next_decay_max_lb_cost leader sched_group hotplug_down_lat_max notifier_fn_t mmap_legacy_base s_active i_fsnotify_marks access max_pgoff ttwu_wake_remote read_dqblk qf_owner d_compare imbalance_pct dqi_valid _overrun hex_asc_upper dqb_isoftlimit bitset PG_locked tgid f_ra cputime s_writers_key bd_inodes zone_start_pfn thread_group_cputimer sa_handler notifier_mask freepage d_manage super_block unfreeze_fs span_weight arch_irqs_disabled_flags system_wq fl_pid fe_flags leader_pid nr_unused s_vfs_rename_mutex swap_info_struct dqi_format i_blocks ../lib/scatterlist.c level rename_lock bd_contains module free_area qs_pad1 qs_pad2 exe_file persistent_clock_exist forkexec_idx set_info upid order uts_ns processes fl_end kunmap PG_tail fl_release_private run_list fe_reserved func core_sibling pcount fs_kobj sg_next maj_flt i_default_acl small_block owner first_page user_ns i_rcu qf_ops USRQUOTA __per_cpu_offset preempt_count_add fs_qfilestat_t addr runnable_avg_sum quota_on_meta rb_subtree_gap fl_copy_lock d_rt_spc_timer sysctl_memory_failure_recovery wps_disabled consumed write fl_file atime get_xstatev stimescaled hrtimer_restart scan_objects cputime_expires pte_t def_chr_fops HRTIMER_RESTART write_dquot fu_llist inactive_age address_space_operations alb_failed filter show_unhandled_signals sysctl_memory_failure_early_kill i_gid vm_prev policy a_ops cnivcsw trace sigset_t set_acl hotplug_down_lat_min nr_wakeups_passive ptrace_entry real_blocked __con_initcall_start on_cpu SYSTEM_POWER_OFF private_list sg_page_iter compat_rmtp rb_subtree_last sched_domain_mask_f nents PG_swapbacked readlink compat_time_t nr_failed_migrations_running d_iname oom_score_adj_min files_stat_struct oublock function __kernel_off_t inode_operations PIDTYPE_PGID lb_gained s_inode_lru page_symlink_inode_operations free_cached_objects sched_rt_entity sleep_max zlcache_ptr mmap_miss timestamp_enable group_exit_code fmode_t qc_dqblk __kernel_timer_t busy_idx uaddr2 bd_write_holder simple_dentry_operations vmacache __min1 __min2 tail env_end kernel_cap_struct s_options wait_queue_head_t d_prune mark_dirty fls64 core_thread raw_notifier_head last_runnable_update incr_error __i_nlink PG_unevictable env_start sched_avg rlim_max linux_proc_banner next sched_domain __sighandler_t sg_chain f_path nfs4_fl PG_slob_free total_cpus nrpages partno d_lru nr_wakeups_local to_buffer percpu_counter_batch nr_free SYSTEM_HALT tick_cpu_device back _Bool min_free_kbytes freelist i_atime zone free_list linear parent rlock dirtied_when s_vfs_rename_key cg_list cap_bset total_forks task_cputime system_states put_super utime alb_count memcpy init_task softirq_time nr_normal_prio s_export_op _sigval isolate_page d_flags pgoffset group_leader pi_waiters __sched_text_start removexattr hash_len names_cachep nr_forced_migrations node_zones min_interval migrate_mode is_dirty_writeback setlease launder_page __offset age_limit my_q siginfo_t fa_lock wait_table_bits kmap nr_events lock_count sg_page fpsimd_state nr_deferred kmalloc_dma_caches i_op exec_start hrtimer_cpu_base journal_info min_flt avg_period tv_nsec set_dqblk mask rcu_blocked_node bd_claiming jiffies_64 s_writers bps_disabled hres_active fiemap_extent arch_spinlock_t saved_auxv hbp_break free_file_info secondary_data fl_lmops sg_free_fn release_dquot min_count kmsg_fops clear_child_tid __sigrestore_t s_dquot load s_type rcutorture_testseq ioctx_lock inactive_ratio _pad dq_count fiemap blocks audit_tty zone_type cred pgd_t dqi_igrace anon_vma_chain compact_considered index prove_locking clock_base __get_free_pages start_data PG_error ipc_ns notify_count init_user_ns radix_tree_root task lm_setup rwlock_t vm_event_states cgtime recent_rotated workqueue_struct empty_aops inotify_devs tv64 n_pages slab_cache i_sb sbf_balanced vm_end error nsproxy sg_kfree sg_alloc_table_from_pages swap_deactivate i_devices parent_exec_id loginuid sched_dl_entity hex_asc inode pipe_inode_info fe_physical sbe_pushed d_weak_revalidate mknod cmaj_flt create tick_nsec swapper_pg_dir ipi_irqs fe_reserved64 lb_nobusyg dl_bw lb_nobusyq lm_change siginfo __cond pfmemalloc_wait _stime rw_semaphore i_ino tasklist_lock chunks file_operations s_lock_key s_security has_timeout pid_chain radix_tree_node files_struct sg_copy_to_buffer llseek file_lock lock_class_key fiemap_extent_info sa_mask page fpcr sched_task_group zone_idx runtime lookup sighand_cachep invalidatepage persistent_clock_is_local max_ents sbf_count d_child f_pos_lock gid_t compact_cached_free_pfn short unsigned int refcount kmalloc_index tick_usec sync_fs per_cpu_pages i_cdev PCPU_FC_EMBED active_bases __sg_page_iter_next lb_hot_gained panic_on_unrecovered_nmi rt_rq s_umount group_exit_task bd_private pid_namespace destroy_inode _pid private_lock i_blkbits is_child_subreaper dq_wait_unused sys_tz deadline host sched_domain_topology_level PG_private s_xattr cpu_timers getxattr inotify_watches PG_writeback it_real_incr f_ep_links coublock rm_xquota need_qs rwsem dqb_bhardlimit s_root iov_iter remount_fs sysctl_protected_symlinks nr_retries PG_mlocked qfs_nextents compact_defer_shift vm_ops base s_inodes seq_file regs_on_excp hotplug_up_lat_max sum_sched_runtime cpu_hwcaps printk timestamp_us cpu_online_mask wait show_fdinfo audit_tty_log_passwd pgoff alb_pushed exec_vm cpu_all_bits unix_inflight nr_isolate_pageblock default_timer_slack_ns nodemask_t child max_files printk_delay_msec pcpu_fc nvcsw def_blk_fops completion vdso PG_mappedtodisk vm_area_struct signal d_rt_spc_warns pglist_data super_blocks sighand_struct gfp_mask ia_valid PRJQUOTA pgprot_t direct_IO default_exec_domain atomic_open ipc_namespace pagefault_disable d_spc_hardlimit sg_table get_dqblk pcpu_base_addr utilization_avg_contrib virtual_address thread_info wait_table_hash_nr_entries __count unsigned char rdev file_caps_enabled uts_namespace umount_begin _kill bd_list sigval_t incr dq_op fu_rcuhead dl_new fa_next pid_cachep hotplug_up_time d_rcu __rb_parent_color page_mkwrite tlb_flush_pending hotplug_down_lat_us projid __kernel_clockid_t s_time_gran rename euid sysctl_protected_hardlinks PG_slab read_iter hrtimer flock process_counts phys_addr_t vm_stat files_stat i_hash sigcnt __builtin_memset run_delay cap_inheritable rlim_cur /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out kswapd_wait kmap_atomic write_inode i_opflags __kernel_pid_t cfs_rq sg_mark_end tz_dsttime task_frag cpu_topology bd_holder_disks arch_timer_read_counter sysctl_lowmem_reserve_ratio free_pages i_mmap_nonlinear last_pid kmemleak_alloc debug_info sas_ss_sp mt_need_uart_console type s_umount_key mem_section qfs_ino lm_get_owner mach_panic_string sighand span cmin_flt in_execve d_dname fs_struct PG_checked page_link i_mmap quota_format_ops kmem_cache mem_dqblk hotplug_up_lat_min real_cred proc_inum pi_state_cache wait_unfrozen numbers si_code s_readonly_remount mm_struct done nlink d_parent nfs4_lock_state atomic_t path sysctl_user_reserve_kbytes anon_vma lm_compare_owner init i_lock_key init_nsproxy present_pages current_stack_pointer i_security rmtp s_magic d_lockref __ret_warn_once perf_event_list robust_list_head last_arrival sg_alloc_fn zone_padding put_link cred_guard_mutex kmalloc_large migratepage s_op fl_start core_state show_devname ia_gid debug_guardpage_ops sg_miter_get_next_page mnt_ns suid d_ino_warns init_groups slab prev_cputime nr_balance_failed fs_supers kgid_t watermark test_ti_thread_flag sigpending thread SYSTEM_RESTART clock_was_set PG_lru linux_binfmt fpsr __dummy perf_event i_flock ioctx_table vm_pgoff sb_lock reboot get_unmapped_area units PG_arch_1 cpu_active_mask poll_table_struct __kernel_loff_t wait_sum wait_chldexit pid_link sg_set_page page_table_lock stack plug quota_info quota_off counter set_page_dirty vm_private_data node_states count qs_pquota list_head nr_to_scan nr_cpus_allowed epoll_watches pprev i_generation f_owner timerqueue_node rec_idx _zonerefs ia_file fl_fasync quota_sync ctime fl_downgrade_time oom_score_adj init_thread_union d_ino_hardlimit rcu_node sessionid ttwu_move_balance def_flags uid_t _flags f_version slab_page quota_type dqstats system_power_efficient_wq swap_in sysctl_drop_caches nr_dequeuing_low_prio signum dentry print_fatal_signals d_rt_spc_hardlimit fs_quota_statv rcutorture_vernum arg_end fa_rcu tty_old_pgrp arch_rwlock_t i_nlink dl_boosted ptrace_message late_time_init balance_interval lists release_dqblk normal_prio fl_link dmesg_restrict signalfd_wqh action bd_part_count d_spc_timer compat_robust_list_head spanned_pages memstart_addr nr_wakeups_affine_attempts PG_savepinned sched_class off_t statistics thread_node __restorefn_t qs_bwarnlimit user_struct exit_code dqstats_pcpu i_pipe wake_entry ktime_t compat_robust_list sg_mapping_iter nr_ptes kfree blkcnt_t kqid suspended_step tags thread_union __kernel_time_t sector_t PCPU_FC_NR write_begin GNU C89 7.3.1 20180522 -mlittle-endian -mgeneral-regs-only -mpc-relative-literal-loads -mabi=lp64 -g -Os -std=gnu90 -fno-strict-aliasing -fno-common -fstack-usage -fno-delete-null-pointer-checks -fno-PIE -fno-store-merging -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -fno-strict-overflow -fstack-check=no -fconserve-stack --param allow-store-data-races=0 s_d_op d_automount futex_pi_state posix_acl dq_inuse start_brk system_state hbp_watch fl_block inblock __softirq_pending prev_sum_exec_runtime dq_dirty dqi_max_spc_limit dqi_flags mm_rss_stat qs_iwarnlimit MIGRATE_SYNC max_hang_time s_shrink compat_ioctl sg_miter_stop sg_free_table slots f_mapping early_boot_irqs_disabled i_data nblocks note1 note2 note3 note4 async_size node _tid __NR_PAGEFLAGS cad_pid piter i_mmap_mutex sched_contributes_to_load slice_max PIDTYPE_PID i_ctime fl_flags nr_wakeups_sync sg_flags reboot_notifier_list kstatfs sysctl_overcommit_ratio lock_manager_operations count_objects i_mode linux_banner dummy entry __int128 unsigned root_mountflags mm_rb __kernel_size_t splice_pipe avenrun sg_miter_skip _band bits numa_level dl_timer __con_initcall_end short int __kernel_dev_t current_thread_info cpu_power __compiletime_assert_596 notifier sched_group_capacity si_signo hotplug_timestamp_lock max_newidle_lb_cost dqio_mutex active commit_dqblk sg_assign_page vregs file ia_mtime vm_area_cachep nr_cpu_ids __PIDTYPE_TGID nr_zones dq_flags atomic_long_t f_security cstime nr_migrate_reserve_block sb_writers sched_domain_flags_f preset_lpj curr_target sbe_count io_context dl_deadline fl_link_cpu wake_cpu sas_ss_size is_partially_uptodate thread_group on_rq fs_overflowuid write_info lm_owner_key s_maxbytes qs_pad hlist_bl_node qf_fmt_id dirty_balance_reserve i_mutex_key sbf_pushed timer_slack_ns total_link_count group_rwsem i_count gfp_allowed_mask sg_init_table s_anon long int zonelist PG_isolated mmap_pages_allocated counters shrink_control start perf_event_context arg_start s_blocksize_bits compact_order_failed recent_scanned panic_notifier_list startup PG_private_2 bd_queue pinned_vm tty_struct idmap_pg_dir initcall_t hotplug_up_lat_us proc_mnt address_space irq_cpustat_t writepages optimistic_spin_queue symlink fi_extents_mapped dl_runtime should_resched fe_logical test_bit wait_count sglist bd_fsfreeze_count nfds state protection_map proc_self f_mode dq_id kuid_t wait_max expires_next cdev nr_pending decay_count nr_hashed files reclaim_state write_file_info cache_nice_tries batch mem_map overflowuid s_instances node_start_pfn weight bdev_try_to_free_page nr_wakeups bd_openers locked_vm writeback_control s_pins real_start_time list_lru get_xstate i_bdev PG_dirty fi_extents_start f_inode true nr_free_files futex blk_plug readpage _utime time cluster_id prev seccomp cleancache_poolid ufds __kernel_clock_t dentry_stat s_dio_done_wq _sigfault getattr fe_length nr_wakeups_remote sysctl_panic_on_stackoverflow fault_code left bd_disk d_revalidate iterate dma_length mm_segment_t load_avg_contrib PG_swapcache context node_zonelists bd_invalidated locked_shm get_acl last_wakee oops_in_progress hiwater_rss hide_pid nfs_lock_info ZONE_NORMAL sg_pgoffset _sys_private d_fsdata fl_ops bad_sock_fops busy_factor rcu_expedited __icache_flags setxattr robust_list initcall_debug sysctl_admin_reserve_kbytes timezone nodes_to_scan sg_init_one children pi_blocked_on writeback_index dq_data_lock PG_head __ilog2_u64 sg_last _sifields dqb_rsvspace table zone_pgdat unlocked_ioctl nivcsw timerqueue_head prio atomic64_t sg_size tv_sec dqi_fmt_id swap_activate max_lock_depth proc_thread_self qs_gquota css_set pages task_works nr_inodes offset saved_command_line init_mm work_func_t listxattr s_mode cpu_vm_mask_var timekeeping_suspended __signalfn_t system_long_wq events d_release sysctl_overcommit_memory splice_read max_interval d_op _sigpoll __flags notifier_data unlink groups hash cpu_stats clockid_t nr_items zonelists_mutex sg_page_iter_page cputime_t dl_yielded s_count cur_page wakee_flip_decay_ts i_state fl_owner lockref rb_right sched_domain_level_max SYSTEM_BOOTING s_mounts cinblock rnode signed char i_fop pidmap pids __func__ dqb_btime zonelist_cache thread_head mmap_rnd_compat_bits kill_sb nr_cached_objects _timer vm_start quotactl_ops alloc_dquot mmap sequence dqb_bsoftlimit d_subdirs i_private posix_timers f_pos hlist_node siglock mutex _sigchld d_sb permission page_poisoning_ops comm i_version cpu_excp mm_users _addr_lsb sigval vruntime _syscall ktime reset_devices kmemleak_free pageblock_flags dq_off isolate_mode_t inuse preempt_schedule ia_atime dirty_paused_when dma_addr_t init_struct_pid free_fn head securebits SYSTEM_RUNNING pid_t qf_next perf_ops_bp show_options long long unsigned int egid cpu_context nonlinear __kernel_uid32_t numa_zonelist_order d_spc_softlimit pipe_bufs wait_table filldir_t debug_locks real_parent leases_enable ia_mode cpu_present_mask wait_start fa_file lm_notify lease_break_time hang_detected __wait_queue_head d_ino_timer i_mmap_writable nfs_fl s_dentry_lru dma_address s_bdev tp_value depth skip_first_chunk s_uuid fa_fd vm_event_state kernel_cap_t i_size d_ino_count nr_hangs mem_dqinfo spinlock_t node_list exit_signal high_memory pobjects shrinker work_struct kobject i_mapping d_canonical_path end_code gfp_t run_node mmlist_lock flags lb_count binfmt user i_wb_list hlist_bl_head wake_idx __kernel_long_t spinlock empty_zero_page fallocate fsuid i_mutex dqb_itime vmacache_seqnum MIGRATE_SYNC_LIGHT cpumask __kernel_ssize_t sg_pcopy_to_buffer __s32 block_start pending_load char __sg_free_table kioctx_table arch_local_irq_save dq_free sum_exec_runtime nr_wakeups_migrate d_spc_warns freeze_fs uaddr dq_dqb vm_next fs_qfilestat GRPQUOTA cpu_bit_bitmap qs_version maxrss mkdir sgid vm_operations_struct swap_out rcu_special utimescaled s_list irq_stat lb_failed task_struct nr_migrations_cold f_count sg_miter_next fasync bmap child_reaper mmap_rnd_bits_max profile_cpu_stats d_inode PageSlab follow_link pgdval_t PCPU_FC_PAGE bd_holders _sigsys fi_flags aio_read cpus_allowed ptraced rename2 dir_context hmp_last_down_migration rlim oom_flags_t d_iput bd_super cputimer task_group clockid rss_stat shared_pending node_present_pages d_time d_delete dq_lock __kernel_ulong_t fs_qfilestatv data sd_data rcu_scheduler_active projid_t tz_minuteswest nfs4_lock_info i_fsnotify_mask xattr_handler sg_nents open kmalloc_caches sg_copy_from_buffer d_alias writepage pagefault_enable lock_stat MIGRATE_ASYNC blksize timestamp_rec pi_waiters_leftmost qs_flags bd_holder flush get_xip_mem mode saved_sigmask i_lock __pg_advance nr_failed_migrations_hot panic_blink dqi_priv lm_put_owner pageset classzone_idx loadwop_avg_contrib i_flags resolution __remaining d_ino_softlimit i_dentry fl_next rcu_node_entry gendisk wait_list aio_fsync nr_wakeups_idle start_stack _min1 sg_copy_buffer PIDTYPE_MAX d_rt_spc_softlimit exec_max raw_lock page_ext_operations bd_fsfreeze_mutex s_blocksize block_max timeout raw_spinlock_t tvec_base fm_flt compat_elf_hwcap2 stat show_stats contig_page_data warn_slowpath_null signal_struct __cap_init_eff_set link_count pid_ns_for_children fasync_struct i_acl write_end d_hash set_xstate sysctl_overcommit_kbytes stack_vm cpu_chain _count __sched_text_end pollfd __invalid_size_argument_for_IOC __u16 d_select_inode putback_page task_io_accounting llist_node pcpu_unit_offsets has_child_subreaper i_uid vm_flags kswapd_max_order fault rcu_read_unlock_special blocked get_info sival_ptr raw_spinlock sum_sleep_runtime mmap_rnd_bits_min write_iter randomize_va_space hotplug_ts_rec kswapd percpu_drift_mark d_fieldmask ssize_t rlimit ra_pages dev_t cgroups zoneref __sg_page_iter_start __u32 sg_set_buf cpumask_t iovec lm_grant node_spanned_pages bd_part s_max_links length simple_dir_operations __warned acquire_dquot rt_mutex_waiter _unused_nodemask_arg_ lm_break file_system_type __MAX_NR_ZONES drop_inode page_cluster cutime i_dio_count ptrace root_task_group qfs_pad managed_pages inodes_stat_t arch_local_irq_restore bd_inode f_lock dqi_max_ino_limit unsigned int movable_zone hlist_head vm_mm ZONE_DMA tick_device i_mutex_dir_key  GCC: (Linaro GCC 7.3-2018.05~dev) 7.3.1 20180522        x ,               (       ABD
 A     ,               4       ABF
 A                    (       $               0       EAE $               P       IAI ,               D       A AAM     4                      A0AABZ      <                      A@AACN
 A $               $       ADC \               (      CpAABB
	Dx
 AB    ,               X       A DAO  <                     A@CABGd
 A                      $                      HA[ ,               x       DBS C,               T       A BAP  ,                      A AAr  4               h       A AAG
 A      <                     A@AACs
 A    D                      AAACGCY
 A   $                      ACB $                      ACB $                      ABB $                      ABB                                                                                                                                                        )                    6                    C                    P                    ]                    j                    w                         	                    
                                                                                                                                                                                                                    +                   9                   G                   U                   c                   q                                                                                                                                                   (           (       4                 x           	                                                                                                                                                                      
                                                                                                                                                                                                 )                                          #                     4                     >    \       (       F           0       O           P       W          D       e                     l    H             x                                          `      $                 (                X                                                                                        T                                 P             !                     3                     D    (      h       R                `                     r                     y    
                 
                 
                 
              scatterlist.c __reg_num_x0 __reg_num_x1 __reg_num_x2 __reg_num_x3 __reg_num_x4 __reg_num_x5 __reg_num_x6 __reg_num_x7 __reg_num_x8 __reg_num_x9 __reg_num_x10 __reg_num_x11 __reg_num_x12 __reg_num_x13 __reg_num_x14 __reg_num_x15 __reg_num_x16 __reg_num_x17 __reg_num_x18 __reg_num_x19 __reg_num_x20 __reg_num_x21 __reg_num_x22 __reg_num_x23 __reg_num_x24 __reg_num_x25 __reg_num_x26 __reg_num_x27 __reg_num_x28 __reg_num_x29 __reg_num_x30 __reg_num_xzr $x sg_kfree sg_kmalloc sg_miter_get_next_page sg_copy_buffer __func__.10974 __warned.19560 $d __get_free_pages __kmalloc sg_next sg_nents sg_last sg_init_table memset sg_init_one memstart_addr __sg_free_table __sg_alloc_table sg_alloc_table_from_pages printk __sg_page_iter_start __sg_page_iter_next sg_miter_start warn_slowpath_null sg_miter_stop preempt_count_sub preempt_schedule sg_miter_skip sg_miter_next preempt_count_add memcpy sg_copy_from_buffer sg_copy_to_buffer sg_pcopy_from_buffer sg_pcopy_to_buffer           :                     ;           D         <           T         =                    >                    >                    B           h        A           l        D           t        D           l                   t                   x        E           4        A                      (                  (               G                                                         E                   D           $        D           x        H                   D                   *                   *                   /                   /                  /                   /                  J                   >           \        >                   L           0        /   <       8        /   <       <        N           p        /   <       x        /   <       |        N                   ,                   ,                   /   <               /   <               N                   ,                   P                   Q           <        O                   O                   D                   D           ,	        T           0	        D           x	        D           	        M           	        R           
        S           ,
        O           x
        U                    1                    6   6               6                  6   =,                          )         5           0         6          Q         6   jL      m         6   +V      |         6                  6   F               6                  6   ~*               6   2;               6   3S               6   y%               6   KL               6   T               6                   6                   6   I      Q        6   p      W        6   KA      i        6   K      v        6   >              6   O              6   ,              6   OI              6                 6   :              6   'L              6                 6   1              6   Y6              6   A              6   g      	        6   g+              6   <;      %        6   T      0        6   K      ;        6   5      F        6   H      Q        6   E      \        6   X	      i        6   a      n        6   t3      y        6   [%              6   <              6                 6   uT              6                 6   i6              6   *6              6   H              6   ZK              6   V              6   N              6   +              6   -2              6   .      %        6   -2      2        6   uD      =        6   p2      I        6         U        6   A      h        6   EV      t        6   
              6   G              6                 6   2              6                 6                 6                 6   >              6         #        6   ;      .        6   i      9        6         O        6         Z        6   D      e        6   @H      p        6   4      {        6   C              6   `C              6   :              6                 6   -              6   -              6   G               6   (              6   4              6   -              6   $$              6   2              6   $      +        6          8        6         E        6   JN      R        6   	      _        6   +      l        6   #T      y        6   MB              6                 6   JD              6   9              6   mG              6   O              6   CP              6                 6   	              6   BQ              6   M              6                 6         "        6   }1      /        6   
      <        6   +      I        6         V        6   E      c        6         p        6   K      }        6   Q(              6                  6                  6                 6   H              6   >              6   P              6   B              6    	              6                 6   &              6         *        6   
B      6        6   :      B        6   R9      N        6         `        6   F      f        6   H      l        6   @      r        6         x        6   1              6   f8              6   ##              6                 6   -              6   @5              6   L              6   uK              6                 6   }A              6                 6   N      %        6   /      1        6         =        6   )      J        6         V        6   D      b        6         u        6   B              6   D              6                 6   A              6   ?              6   J$              6   D              6                 6   S              6   ^A      	        6         	        6         	        6         S	        6   `B      ^	        6   O*      j	        6   uK      v	        6   o      	        6   "      	        6         	        6         	        6   ^
      	        6   '      	        6   H      	        6   M      	        6   ?      	        6   2       
        6         
        6   uK      
        6   U      '
        6   5      4
        6         A
        6   B      N
        6         [
        6   UF      h
        6   <      u
        6   &=      
        6   pD      
        6   K      
        6   4      
        6         
        6   w5      
        6   $      
        6   &              6   2              6   SN      #        6   U      1        6   S      ?        6   !Q      M        6   
       [        6   
      i        6          w        6   ;              6                 6                 6   W              6   K              6                 6   N              6   S              6   5              6   J              6         "        6         0        6   f      >        6   .      O        6   
      `        6   q      q        6   9              6                 6                 6   I              6                 6   C              6                 6   z              6   `N               6   z              6   F              6   =      *        6   5      8        6         F        6         T        6          b        6         p        6         ~        6   cM              6   7              6                 6   _;              6   0              6   )              6   YD              6   9              6   @              6         
        6                 6   R      &        6   3      4        6   NM      B        6   `      P        6   &      ^        6   t.      l        6   l!      z        6   G              6   yR              6   =              6   1              6   >@              6   "              6   I)              6   -              6   S              6                 6   ZP      !        6   {
      /        6   -      =        6   <      K        6   ;      Y        6   E      g        6   ?      u        6   D              6   !               6   
#              6   N3              6   A              6   "              6   z              6                 6   4              6                 6   P              6   C              6         -        6   $      ;        6   2      I        6   D@      W        6         e        6   <      s        6   4              6                 6   P              6   T              6                 6   xC              6   5              6   v              6   .              6                 6                 6   /              6         8        6   :      F        6   ,      T        6   Q      b        6   d      p        6         ~        6   H              6   =              6   (              6   ;              6   L              6                 6   d/              6   
              6   R              6                 6   0              6   <              6   91      (        6   $      H        6   :      V        6   2      b        6         o        6   c               6                 6   e4              6   !              6   O              6   $              6   S              6   Q              6   Q              6                 6   K              6   J               6   Q      -        6   '"      B        6   <      N        6   91      [        6   $      s        6                 6                 6   I              6   ~-              6   86              6   <               6                 6   ~               6   s8              6   F1              6   9I              6   c              6   9I              6   sJ              6                 6                 6   (B              6                 6   Q<      $        6   J      1        6         >        6   *      K        6         W        6         c        6   rG      p        6                 6                 6                 6   k              6   ;              6   (              6   MU              6   T2              6                 6   N              6   p      '        6   q!      2        6   )      C        6   $      P        6   uK      {        6                 6   =              6                 6   8              6   /              6                 6   G"              6   >              6   1	              6   4              6         <        6   sH      G        6   %      S        6   `2      _        6         k        6   s@      w        6   4              6   S              6   .              6   y               6   b!              6   VV              6   C              6                  6   }U              6                 6   0      !        6   W      .        6   -!      ;        6   ?D      H        6   P      U        6   }=      b        6         o        6   U      |        6   25              6   V/              6                 6   q<              6   (              6   I              6   [*              6   T              6                 6                  6   =              6   uK              6   c      *        6         9        6   1	      G        6         U        6   WT      c        6   a%      q        6                  6   !              6   '              6   >              6   
              6                 6   +              6   _)              6                 6   B               6   ?<      .        6   @      <        6   N      J        6   T      X        6   '      f        6   ,      u        6   #              6   PT              6   S              6   P              6   T              6                 6   $              6   >              6         )        6   2      7        6   F      R        6   y@              6   H?              6                 6   G              6   `2              6   	              6   8Q              6   2              6   #              6   `2              6   8Q              6   	      !        6   2      .        6   L      :        6   ;      L        6   T      W        6   %<      b        6         x        6   <(              6   I              6   1              6   V              6   (              6   M              6   )      
        6   .              6   L(      $        6   RC      /        6   !      :        6   74      E        6   @O      P        6   C      \        6   ^O      h        6   ,      u        6   &              6                 6   d              6   @              6   	V              6   N              6                 6                 6                  6   9P              6   .N              6                 6   -              6   *      +        6   -      8        6   T      E        6    5      R        6   B      _        6   8B      l        6   >      y        6   *              6   ?&              6   ?              6   Q              6   K              6   #              6   >              6                 6   +              6   F              6         !        6         -        6         @        6   .      O        6   mG      \        6   :      i        6   K      v        6   }1              6                 6   +              6                 6   1              6   H              6                 6   6              6                 6   1               6   C               6         !         6   B      .         6         ;         6   
      H         6   @      U         6   >      b         6   o       o         6   (      |         6   R               6   j3               6                  6   QK               6   !               6                  6   \8               6   \Q               6   h>      !        6   I4      !        6   s      !        6         ,!        6   s       :!        6   N      H!        6   K      V!        6   4E      d!        6   B      s!        6   uK      !        6   50      !        6   "!      !        6   Y1      !        6   W      !        6   :+      !        6   "      !        6   "      !        6   4       "        6   %)      "        6         !"        6         ,"        6         8"        6   !?      F"        6   &      S"        6   X      `"        6         n"        6   <J      {"        6   4.      "        6   U-      "        6   9      "        6         "        6         "        6   C      "        6   -      "        6   uK      "        6         "        6   k&      "        6         #        6   !      (#        6   !      3#        6   w      >#        6   @      R#        6   H      a#        6         p#        6   	      #        6         #        6   1      #        6   R      #        6   7>      #        6   ;       $        6         $        6   D      $        6   K      =$        6   3      H$        6         T$        6   0      h$        6   O      $        6   "      $        6   8      $        6   L.      $        6         $        6   $      $        6   D      $        6   l
      $        6   <      $        6         $        6   CA      	%        6         %        6   V      $%        6   M      1%        6         >%        6   ?      K%        6   P%      Y%        6   G      f%        6   2      s%        6   0      %        6         %        6   3      %        6   _<      %        6   !      %        6   &'      %        6         %        6   H9      %        6         &        6          &        6   EI      ,&        6         9&        6   :)      F&        6   KG      R&        6   "      ^&        6   L      j&        6         v&        6         &        6         &        6   PV      &        6   V       &        6   S      &        6         &        6   !      &        6   /      &        6   '      &        6   e1      &        6   p      '        6   D2      '        6   /      &'        6   9M      3'        6   O      @'        6         M'        6   S      Z'        6         g'        6   -+      t'        6   V      '        6         '        6   G      '        6         '        6   "      '        6         '        6   50      '        6         '        6         '        6   >      (        6         (        6   vE      &(        6   `2      D(        6   8      Q(        6   `2      (        6   ,1      (        6   L      (        6   (      (        6   6      (        6   -      (        6   %      )        6   #      )        6   '       )        6         ()        6   <      3)        6   :H      ?)        6   "      K)        6   5      V)        6   DE      a)        6   `      l)        6   %      w)        6   R      |)        6         )        6   E      )        6   "K      )        6   3O      )        6   :      )        6         )        6   V"      )        6         )        6         )        6   gE      	*        6         *        6   =      !*        6   3      -*        6         9*        6         i*        6   W      u*        6   /       *        6         *        6   l      *        6   +      *        6   L'      *        6   H      *        6   (      *        6   H      *        6   R      *        6   +:      *        6   F      *        6   8V      +        6   .-      +        6   `I       +        6   4R      ,+        6   -      9+        6         F+        6   \H      q+        6   -      }+        6   hS      +        6         +        6         +        6   |      +        6          +        6   2      +        6          +        6   M      +        6   +      ,        6   k      ,        6   ?      ,        6   L+      (,        6   '      4,        6         @,        6   a.      L,        6   R      Y,        6   E      r,        6         ~,        6   =       ,        6   /(      ,        6         ,        6   z9      ,        6   9      ,        6   9      ,        6   9      ,        6   P      ,        6   2      ,        6         -        6   AT      #-        6   ;      .-        6   5      9-        6         T-        6   a      _-        6   *      j-        6   sS      {-        6   (      -        6   *      -        6   %      -        6   !N      -        6   r6      -        6   A      -        6   /      -        6   ,      -        6         -        6   ^      -        6   A       .        6         .        6   \      .        6         5.        6   ,      @.        6   =      \.        6   O      g.        6         r.        6   I      }.        6         .        6   @>      .        6   )      .        6   z2      .        6   C      .        6   K      .        6   x:      .        6   S      .        6         .        6   s@      /        6   uK      /        6         /        6         R/        6   }T      ^/        6   4,      j/        6         w/        6   Q      /        6         /        6   9/      /        6   S      /        6         /        6   K      /        6   U      /        6   c	      /        6   T      /        6   M      /        6         /        6   S      
0        6   R      0        6   G       0        6   /      +0        6   C      60        6   E      A0        6   H:      L0        6   R      W0        6   <      r0        6   ?      }0        6         0        6   uK      0        6   r(      0        6   ?*      0        6   $      0        6   ]      1        6   f      1        6         1        6   !      1        6   
      1        6         1        6   )A      1        6   %1      1        6         1        6   +      1        6         1        6   1      1        6   L      1        6   &      1        6   >      1        6   '      1        6   D      1        6         1        6   ~B      1        6   *)      1        6   k      2        6         
2        6   d      2        6   '      2        6   9      2        6   .      "2        6   C      (2        6   	      .2        6   i5      42        6         :2        6   >      L2        6         W2        6   J      d2        6         2        6   0"      2        6   +      2        6   B      2        6   g      2        6   ">      2        6   2      2        6   3      2        6   .T      2        6         2        6         3        6         3        6   T0      3        6   G      +3        6         73        6   *.      C3        6   D      O3        6   	U      [3        6   `J      g3        6   UB      t3        6   *      3        6         3        6         3        6   /      3        6          3        6         3        6   C      4        6         4        6   oP      &4        6   6      34        6   $      @4        6         M4        6   	U      Z4        6         g4        6   9      t4        6   *      4        6   P      4        6   E      4        6   K      4        6   
      4        6   e=      4        6         4        6   2      4        6         4        6   `2      5        6   s      &5        6   zF      C5        6   E      i5        6         u5        6   	      5        6         5        6         5        6         5        6         5        6   3      5        6         5        6   :      5        6   A      6        6   O      6        6   +      "6        6   3      /6        6   i      ;6        6         G6        6   R      S6        6   .      _6        6         k6        6   M      w6        6   S      6        6   /      6        6   E      6        6   G      6        6   N      6        6   (C      6        6         6        6   H%      6        6   G      6        6   +#      7        6   :      7        6   ,      %7        6   S      27        6         ?7        6   P      L7        6   R      Y7        6         f7        6         s7        6   "      7        6   6K      7        6   z/      7        6   	$      7        6         7        6   J      7        6         7        6         7        6   :      7        6   hP      7        6         	8        6   x&      8        6         #8        6   iF      08        6   K      >8        6         K8        6   +      X8        6   K      e8        6         r8        6         8        6   G      8        6   =      8        6   U      8        6         8        6   F      8        6   Q1      8        6   k9      8        6   "      8        6   2      9        6   |O      9        6   E      )9        6   G      N9        6   	      [9        6   @B      g9        6   X#      s9        6   R      9        6         9        6   O      9        6   }E      9        6         9        6   N      9        6   .      9        6   .8      9        6   V      9        6   9S      9        6   @K      :        6   _      :        6   oM      :        6         ,:        6   r>      9:        6   Q      F:        6   S=      S:        6   !      `:        6   '0      m:        6   *      z:        6         :        6   H      :        6   >      :        6   /      :        6   a'      :        6   &&      :        6   DF      :        6   <      :        6   ?$      :        6   &      :        6   '      
;        6   =      ;        6   F      $;        6   lJ      1;        6   ^      >;        6         K;        6   @      X;        6          f;        6   2       u;        6         ;        6   J      ;        6         ;        6   T      ;        6   -E      ;        6   z+      ;        6         ;        6         ;        6         ;        6   '8      <        6   A      <        6   9      <        6         ,<        6   .      :<        6   A      H<        6   @      V<        6   SJ      e<        6         <        6         a=        6         =        6   .      =        6   3      >        6         >        6   	      (>        6   *      3>        6         \>        6   J      l>        6         w>        6   fR      >        6   M	      >        6   pD      >        6         >        6   J      >        6   /F      >        6   @      >        6   ]      >        6   ,=      >        6         >        6         >        6   !      ?        6   ?      /?        6   0      :?        6   5      G?        6   v*      T?        6         a?        6   0      n?        6   &      {?        6   r"      ?        6   2      ?        6   B      ?        6   (      ?        6   I      ?        6   F      ?        6   @      ?        6   A      
@        6   ZE      @        6         &@        6   5      1@        6          B@        6   !H      N@        6         Y@        6   S      e@        6   *      x@        6   f&      @        6   N      @        6   9      @        6         @        6   <!      @        6   T      @        6   C      @        6   f&      @        6   N      A        6   T      A        6   f&      &A        6   N      2A        6   	      >A        6   vA      JA        6   #      _A        6   ]	      kA        6   H      A        6    ;      A        6   6      A        6   1H      A        6         A        6   <!      A        6   *      A        6   DG      A        6   G      B        6   A      B        6   E      B        6   9N      7B        6   #      CB        6   ;      OB        6          [B        6   .      gB        6   "D      tB        6   B      B        6   4      B        6   0      B        6         B        6   I)      B        6         B        6         B        6   4      B        6         B        6         B        6   $      B        6         C        6   $      C        6   D	      .C        6   9      4C        6         :C        6   @      @C        6   }Q      FC        6   0<      MC        6         oC        6   V$      |C        6   J&      C        6   B      C        6   F      C        6   f-      C        6   4@      C        6   M      C        6   *      C        6         C        6         C        6   ?      	D        6   ?      D        6   D      #D        6   C      0D        6   q
      =D        6         JD        6   B      WD        6   v1      dD        6   ~.      D        6   `2      D        6         D        6          D        6   .      D        6   H      D        6   1      D        6   9      E        6   c       #E        6   
      0E        6         =E        6   `2      IE        6         UE        6   7>      hE        6   #      sE        6   A      E        6   UP      E        6         E        6          E        6   D      E        6   2      E        6   9      E        6   )      E        6   `D      E        6   H      E        6          F        6   C      F        6         F        6         F        6   +      +F        6   9      8F        6         DF        6         PF        6   '      \F        6   ?      F        6   D      F        6   7      F        6   !      F        6   N      F        6   ;      F        6   P      F        6   }      F        6   ,      F        6   D      F        6         G        6         G        6   %      *G        6   1      6G        6   @      BG        6   I       NG        6   J      ZG        6   i      fG        6   '      rG        6   J      ~G        6   9      G        6   !      G        6   _V      G        6   L      G        6   US      G        6   "      G        6   `2      H        6         H        6   !      H        6   0      %H        6   R      1H        6   
      >H        6         JH        6         VH        6         bH        6   r9      nH        6   &      zH        6   Q!      H        6   0      H        6   l!      H        6         H        6   0      H        6   4M      H        6   +      I        6   4I      I        6   K      #I        6         /I        6   H      ;I        6   $,      GI        6          SI        6         _I        6         kI        6         wI        6         I        6   K      I        6   C      I        6         I        6   :      I        6         I        6         I        6   +      J        6         J        6   $      #J        6   iK      /J        6         ;J        6   R      GJ        6   x)      VJ        6   `2      cJ        6   4      pJ        6   G      J        6   4      J        6   	      J        6   )      J        6   *      J        6   "      J        6   O      J        6         J        6         J        6         	K        6         K        6         #K        6         0K        6   L      >K        6         LK        6         YK        6         fK        6         uK        6   XR      K        6   ,      K        6         K        6         K        6   	G      K        6   1      K        6   <      K        6   N      K        6   F      K        6   !      K        6   /&      L        6         L        6   uK      !L        6   &      1L        6   S      AL        6         NL        6   G      [L        6   	      iL        6         vL        6   '      L        6   N      L        6   `      L        6   &      L        6   X4      L        6         L        6         L        6         M        6         M        6   U      M        6   j<      +M        6         9M        6   @"      GM        6   0      UM        6   )      cM        6   YD      qM        6   *	      M        6   3      M        6         M        6         M        6   -      M        6   p#      M        6   8      M        6         M        6   F      M        6   1'      M        6   'M      N        6   [      N        6   P      'N        6   (      5N        6   N      CN        6   X!      QN        6   ](      _N        6         mN        6   =      |N        6   f      N        6   3      N        6   [      N        6   /      N        6   >      N        6         N        6         N        6   
      O        6         O        6   ,      O        6   /      ,O        6   8	      :O        6   F      OO        6   O      iO        6         wO        6         O        6   (      O        6   E      O        6         O        6   E      O        6   FC      O        6         O        6   b@      O        6   x      O        6         O        6         P        6   K      P        6   w       P        6   B      -P        6   
      :P        6   uK      GP        6         TP        6   Q
      aP        6   4      nP        6   0      {P        6   ;      P        6         P        6   {K      P        6   M      P        6         P        6   v      P        6         P        6   %      P        6   #      P        6   #      P        6         
Q        6         Q        6   x(      $Q        6   <      1Q        6   
      >Q        6   M#      KQ        6   >%      XQ        6   "      eQ        6   =      rQ        6   g      Q        6   2      Q        6   X3      Q        6         Q        6   w      Q        6   -      Q        6         Q        6         R        6   <      *R        6   8O      iR        6   ;      zR        6   &      R        6          R        6         R        6   uK      R        6   ;      R        6   3O      R        6         R        6   ]      R        6   ;      R        6   @      S        6         S        6   }      S        6   :      *S        6   (@      7S        6   mB      DS        6   '*      QS        6   P      ^S        6         kS        6         xS        6   	      S        6   ]L      S        6   @      S        6   3      S        6   9      S        6         S        6   |N      S        6   G      S        6   I      S        6   @      S        6   ?      T        6   1      T        6   X      "T        6         /T        6         <T        6         IT        6   S      VT        6   QL      cT        6   Q      pT        6   Q      }T        6   9      T        6   M      T        6         T        6   6      T        6   |P      T        6         T        6   @      T        6   :      T        6   L      T        6         T        6   A      U        6         U        6   N5      &U        6   g      3U        6   LQ      AU        6           PU        6   !      ]U        6   `K      kU        6   7      xU        6   &=      U        6         U        6   L      U        6   (H      U        6   8      U        6         U        6   5      U        6   |J      U        6         U        6   ,      U        6   =       V        6   ,      +V        6         8V        6         EV        6   Q      RV        6         _V        6         lV        6   \      yV        6         V        6    &      V        6   =      V        6    &      V        6   #      V        6         V        6   x?      V        6   <      V        6         V        6   #      W        6   $      W        6   &      W        6   uK      )W        6   {	      6W        6   *      CW        6   {4      PW        6   9F      ]W        6   ;      uW        6   S      W        6   D'      W        6   WM      W        6   w5      W        6   N      W        6   E3      X        6   .      X        6   p$      LX        6   !       WX        6   =U      bX        6   $      mX        6   dA      xX        6   D@      X        6         X        6   <      X        6   D      X        6   /      X        6   5      X        6   :8      X        6   U>      X        6   1#      X        6   9      X        6   )      
Y        6   L6      Y        6   O*      $Y        6   2      BY        6   #3      NY        6   "      ZY        6   E      fY        6   U      rY        6   *      }Y        6   )      Y        6         Y        6   I/      Y        6   B      Y        6   %      Y        6   F      Y        6   8      Y        6   $      Y        6   (      Z        6         &Z        6   UP      2Z        6   .      VZ        6   *      bZ        6   l
      nZ        6   %      zZ        6   
      Z        6   2      Z        6   P      Z        6   Q!      Z        6         Z        6         Z        6         Z        6   F      Z        6   A      Z        6   9      Z        6         [        6         [        6   !      *[        6   `$      7[        6   .      C[        6   `2      U[        6         a[        6   B9      m[        6   G6      [        6         [        6   	"      [        6   /      [        6   )      [        6   F      [        6   U       [        6   ?      	\        6   A#      \        6   A      !\        6   #      -\        6         9\        6         f\        6         w\        6   O      }\        6   L      \        6   8      \        6   S      \        6   m      \        6   u      \        6   PA      \        6   (      \        6   U      \        6   D      \        6         \        6   :      ]        6   +      ]        6   N      ]        6   	      (]        6   I      3]        6   I      >]        6   |'      I]        6   +      Z]        6   
      _]        6   !      k]        6   )      w]        6   I      ]        6         ]        6   M0      ]        6         ]        6   H      ]        6   <      ]        6         ]        6   2      ]        6   L      ]        6   -      ]        6   L      ]        6   '      
^        6         ^        6   k      !^        6   M      -^        6   0P      9^        6   ^=      E^        6          Q^        6   D      ]^        6   s      i^        6         u^        6         ^        6   &      ^        6   5      ^        6   8      ^        6   %O      ^        6   -      ^        6   L      ^        6   '      ^        6   U      ^        6   (4      ^        6   M      ^        6   G      _        6   0P      _        6   s      _        6          +_        6   D      7_        6   f2      C_        6         O_        6         [_        6   &      g_        6   5      s_        6   8      _        6   O      _        6         _        6   	      _        6   S8      _        6   L      _        6   8      _        6   O      _        6   A!      _        6   &      `        6   ,      `        6   ?      '`        6   lH      4`        6   H<      A`        6   L      O`        6   UO      o`        6   
      z`        6          `        6   A      `        6   w!      `        6   8      `        6         `        6   3      `        6   X      `        6   M      `        6   )      `        6         a        6   `+      a        6   36      "a        6   -      /a        6   C      :a        6   W.      Fa        6   R'      Ra        6   {G      ^a        6   ~      ja        6   ,D      va        6         a        6         a        6   C
      a        6   F      a        6   K      a        6   J      a        6         a        6   D      a        6         a        6   8      a        6   A      a        6   w!      b        6   8      b        6   V      b        6   P      ,b        6   J      9b        6   s=      Fb        6   Q      Sb        6         `b        6   H      tb        6   3      b        6   $R      b        6   -2      b        6   5      b        6   3      b        6   ;.      b        6         b        6          c        6   R@      c        6          c        6   x      'c        6   ;      4c        6   4      vc        6         c        6         c        6   aG      c        6         c        6   /U      c        6          c        6         c        6   ;=      c        6         7d        6   ^      Dd        6   iT      Qd        6   )      ^d        6   tI      kd        6   53      xd        6    Q      d        6         d        6   J      d        6   0J      d        6   5      d        6   0      d        6   L      d        6   4      d        6   Q      d        6         d        6         e        6   P)      e        6   TG      "e        6   	      /e        6         <e        6   #2      Ie        6   2      Ve        6   S      ce        6         pe        6   *      }e        6         e        6   A      e        6   R      e        6   +      e        6   :'      f        6   2      f        6   uK      f        6   ;      f        6         g        6   >@      g        6         `g        6         mg        6   O      zg        6   mA      g        6   =?      g        6   52      g        6         g        6   }6      g        6   R      g        6   M      g        6   %      g        6         g        6   M      g        6   )      	h        6   IP      h        6   0      #h        6   \      0h        6   HS      =h        6         Jh        6   =      Wh        6         dh        6   r      qh        6   D      ~h        6   "      h        6   @      j        6   h'      j        6         k        6   g"      'k        6         2k        6   0Q      =k        6         Qk        6   s4      ]k        6   Z      sk        6   Q      k        6   K      k        6   5      k        6   "A      k        6   %      k        6   @      k        6   I8      k        6         k        6   $      k        6   N      k        6   G      l        6   B      l        6          l        6   /      -l        6   y#      :l        6   B       Gl        6   E      Tl        6   ^?      al        6   .M      nl        6   j      {l        6   j#      l        6   +      l        6   hN      l        6          l        6   A      l        6   oC      l        6   &      l        6   #E      l        6         l        6   J!      l        6         
m        6   )      m        6   G      $m        6   J      Cm        6   $      Qm        6   Q      ^m        6   4      km        6   }8      xm        6   qF      m        6   	:      m        6   b      m        6         m        6   <      m        6         m        6         m        6         m        6   ,0      m        6         m        6   2      n        6         n        6   3      "n        6   1C      /n        6          <n        6         Pn        6   O      ]n        6         wn        6   D	      n        6   +      n        6   3      n        6          n        6   O>      n        6   l
      n        6   9      n        6   T      n        6   +      n        6         o        6         o        6   *      *o        6   y      6o        6         Co        6         Po        6         o        6   `:      o        6   (/      o        6   F=      o        6   -      o        6   P      o        6   I      o        6   T      o        6   cU      o        6   #      o        6   "      p        6   B      p        6   ?      p        6   2      p        6         p        6         p        6   mO      p        6   2       q        6   .      q        6   B       !q        6   ?      8q        6   LJ      Dq        6         ]q        6   R      kq        6   L      yq        6   '      q        6   J      q        6   *      q        6   I      q        6   Q4      q        6   k)      q        6   n1      q        6   <      q        6   -2      r        6   L(      r        6   	      r        6   .      <r        6   lU      Ir        6         Vr        6         cr        6   ,
      pr        6   *G      }r        6   2      r        6         r        6   0      r        6   4$      r        6   -      r        6         r        6         r        6   >/      r        6   =      r        6   kV      s        6   x      s        6   6       s        6   X&      -s        6         :s        6   ,      Gs        6   U      Ts        6         as        6         ns        6   %      {s        6   L      s        6   k      s        6         s        6   q'      s        6   *      s        6   I      s        6   @0      s        6   "      s        6   )R      s        6   @      s        6   2G      
t        6         /t        6   j      ?t        6   O      Ut        6         pt        6   $      }t        6   AN      t        6   f?      t        6         t        6   2A      t        6   I      t        6   pN      u        6   	      u        6   T      v        6   1      w        6   '      =x        6         {        6   @:      |        6   .K      |        6          |        6         |        6   )      |        6   v      |        6   8C      |        6         |        6         }        6         }        6   U      }        6   k      )}        6   h      =}        6   8      I}        6   #      f}        6   /?      ~}        6   vM      }        6   8L      }           
      }        2           }        6         }        2   #       }        2   F       }        6         }        2   i       }        6         }        2          }           
      	~        6   p      ~           
      6~        2          ;~        6         F~        2          V~        2          [~        6         f~        2         k~        6         v~        2   ;      {~           
      ~        6   }$      ~           
      ~        2   ^      ~        6         ~        2         ~        2         ~        6         ~        2         ~           
      ~        6   O                 
      &        2         +        6         6        2         F        2   0      K        6         V        2   S      [           
      j        6   nQ      u           	              2   v              6                 2                 2                 6                 2                 6                 2   N              6                 2                 6   D              2                 6   e              6   uK              6   ":      )        6   >1      5        6         B           P
      c           P
      x        6   hQ              6   f                 |
              6   >1              6                 6   >1              6                 6   >1              6                     
                  
      *        2         5           0
      S           	      `           	      m           
      z           0
              6   &9                 P              6   e              2   L                 `              6                                                   6   &U              ,                   6   /                       1        6   z3      B        6   >1      N        6         `        6   >1      l        6         }                                          2                                  6                                                                    6   #               6   i;      -                 N                 q                                                                                                                       4                 A                 W        6   M      h        6   e      u        6   :                 (              6   e              2                 6   D              2                    T              6                    d              6                 6                 2   J      
           \                 @      &        6   h0      7        6   e      O        6   q      \        6         h        6         w        6         ~                         6   e              2   m              2                 6                 2                 6   uK              2   "              4                 6                    @                       &        6   %      7        6   9      J        6   B      i        6   T      v        6   9              6   ?              6                 6   q              6   "                               2   k              6   D              2                 6   "              2                 6   D              2   F      	        6   l
              2   |              6   )      $        2         )        6   $      4        2         C        6   LF      g        2   1      l        4   0      u        6                  2   z              2                    x              6   hQ              6   f                 `              4                    `              4                 4                 2                          %           |      2                 F        6         W        6   9D      c        6         o        6   )              6   2
              6   9D              6                 6   5%              6   
              6   )              6                 6   3B              6   D              6                 6   49      "           `      9        6   9D      C        2   /	      H           |      W        6   oL      ]                 t        6   9D      ~        2   R	              6   5%              2   	              6   J              2   	              6   H              2   
              6                 2   =
              4   0               6                 2   
              6   D              2   
              6   "                                 2   
      !        6         +        2   (      0                  =           $       L        6   <      V           (       m        6         w        2   ^      |        6   )              2                    <                  H                  P                  X               6   C                 H              2                  2         %        6         /        2   I      8           l      b                 j        4                                                        l              6   =                               2                 6                 2                    ,      ,           $      :        6   D      D                  e        2         k        6                                   6   O                                2   !              6                                   6                    \               2   j      !        6         -        6         9        6   ,      I        6   $      U        6         a        6   $      m        6   d      }        6   $              6   u              6   $              6   O              6   )              6   F              6   9              6   ,              6                 6   
              6   T      5        6         A        6   ~      \        6   1      r        6   $              6   D              6   ;              6   $              6   *.              6   F              6   ;              6                  6   $              6   N              6   $      #        6   l      4        6   l
      @        6   uK      M        6   !      [        6   0      l        6   l
      x        6   uK              6                 6   %              6   l
              6   F              6   %              6   NH              6   o-              6   l
      	        6                   6   \      0        6   l
      ;        6         G        6         W        6   uK      c        6   U      o        6   uK      {        6   #              6   uK              6   L              6   uK              6   ?              6   ^
              6   0              6                 6   K;              6   D              6   ?      7        6         I        6         c        6         s        6                                  2                 2                 2   k              2                 2   6              2                 4   `               4   `               2         '        4          0        2   $      9        2   m      B                 J        4          j           l                 8                               2                 2                 2                                                            $                 6                 n                         2                                     4                 `                               2   h              4   p                       '                 A                 V        2         d                 y        2                 2   
                               2   -              4                                  4                                  4   @                 (	                 (	      6           0	      H           0	      f           x	                 x	                                                6                 6   !              6                 6   ER              6   ER              6   t              6   t              6   H              6   H              6   ((              6   ((              6   J-              6   J-               6   $6              6   $6              6   !              6   !              6                 6         #        6         '        6   	,      -        6         2        6   r      6        6   r               0                               i                            8                               D         8           H            (       t         8           x            \                8                                       8                                       8                                     8                      H      D        8           H                         8                      `              8                                    8                            <        8           @                 |        8                                    8                                    8                                    8                                    8                       P      L        8           P           (              8                                    8                      	              8                      
      4        8           8           
      \        8           `           
              8                      
       .symtab .strtab .shstrtab .rela.text .data .bss .rodata .data.unlikely .rodata.str1.1 .rela.debug_info .debug_abbrev .debug_loc .rela.debug_aranges .debug_ranges .rela.debug_line .debug_str .comment .note.GNU-stack .rela.debug_frame                                                                                             @       
                                   @               @3                               &                     <                                     ,                     <                                     1                     <                                    9                     K                                    H      2               L      Q                             \                            =                             W      @               8                               h                                                         v                            v                                                         0                                    @                    0                                                 +                                                                                                  @                                                      0                     {V                                  0               +"     2                                                   ]"                                                          `"                                        @               8                                                     '     p         :                 	                      x/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x{@?oxD3.D(RyXjx0<IN)iGJ#^N.<]Nx9N-(g=f~P{_a>5kYf{geDF5O=n109pX{=@}T13yw0oo=?n*B*r;|r=="kF=wGE;vT0]r$^^YD?	9%E9FcDt>4/'~u z^[ZNVJmhv%Zy>>vo>77|>_ed 	}_[a _,6\e_mXO{_lg>oOxsO|w{Zy?k[.O,,x]EW{e[YZ^@|~^d/Z[,w-o,x+Ldg:|Z,7yo?/G;9O;7<am' &(x0)oO'<#? dRagV>!L?
AYHx	A|F
BPLxb<rYzyxp.b>F	<g>9|HgK 0NB?
 @K^/!C8D$OP_6~ 	>BT\z,x\$75 7
|7$WqIy>S}0O+Job|p'/%_Y-0@O;e_"W<&T0~3//^?2^"%WAx_)$8L:[^W&c0	/
+
*[? r^# 
+.'A(l'
>}$SC}^+A:D.i"p)<N's8|bRL_3})QPDwNL{	Bc y!_Y_Jx}>N<N?!2[kN^?ABHhAL,4p21v>%#!><`t57JSyL <m+x7YnxXzz{T+"N@u)(y>y
G LWO3^a$12/(-]z}zelgH<C/c{=D0.g1V?R?xN Du'OD^yxc.^ 
|1s;DA(khBxr2q	Or/b7#|ssgQoQa
9r0Gb/c&AgA$ghA_|r~f|4AzA/|3}$^Sw/!k^!<rw/Wxz(q^`<~clDje{yd>qIgd5Onr!oeLS5?h%~KFfI[!OA9-~8	B|hoT	9Wr'#	@ A(gkN>/"(A!7
+Y?[Y?,{O|FOx8 <mm/1~%{.~/M*gO83ZQSza<N6zc {,?/uZq7
|6< |w$g,:pA_J8qK.+?by"xP<N8v^0Hx/gE3i_iO{[xe.cWF5B@?e}R?0~qEa	=/g60a/A s?KNvox z@AY>|-.<K%y}"9/|39g;_H1^x u:E;r^{0RB8	!
sg"'7x^~g+mU&yK;}GM_qyq3h|jx*x !`'7(O90?&D9 lYYPe <	|/k>?KXoPxm`|ti?dE}G&3
^|D$|?3F|!>+q`$7qBzO"!L<@ys5mFpT<F
<)/_s'?"W> !M`}<<Lp\yfoH#<."c=q?}>W2isO=KO}z3~x~_BE{'/}X>	|^-5+3t\#	M_0^z|2ZW~*Kw?B9i]
z6%Q|+Z<]!P~qbwpT'<<R~7AOz/sG9SCR;|r_|vH|*YR_s{8AMBtyEA_xB!Y#4;r+f@(ElqO [r<s{ 6<Nj%O-61nW
Rk@>O%Y;g?H{1J/A!f<
!y2#-J0JquG%}@/\<7Rf?VN0^i!B=x]|F{K;xT08|Np0x_E)<~_ =t|^CGa4GzYw &>w	>A:{9N<BJGX80
'#S.qh{-y9xs 2_"qyIyx?!LPil 1$>/;	rP 4M|Ry0lWPyD^Em@]j#/<F0O"xC#}@DPb+Ao,5d=;~5i_Q:f`>-ob=Ob|pq s	,?Cx
C<B#sEK?m~~`u:A#Q;0eOI(flJ8BGzD<cil{dvGn[uGt}ExNrt&T<!qQ \U
+8xq_US?!BbwGj/S: 3F7w.3x^8^/ 7X~i#b}m~s^u7sFQc/Ag p#|!}_)L+'=9yQPK !CC>y+>vvgkdI 1gG_ywrYlW<uzw,_qF0]g*a/~88oo]+Mb"/Yxn/3{^
< }_|Tb@:g9~*p=[8LS0m=]3,#l$!ygnW8?	x28`<qsF@*57qT+,	q}/Sw+EYST%	,@[_ +2s\*A`,[19B|R:y/,X'QoQ_E~a>E6~og	)4	@pJ|g1txyG=,oJg]n"'8^}<za;Icw>^/x[0U q8*}f>aGW W?yF~f8 R;iN!P3
=W`(3X'7<IA_xye|^o;^_$d{)_XB|kK>,NO.L_Yo.%SKrK3&Lc2(;E9%Fcd4FF.Z_#SoGIQI~	QYd*Y"!Q~i^,JeL-+'&=*s.,YiYdq%e	enD_VFmp<}QdIQTsivfd	e8E#c&aa2R
5&g+onLJ-(fy" 3
&efOY#HWz"5X#*u3D/3"D4$3;7v8lWjd5*Ev,}9E909_B(.*D0K*3eMpYbdP[,^V!K+J2QJ-hJKnQb193h@OmES	$Jfc5hxnw9fN87;r>TXq@)RYy'g+U+DSf2czt2
j4!#ra9Ks#lvnWRAsLF?=5sJLFnqQAAzvY7Bx}LL^B*7t^AmMYID}%%E\c1}:tXi@XTb)tCFNYwG^~YnaT
srKa,I6!=myE_.$^azlInLtqj~g#&'JMK!tri&G$\%rg%JI#|9yBAl1x+XQ
eMNLs&MOJ1erS0rc.4<iE}A]:uRYoT<z>'R8{txb9eJS89m_U
QID%*
^{AU%yh'!zcBmF20 FI-UcM9E9CtzfJfn[mGL{)YMadbd|#OO5ie4-%KffF9s#Gm,TcL-lfH.d>y-j7Y-SPlUkdE	\2nPf:T/>hZn!b+"V
ztY=ibK*B<x$=7xfT QUH@25s1r#))m6f]}CKq\an6sN_wVdd^f "}Y)+ssnE"
S+jv3XZ7,^M'*=9Y,l:kB[rr5}Iud>_[>vtf.[(;{f<!N)nU+"#mBkisg8%c'5J}&LKhB\YQT8"yye$0sz.?2\@**9~di%Xs-`YEOq;PeZuJQ!yZ`yCMnMX.*YZFDX;XV@)?9v=6>eQ0WL:cFW$,drRF(EFjhKbicQ\bxLmn=5'{*.\H*%YafS<lDqSRKu<93'Y.}Qv&q.0/("#rsJiEk<A)28H1$i13=x;{ dRz=f:fV aew5_
|e"2Vx$Q$e/Y..uzA;22=q?czxSZByjX=}\3~aKsshLO7U}-f,O}7'hyDFb!5!Fo"#` >..g3MVEjDYE&G,4<ZvoBY|:x.6]EbZ,'LzemAh-I^~^sWWlM7[,Kc1A`s!eEf#h\Oo[cKr\5e4^g#wA^GE<~yj7y\<28Q;<7"8hxe3-y5jiUli`Fqi}h'h>Q8n1=u(>GjNc+(UlL3]dd['%
i&Xife1f";B63X3Y(XZ(eExcK&e#cGg.&0:*}rItRJsJ8P;qw$\(l	%&y_4~~E44XqMuKn*
.3cD /TZKQu{R8hM,y`c7Zt#[3[-}}]y)jE}{vzW9=w?Ydf-,"d.!,>G_lEOfI:4v\rRp/5vyn/@(ivyDs+*#c2q`s'":)bp,[rR7LJ:+yBz=XAB83g"*W 2]]TTC^HJrgydlS(
s!!%-D bMEF``u[StPS'.e
$s?/e4S.M"b4@IaeOSHa[n$NS.g2,G,tG-zAx.2..!'U"dz`5xypW,h4
\OrJW	{-ONy,N$O]ED]8v9- rZYIKs",4;/7'jYpW$.m,;9S^DQ8$Kwd7;.jNGKNBr4r4vZe2 9\Av+3Cz^zQp33S(p&NRB+T 1$d4.8<83'=<x{IT<`[j:=	Ej[5)Z#"V6FTv>UTQ	mTxRce$h*R
G3.2[]iLRR#I/J51txS38}JI+o8$4Z ucJ,iMxVBf\!7z<Cg8Foh-gY4.%5ci(|)f
jF!2DF!WlAxMXM3"@ O\CoJx6Hz2c(ty1bN,X(yxY}K'<9yt)gp.%-6^(&u<*>?=9-BuCp;("c;%-3u,q 1'q"h[#_dTkM 0':\Xs&zKtM_Z&AcKp}nht S?s9BPbs;"'+zP/`wIM/g>h9ZXx.0,b42t8+YzP|#I?IeqQ]E05NaZaZ5iyg0q>($ 
"[hby(>U->Jf4Gx2fUo<wsZtoFsQ$*}"M:kOmKOr=jehBOA1K&z*6zMY`Oas'bo $j^,Hh oYr"%8((20q3ubq!Flg*oU^&#R2F}/*_=pQz 8Ujqy9glM)\cR"vY
qQ&L41bfWc8"c5_,-<u <<M*j4OG^)*>sXo4Qcxbda!Sy{'QscbjI]O!k{`|e}eT;KKbEG0vf)d539hRJ]%.4OuF' 68l&q$$V-%1hF]KZwj_aqyZW
zvp[~oa{rDR{+j<uEZ'w"rkNU)m%h)KO~Ie>5iAC^iYfnZ;Hgc>0oSof/*Au1>5EAZsdn+2B,FobAGsPOSy7&jLCKGQ!>#-*I
-k^p-W:i8^:eq]CI[M^9s8UZ/8z0FtAt_?	_	kmAvP:J7b0j|m6_i7
ynyuoe;x&c$TGTi ./cohk#8[j|0l$&:[9&.tu+~<+cn"B*mFZ'Ig+F%@3
?4`CHuU)l,qv.nxPaUvPVk}:uIZ.;?cGV9a??|N:1vv	mp3vn[Zw	!q\06h7yvWTd>hD+!BVW$(=NXXHO56VTb|w@!	/=x7B4eL$y?f^4^!G@Z R%#H!=DSf	?i-H/""mDzifW^GHD_QH1H_0% #FRHtC:ae'q?t:}4}=1@+$S]]{i^HX<} $oW5b ;	H	HHIH7#O>A+7LHCi"}HH9HtM=i:	6J!WGm]D?/aeH jZw3?,j~VsH#H/!iH[!mGD?p.H }Ht}O?Gi?c~ a"G:tR][!Aj~*~v
P~HW"@*"#])X$Ft=0$dF#ADtH~Cuwb>`o_1zku?	8
Lmm=/\>_}_o{Sjs=LMW'N?n|neoj-Haj0SIRSe_v}fTz7w>}?~u{+,x}nGw_Lye?.&mImNG={z<>+r?d_zae=6wLhJ{^,1<zmi7=sgcly;7*Oi{+ZU)FOM^\WJ]CcK|=Cx+I;GcFyA<zU~}Nz8zO_{f#]Wmxo8>'	E~vm(S6iyFd>?VKJUO-yO	->Tr~1oS{8S~7oW)v?_0#^Tp.>1kkx|34yOk;V<oY5/awhO|qn_q@o)?'w~Q_70wz87<3q=\q?^)8}Uw.g>g~~f_1kC?%x`L?53&^hM/<>wE^AmG_7|go*-mWVe%9|79X*O6(;VW|o6q6g~;Guzt6_Ks|[sv'86>8y~~Kcy_M&1|l^Xc~V/o\3qK1s}??O [Mkg}g7=yO;=iIgqC[<nS2,x7d?;mwW]2
6oCztdA4P}3VG-+}8g8j%'kx-KRogR5n_[uG>-xHK^q"b~\}mYGkg\{crW}=7Mgs4}{?2OwbG>Wyw6gz{jmN~[#KI'=0+o1(o7sT}}p'6_}sc"d[KG^_rS^V~{YF?3Oxn<saQgkM}v5}{c{SZ3[ro=q>gp]v7B|hsc|{E}wqwjIv{559]aRF'=Gt{UTyF>TpoUZv)#,~m}{nosLp/h:9#nkn|+N1)>$-foLLI/aJo4]h*?e6<kv{/.;9gq?y~-dcCk6V}Wiwv-0.71~cuWo[zq'W}4c^|]W|$OU?9a^?wc_u7?4B?	M!iLp/{)7sQrs4_N3v?fp>}+cf||?tUb| m&j{}!Akg0_k},|lIGp{..Ns>J>Q%4\R%*WjI?j_^5\`K'4\op?OR{oziz8 0/g<BS+OS5|ib/M<\.VaWj]*|6i^b3k
!?DcK#,8zpjR/.p.}K:KIBAAB4\oF4|wjh2ix#.p.hxY:&|Zu.OftW2~B7j}FYOJhC2gihxS:14<LYuh:|OvF]}BklgI4GD//phT;Qe{3,<z+pG_R_Wjl&wWN{-}._%[]og\372>QexK5\ hR~?^B7jA|$p)K0s"4|q.uL	.|?x?B2JUJ{Bop;[5<);Y5\K~9_5\3p/!.8L+Fh4<hwjx)xe\5|"d4~Ink9So^	
 za_5\Wl -~^/x9:^aWZ8TcYiX{-}~oOXux_]k>#iGD-)A(#?5=2zTg(x)x?/V
^
^RSJt8_}FRu
|oUkN)^Z)xW^AuORFTpp
d
C+(x*x)x+x_
~)w*`OQ
N7)x]WBX\G(x
U
~TdQ|)&[<Q<U*-
OG)~
>N|P
#vhw(P<H!
~)DPI
w+SRGSN]<CP<
IW(|C+<HR_}F)CoRpez7*8W{*yUp:-}
FW
^AwTFSX^_=<) 1:yp?e2=gYJI*UR"PE>JD%2YJ*_.%w*]c|D%!YJ*_D~7AC|?|/YJ$Y*_CF>T#; ;#PwC~.%|(xwU'*kRQ/TU#KA%zw#u7u||B%;kR Pg!oAdCT|!YJJ~kR?"oAC'*GR!P?Z%
]JY*otJD%2YJ*_.%w*]orJ]g)O_?G~]JTsJ(Jg)/Tg_A~"QXqegcZLye#0%[d[aTo~]3YOTlQs|W3:mjWMyUj~*.hZhZKu5MrNLnT	?'Q>uhcAjGQg7X!;(w}EFMg|!'l<B5H=WtRC>Q?:X"fl9>&qM}5ahmle3vqlo_cEtx0^}hGw}& 5of3>w{4xN6R	5VOg	|Ny%|9alLQR6R[|lc!OC?xt9_!~}M,|96}+Q
yvMez;~SAv#9qEE.:D.6W"1}i_{=$oB:}:]5y_4d}CA-<:LoAc!z7uO%3V[f;Y{z9k>ypn/|nLqZE=,|Q&{=OWQXYFX~dRg?|w);e=Z6~gC]fkK/\xM~ZT12PZ/t9Zh9H#AExyWx><'x0gNt rq~u=/}9c=(f8wpo{ h4fY1j3`sN.{[21.)19K4|n`z14sE]~[aU:|ZaE6b^8nel> }VQn1$wH=	;;e?6F{W<:6 ef{t6(iGC;U!~;|iP|z.:w=DznY%dG4oo#z@~S7I7Q0xgucHuV`vz-zv1@Q&xKk"\[|14}j11BcsA.	?>w.=,OVMs!slb~F,.z`k`om2nt1Re|hcb@Gh#e;le36,S:Cq7(oZyqM'(>}lFQ:{u[t!#vwQt?EmQ_tB<?9~@1`6?$_S y{ScD}$GxA)VzcEH#hZaT67%G.Y5(r_L{g~O
@'Whz|.i'zQOzzp3{m_omj=@?\opn1IiLS{X{o~xc6%=o=yk`\|tz(y=dAZ1~9T|z`+:rb[-2ji(['~6wm~G;'7V8w*6/59K=uQ]a~ya^ [9C117_]\}1uJ8dva+-mG la3dOf%cEd/_L9FSuWcEFu/e]^q;e~v'#}u='v=?ujUs[&l;/'nVM_<;z&16z^Q?n=hsmbnt^nl=o^z%<ZAsu Xg9#/hr$kj0Hw>=z) kb9xr'857Jr>\w}6~npw;:VdVv>MW]?puCo\fsnfmY4t*bkk|jxA~2hD6uN<:;CM%4|\U=x1?`*{ u*(;?kC\XUgP^{uv@3\|Jq4ToUOi_~FmtU~mT4|[cl3YYMMMHXOrKFQ8G{EH4V!6ocrDoVo<'Xqgq?4&G/~LD>g=	^3b^<nI'oCWmS\kb-6VmJhk&j_s=Y7&cXQ}
#sQmr>!unLt4vIDUTW4 UGk[*oZkKR{O~M>^[2UHx_xFz6-yK;h'/Y,w,:gM/?^~L_CMpX<d[2*]_.5((v!54z?d}]w[^5`,6`#:7^^d7r]%W1mlp}.<Uc^#YE m1V#0Sz>/=:1L+;_SXa!@A;zw1Qkc!vmuCWFo_/}7ehj_>]OW'&=M
[#E)hi,zPI?g9OFOo0:W}XwZ?8'aOyKx*%xwq(lwX7Uz }j7H.I	<;^[g%s/ji"T%\89/,q=bX;[uHf##AZRZbH'{Twu>{Igj!1< kz}z~ Awd~l9'{D]+SM\\:tC6X_edmr^/RYP(U$skVd2v=G	(Or+uQnh|a['!7g=a=R;,1/p*75yz?Uo{B:5 j"XIx3~"wWFI^>A#!_mtk=o`6[s68#5NK5ublGHkG/.{u3~>s @<r=:9{CWB'SWXX2gkx|%|:*p==aY?{glAqs' ;lW|-2^u6u21
V8>Ql#})5 lx/k9hIb\7?
UkPxxvQbsu_zg+	`..G3>R+C}{UIOs6ej^_aN&]I4B eL=(2y$=.i_w7l9=c{kL:}>h01]>_0O{'E`>Gp3q{womPSM,hgu)	GqE$XS|QzQ^z8Db_^M$+'3:yrUuu2GO x;sdx_1&vb~68DtvtZH qId\xNr#GH6G['_HzH{.3`sK~>P*hQqqip8Z`c]W\cn~+50%SkWY unOf?'Kwc\~[r)4gw{ntQ8}.#3Zg|h.%?7wL+|	@sm,$m='	SO6[o'`]oS146xARu.5-:/.(W1<s.Ji=~w~'e`M2Td!G:9O@1z#X H6@.;3+#6M]kH@HG~9Ou_s&`^
><[[Njtl<Fk3h :$^b.]Qy!YrVIcQ[:^Bu,3+2#]K!pd[k+u1EtY(K$~<.f}),lc	-zVmQ~!xA#^hQ=T^) {Zte,d6gO^E'g>eiP^UsV^ZIR58g	dj'HIG.C8p45j{im1rNYyPnv=1e|!,g[U-1c:`>c)]#/?F'Ew2^qQ(rq1gDzb+pcIAOV*zbi|NWauimK:jbOz8`jmC]lqI<Bakr@.?:QXBx
|AKru 2E hF@<[DCSLUS,b"U$Y=6o.8G2fO+2,_X2i&8gjc)pOzh sK-/{6<|4>{uw5u.hIf8Iy++mxQkmL{msVKOZNuxxz*n't/ut	u-JS8sq#516>sMN3^r5g8`Ti[`c=kx5j_GEs7~4|E7l}X7kZJyf({{xz5s:'^e|$AW@.Cdg }~ rgd@=Pqwh]wc}3T}RGx{u'w>h&}&z7V^<a$Cp{xAkY8?|<z/egC)1c`N;-hi_%;
|]r1rdwMjx:Z9~6 *?4_j9>W=L3=:OcEbnZ>s|gIR"5vEq_(o]VVuzjl\jH',*uWC}gs~qgZ:CMs 
m1kfm[Zl-?o!6@N:lZK{@B+w]zQ|PJw8YujoY?3n6a|=2x5b 1nCu[ 8%gq86r{]_Z`):bsbH<Gl'+]gD|CowxAmdj& }l;F[64v(b'~W0==5CiNhMXQBH)~$\"Nxye/P>'/A/W9G8R;Os9Cy^5(o99x\k\4O#>ZAdcF&s=^l:GS` w!xE(G'8?&:OnQA/'@b%TZAt[n4M'zz	*#~*W^P4uw6wy?GGU^{2'NnL@$@6(ZK-$: 	7		NK`[<BV{b-k[[6TTD~;Lf=y?o>ykg\vK7i{fSW2F>N;ts=!-`^igv-a$0(0~;+/:xIb	I'%J74,=1:[L}:=f{<i\G	;lm/|kW7|a3<.|;b$=18t$Nd|8-o-ho#4'6BRw*;ZN?HH~.r="[,M, .&gzo+XYsC(W_e1+{/N_P;2iiw'O@};y)1:NS.cG;kKrIR'QBgY]__: -/'Tk +]fMyuo7.Lkig9<Pv'^w:?#:rqQ4m##L@&mO^a}`/E-{cEXROniT-^M5_}<g;]<DFP9At}^N_qbW:]}??s	38[^Fw6}*N"\QTIl}cE6!Hi'89o][>{2^d/L{S	-XvDEiuO<9$!^8yv}oD3y<
-06<{/OzJxMU4M	=H2k/i6{
{[{:)f):NWB3>h`X{^"5lM"t]s^X`?oc)d:OI:eA<%GgE7R]mWZ>B3MsE2d9-G=1ZGZGgKSu-c"y>	}]yNn,y>{Nw'bnnJ%z~ukC	ql~[o8DF9>+>ok "}~qOU^n8T~OFSdK'(S}5!5(?4Md3\bN[s4>2tUw27{=Mk|[5]w?yS6nx]g4Z,;bfX[5!uWe~hLLo,xHX48;fioB+a~sI?o<+1d5[ L[4&]{bpV~k.c[BJk3<k^^J-
'~_o"iVrzB G	);5'{;r
_9G48I/q}OT#eh3D8vGc-+x7n15wwe;g,0n8qu;C]}ovm$'>GNOcx]BG"$#{E7hu0 Ert<}YpK d0)_3H9xqW<^B91`WJ-X iCW1l&FeqH/_9gfl`Z\b/`Kw,n-v7IszQm<~Zg\FBLtscSh;=~"04PAOK:QbzD#<xv(;ZO>wUu%
],>=> OmG(riC\]HS/*4>kt^<VSLkk63m*Ff{3ZG0CsNF?1
pHH43V)&5Hz0|\E^_z]V$+ypbvu#N|x~6};J[5>nd{n[BbB^1ao||4D;<]1ZV7i#}qU:mkO	l?\gR}Fg~|qQ.lr`z (IT?wO{Us<Yf-m9HG~O?z"xV5#`lUNHmP6]~(^<7],X2*XOGN^h=0=UY|->aU>Rp nWg?h;#86q3j&C_@i_vtUKiW6qO<;<#'0:3[hODZXfJzev77V8V=t53pO!4qO{|k
{~5"#eXq<itW3vK7g=IVuMx>wy>O6//S6<	7Um^v8Zj$>G~&YDeMhZ:myv^w>]><|i(83YKkO6gig03xK)>s/
PbR><am}\@c6>%1B:	wr3;tG3e%8j(f=sihIB1ujJ[%v6&/{NZN>W?w>#sMn|90e}l1Q7jXXOKgpR3S|JL'%~?k-wl57G//DG\q;P/G:F_.zPodo<-1F]L`suv]%6SsW@j<5wrGtViLn?VZm~kY{kGrXk~ElE5&]m>d?T0mpkp~'Lfz>x2k?x{3%Wv/7#{$tY)0I9`R\]`LA'sY6}ER~P?>z\>>_WK^?2_'x8!Zy
>-/g/Ot]~=%_}hzW<)g>auNz_vaH~p~Naj>}
tSJ@3s|Nh]Zwkb&.Dx?wB|f}1@OYY=:r[}[lBF."aU=3F_ih<%;p>t}V`#~;|b%<=C;-O/pO6dF+8ZSsa^^{d7GKq9Iw(3}#~9gKSj/G')JCv[yk]if#yPSj9MB'*<.;qQY,tGgE m<-ZbM}ixb,OW<Qunq<3~s/m%|BSz@:*o]Op	W7g~)kzO+s<vC	lN/6e\Mn2dgEno(W\E{bXNg~%xxk8c2"`f;qzizWmv: kkwF%9/]}~I
|?[K5ViNusd`C3*Jxs+d+h'Oe^G#^0s&-g5tlq082f6c/&)i~=|X]x<B\"!gwKw7nO31f5sE0=+H8tcr=wC~]~qX{-s'GqbsH9x;-?:#Os`[s#o	];?'[
~JQ'>s3F\M	z|9dtpE[*6:{h.ch?wL;}R&6^.EsCcZG=<f qcVm%J[~f haxu=T5Q'_kpCfrQx>&x^Hw{?>/%y}c[<2XIIz_Svdxq_\1vD{upnDBBhqNC|fsH'CxmOC:s8GC:w{7|^	FDOd=I^`2'N%|c9Ov%\Xw,FnZ
80ix86
p.-:t]|br;!+fOdy ]rtVMwCm;*_0y1wVGOzMLfk_.,\GW	U^e~O;Gig_O\ZQvJ?'Nr{kn}Ac25k-a=y*ShY@^54ppcf>A[H,4<'a	p<~gk%8}n[l^x3m~:Opxcj,A^>d;PM8r`1Y6E[A<9k/vex~<5<?os6x< uVbhS`%h KVhq|=#!to5gN\{_fl sr	hLf|.*Y)?<<l5dt``t'2OvZE~`yW	 ;bg|m7*'}Q	[w\:yT:3@*nCIi{Q<MNi*g)>.`u]@ZSWGj:5!_g9<1{Ng}s>.:OEC]~'zMy>#333CEv`KJ_](}\hCr-%!3,o
iw6`r&'=}SH}~ x7ck$G0(B}xqnI.uQMN|h@G{ ;>83!@;(!us{D'O3gYKO}
G}8BO.$rY)0rOGC3r]{%? r?GK{/_$rD+;`%y
$;y'k+3lMd'Lo&0'z]}Ipx9yndX;@y'OiAKz}@VJxI[oEl#?3K{vX7g/w3cm:ke)n/%_MG: y>"%>l1b?9l	%_<7P<m /$I{iy59y7?=e{8gN?xGo>u;bl=^#O'w| 3oo+_yct
C[[},p-U_tp>%:$pxIpj?S6t~OdKko:sTLET'~8^v'ZfAp7`Qgo1]/s#_7u~Z'z%O5O2oo'a%S#~oG%`OZ0Oj-~=[<zo>Iq>IG<6{3l~|]px~zs=4+U:p }{?F+jC<#|~n2>?izZDkQd;|&3Nls)Cl:hMdXBG#gOKK}c3t ]`ttWBCC7}t=t9	]/F
~;2^N}d\df.ph{t=ti34Z hxI{wZV}>!Prl7&2d98+urxg"hs{N3T_:)5st$0{Z&~d6_dy&_nb;X~r'~GVwwd*8D	_|}$'xv]wpWq&><}\~f'to~]MVf&ZKsMoR/Yb=C[)[^0O;
7;w1CZGHaz|rnOFO8Zm/&(z*.
=Pz`s`_uvwe]k11^e.P/w]N:OWa;,z*Z\)/IhkMHj]w~H}L5CE!tgEjKyyE>o1yw)+Z['UT]:|xA6I [45id9Q.DM-w[KL85XwtS[q`Wl9[g(mCWGb`W{z-~ b/ `'|wOc,'Em%>:wndr<i;[EIN2x&<Hj25W<rj#_]>sC*E_LSXE9fS|NY_Kl|6~Kg:^iN6+s;%NM@20|kgOr!*c"MW1?Bw?m_1}BNZUNsu[J0?*7#t{myu?-p<EnE|Yxc6{F8|B/+]\$:C=)>e-[v,-ky{ O#sdaLx_F1|9bk{{w?gG o+2^Ty7>1qW^nmMzsB0H^,,& =Y/5A^Zi 6^kC:e_.c%kbkN9t,OtEM{2B>pnorZ^-{['eNjr}PVc}"wV2I5w[FMGOn=7g^;{GZLmO`$c+:&h W:ZvpxU6=G;ok:R`s&,YaIW:{X`o14q1x'G}
~X|hu2$?fL?vEM[m-k<[wow.\/If\>-z?\hk,%;ZF1O9\XkfwY5T|+z&vnW5Rj+*.Q|@vk
K (	Q78u5/=
O;7K8[mw/t!DmK~-Owp]!6}U|yW_54h=9%?>Y ]584tsj{#5+WoF'847 j3QyR+T&w*&ryJoS~9O3_Asd+;@3<q4C/)NSvkwd@:z%^F:OyOES^EIN9~o9gX#;dz]cc7.n`;gVbI!;w"\mz$q[oB	 %w#;8{%%t{qOfInAwtmugN8sOo)cRGS^<SbHfYw|yc@<L>~qH\8'Rdw0Fnx[} :1 l6i|1h+<txpT cyA Oyykx"c'}kVjq.g,	sc.7qtE~WWJJh-e#-zgtds6qdNqwg<].7$9d>VbqpK4oo+}@=NCqSl	wcx;itqJq;oNyL1'6^.jO|'~=scbfi]8H6}HW66}&;
#[S0>#~;s:ba~KH
x=6GG'>:Slz19|WgH_(b>Z.U<_qdVG<.o;}	W&qtW3WW$=y&y{)Z_sv~}pwi)~K'qt|J''X[m,4ozb/@rE}Rd[QOzjlX:Gs-up~F/]nYlk~3-&p*Gx	G9s7;ks3JSTpgV'Z3.195ro'Y3G%o;[K`fkc|;qvic1Y8}>68h|RI o9~w3;N3xO0CBb77uk >;SyDg&Llr<f 6_W#]Zk?o]17MCok#g^s7}+Zco m,=BcDwVbb7ws&cIY=}MSROe1J7wzX"z{tG_u+y%;!s<&T;'8|3XUkP8NYaoFo5(lA9Gw"wwqF_Fl?ow~|Zc7D?R]zO_w>z&asQuQu[f4L	menGLxSgiV`E|9d+I?uy~[A#XqWV@~'uS[('gk5Isx?'e(m!xU;^~qa|:7;v-0_'z.}n?jOm9z.sg}[Ru-{b^<dy=dGk|o+rBO{}c)Oec?V{jGms|pl~n-Mt>|9$E<ow#2pp+pDV73w2`Op^ =<'>?~roG_(Grwi'MZI9|^{mwVri6v9w_92L9'fay%W/V7n~qu{>GgGDyC9tj<U}`wqEL>:txoH(VOcFklo^WL;Gfxm|V(>j<Ii~cRuI89p>Y/OEvthL,[v <8gx1cj.:Wx3h^mF+BY>j>$;UG~Xt38b?x@/l5zH_yI<@|t5/$=Zw0?5u'{~z'U^KcKDh  83dC(psJ>a/5i(mE6oqwW1NV/g6^J'vUuxi\q<
jI147{3~h.7eIiYs4tm!OGu$Pn}>~N'MxNUy`57r&g,}<h4Nef.*a-oe/nTpF&~<->peP6quq=;zz_7H_:^3L?Evjp>r&Grd M}[6ycj?>#ok&]X;p|^;:uu:R3u~5sC.&9||,}p6xoZf`F?f_7UCa7{G6~o26iMZh'Kl
sGw-Fb{5n)S:cg8,}<<'UV:i0ee[z|||&-[7"{l+xGu'en<|_~GW)_+kz;5^g{<y{"SJ oc6Y	yaM2a:%lraGXDyo|d'lt|nIH)}tpKKn`[|HHK>)'o} o"~|-l>?d?>'?82_7s/&[5k:R2G`q5YA|5NyoA1kdP:41_o>c;cp?mnSlB:p7ks>j(ts~?!u~&Wm#BQb[y!rkC)?%#4H@lY9;;K3s#{-7HZl1(v.kO{"5^xke>;zC_Wz/qc@w]ys`[jdWM!8^xB>xj:3S7~o>Swow;k+Y}kc[3uGG!v.WW3xpqisu\>6lR~xyZ37W;a~-_$[LDx)pINyf Y_#x*=?{
pt8{ryb+Ic,<%e>~+xki*y8YSA]4"Scj].K6O17t ogy0XvvW <-eAcwE6*PZ9]ilx!sg$o{  a|O)8>VtP|/]GiQTsfomjl9||tN,>7: pz)?1%t10'}5g[g6^X~?y;}=2&OsI_2wowDMz_s<PMizW6W7WF^QYGg3K:
%w*D(;OZ;1/WFYx0<E{U_}}[
N{FHd(XyZ|;cdHZ?5S=FsC_scu1,}3"Fb4U/}8Z
7[, N
KH{g70~>}7keJZL	*G}[O*~3Gg?eL	0F	N1N;754+hsU4<^JqRTtD>zdMs2&{]_n)Hf<ynZl>x@l7i 7miIV{%T~m[O;$p:~:{lH0cMj=VxsJCKD-d`l.$P{9;k_\-s'W@pMJiry$]h!vWJN=Wj)]5wvCJ{JzMwj=G{0Z?s}WWk4~'s`h%
w_3.U5lq}AOR>?a?7]=j/~U}[SxPx76)"mu-1OmQP>3^rj.~rOk&|Py5%\^fr$)RG|1u;w8gJy%LN;L{vyk_{T?>-gT'Am{n5
tMO[wI^-qgz*<Z[m<u`A/_'=SfxKR}G6GU0{9mZ/s};VlF?XsTIPh{^Y;8}M^$$"s>9
i5} h0=zpvmb5zs)Oq>F+m:28%gL5)OWWS|wI|$Vwo{<]SN
NDSfS2qH6+R]xn&\AuQ#3#wm;c}V'?:wE>C-zYuU/Oe;f`95)Q8}- ,asLNo`l/{b5h#e.cD}9pl'F8VQ1_c,[&L~hbrc-[weJh3KysC;)uu)jg Oaeq/7_M^'V1)#9\Nl}o)L.F*'o]:F|x~>g/;XK>vn%[z=Dt^CM/G<M~ wM_k5Y;!;'xZ~b}I%X@d7co.u 42qd$ylOZ{GZ%joNSwSw!u#+1p1?{5C}/(;5b*A#$bd/L+mQC(]0P'?q):G FDoJNd&X8`Y,_Db-I7&lZ])c+VA;:&-&ZU$7oj
mmZwfvH>GwC[35O>ky|Ot/fmM.%|?W&X?r6o6<lh#va}w/}E/tpy%rlFIZy8"pg	>{d!K|h"2l
?#%b63SOr;k2Kc U %\3-q5Ckc](1w:!pm4e<w-.Sw?X#M{	-{5<^>"q .y OV^-V})H]zV(~{]G.Howol,yMi/x'nOZvME1}[e`3{/u)ci?DkOERx0^=s{/ 9_?K3;w}
GhC|k=>|Zmo.==taA) $3oOo[3Z$(Yw"L0. \j/cz$ z:)Z%W"S(|jBsWvZWi3$}46o~ghs7xi
}.7Bvl?Ag3r~pr0O08'dQ:aw7>Oz<q<&;O]q}{{8Oeq.BLzSe/Odykz;7bohS2ya!m"bZ<_b5fPN5f9cJ8S7e:e!_/C*}K7Ww1eg&o*I8zn'1Po?#!j_2}^4Le>OU8[3F#ts6nc/0?n::=:8d'SH6?^v	ZF\JUIl|w3O4']<4O#X:WyleMjx={Z;i-7:H1$Tn>g?7N=M`Z=cFu'i#Cy0Db'FDrS[Sgtm]-[3V(/.=/1G-<;x.eX	D;9Q^{3dK9Kq'zwQc+NkIv%=w_'/kpSgtw>Rd1}})-}ol9yw|_;3}*+9};jD/Gx'1
w<}(n2wS&/QF{scN4f!9:.eeqMW83xTx] #SS[w\W^,?[m>d^kye7~P}a2c{Iqcgw{lP7 S<K~/\7`{4yIoC b1YsMY	P>fX<OEk=1,c5,?
D_Z7+D62h#r^VHGL]}*f]}>u4>m"a7V}Ohokc]lMm-;g/j/
{>,D8m`o~	U9tw!{x2N>2>]5 ~As.0t@/0XC31p'{%[^fYSx^Sc1R-uk-:55w71~:u8'R>s;^1A]b!zoo}:6TCcx*Ch_}/mxv;*C;3Vn2[ibc5J@N$[-k J:?m/3y5|>i{2zloc?=;7_dqug3@S,MFD1he#s-{3\/FJ1 ^CjU	mf9uLL4+BF>R8>Z L<Y(HED]m`3fS5=cYu=}j}udccXc:<7<sxmDgHzGuwj\ww"o:7EN(M}=k}{=\P?s4s8sj g
mm*1cG:;zwoB~D'VRWw6?W?xo>s1yIY<QC[18fz}1:/])ckWoyfBB{=h!R:+e+oJCUy`~D?o\<	Z:s8(~m/S9}|*?>DIPkm}Kf*D
nXPv`tKw$`AKR7)9U*zr'Kfx5z\{xE4w4_ioE(8MkV+{1[6jgef}jg,8OS)55+~<ks6`|Dxbs{t}g6As
0Dg9)07t.M6kEE=wI{5^8H
ab?C/5k#;oG6?|jn^1Q<>}@/>+c	M
99(R@PLkF[/8d D%j-g"2L/wUOaF0f|udh-Re5JS978.92gob_=.G]=F 6dOl+;=zy[2.a>e`89p.p>/Mt]{Sb}Of"Huwtl*Ed:>9uzfqCW.}^lH22,H=AFWt	OWFh#)!%tnKQ>>HG7&w#[:4_=ohto~e$^k^<[]i)]\>HVZbN_w=1q7o$P=}>N;:z(x;P{voN9+0O12Z640-{&<~w\!iVp3<E>;xGTXb'Gy+srrQ>Y!Ma2c|M(:^ip?go|#Cy~~s-Ef=KYo{HHXe5pr8]~9``CWkgen|71bnMq"kd+J5U++K%dW+{|IiqMu;%//=rh;o7Ue5ysg3WFEE*GVU\,{d.F.,+)[UkZ2We)|g;KD)j]pU,+_RS__uYqe~f]]KF.)cQ2k_Y\W\dR2hT-)[V:H~/*[5z?@~//3cV-)+J
Ql1UR?TB<2F?zK/YY
bAY. Ahu5&vrU-[b%e?Q~@5|v6c_-0@hh|IEy	 O+;W^n-KJ={.,e999,gSJB`eW[S l|90=RdoYj"d`Xx	XZO,oBuiiK+-*,)SXVV\ZmAeU3USvC"~UM#l[
I2qR:Iv*`e5CWV/.+gKjYv$K#b+Kl/[^.4	/UcT.jUyM6aYb *vW-Xdv;OPJidQV-*BQy)3_v;Ze~!wltEHXZaWx?VQSeFZ'M?62f^r:3}\w@0E9EY7Ae#|_|AIk/vVZ"G%CVVL
fr5?x 	V)[l*
@W6W%fp	Jk`Qo/xyEEH<l]r;%%hG9]h^<V3_XKQZQ2Zgn~<TM$/PgXP*H\=n9Bl8CH =j@U]VsqJ^PVRL:yt'b26~)c:^Q\SSViXVYY*BZ^=jcK/PK:Z^
;]D]:[\|Gy	peH/Q]K*xY)_o+jfXKl=1N
%F:z}eyM M)x"#_n7Lygf`k{HTUT8(vVblL(zeakVJ|CjR9+r}F,gXqDY<*;*kpj*UeWX_nM qWT.;JDJ#wTW@:NNdQ]0*Yb=aq,-V0^)XGl1nI\0%qKp=>Jh 2j:UOfVUv.1`)V8>f6TmY=_wZa&JKKe_ZS\=drQv=u+|EU++/)/ddtd%U[~M./.cC;V60T5J0A~dX\j{.WG9eS.ZE|">fzsM8g/'wg3W=^a>pv>{f>',<e%?I'0 }	'[|T>7-$?H\)9BrwB6?(~gn>RnU[W:`PnWlG nE
''3O"W)PNrT>|oq>WI7x:jo6mWZI rj8\CmQ">GR?:l(pqG'8%M#SWI?HI+OOOE|p@	]P	/|CW+HE6J'8dGIo"eYk#VCI_%&(J	qJpas&SI~T 1?ruwO yt]7ZKH?Hh_M	v>5NY=n'<9j'}TO8OCI{{I7|Gg;uP{IKz$|JV~l'+5'q7	1E:Njr)xA8[	rQB"U"m=yvu!w{~gSr%q&rE'(wd8':<KBBU1g/| U?Q;rRNVPMXE8)(Mp9J~m'+P=pQR_C|JIH&Tm%;O[L),l_t]~'/JAn1G?]&jSz)EG2kHC{nc<E/!{(7dt8|Ev?|mG_9t3T*?xp)+g'}?JKgB	j4
?KDM~a1N3%?z|o#}	OAg*?~2W~%?v-GoMT}}OtIeT>Tn*(Dv)f|v8j'
_ 8G_.=@b#_A~VN/CzoR?*?rVe]-m8Xp%bc(
 TP	?Bw9Ny7782g Iw&s6\_^pt9~+3?G1~2	W[M~N|3j/O#=?5~;O2p2JUWS~_!tM}OV~f@[j(wAl!a_9|GSOxO9}9ZA~*o4?8	"acs0k(4#}7WQgo#?x(-mxSrp$UP?!IfJ9m~$~^&sr\RYC~<8&_KXS]N"GK!WV~>/>G&Y?.d(weW#K5C
	.aSRB?W'/gvGHV<XYQrEgk(w:g|c(c,C?!x"K?{rn"O~EGEi[Q:o8T#}w3~;Fo.L0qpct%##"8]K09qPEC1$qNKEaM.0E%p*0yv'we'mh;c}vZI^)w=)ZoKg_H/`g|{OaOa^qtwCO?>F/w\<]z21}r^byi,5U0z&7*T/"r}GOBdrz)#+q1Q~t8_A	+6>n}SoRkSF9+]-R~')~1=f$bj_~:_?v!:\3[7s1w8.O/6]'>s>^a8nP1%]y.*{uc8K5sut#j)@|9'X{/`F(w}CGziP1M*4zdXC>"7N/77LK[]/O->k}Xb/c)omg{GGR~9.?J9!|,Yow]5~=f31}G|$mwR ~)u]R9'z9r.%w_g``_mGECousY]ag\r\s/a/aKFvWH>w:~E^x"yL~w^yV<"m`bi#:Ib{Rn5omDE_x}>}_</>}]gc@.*~:8/qt0G7NQ7_."-_@><s_A}>eE~k1>O>@Jhl zVtK~M{qwvc{x_z_w_Y/OCm$Q.zu?'R2/J3}@k%j_R=Q^gq?;Q!YtgiE/.zn7/zi^K rzXu:0F3bpf[jSO	yWC[1s),t{#J!4u3^DOIK;oMFIQz<])/*s%<eouH?Da%n}Ga1EF;%T^@OkK>+|'6G>M8GAoQe]/	9}}
KYKrk%ly"sc5#DB/X'(B}}])~v&nR:-XwokE'/q65kI,:nbH>3>/2;|T:~G{^w8~./1K>O? qN$>\6qW-~#2.MyhIhu+oR}U_2-lm2?#C[7AuH0v>C%a^Ay9\og{~]dF"IwI~X_vB/?r7[=R'0~CJr.~?+JrjM Rx/N zStN\=.wy_<8\[ADO 6w86_A?}FOnoAg]'"5*~N!LoI@s=MS7GGRNJN-}ofw3[sW}_
o7rp7UX_Dl7on7pFafOgF!00*pu](0FVaFkaN|g
.f|F{pFN5S
&Bc ,}<`f`aspv0(\i
s0uXX<\'aGES]o\@?1X)yX
7K	yva8S(:\_n_\0`n<jn` cpyspc2C?<8",ea?N00	^y\a,y6u ,y\;A?\aa%{8;i/iX<!,P,A)|e=]=/0 0|)	maX	<5_L0c\2CK&4/L}m%Xk0
k0	/'7()I^83.$GG`RpnM8*|x2eh#4^M}0~`a2,i'@Q|a7C?4030WawaJ|M_B?(3_M
sWK00G22}J&^K0p`5h|ki/ FF<:,Kp@{_G0
0X9#A:r#%s0#"\U>8r5{+pHy}
7R/.y7QUx~	30
aF`
;pzwGc gavBpVb$0pfJ;6b`S0'i;w'9EaNp|\%QMi772gW8s0a+:yc;vE8	pzDp`&af}#p.:'W0k0'GE
Wa pi;/Sp\R/BO;Q/\is8,a
)eB 0yG&>:pAgcni+,\
p7)x($Sw-8g^XcN<iL<I!lp	&

?#veu8
c0	ls| =9Ir*,e8ro(4{SpO.OX50c0v|,EX\z7>;NA\#9=zzzzfx}h3/X	9E-u%kgmNkIGf.K+O?S7ZV,+jRv?QaY|]|3<\S-iKh*P<5.Gx_g?]O[lq	=XQv]V944GG9EWI+>XW,}^vEqp'G-.[e>^UNYQSyh{u6iyThsYnhj(|5yM{M14g6ns9+z4MESt}w[WR,+vc]ZuiKUXRb1-{<a	T9>e}bvBqM1Ce9:cQV[._0zO%8gQ>YvX~20#kOn;AUsN_eCCO?bm[5'o>Ok}m[J|E~l._$E?6O|E\?K?Emnws)fnEU;wjciR/YAz<F0eMCwYO^*_u%k|G>rG!:1r'y+<r5>_M8}7I RTdz98LctGcPwe;Z\-~-QyTZSl#Jv v\JRk=Iu8<v);kD]?uRS">#A@L')N6?P2tgKwzEQu26?oWu{<_5$]>kV'3Qt^rZk<7kX#:^5Stl"4E`4o$^z[G5[IyVu=ttQ:~wkT=:MS_I=dLu GW/55v^w|!	5WsVf6/:mSV$B_}ujO:VRrX%oR_~'\":^_W&36kiPu<tebuEkKxC1* {xZ8{xO@E{&vo7+Y,zW8m)Gm7$z gvo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ELF              @      @                @ 8 	 @         @       @       @                                8      8      8                                                                                0     0     0     4      C                  X     h     h     0      0                   P      P      P      8       8              Ptd                                     Qtd                                                   Rtd   0     0     0     s      s             /system/bin/linker64             Android             GNU =.+M
y#B                                                                    ,                      9                      F                      N                      V                      g                      y                                                                                                                                                                                                                                                                                                                                                                                                           
                                                               !                     )                     1                     8                     A                     F                     M                     S                     d                     k                     r                     x                                                                                                                                                                                                                                                                                                                                                	                                          "                     /                     5                     B                     N                     U                     c                     q                     ~                                                                                                                                                                                                                                                                                                                                                                                                               #                     +                     2                     9                     @                     H                     Q                     \                     c                     o                     {                                                                                                                                                                                                                                                                                                                                                                                                                                    %   ?             *   d             1   d              __libc_init LIBC libc.so __register_atfork __cxa_atexit gai_strerror bsearch __errno __stack_chk_fail __stack_chk_guard __strchr_chk __strncpy_chk __strncpy_chk2 exit fclose fgets fopen fprintf free fwrite getopt_long optind printf putchar puts sscanf stderr stdin strcmp strdup strerror strncmp strncpy strtok basename bind calloc close getprotobynumber memset optarg sleep socket strcpy tzset __fwrite_chk LIBC_N strtoul setenv __strlen_chk ctime inet_pton getprotobyname malloc abort time gethostbyaddr getenv fflush getaddrinfo freeaddrinfo getnetbyname fputs getnetbyaddr getnameinfo stdout gethostbyname __sprintf_chk __strcat_chk __read_chk __strcpy_chk setsockopt fputc execv in6addr_any inet_ntop __strrchr_chk wait vfork uname realloc open lstat getservbyname strtoumax strspn strpbrk statfs isspace memcmp memcpy opterr tolower vfprintf strcasecmp strsep strncasecmp log libm.so strtod fcntl getsockopt atoi strstr getservbyport getgrgid getgrnam getpwnam getpwuid isupper toupper lround isprint isxdigit strnlen __snprintf_chk gmtime mktime perror _end _edata __bss_start libc++.so libdl.so    t         @    t   v       |CEqX                                                                                                                                  0   c          >i           s         c           `            \     h                 p           -\     x                            1\                |                ;\                |                A\                |                 P\                |                 V\                                 h\                                 a                a     0           a     P           !a                c                a                ]                #c                ]     0           (c     P           0c     p           !a                a                q     0           Iq                q                |r                  r     P            r                 r                 t                |r     @           $t     p           -t                5t                r                 r     0           >t     `           Et                r                ft                 kt                u                7u                t                t     @           u                u                7u                 u     0           t     `           t                u                u                 u                u                 u     0           %u     @           -u     P           7u     `           >u     p           Cu                Nu                u                v                v     0           #v     @           'v     P           +v     `           /v     p           3v                7v                ;v                ?v                Cv                Fv                Kv                Pv                Uv                 Zv                _v                 dv     0           iv     @           nv     P           sv     `           xv     p           }v                v                y                y                y      	           y     P	           y     	           z     	           z     	           *z     
           6z     @
           @z     p
           Qz     
           [z     
           ez     0           u     `           z                z                {                 {     P           {                |r                $t                -t     p           t                |r                $t                 -t     0           5t                }                }                }                 }                3~                =~                K~                X~     p                                                0           c                n                v                n                v     0           u     P           u                                                      P                                                @           /                /                6                 >     0           E                                                     P                                                                 @           	                                 	                 W     0           f                                                      P                                                @           )     p           A                O                 R     0           a     `           q                                                 >u                                                                     @                p           #                -                6     0                `                                                                            #     P           -                6                M                [                 i     @            w     p            &                       !                0!                `!                !                !           #     !           -      "           6     P"           M     "           [     "           i     "           w     #           &     p#                #                0$                `$                $                $           	     P%           #v     `%           'v     p%           +v     %           /v     %           3v     %           7v     %           ;v     %           ?v     %           Cv     %           Fv     %           Kv      &           Pv     &           Uv      &           Zv     0&           _v     @&           dv     P&           iv     `&           nv     p&           sv     &           xv     &           }v     &           v     &                &                '                p'                '                 (           o     0(                `(                (                (                (                 )                )                )                )                *                @*                p*           o     *                *                 +                0+                `+                +                +                 ,           "     ,           '      ,                0,           /     @,           1     P,           '_     `,           7u     ,                ,                P-           )     -           H     -                @.                P.           "     `.           '     p.                .                .           >u     @/           ]     p/           j     /           q     /                 0                `0                0           4     0           :      1           >     1           )     1           3     1           =     2           G     @2           Q     2           )     2           3      3           =     03           G     3           )     3           3     3                P4           6     4           A     4           M     4           [     5           j     p5           	     5                5                5                5                 6                6                6                06                H6                `6                6                6                6                 7           y     P7                7                7           y     7                8                p8           	     8                 9                09           A^     `9           	     9                9                :                0:           &     P:           /     p:           <     :           I     :           V     :           c     :           o     ;           {     0;                P;                p;                ;                ;                 ;                ;                ;                 <                <                 <           !     0<           '     @<           ,     P<           0     `<           6     p<           ;     <           A     <           F     <           L     <           Q     <           W     <           0     =           4     @=           ;     p=           B     =           I     =           Q      >           V     0>           _     `>           A^     >           d     >           l      ?           0     P?           4     ?           ;     ?           B     ?           I     @           Q     @@           V     p@           _     @           A^     @           d      A           l     0A           r     A                A                A                 B                B                B           y     B                B           
y      C                @C                PC                XC                hC                pC                C                C                C                C                C                C                C                C           
     C                C                C                 D           "     D                D           /     (D                0D           5     @D                HD           A     XD                `D           L     pD                xD           U     D                D           ]     D                D           o     D                D           v     D                D                D                D                E           0     PE                pE           0     E                E                E           0     F                0F                PF                pF                F                F                F                F                G                PG                 G                 G           :     @H                 pH           :     H           W      I                0I                `I                I                I           c      J           h     PJ           k     J                J           p     J           {     @K                `K           y     K                K           
y     K                K                 L                @L                PL                `L                pL                 L           $     L           (     L           S     L                L                 M           )     PM           3     M           <     M           F     M           O     N           Z     @N           c     pN           m     N           u     N           y     0O                O                O           B     PP                P           y     P                P           
y     @Q                pQ                Q                 R                0R                R           k     R           r     R           y     PS                S                S                S                T                @T                pT                T                T                T                 U                U           "      U           (     0U           -     @U           4     PU           :     `U           D     U                U           h     PV           D     V                V           1     @W                HW                XW                `W                hW           0     xW           ?     W           b     W           y     W                W                W                W                W                W                W                W           t     X                @X                X                X                0Y                `Y                Y                Y           n      Z           v     Z                Z                Z                [                @[           %     p[           .     [           w      \                `\                \                \                \                P]                X]                `]                h]           _     p]                x]                ]                ]                ]                ]           N      ^                ^           f      ^                0^                @^                P^                `^                p^                ^                ^                ^                ^                ^           2     ^           A     ^           N     ^           S      _           ^     _           c      _           w     0_                @_                P_                `_                p_                _           q     _           x     `                 `           j     0`                @`           j     P`                ``                p`                `                `           "     `                `                `                `                `                `                 a                a                 a                0a                a                a                a                a                a                a                a                 b                b                 b                0b                @b                Pb                `b                pb           !     b           /     b           X     b           `     b           l      c           s     Pc           |     c                c           t     c                c           t     d           ?     d           t      d           W     (d                 8d                @d                 Pd                Xd                 hd                pd                d                d           (     d                d                d                d           P     d           )     d                d           C     d           P     d           C      e           (     e           \     e           (     (e           p     0e           H     @e                He                Xe                `e                pe                e                e                e           !     e           N     e           h     e                e                  f           (     f                f           |     f                 f                (f                0f           i     8f           i     @f                Hf           i     Pf           i     `f            _     hf           _     pf            _     xf           _     f           _     f           z     f                f                f                f           a     f                f           6     f           F     f           :     g           >     g                (g           n     8g           u     Hg                Xg                hg                xg           }     g                g           pG     g           pG     g           pG     g           pG     g           H     g           H     g           H     g           H     g           K     g           L      h           M     h           PO     h           |P     h           TQ      h           4S     (h           S     0h           (T     8h           U     @h           tW     Hh           Y     Ph           LZ     `h           G     ph           V     h           j     h                h                j           0     j           @      k           P     k                 k           `      k           p     @k           X9     Hk           f     Xk           8u     `k           ?     hk           e     xk           h     k                k           ?     k           ?     k           ?     k           t     k                 k                k                k                k           `     k                k                k           `     k           (      l           x     l           (     l                l           T      l           H     (l           P     0l           |     8l           0     @l                Hl           P     Pl                Xl                `l                 hl                pl                xl                l                l           ?     l           ?     l           ?     p            \     p           q\     8p           ]     Xp           ]     xp           ]     p           <j     p           Cj     p           Jj     q           Pj     8q           Wj     Xq           _j     xq           dj     q           oj     q           uj     q           zj     q           j     r           j     8r           H^     Xr           j     xr           j     r           j     r           j     r           j     r           j     s           j     8s           a     Xs           A_     xs           j     s           j     s           ]     s           0c     s           j     t           j     8t           ]     Xt           j     xt           !a     t           k     t           __     t           k     t           k     Hu           q\     Pu           p     `u                hu           p     xu           p     u           J     u           J     u           DK     u           K     u                (v           p     8v           q     `v           0L     v           <L     v           L     v           L     v           0     v           p     v           Wq      w           L     @w           L     Hw           M     `w           ,M     pw                w           p     w           q     w           M     w           M      x           M     x           N      x           O     (x           P     0x                hx           p     xx           q     x           HP     x           TP     x           `P     x           \Q     x           Q     x           P     x                 (y           p     8y           Lt     `y           R     y           R     y           S     y           S     y           S     y                y           p     y           t      z           T     @z            T     Hz           4V     `z           @X     pz                z           p     z           t     z           X      {           X     {           [      {           @X     0{                h{           p     x{           t     {           X     {           X     {           [     {           <]     {           @X     {                (|           p     8|           t     @|           t     h|           \]     |           p     |           t      }           t     (}           \]     }           p     }           t     }           t     }           h]     h~           p     x~           t     (           p     8           u     `           ^                ^                ^                _                _                                p                v                 `     @           `     H           `     `           ,a     h           0a     p                           p                v                `                 a                b                 ,a     (           0a     0                h           p     x           z                ti                i                i                0?                0     (           p     8           z     `           j                (j                j                tk                                p                {                 ll     @           xl     H           l     `           l     h           <m     p                           p                {                ll                 pm                m                 8n     (           <m     0                h           p     x           {                n                n                o                o                o                p     (           p     8           }     `           o     h           p                p                p                ,p                                p                }                 @q     @           Lq     H           \q     `           lq     p                           p                }                q                q                 q                r                 Lr     0                h           p     x           }                r                q                (s                s                 t                     (           p     8           }     `           <t     h           q                xt                t                xu                                p                ~                 dv     @           pv     H           w     `           y     h           y     p           p                p                $                |                 |                @}                 L     0           0     h           p     x           j                }                }                }                 ~                P~                ~                     (           p     8           j     `           }     h           ~     p           ~     x            ~                L                                                p                j                      (                0                8                @                H                X                           p                {                                                 <                 d     (                0                h           p     x           {                                                <                d                                      (           p     8                `                                            `                0?                                p                                      @                H                `           0?     p                           p                                x                                  T                 d     (                0           @     h           p     x                                                                                                                (           p     8           M     `           <                H                                                                p                M                 <     @           8     H           x     `                p           P                p                M                <                                 T                      0           P     h           p     x                (           p     8                `                                                                                                           p                                     8                @                X           l     `                h                           p                v                4                @                l                                                      P           p     `                                                                           D                                                p                     @                `                h                           0?                                p                )                                                       8                H           @     x           p                ^                h                t                                                                                       0           p     @           ^     h           h     p           t                                                                                                 p                ^                 h     (           t     @                H                `                h                p                            p                ^                h                t                                                                       (                 X           p     h                                                                           x                                 p                      H                h                p                                                            p                                                       (                0                @           0     H           0     P                           p                                                d                                                |                 0                0     8           p     H                p                                           <                                |                0                0                p                      (                H                P                X                h                p           0     x           0                p                                                                 $                                      (           0     0           0     `           p     p                                           @                `                                |                0                                 p     (                P                p                x                                           |                0                                 p                                                     (                0                H                 X           p#                p                                                                                                 l                p#     @           p     P                X                x                                                           l                p#                p                     0                P                X                p                           p#                p                                                                     (                8           #     h           p     x                           X                d                                                                                 0$                 p     0                X           |     x                                                                           $                p                                     0                8                P           l     X                `           &                p                                \                h                                                p'     H           p     X                                                            $                                                P                '                 p                     8                @                X                `                x                           4                )                p                                                x                                     0                8           4     @           )     p           p                7u                $                0                \                                `,     (           p     8                `                                                                                           ,                p                                     8                @                X           T     `                h           ,                p                                                \                4                                                 ,     P           p     `           )                                                                                 P-                p                H     @                H                `           8     h           ,                4                -                p                                                                      8           (     H           .     x           p                >u                l                x                                                 .     0           p     @           >u     h           l                $                                                .                p                                      @                H                `                h                p           @/                p                                                                                  0                      (           @/     X           p     h                           <                H                \                l                                @/                p                      H           <     h           |     p                                                           @/                p                                 h                 t     (                @                P           `0                p                                H                T                                                0     8           p     H           B     p                                           0                                                1                p                 B     (                H                P           X     h                p                x           2                p                B                                                                  \     (                0           3     `           p     p                           D                P                x                                                P4                p     (           }     P                p           h     x                                            p5                p                H^                      (                 0           |!     H           "     P           &     X           `6                p                H^                                 '                (                 "                &                `6     @           p     P           	     x           +                ,                ,                T,                p8                p                0     0           ,     P           ,     X           d-     p           -                8                p                                .                .                <3                6                 9     0           7     h           p     x                           L<                X<                <                <                <                l=                <                 p     0                X           L<     `           =     x           =                =                <                l=                 ?                p                                L<                =     0           >     8           >     P           <     X           l=     `            ?                p                r                @                @                A                ,A                A     H           p     X           F                XB                dB                |B                I                hJ                B                 p                0     8           <P     H           HP     P           R     X           R     `           S     p           D                p                0                <P                 S                R                T                T     (           D     p           p                0                T                T                R                0V                xV                PE     (           p     8           0     `           V     p           V     x           R                Z                Z                E                p                                p                                _                _                0`                H`                 PG     P           p     `                           `                `                `                4a                G                p                     @           a     `           a     h           a                \b                @H                p                f                b                p                o                b                b                $c                4c                 d                 I     8           p     H                p           e     x           e                e                hg                (i                (m                I                p                      (           e     0           e     H           e     P           hg     h           (i     p           (m     x           I                p                6                lm                xm                m                 Hp                r                @K     `           p     p                           x                x                Py                y                L                p     (                P            z     X           ,z     p           Lz     x           D|                `~                                 M                p                                     (                0           x     H                X           0O                p                                                                                 0                O     @           p     P           B     x                                                                           O                p                :     0                8           xm     P                X           8     p                           PP                p                                d                p                     (           8     0           (     8           @Q     p           p                                D                P                                D                 R     0           p     @                h                                           ,                                                R                p                      (           ,     0           8     H           D     P                h           |     x           PS                p                                D                P                     (           T     8           `U     p           p                M                                (                                                U     0           p     @                h                                           \                                PV                p                      (                0                H                P           x     h                x           V                p                                                p                     (                0           (     8           W     p           p                ~                                P                                D                X     0           p     @                h                                                                           0Y                p                j                 L     @           \     H           |     `           d     p           Y                p                     X           p     h                           P                \                h                                                Z                p                 7     H                h                p                                           [                p                                                       (                 @           $     H           |     P           `\                p                #                                                                                 h                ]     8           p     H                p                                           |                                _                p                 }     (                0           P     H           \     P           @     h                x           0a                p                                                                 4                      0           b     k                  0k                  (k                  8k                  Pk       '           pk       ?           k       H           k       Y           l                  l                  l                  l                  l                  l                  l                  l                  l                   m                  m                  m                  m                   m                  (m                   0m                  8m                  @m                  Hm       	           Pm       
           Xm                  `m                  hm                  pm                  xm                  m                  m       %           m       *           m       #           m       !           m       &           m       )           m       "           m       (           m       $           m       5           m       0           m       /           m       <           m       8           m       [            n       F           n       I           n       V           n       Z            n       X           (n       B           0n       W           8n       D           @n       \           Hn       ]           Pn       ^           Xn       _           `n       `           hn       b           pn       a           xn       c           n       d           n       e           n       h           n       g           n       i           n       f           n       k           n       j           n       l           n       m           n       o           n       n           n       q           n       p           n       -           n       .            o       +           o       r           o       s           o       2            o       1           (o       3           0o       4           8o       E           @o       7           Ho       ,           Po       L           Xo       K           `o       O           ho       C           po       G           xo       P           o       U           o       R           o       Q           o       A           o       6           o       =           o       >           o       J           o       N           o       9           o       :           o       S           o       T           o       M           o                  o                  {P ZF2    P ^F2 P bF3 P fF"3 P jFB3 P nFb3 P rF3 P vF3 P zF3 P ~F3 P F4 P F"4 P FB4 P Fb4 P F4 P F4 P F4 P F4 P F5 P F"5 P FB5 P Fb5 P F5 P F5 P F5 P F5 P F6 P F"6 P FB6 P Fb6 P F6 P F6 P F6 P F6 P F7 P F"7 P FB7 P Fb7 P F7 P F7 P F7 P F7 P G8 P G"8 P 
GB8 P Gb8 P G8 P G8 P G8 P G8 P "G9 P &G"9 P *GB9 P .Gb9 P 2G9 P 6G9 P :G9 P >G9 P BG: P FG": P JGB: P NGb: P RG: P VG: P ZG: P ^G: P bG; P fG"; P jGB; P nGb; P rG; P vG; P zG; P ~G; P G< P G"< P GB< P Gb< P G< P G< P G< P G< P G= P G"= P GB= P Gb= P G= P G= P G= P G= P G> P G"> P GB> P Gb> P G> P G> P G> P G> P G? P G"? P GB? P Gb? P G? P G? P G? P G? O{C H E *@_ 1  TH EA !p, @bH I E)EA !, @"@X 22 *X{   A !xE   A !|E  A !E @ E @ +c?{  @ `  T@  ?{_{      @   @ {_{    @   @@@ {_ B1 og_WO{C@C2H EI )E *@@ ?  E~ U V W 1  2=    19*q  T 1 Tq`Tq  T819qTH EA B !t7 @B0 2U E Q	k T`zhA !1  I )Eszh4@  @A  !1 2k+b TH E@  (? # R# N #\ W  x 23 #! H EI@#R9! A ) q K T q  T# S (q9 qA T*  s `_8 q`  T 5   q  T2*   @R`_8( qTh@95s @  ,>k# q9  5h  4 & #R9? q@ T? q
 TA !83 O   12{@  \: 9g@ A  9!9bu @  9]@  >> J 4W :3] G X 7L S  /@A #!:U H	 R	kjE TQR {#}`k(I<	m?@    =?!  (D 4 ?mq T#R R7 G A !5!K A ; !h5 `F w 7   # **C   9 )@9?} q  T*% Q_	 q T)5_  ? q T? qT  4(_8qqa T  2 29 H5  2( 9;; 4v@#2A ## 2!p5i686 4A #2!|5 6 4 Lv` q T# (L JA2@y( J! \y(8 q T  Q)A2 YhA !D6 5  Q)A2(YhC   *   `	**C@  "@ 4H q T #A 6_ C@  5!_*< H 2(  9 <T L qK T q9 4 A2	@ A !;u 4A !;p  4A !<k 4A !<f 4wH 4 4Y{| A !;[  4A !;V` 4A !<Q  4A !<L  5 A2y| A !;C 4A !;> 4A !<9@ 4A !<4 4 A2y|. 5  TT9  ! !;#  4! !;@ 5 k TV[h ! !8< 4! !T<  4! !h<
` 4! !< 4! !<   4! !< 4   :E 3@< 7 y 23d   b9  4 " 9 c9  4 # 9   ,;3@;@< 7 y 23v   !  9!<9    97@u   !  9!p9    9   > #! 2#R 2!`; 9 qK Th A2	@ ! !;  4! !; 4! !< 4! !<@ 4   *n  *   *h b9 5  )b "! 2#RdR!; 9 2* hH 4*ZshHs kcTh (L?@?h( 4i )A2+@?  K # RPh q9( 5~   )/s hL 4u *B2*}jvmhL j6kT H 4 *#*}jv]Hs j6kTI Z)E)@( *C{EODWC_BgAo_H EI ! !5@2@)E"@ ?H EI ! !3@)E2"@I @)E#@ ?H EI )E!  @H "@E!P6@4  H EI ! !H3@)E2@"@I )E#@ ?H EI ! !H4@)E2@"@I )E#@ ?H EI ! !4@2@)E"@ ?H EI )E!  @H )@E!6# @ 2H E   D2R@ 2 2H EI ! !5@2@)E"@ ?O{C     83 *  s `_8 q`  T 5   q  T2*   @R`_8( qTh@95{A   ,>OjWO{  hb9 4 b9  4  "] c9"9  4  #Vhb9#9  4   l>P"9 H q T )#3A i@I 5`R  `_`_H s (KTs hq9  4   @>119{BOAW_g_WO{ b9*  4 b9  4  " (c9"9  4  #b9?#9  4   l>"9 "21   8 9  !  9!9+     9! !9` 4  !  9! 9	     9@5 2:! !<9@! !p9` `  4"9{DOCWB_A   >g_WO{   @9 43 4 5 6 7  s9:99:( q  T   q T q T q! T   q  T qA T	      *@8!5{COBWA__og_WO{CC*2  qA TO  q T | 5 6 7 8 z~@2{#C2;;<<h{th 5{t9 @ 4 4@ 4  4 KT  O k** Th A2 t! !<|  qk Ti )A25h@9 q! T ! !;m 4! !;h 4! !<c  4! !<^ 4! !<Y` 45   ! = =!<H   >)    
          kj1 T<  <{## ? N h A2yv ! !;-. 4! !;(- 4! !<#@- 4! !<, 4yh A2@! !<  4 ! !;   4! !;` 4! !<  4! !<  5h  A2v  " 4 ? q T {#`@    4s { T   kJ Ti )A2(h@9 q  T(R?     8= @
 	k TB {# ! !;  4! !; 4! !< 4! !<@ 4! !< 4! !=  4@9 q T     T=@ H@8 qT  !  =!<?@   4   = k  Ti )A2(h@9 q T   >b   k* T     T=t#@7 <5    p=l   T=hh A2v   =`
 kj Tih 5i }@)A28yh ! !;Z 4! !;U@ 4! !<P 4! !<K  4! !<F` 4! !=A  4   >#      ># < ? <w  @k T     T="#@{ 8 {#<4    p=   T=@! !<~@ 4! !<  45 =7 =  5 =7 ~=   >h A2yt! !<   >< ? <# 3  2< ? <,  htO@~@? 1  Ty  5h4yh A2@6 2 :    p=  @	  (@h  4@(@h  4< O=* kKT     T=#@5   !  p=!<   T=C{EODWC_BgAoC{EODWC_BgAo_WO{   5 >@H 4@R@h   ?  
@~@ 4 >@R{h@	@i   ?  	@os@{BOAW_O{C  *h   4  5` `    @  ( E@  2

J!@9_3k  T	*K| ik)  {AO_WO{ C 5 E @ tf@T v@*  2  6@9 7 4*k@   @    J  *  ( E @  2

J!@9_k  T	*K| ik)  	  *   h@h  4.  tf@v@*  2s ` 6@9 7t 4*:    @    2  ( E @@  2

J!@9_k  T	*K| ik)    2}  @   {BOAW_
WO{  b@c h$@h  h<@ @h@ kc T k T@r@ q L  ^@( 	A@9 5@i<@i  i$@	 @i@ 	k  T) 	k T@(a u  2 @ 2 Z V   yV@
@ 	 @9V@(} 9J@ N@J@ 2N ` "@h  V@ ?F@`A     :@S `  ( E 2	@) Q	   @r@ q *{BOAW_( @E? q T) )Er@@! )!?@2I	"_ ?( E! !<? 2@@ ?( E! !2@@ ?@? q@a T) )Er@! ! )2I	"_ ?) )E! !` 2"@ ?O{C  hJ@ `N@ZaJ@ 2o`N @ a"@  `V@{AO  {AO_( E! !2@@ ?_WO{ @ *Uv@    4 A  @
 q T @v  Q  4Av
  @ *{COBWA_@ 4 E    R@ 2b@" uB 3 s~@A 2_WO{ 5 E *# R@*i)L 2	 2 2* y  *7# BR*	 * q	 ` 4 R ( 77 E4  2  @	R 2  V6 2# BR*  5*  {2\   {COBWA__@ 7_og_WO{C5 E(  *1AR  7 g 8 9 E9E6  ~3  2  @( *@q  Tq@ TqA T@ 1 T4qT[9qAT&  *7( E@k T  {EODWC_BgA  qo_( E! ! @@ 2( E   R@ 2b 2g_WO{9 9E 9@  w  S ( E* @W w  3 l # m   !  !1   {  8 4 5 6 7 VQ|  4C `|  A  {  8{    { 	  C9u {  {  "    8#      Xy "    !  X!1 t C !RC  2  C !R jh8?) q! TC j(8v 
C !R    2@(H *{DOCWB_Ag_( E! ! 2@C @ ?( E@@m  @R !  ! 2`?og_WO{C@3) )E *<   )@E E( Y1AR?     J7 e 9 o 9E7   vC6 2{s   ) (@)E( *q, T 1  T4q TPqaT5@Q% q  Th{  9q T 99 9 2o q!T( E! " ! @BX1 27 E Q	k T`zh! !1  ) )Eszh4@  @!  ! kC T( E@8 E9  9E; @*{2+ @3 @/ @ @ @# @'   !@D @F R 7 @B9  + qT q  TC9H6! !3Z  4@ 4 5 qa T  C9 * 1`9 T;@! !83 9 _29  @5?@`  3@ ?Xv  H ( E* @ Ov  (;  )C9? i 6 2 2d o@
 4 2W  Z 4 q T;@! !83 ;:  t : T?@/@ ?  q# T C9 q" T?@@ ? " 4?@@ ? " 5   C9 E 2 2   C9?@ E*  2.  Z 4? oqA TR Rl {8 ;@! !5V  < ! !h5P 6 h     ?@+@ ??@ *3@ ??  7** * **   `@ + (@ q* T	8h {`{(	 	 I )q( T   p5* H`{(	 	 I )qB' T_ (`{(    @  @  )C9I 4	 q$ T   4	 h )	@y(	 	 i _)q" T@h )	@y(	 	 i _)qB! T@h )	 y(  ` ?y @ j@9
 4@***{ "   (8q% T*   4/ 5K qq T q  T2i8  * (8*5  I +% Q	 q  T? q T? qT 4@!  "2!p5+ (8 4@!  "2!|5 4 @ qB T@ " +@y*J @** y*"  **   2   2j@85  @A  2^  @+  qK T  y{{ +T @@+@3  ?@#@ ?@ 4! !83 `  ! !9V 4 C9 qa T! !83Q@ ! #!:S#H q_c  T   2  c_?@@'@@B" ? 4 2  _0 *(5  5( E) ! !P6@)E@@ @)   5F) Z)E)@(h *C{EODWC_BgAo_( E! ! @( E@ 2( E) ! !6@)E@ @@#  2!( E   AR@ 22( E@! !H3@2	@@ ?( E   R@ 2	 2( E! !h2@@ ?( E@! !@2@ ?( E) ! !@2@)E"@ ?( E@! !3@2	@@ ?( E! !\	2@2@ ?( E@! !H4@2	@@ ?( E! !2@@ ?( E! !42@@@ ?( E@! !
@2@ ?( E@@@@g  @?@!  ! 2*?( E@! !5@2@ ?( E@@O  @Q!  !p
  ( E@@D  @F!  !	2`?WO{  *( e5 E) )0AR   @6( E! ! @@ 2q b *#  *   4@~ @ *u  5(  @E@  @  Z q  T! !  ! !H 2*WO{  
	5 , EEc2#;) *@@ Hi ! <C !~@=T@@RU q  T
 q! T2O@   R 2	 2 *g_WO{ **w *  Z w * {~  w  h **	 w  Z 4 2  5x  q  T*? 
9 Z Qz5   2*{DOCWB_Ag_O{C    4( E! ! @g{AO3{    E{A 2OO{C    4( E! ! @M{AO|    E{A*Og_WO{*  q  TaI   4I   hEhB9  b    hB9  aB b    hA9 4hB9) * )<J r  A -"R***h	A9	 4 A9@  4& A qT   QhB(A9h  4`RhA9 4hB9) * )<Jr  A -R**h	A9	 4 AA9@  4 A qT   QhB(AA9h  4`RhB@	=  4) * Z= )<J*V)   @   .  ( E@  2

J!@9_k@T	*K|ik)    0.*hB96hB9b
B9) * )<Jr  A hAyq# T6 RV.wB:
 2U   (7@   ? (3@   ?  @y 5@yiAy_	kT 6aI   v hAy u.@8 42    6@   ?    2@H  ?   @9 4hB9IR   DrRt  @y q T{DOCWB_A@Rgm( E! !p. @J 2L( E! !  @( E! ! @_WO{ 8 E @*   **H 4( )  q<)@R cR7    -. 1  T   -*(
  @R cR    -@   {COBWA__Hog_WO{C(  E7  *@R*)H) )E( <4  (@ E    @( E@  Y @* *s  ( * EJE7 8 EEJ@ (3 (/ H@: *A *Zg+ *)s' ?    @* Q!qh Thz AhH7A24  1d T q T@H @9 qAUTH@9U5Ah`5 2_  9 q TAK56 5@2AJ5 5@2AJ5 5@k
F T{h2)@9? qT? q@T	  {h 2{ 25   O6@2 AHF56 5kjk T{h)@9? qj T? qj T	  {h@2 AC5V 5@HD 2AB5 5@k
? T{h 2)@9? q> T? q@> T	  {h 2{ 2   hH6@ 2 pA>5
	 5	@@2)5 	 ) @)E( _ @   @9_ q FT_ qET2 FA;5 5@2NA:5 5ka T{h)@9? q@a T? q a T	  {h@2# :A(85 5kJa T{h)@9? q` T? q` T	  {h@ 2{ 2   >6@2 A45
 5	@@2* 	` A(35 5@5 2	A25
I 5	@@2	6 	 A(iP7A2) 5@R    8   A(h7A2  4E929@G Ah 7A2 5E98@  2*	9@/p /T@9 2  4  @#5ku8 h5*@  s @ @9*4A87A2  4E9 29E Aa 7A2) 5@ @(p (T@9 2  4  @5ku8 h52   . @ 2 } @ U @U@ y@	U@@ 	 / l@	@9) / 7) )E@@!  @!D9s A'5 @?@ 2  @ 2 }  W   yW@@ 	  E@9 H 7( E! !; @A  A$7A 2I4(	  @ @9H4Ax@7A2  4E929D: "AS7A2  4E929 @  @9h 4  W@  9@	  @95 @  E9y	<  29i  5E9h.17 Q	= ?E qTI R=@i r(% 4E977( E@! ! @A(	7A2  4E929@C A5@7@( @  5A((7A2 5J  @H7 2s AI07A24 kj T	}@{iJ@9_ q  T_ q  T  {ik
Th)@9? qT? q@T	}@   {i 2{ 2 ~   "6@@ 2 2 2 @@9	W@(} 9@@ TG@ A    8 E~  k T{h2)@9? q T? qT	  {h2ak T{h2)@9? q T? qT	  {h2Qkj T	}@{iJ@9_ q  T_ q  T  {ikJTh)@9? qT? qT	}@  {i 2{ 2}    6@2 ,kJ+ T{h)@9? q* T? q* T	  {h* ! ! q!b TW@! !  qc TW@   :  Zgs;@  A{  8 E s@@	@9U@	} 9@p@E@A     9@m{ :  Zgs ` 22( E@ 1  T 2 @  `@S s@@@  N @@kk TG@6 4A 5hR
  4A   #r  6C@  #cI   SC Z)
	*_	 q  TE9J 5" q  T? qA T q TA  2k }@O!*	
}@Q!1
 4jh8  4?q  T q  ? qa  T  2 . A T 1  T ) iT   t B T@   7s@  N 1 T4@ 7@ @m  4  ( E* @X|  1 T7@ @m  4 2  ( E 2J!@@)}J ? qTB@9! !42 ?( E 2J!@@)}J ? qTB@9! !2 ?( E 2J!@@)}J ? qTB@9! !p2 ?4@T B q  T 2) R! r	
  5@q!Q T! !&  4! !('`  5F9 7! !'  4! !'`  5F987@(C @3q  A 5@hF  ( E 2J]@@)}J ? qT  ( E 2J]@@)}J ? qTB@9! !@'2 ?( E 2J]@@)}J ? qTB@9! !,2 ?( E 2J]@@)}J ? qT ( E 2J]@@)}J ? qT ( E 2J]@@)}J ? qT ( E 2J]@@)}J ? qTx ( E 2J]@@)}J ? qTl ( E 2J]@@)}J ? qT` ( E 2J]@@)}J ? qTT ( E 2J!@@)}J ? qTB@9 )!
 q" T~)  qT ( E 2J!@@)}J ? qTB@9 )!
 q T~)  qT  ( E )!
 q@@  T~)  qT#@9! !L/2R ?( E 2J!@@)}J ? qTB@9 )!
 q T~)  qT  ( E 2J!@@)}J ? qTB@9 )!
 qk T~)  qT  ( E )!
 q@@  T~)  qT#@9! !L/2"	R ?( E 2k!@@J}k _ qTb@9 J!?	 q T)}J ? qTi  ( E 2J!@@)}J ? qTB@9 )!
 q T~)  qT  ( E 2J!@@)}J ? qTB@9 )!
 qK T~)  qTm  ( E 2k!@@J}k _ qTb@9 J!?	 q T)}J ? qT*  ( E 2J!@@)}J ? qTB@9 )!
 q	 T~)  qTC  ( E 2k!@@J}k _ qTb@9 J!?	 q  T)}J ? qTC@9.  ( E 2J]@@)}J ? qTQ ( E 2J]@@)}J ? qTE ( E 2J!@@)}J ? qTB@9 )!
 q  T~)  qT#@9! !L/2 ?( E 2J]@@)}J ? qT0 ( E 2J]@@)}J ? qT$ ( E 2J]@@)}J ? qT ( E 2J]@@)}J ? qT ( E 2J]@@)}J ? qT  ( E 2J]@@)}J ? qTB@9! !2 ?( E 2J]@@)}J ? qTB@9! !P 2 ?( E@! !' @@ U@@   @ @9  4!@o   4   < 2!|  @* 2 Fy @ U @U@ y@@*U@ 	 @I@( @U@*R  %@)U@)@y5@y 3y R uy@yuhy *@U@" @y"@U@@yB8  @y@ U@{*  E9H7@ 2{ qL
 T~ q T QS  qHK T )(y	 @* ii 4 Qg@S@7@; _@+ :A 7 @;  2G c c@' / [@+ A;@H|K  i<S@ =7@ i<'@ =sEc@* 4=@==`=8 4S@*cRAy 	  S@*o  
9 QB C Y5K@@J _kT^ Rk TRkm TRk  TS @q1 T@q! T@A6@G  g@	R; _@7 @c c@/ [@+ ZR ))@J)@
 	 H@ 2	x  2R  (@ 2@ 9#@@ H@ 2 @] 4S@
 A   2' K (|;@ i<S@ =7@ i<'@ =gEc@* 4 = ==`=< 4S@*cRAy 	 ~ S@p  
Z QB 9C Z5K@@) ?kT q- TqL Tq` TS q T!@G r  S ql! TqL TqA TA#@#@)ar"G t  RS k T
@q!} T"@G   q TS q| TA4@uQ G  4 E ! @'q  A7@	RIRrS G :n  ( S	SJ 3) J 	* 9E*R* q< H#k H2s c   ` 5t  4@R 5n     d 4      @ 5!@2sc@s@*? #@  !R 2  )w@*6 #@   R 2        s"s   4@      `  s@  4  !  @!X@ 5k@( 5  !  !|     4 j! !|! !   !  =!#@  2 2 #@   2 2 @h 4  !  `>!  !  >! !x* !*@Rm   2 k* qA Tm  **r m    2hm  g2  41 4v:86G@A4@7   4 @! ! LGq   q- T@q^ TA7@G rZs 52m   4 9  f9CZ  O 5m   4m  :  4N6@R8  0 m  [m   * q{ Q  ( 5*m  *4  q* q  T*(m   Q4 2*l  2  " 4+86G@A4@u*  4 E! !  @p L 2*  P B qN T@  4g@S@6@C _@G * ; @7A <  2k c@+ 3 [@/ AC@| i<S@ =;@ i<+@ =Ek@* 4@====9 4S@*cRAy 	  S@n  
{ QB ZC {5@ kAT @A6@G  g@	R; _@7 @c c@/ [@+ ZR ))@J)@
 	 H@ 2	?v  2R  (@ 2@ 9#@@ H@ 2 @( 4S@
 A   2' K (|;@ i<S@ =7@ i<'@ =gEc@* 4 = ==`=< 4S@*cRAy 	 ; S@o  
Z QB 9C Z5K@@) ?kTx  "@a QG o   #Lv Q ='KS@A4@G =@== =
= ==+(6Ay*cR	  *m ~  A4@
 S G  4 E! !  @o l  A4@u	 G  4 E ! @Lq [  "@@G q U  G  2S  *Q  *O   E 2J]@@)}J ? qTB@9 !62 ? E 2J]@@)}J ? qTB@9 !\72 ? 2   2)    G  E     S G   2    G  E*       2 *T 5*       2 * 4 h6G@@*o  *@	 q  TG@ @\i ?@y S@@  g@_@c@[@ 2Et 	 )EZ)@( *C{EODWC_BgAo_*	 )E J]Bih8)@ !8<2)@ ? E !8@@2 ?A 5@   V*@@  {h @T @   	 )E J]Bih8)@ !=2)@ ?
@   :*$ E !.2@@ ??@2v @@   0   @   + E @* E !2@@ ? E !72@@ ? E !@82@2@ ? E !! @2l' E !/2@@ ? E !2@@ ? E !2@@ ? E !:2@@ ? E !6@@   E !\7@@2R ? E !62@bR@ ? E !X2@@ ? E !2@@ ? E    R@ 22 E !d!2@@ ? E !<"2@@ ? E !"2@@ ? E !,#2@@ ? E !<? 2@@ ? E !%2@R@ ?2 E !#2@@ ? E !$2@@ ? E   AR@ 2 2s 2; E !x2@@ ? E !/@@ E@@7@@-  @r   !T& 2? E@ !(@2@ ?O{C    4 E !  @{AOm {A     2OBog_WO{C E c @**( |i   4   < 2  2v Ay 3@6 	 =)=r * 7N@*+} R@*(} y3(7 	 =)? q  B9E2 3@GB9v *c H 	 
 )=J? q@	  Ay 	 >)>? q 36  4@   0>2 2@2%@2"@206B9h  7 9  (RO y(D87R7r   4BR$	  AR v  5j   HRj x 	 a>)E>? q  B9h 7 9  (RO y(E8  4 BR
   AR v  5j   HRj x 	 >)}>? q  iB9@2 3 !E 2 *  4 5y    	 >)? q  !>  y   2y   2 	 >)? q  ;B9@2 3 !E 2 *  4B  5y    	 >)>? q  !>  ry   2y   2 	 >)>? q    4@   ?2 2?B9 6   ?Ayq# T  R?9B5[ 2t   ,@h * ?	  h@9  4  @H@yAy	kT@ -@ * ?  @y q  T   8? 87@@RCc 	 @)E)@(( C{EODWC_BgAo_{ B       2  7     	 	      Z J   F      g !! G! O" " E# # u( ( * &+ ), , , ?0 v0 0 3 4 5 ^8 8 8 n< = = gA OE 
F F F H K K O pP {6R    Dv @   UO{C    jh@9	 q  T q  T 5        4      {AOY{AO_(@9	 q  T q  TH 5   PM   J   G_O{C  t@| s@ ! 4 ! @ 4 !4@ 52   9   2 9{AO_ E !2@@ ?   u @   O{C    h@9  7{AO_{A   O(@9H  7_   O{C @|  2h 9{AO_   u @  @O{C    h"@{A   }S= O( @   }S= WO{ C  E @ u@v| `@ !   q T@@y	=3 @  {BOAW_ Eb@ !0@2@ ?   2u @     _O{C h@9	 q T q T 5   a@   Hb@ _   T    `!$          ,b@ _   T{AO_    `!l{AOz{A   OuO{C h@9	 q T q T 5   ha@   Hdb@ _   T    `!$     	     Ub@ _   T{AO_    `!{AOG{A   OBO{C  t@{ h
@@% qh T )Q(y	 B 9h*@ h.@   2B 9  2B 9  h*@ {AO_`@9 H  4_{  E !P	2@@ ?@   @_	@9?	 q` T? q@ TI 5	D)a 4? ka T   
D)( 
 1 T? k T   D)( 
 1  T? kA T   P     "* 
   T   _ 1` T 5            d   (@9	 q  T q` T 5(D)   *"D)   "D)      O{C  t@Z{ h
@@% qh T )(y	 2 9h*@ h&E)(*    22 9  22 9   2 9h*@(*   2 9h*@ h*@   2 9h*@~ )	  2 9h*@ h.@   h*@ ){AO_   $Pt @  aO{C    `vb@9_ q  T_ q! T        {AOi E ! 2@@ ?O{C    hZb@9_ q  T_ q! T        {AOM E ! 2@@ ?O{C  t@z h
@@ q  T  5 2  2 9{AO_@H  4_{  E !x2@@ ?   ' 2dt @  "O{C    @h@9  6   P(B8  4   tt&@4 4    !  7 !<
       8=!<B, !$6    8=B< !$6    8=B\ !$6    8=B| !$ 6    8=B !$(6    8=B !$06    8=B !$86    8=B !$@6    8=B !$ H6    8=B8t*@ 4    ! 6     8=!<B,aF@y  4{A   O{AO_O{C hB@yh7  6   X(B8  4   t&@4 4    !  7 !<
       8=!<B,x !$6    8=B<p !$6    8=B\h !$6    8=B|` !$ 6    8=BX !$(6    8=BP !$06    8=BH !$86    8=B@ !$@6    8=B8 !$ H6    8=B80t*@ 4    !) 6     8=!<B,!aF@y  4{A   O{AO_O{C  t@y h
@@ q  T q TH 5@y 2 y  b@  @ 28 
   b@  AR1  {AO_@  'O{C h@97   @h@9  6   P(B8  4   t(C8  4   t&@ 4    !4 7 !<  {A   O     8=!<B, !$6    8=B< !$6    8=B\ !$6    8=B| !$ 6    8=B !$(6    8=B !$06    8=B !$86    8=B !$@6    8=B !$ H6    8=B8zt*@ 4    !s 6     8=!<B,kaF@y  4{A   Od{AO_O{C hB@y(7  6   XW(B8  4   Q(C8  4   (Kt&@4 4    !D  7 !<
       8=!<B,9 !$6    8=B<1 !$6    8=B\) !$6    8=B|! !$ 6    8=B !$(6    8=B !$06    8=B	 !$86    8=B !$@6    8=B !$ H6    8=B8t*@ 4    ! 6     8=!<B,aF@y  4{A   O{AO_@9	 
 )J!r@_ 2@ y_ 2@ y_og_WO{CC  E* @  @ |     **& 2D   4@  4{ C #T  *  	@H#*kT E !@2@@ ?ZH *C{EODWC_BgAo_   <Iq @   .ZO{C    oa@9{A   Oi!@9   e_WO{  u@x h
@@ q Ts@ @   4 C V T E !(2@@ ?	@ 9{COBWA__@H  4_{  E !2@@ ?   ?2gq @  4O{C    DhJ@ P6aV@   dhJ@ X6aZ@   hJ@t  `6   	hJ@ 6Tr  *   hJ@ 6` Lr  *   {AO  O{C J@  6;r  *   J@ 6 3r  *   D{AO   { @HP6(H6h 6	 5?R	
h 4{_ E !h$2@@ ? E !$2@@ ? E !0%2@@ ? E !P&2@@ ?O{C    DhJ@ P6aV@   dhJ@ X6aZ@   hJ@t  `6   hJ@ 6,s     )hJ@ 6` $s     *{AO  O{C J@  6r  *   tJ@ 6 r  *   Dl{AOD  O{C  h*@06hB@y   0	Z}S\h*@86hF@y   t	Z}STh*@ 6h"@   	ZMh*@ 6hJ@y   	Z}SEh*@(6hN@y   $	Z}S=h*@ 6h&@   T	Z6h*@ @6aZ@y   |0h*@ H7{AO_a2@{A   O%O{C  h*@06hB@y   	Z}Sh*@86hF@y   	Z}Sh*@ 6h"@   x	Z
h*@ 6hJ@y   	Z}Sh*@(6hN@y   4 	Z}Sh*@ 6h&@    	Zh*@ @6aZ@y    h*@ H6a2@   H!h*@ P6a6@   !h*@ X6a:@   !h*@ `7{AO_{A   $"O_WO{  t@ov h
@@5 q	 Ti )(y	 *@ 2?  h*@*@	Z)2):  h*@*@	Z)2" * 3  hR@y*@	Z)2}SJ y* +  *@2'  *@2$  *@2!  *@2  hR@y*@	Z)2}SN y*   hR@y*@	Z)2}SB y*   hR@y*@	Z)2}SF y*   *@2  *@2* h
@@i"@ 2H!(*h" {COBWA__t@u@R   v ` T)   4 R y w@9 4  ( c    5   E !l"2@@ ? E !"2@@ ?WO{  !$  4 !* 4 !*  4 !$` 4 !($ 4 !@$ 4 !X$  4*8  *@2* h@20  *@	 &  2* h@ 2(  *@	 &2* h@2   *@? 2B y2* h@2  *@? 2F y2* h@2  *@? 2Z y2* h@2  *@	 " 2* h@2 2h {BOAW_   n @   O{C a"@   h*  a  *aA9{A   *OO{C a"@    +  a  8+aA9{A   h+O   pn @  O{C    ,t    @9 q  Tpq`  T 5  R@9@Ra>@? 1  T   ,     P,{h@9  4{A   ,Ot{AO_O{C    -t i   j@9 q  Tpq`  T 5  Ra@9@R]a>@  4   d-Th@9  4{A   -OM{AO_O{C  @t 
@@	 q  T q@ Th 5 * 9-@IRi y h @{AO 2hn 9  @ ! . 2br   4* j    7 E !0.2@ @ ? H  {AO_    2Nn @   O{C    /a@{A   /OO{C    /a@{A   /OO{C  t@t h
@	@  5h*@ {AO_	 )E@ !/)@2)@ ?@H  4_{  E !02@@ ?O{C h@9	 q  T q  TH 5   /     1     d1a@{A   /OO{C h@9	 q  T q  TH 5   /     1     1a@{A   /OO{C  t@9t h
@@	 q  T q  T  5" 9  2   2" 9h*@ {AO_@  b	D)  4? k T   H2v  "* 2r_ 1  T  5   2l   2i   2f(D)   *aO{C  t@t h
@@ q Ti )q(y	 h*@ h&E)(*    h*@(*   h*@   h*@    h*@ h.@ {AO_@H  4_{  E !L32@@ ?   l @   
L y_    !<     !5  O{C  s h
@@ q  T`@AR +  {AO_ E !52@@ ?WO{  @8  4   4sq 
@y  4   4@  4   5@y 4{BOA   `5W{BOAW_   2m @  !@@y   L7!@@y   7O{C  ms h
@@ q  T{AO_ E !72@@ ?{ @  @   { 2D y_(D@y!@@y	 q  T   Q 9   L7(D@y!@@y	 q  T   Q  :   7O{C  t@4s h
@@ q Th@9	 q TbR@ycV@y_ kb T yhV@yiR@y 	K y{AO_ Eb@ !\:@2@ ? E !:2@@ ?{ @  H@   E@  @{AO{C hF@yaB@y	 q  T   Q 9P     L7Lh@9  7{AO_{A    ;OBO{C hF@yaB@y	 q  T   Q  :5     71h@9  7{AO_{A    ;O'O{C  t@h
@@	 qa  T 2
 y{AO_{ @  @   @  @@  @{O{C hF@yaB@y	 q  T   Q 9     L7hJ@y  6    ;hJ@y 7{AO_{A   `;OO{C hF@yaB@y	 q  T   Q  :     7hJ@y  6    ;hJ@y 7{AO_{A   ;OO{C  t@ir h
@@ q Th@9	 qa TbR@ycV@y_ k T yhV@yiR@y 	K yh
@@	 q  T 2
 yh
@@ q  T
@y2
 y{AO_ Eb@ !\:@2@ ? E !:2@@ ?   #^k @  @oWO{ (`@yRGr 
 J	 )!* ? q  I  <" 4}}S  <"s   ,<ock	 Th ]B   < af  q Th YB   < a]     <*X     \<!<S`ck  Th ]B   < a  qC Th YB   < a{BOAW?*{BOA   <W8WO{ (`@yRGr 
 J	 )!* ? q I  <" 4}}S  <"    ,<ck	 Th ]B   < a  q Th YB   < a
     <*    \<!< `ck  Th ]B   < a  qC Th YB   < a{BOAW*{BOA   <WO{C  t2@q h
@@	 q  T qA Ta@  6 Eb@ !=@2@ ?a@ ~   7{AO_ Eb@ !=@2@ ?#mWO{ @i R)rB 9@	k T 2hB 9@ R	$r	k) T2hB 9@R)Hr	k T 2hB 9@R)r	k T2hB 9@R) r	kC T RhB 9@IR	@r	k T 2
  2   2  *   2  2hB 9 2n 2uF 9 @" b ` 9`)c@hF@9 @a `!a~  a  T 	 hF 9? qT	 Q	 Q iF 9y q  T{COBWA#l_ E !<?2@@ ?2hB 9 E !>2@@ ?#mWO{ C  E  @ @N  T@9 4 !>` 4 !> 4 !$>  4 !8> 4 !D>@ 4 !X> 4 !p>` 4 !|> 4 !>  4  
  h  ]B  h  YB	`y*h @   {COBWA#l_)   &i @  !O{C     b@9_ q  T{A  a   O E !  2@@ ?O{C    hb@9_ q  T{A  a   O E !  2@@ ?   ) 2i @   #? 2 y@ y_{  @ q  T q T       2{_@  4_{  E !	2@@ ?O{C   a  ' {A  a O! O{C   a  
 {A  a 
O ? 2H y@ y_O{C  @ q T qa T  B h@ 2	    B h@2h {A 2O_O{C   a  ! {A  a  O O{C   a  
 {A  a  
O @   &? 2	 H y@ y	, _WO{ C  E Q q@  Ti )(y @	   BZ h@ 2  *@ 2* h@2   E*  @{2e   ( 6@. h@2	    B< h@2h @   2 {BOAW_ E !
2@{2@ ?{    4`  77`7{_ E !	2@@ ? E !2@@ ? E !2@@ ?O{C   a   h@9  6   da.@? 1  T   {A  a  O} O{C   a  
u h@9  6   a.@? 1  T    +{A  a  
Od og_WO{CC  E @ @h 5 {Ehzh
 @9 q
 T q@
 T E @ B Tk  hzh~  2        &** 2  2 x` 4 2s 5H~jh)2j(  H~jh) 2j(@_ l  TZ  E@ fh@ h | @h C{EODWC_BgAo_ E !l2@@ ? E !x@@   E !@@2 ? E !2@ 2@ ?< E !h2@2@ ?_WO{  EC  R@~  A   *2" 2 *b
RC 3 * 9 **9V 5@ q! T3@y? 2	k T y@h  {COBWA__ E@@ @ ! 2`? E !H 2@R@ ? E !x2@@ ?WO{   E 2 2@ 2  *2 t72 2*H 1 T2*b
RC 3 * :  5@h @h * {BOAW_ E ! 2@@ ? E@@i  @k  !H 2`? E ! 2@@ ?WO{   E ? 2@ a@y? k@ T# I     	# Oh@( 4    ** r     8=!L=Bh
@ 4 r     8=!$9h@h 4 r     8=!$0h@H 4 r     8=!$'h@( 4 r     8=!$h@ 4 r     8=!$@   {BOAW_@_WO{  EC  R@ ~*  N 2*b
RC 3  * 3 y **K 5@ q Tc@9h 4# 2 2@h  {COBWA__ E@@ @ ! 2`? E !H 2@R@ ? E > !	@2@ ?og_WO{CC  9E 9@ h
@9 5 ZEHzh( @9 q
 T q
 T E @  THzh    h
@9 q T      &* 2*  h
 9 2   4 2  5h
@9  h@y	@i#)!H*i 9@ _  qH  Ti 5H@ H @( C{EODWC_BgAo_ E !l2@@ ? E !x2@@ ? E !2@@ ? E !2@ 2@ ? E !h2@2@ ?`og_WO{C  E ? 2@ a@y? k T#    	# h@y	 i 4          *}S&O= 2Z*{*:= q )#	
 rbi@y(}S)kT@( C{EODWC_BgAo_   22(f    R!@@y? 2? k  T      ,!@@y? 2? k  T      O{C  t@nl h
@@ qa  T? 2 y{AO_@H  4_{  E !L2@@ ?   R   82e @  )O{C ` b  4f   f     hC8  4{A   O{AO_O{C ` f     hC8  4{A   O}{AO_O{C ` b  4g   g     mhC8  4{A   Oe{AO_O{C ` g     XhC8  4{A   OP{AO_   >2e O{C @  +' sz c22; cX225 c22/ c22) **c4#{A@RO#O{C    pa@9{A   O!@9   O{C  t@k h@9q  Th@9 9{AO_ E  !2@@ ?`@9 H  4_{  E  !P2@@ ?O{C      !  s  c22  cX22  c22  c22  **c4{A    /O@9  4@9   8@9_ q T?@ q  T  B$  ?  q  T  BX  ? q  T  B  ? q  T  B  A 4  4? k T     A R   4   8   4   B4     !(@9"@9   t *O{C  t@ k h
@@ q Ti )(y	 h@9 9h@9 9   9h@9(* 9	  h@9 9h@9 9  h@9 9 9{AO_    2d     29O{C ` je hZ@ydD){A   	Z P!}SOEO{C hZ@y   !	Z}S;` Te      "5bD){A   P"O/O{C  t@j h
@@ q  T	 q Th*@ h.@   h*@
 {AO_O{C ` .e hr@ydD){A   	Z P!}SO	O{C hr@y   !	Z}S` e      "bD){A   P"OO{C  t@j h
@@	 q  Th*@ h.@ {AO_O{C ` .f hr@ydD){A   	Z P!}SOO{C hr@y   !	Z}S` f      "bD){A   P"O   c    2vc {    5{ O{C    t%h"@	=  4   %h&@h  4 R`B@y/ .Bx  }St  4   %h*@h  4 R@y{AO {AO_O{C h"@	=  4h&@  4   {   &x`B@y
 .Bx  }St  4h*@  4   k   <&h@y{AO  {AO_O{C  @j 
@@ q@ T 5@S @9h 4 2h   @a
 K @9h  4 2h
 {AO_`@9 H  4_{  E  !0'2@@ ?{    8{  O{C    t%(h"@	=  4   %"h@9h  6 R"`B@y  .Bx  }St h 4   H(hNB8h 6 R@y    s h@ 6   t(h@ 7{AO_{A   (OO{C h"@	=  4h@9  6      &`B@y  .Bx  }St h 4h@9 6      <&@yo  h&@ 6   (h&@ 7{AO_{A   )OO{C  @li 
@@ q Ti )(y	 @  @9H 4h@ 2  @a
   @9H 4h@2  h@2  h@2h {AO_O{C   sZ#  !#  !$  !$$  !<$  !d$  !$  !$  !$  !%{  !(%w  !@%s{A  !P%OmO{C <   7  !<
         8=!<B#^  !$6     8=B$V  !$6     8=B$$N  !$6     8=B<$F  !$ 6     8=Bd$>  !$(6     8=B$6  !$06     8=B$.  !$86     8=B$&  !$@6     8=B%  !$H6     8=B(%  !$P6     8=B@%  !$ X7{AO_{A     8=BP%OWO{     R    T"  5   Q     4{BOAW_ E  !p&@@2 ? E  !&@@WO{   !# b 4  !$\  4  !$$V 4  !<$P  4  !d$J 4  !$D  4  !$> 4  !$8  4  !%2 4  !(%,  4  !@%& 4  !P%   4*  *   2  2   2  2   R  2
   2  2  (R  HR  hRi@y 2 (*h y{BOAW_   ``    =;O{C    )P{AO  O{C aB@y   *D  {A@ROB_WO{ C  E @ g h
@@(
 5t@s@  !8+ ; q	 T@9 q	 Th@yH
 4q TR 6    v *@8h@y 4
 T  
  q TR   " u  *h@yka T@  {COBWA__ E  !-2@@ ? E  !.2@*@ ? E  !*2@@ ? E  !P+2@@ ? E  !+2@@ ? E  !\,2@@ ? E  !`.2@@ ?`@9H  6_{  E  !t/2@@ ?WO{  h@d*@	= `px?	 q T  v *hB@y_x_8_8@  T{BOA   \*W  @_    ?eO{C    @0za&@h@9  7   0     h0qa"@b*@{A   0OjO{C a&@h@9  7   2     x1]a"@b*@{A   2OVO{C  t@f h
@@	 q T q! Th@9  4@ 2 h*@ 2 Q(!   h@9  4@ 2 {AO_{ 	@@jR*

_- q T	!@) 2I!	 T E  !\32@@ ?R*

_5 q T	!@) 2I!	c T E  !42@@ ?(h  4{_ E  !52@@ ?   Q_     (    P8?|9O{C    x83 ?|9{AOld    9_    @WO{ bBt@_ I T E   2@ 2
B     `9!< 	   T   9 E   8 2@ 2  @   9R 2{BOAW  WO{ bBt@_ I T E   2@ 2
B     `9!5 	   T   9 E   :!R@ 2p  @   :2 2{BOAW  O{C  t@f h
@@	 q@ T q@ T 5b@  h@9	 q  Tc@   Th@9( 4
 /  s@  !P<g  4  ! b 4  !p<]@ 52  s@  !;U  4  !|P  4  !;K 52F 9
  B 9  F 9   2B 9   2F 9{AO_ E  !,;2@@ ? E  !<@@   E  !;@@2 ?@@9	 q@ T q  T 5 E   9@   E    : 2@ 2? E   92@ 27 E    :@2 2/D@9	 q T q@ T( 5 E   D:!R@ 2! E   : R@ 2 E   l:2@ 2 E    :2@ 2	  !2^      _	5@!@    J**?r 1  T+**k	ZJ k}S5  *1@    2>=? r  b
K =O{C t~@9a2@h@9  7   L>     =i"@? 1  T)**)	Z )}S5  *2  !K >  4h@9 7   D?  {AO_   >{AO|  `@9 H  4_{  E  !X 2@@ ?	5@!@    J**?r 1  T+**k	ZJ k}S5  *%@ 1  T+*k	ZJ k}S5)@ 1  T+*k	ZJ k}S5-@ 1  T+*k	ZJ k}S51@    2>=? r  b
K =6O{C t~@9a2@h@9  7   L>     =(i"@? 1  T)**)	Z )}S5  *i&@? 1  T)*)	Z )}S5i*@? 1  T)*)	Z )}S5i.@? 1  T)*)	Z )}S52  !K >   4h@9 7   D?  {AO_   >{AOWO{  h*@t@@}@9d h
@@ q TI )A(y	 h@9 5  5 4@y	  h@9 4@ 2   4@2 {BOAW_ E  !?2@@ ?  `-2]    O{C    h@9h  4 Rb*@a"@_ 1  T{A   O{A   OO{C h@9  4      ,b*@a"@_ 1  T{A   O{A   OO{C  t@)d h*@ h.@ h@9h  4 2B 9{AO_O{C    Lqh@9h  4 Rqa
D)_ 1  T{A   Oe{A   O`O{C h@9  4   W   ,Ta
D)_ 1  T{A   OL{A   OGO{C  t@c h@9h  4 2" 9h*@ h.@ {AO_   3aR\       <*   B5 2{ B9    )Jr@_WO{  @c 
@@- q TI )(y	 @   R     To 5  @9h. y@9  4i&A9)2i&9h  5h&A907h"A92m  @9  4h&A92h&9*@i"A9h
 (2c  @9  4h&A92h&9*@i"A9h (2Y  @9  4h&A92h&9*@i"A9h (2O  @9  4h&A92h&9*@i"A9h" (2E  @   R  v  Tv 5C  *@h *@h" @9	 qc  T.@h" @9  4h&A92h&9h"A92$  @9( 4  h   4@9 4h&A9 2h&9    h H  4@9  4h&A92h&9h"A92h"9{BOAW_ E  !@@   E  !\
@@2 ? E  !P2@@ ? E  !x2@@ ?@H  4_{  E  !(2@@ ?WO{  E* @ RnAy q  	 }S*!< 2/y3y ]   {BOAW_]O{C  Ea  @RhnAy  *!5	 }S 2 2/y3y ^  C {AO_<WO{  E C C @R t@	b	~ZB9Oy^B9Sy7AyWy@[y}S_yCAycyv * 7AyWAy	k T@@
= _!)k! T}SAIk TCAycAy	kA TC R[B9Z9B9^9t @  {BOAW_ E  !2@@ ?WO{  E* @ R6nAy q  	 }S*!< BR/y3y ]   {BOAW_O{C  Ea  @RhnAy  *!5	 }S BR 2/y3yk ^  C {AO_*  _  q  !<2[     *!52 2T WO{  E  R@ t@	Ay7y@;y}S?y#AyCyv  Ay7Ay	kA T@@
= _!)k T}SAIkA T#AyCAy	k T Rt ]  {BOAW_ E  !2@@ ?Z*  _  q  !<BR
     *!5BR 2   _  q  !<2 2     !52 2 2 J   _  q  !<BR 2     !5BR 2 2    O{C    d`"@{AO O{C    `"@{AO O{C  t@a ( R&y`@ Z9h@9  4*Ay 2*y{AO_O{C  t@la ( R&y`@ .yh@9  4*Ay 2*y{AO_O{C  t@Ya `@  h@9h  4 * {AO_WO{  h@y*	}S 6  6      `"@z  h@y	}S6 6      an@y   (h@y	}S6 6      8{` a"*  h@y	}S6 6   p   ll` aB*  h@y	}S 6  6   a   ]` a2*t  h@y	}S(6 (6   R   N`aR*e  h@y	}S06 06   C   ?`&@  h@y	}S  7{BOAW_(  6   0   8,aE_  T{BOA   lW"{BOA   |WO{C  *  7  !L=        !L=  !$ 6   H	  !$ 6   `  !$ 6     !$ @6     !$ 06     !$ 87{AO_{A   OoO{ C E@h@*  4 4Z        (!>  Z  # 2`*[  # 2R   (# ]   {BOAo_O{C  *  7  !L=       8!L=  !$ 6   d  !$ 6     !$ 6     !$  4{AO_{A   OWO{   !	 $ 4  !	 4  !	  4  !	 4  !
` 4  !4
  4  !H
  4*  h@ 2  h@2  h@2  h@2	  h@2  h@2  h@2 2h {BOAW_WO{   !
  4  !
 4  !
 4  !  4*  h@ 2  h@2  h@2h  2{BOAW__WO{  &Ay*** 6RB9  6   &Ay    )Jr  B .Ay&Ay6RB9 6   Ay   &Ay6RB9 6      8B  *  &Ay6RB9 6      l   *  &Ay 6RB9  6      B *  &Ay(6RB9 (6       *  &Ay@6VB9  6   Ay r		Z)}Su  66Ay  *= D 4 k  T     B4       `B4NB96VB9 6   Ay r		Z)}S  6:Ay= d 4 k  T     Blq  =      `BliNB96VB9 6   bAy r		Z)}S  6>Ay= d 4 k  T     BP  =      `BHNB96VB9 6   A"Ay r		Z)}S  6BAy= d 4 k  T     B/  =      `B'&Ay06RB9 06       2Ayb&Ay86RB9 86      8
P)_ k  T   *      NB9  7{COBWA__VB9  7        {COBWA_O{C _( q  T_ q! Th  H 6 Y   h   63Z   {AO_ @( 4Y  7Y    @  5@  5@h  5@ 4&Z  eZ {A    O{A   8OWO{  @]^ 
@@1 q  TI )Q(y	 @   R  v   T   h7  @9hyh  5hRB9 07h&Ay2h&y@9 4h*Ay2h*y  <h&Ay`=<2h&y`=@9 4h*Ay2h*y  <h&Ay`
=<2h&y`=@9h 4h*Ay2h*y  <h&Ay`=<2h&y`=@9 4h*Ay2h*y  <h&Ay`=<2h&y`=@9( 4h*Ay2h*y  Bxi&Ayhy_8 qZhxh6y(2h&y_8( 4h*Ay2h*y  Bxi&Ayhy_8 qZhxh:y(2h&y_8( 4h*Ay2h*y  Bxi&Ayhy_8 qZhxh>y(2h&y_8( 4h*Ay2h*y}  Bxi&Ayh"y_8 qZhxhBy(2h&y_8( 4h*Ay2h*ym  @   R 0   T    h7i  *@h *@h @9	 qc  T.@h h&Ay2h&y@9	 4h*Ay2h*yJ  @  !  4  !8  4{BOA    !BP 2WPW  H  J     6h&Ay 2h&y@9 4h*Ay 2h*y!   4 (     h 6h&Ay2h&y@9( 4h*Ay2h*y  h&Ayi*AyR2)

  h&Ayi*Ay2)2h&yi*y{BOAW_ E  !@@   E  !\
@@2 ? E  !h2@@ ?WO{    !	& 4  !	  4  !	  4  !	 4  !
` 4  !4
  4  !H
 4*  h.Ay 2  h.Ay2  h.Ay2  h.Ay2	  h.Ay2  h.Ay2  h.Ay2 2h.y{BOAW_WO{    !
 4  !
 4  !
@ 4  ! 4  !p 4*  h2Ay 2	  h2Ay2  h2Ay2  h2Ay2h2y 2{BOAW_O{C  *  7  !<        !<  !$ 6   H  !$ 6   `  !$ 6     !$ @7{AO_{A   OWO{ R   *  T,  @ 4  *R  h@9( 4 / h     4{BOA  *W_ E  !2@@ ? E  !2@@ ?O{C   !	 A 4  !	;  4  !	5 4  !	/  4  !
)  q ]S   2  2  2  2{AO_  T    @Y"$D)    <JU  ? q ,Ak"$D)    <J  ? q `AaO{C  t@\ h@9h  4 2 {AO_  T    @ 2O{C @   A] (  }  8 @	 q  T{AO_ E@  @1{A  B  !B O  !  <K    *!  5F  WO{ C  E @ u@[ h
@@ q  T 5`@    @ @@
 	 2 i@9I 4 2  `@  x  @ @@ 	2 i@9i  42 @   {BOAW_#@H  4_{  E  !h2@@ ?WO{ @* ( 6 6      @)_ 1  T   h*   5(  }D*p]       p=     *@ 7{BOAW_ 6      0@)_ 1  T*{BOA   hW 5(  }D*H]   {BOA   p=W*{BOA   WWO{ C  E*@    >Q   6@(@9 q` T 4(  }D]   1` T  @  {BOAW_  * !Q   (7 E  !@@   E  !@@2 ?  S    ")(@9"@9    )<J< q  A :(@9"@9    )<J q  A </g_WO{ v@Z h
@@ q`  T 4#  t@ B5@   4 9C W T E  !(2@@ ?	@ 9h@9h  4 2 9{DOCWB_Ag_@H  4_{  E  !2@@ ?  `7S     (O{C    `h@9 6h@9    )<J<r  A h@9(6h@9    )<J<r  A h@9  7{AO_h@9b@9{A    )<J< r  A OO{C h@9H 6h@9  6      h@9H(6h@9 (6      (h@9  7{AO_h@9  6   a@9{A   dOO{C  t@,Z h
@@	 q T q T 5@92 9h@9 4@92 9  h@9  4@9 2 9@9 2 9h@9
 9	  @92 9h@9  4@92 9{AO_@H  4_{  E  !2@@ ?  @R     +1O{C    FcD)h@9    )<J< rB 1  T * 4 k  T     8!X$2       \!X$,h@9  4{A   O${AO_O{C h"@  5h&@ 1  Th@9    )<J r  A a
D)? k  T{A   O{A    O{AO_O{C  t@Y h@9 qa  T@ h@9  4"@9 2" 9{AO_   ! 2R     R R	}R8 	D _WO{  E   &@aR 2	h6@  4DR	 r	kI T!  H  aB   L(*)  *	I_	kb  T  *R
r 2
k TK	j 2
kC T2
R
k  TI	*?
k2)5 J/I	5	@"@   \(
6R(r~m	}R}	a:@   &@   ' R 2`2@R a>@  4   0'a"@  4   p'aF@  !`?q  T   '{aJ@? k  T{BOAW_{BOA   (WnWO{  E   )@2 2t h6@  4DR	 r	kI T!  H  aB   L(S*)  *	I_	kb  T  *R
r 2
k TK	j 2
kC T2
R
k  TI	*?
k2)5 J/I	6	@"@   \(
/6R(r~m	}R}	a:@   P)%@   )!R 2W`2@Rb    )a>@  4   D*a"@  4   *aF@  !`?q  T    +aJ@? k  T{BOAW_{BOA   +WO{C  t@X h
@@ q T 5`@b2@R q ` 5c@    !B ,  a@B   7{AO_c@    !Bd,{A 2O@R @	 	 4 X7	@
}R@}
() _{  E  !<-2@@ ?   / R R	}R
R0 8 	D 
 y_  2   2 WO{   E @ v@GX h
@@ qH TI )(y	 h@9  4@2 `@b2@R $ ` 7`@b2@ 	 5c@@     !B ,T  a@B V  6c@@H
     !Bd,G  s@# C  2 M  6@	@9@  5*R
 T?q 222j?q(} 	`    h@9  5@2 `@b2@R  ` 6@2   h"A9 9	  h"A9 9  `@b2@    4@  {BOAW_c@@h     !BT 2 {BOAWQ Y  E  !2@/ 2@ ?{ 	@(  4@ X7	@
}R)@)}
	) 	@ (7@)R	k T{_	@ 87*
 {_
@k`  4 	mSA Q  k2_k T  4 	kmSlA QK	  _ 1k2M	_ qji X7	LR	) 
 {_ E  !<-2@@ ?  E@@k  5k2  	 )	)mS"A Q  !2 ? R	}R
R0 8 	D 
 y_  2    2 WO{  *2*t 7*
   E   ( R@ 2 26u  4`  E   ( 2@ 2 2 6u  4`  E   ( R@ 2 2 7{BOAW_u  4`  E   ( 2@{BOA 2W_WO{  2R       w   !, 4  !,` 4  !( 4  !x(` 4*  *   2  2  R  ( R0r   4@	R}		 ( 4 2  *{COBWA__ E  !,2@@ ?g_WO{ 6    !0-$            (2-((9(  4 4	 4  5h@2	  h@ 2  h@2  h@2h  *        {DOCWB_Ag_WO{  E B@9*@  7   ?     ?R 2
@ `(7 4DR r k	 T'  @  B<s   *4  (  aB   L(*)  		( ?kb  T  )R	r 2 	k T*	I  2_	kC T2	R 	k  T(		 	k25 )/(	@@
   \(6R(r~m	}R}	@   &B@9 H 4@   ' R 2@R@  4   0'u@  4   p'p&@  !`?q  T   'h@? k  T(h)`     (_Z@y(}S! ? k  T   ?W@9 ? k  T{BOAW_{BOA   ( WIWO{ *k2@ 4 	mSA QDq  Tqc T
  ~S- 2	 (	 ka  T
  ~SU	  2)	 2? k@  T2 0		@@   X 
 4  * (~ 2%D1		@@    

 LR   SR{BOAW_WO{  E B@9*@  7   !R      AR 2'
@ `(7 4DR r k	 T'  @  B` *4  (  aB   L(*)  		( ?kb  T  )R	r 2 	k T*	I  2_	kC T2	R 	k  T(		 	k25 )/(	@@
   \(6R(r~m	}R}	@   P)B@9 H 4@   )!R 2@R   )@  4   D*@  4   *&@  !`?q  T    +@? k  T(h)`     +Z@y(}S! ? k  T   y@9 ? k  T{BOAW_{BOA   WkWO{   !  * ` T 4_8 22	|@qjq2}	H` H|D 	 (	 h 4 2 2   *{BOAW_ E  !2@ @ ? E  !x2@@ ?{  E  !2@R@ ?  )mM     ,( @    )<JU q  " A XO{C h"@    )<J q  A {A` O}R O{C  t@T h@9h  4 2 {AO_  , 2M    -O{C C h@9 6   h@9  6   a@9b@9c@9d@9e@9f@9g@9h@9    h@96   @h@9 (6   a@9b@9c@9d@9e@9f@9g@9h@9    C {AO_O{C C h@9 6  6      a@9b@9c@9d@9e@9f@9g@9h@9    h@96 (6      0	a@9b@9c@9d@9e@9f@9g@9h@9    C {AO_WO{   E @ u@T h
@@ q T 5B@9	 2B 9i@9  4)R	*B 9`@  cd	# 2  @ @   B@9	2B 9i@9  4IR	*B 9`@  c	# 2  @
 @ @   {BOAW_w@H  4_{  E  !
2@@ ?O{C hA9 6   t ,hA9  6   '@N     (!` :N     hA9 7{AO_   @hA9 (6   `'N     (`B!N {A    O O{C hA9h 6t   6   N     $` N     hA9 7{AO_ (6   `M     d`BM {A    O2  O{C hA9 6   t hA9  6   O     (` O     hA9 7{AO_   @hA9 (6   `N     (`BN {A    OO{C hA9h 6t   6   N     $` N     hA9 7{AO_ (6   z`N     dt`BN {A    OlAR~  _WO{ *y 3 R w   8*$  B 2 q T E  !	 @,  *  {COBWA_c E  !	2@@ ?_WO{  h ~~ ) q! TN      ! 2L =`=N      ! 2yL =`=  M      ! 2mL @h M      ! 2aL @h {COBWA__WO{  @*R 
@@ q T 5@  cd	*qhA9	 2i9@9) 4)R  @  a c	*dhA9	2i9@9  4IR	*h9{BOAW_  @5K     0O{C h@9    )<J< q  A aB@ybF@y? k  T{A   O{A    OO{C h@9    )<J q  A aB@ybF@y? k  T{A   O{A    OO{C  t@#R hR@y yhR@y yh@9	 qc  ThV@y yh@9h  4 2 9{AO_   8J    8 RfO{C    a     Rh& {AO_O{C    &Rh"@  4DR	 r	k) T   (  aB   L(E#  *	I_	kb  T  *R
r 2
k TK	j 2
kC T2
R
k  TI	*?
k2)5 J9I	*	@"@   \(A	"a&@{A   &OO{C    h"@  4DR	 r	k) T   (  aB   L(#  *	I_	kb  T  *R
r 2
k TK	j 2
kC T2
R
k  TI	*?
k2)5 J9I	*	@"@   \(A	a&@? q  T{AO_{A   OO{C  t@zQ h
@@  5`@   4h@9  5{AO_ E  !H2@@ ? Eb@  !@2@ ?WO{ R          !,B  4  !,< 4  !(6@ 4  !x(0 4*  R  *  R	  5Rr  DR r  oR r1  4
  4 2  *{BOAW_ E  !,2@@ ?   ;I    2GO{C     \h*@  4   Wa@9   Sa@9  .Na@9Ka@9Ha@9Ea@9{AO@O{C h*@  4   7   D4a@9   0a@9  .+a@9(a@9%a@9"a@9{AOO{C  t@P h@9h  4 2
 {AO_  =2I     4O{C    h@9  4   b*@a"@_ 1  T{A   O{A   OO{C  t@P h@9h  4 2B 9h*@ h.@ {AO_O{C    h@9  4   a
D)_ 1  T{A   O{A   O  2I    5@y**>  @y*  ,@Q@"|S  @H  4_{  E  !2@@ ? Ay**$   Ay*  ,@	P)     :y@y**z @y* ,@Q@"|SO  Ay**m  Ay* ,@	P)C og_WO{C    0**o@9	 q  T q  TH 5   `	               ]@9 4         * {<'r= qL7[xx 5
Z }S_ qM T_ q  T_q@ T_#qa T  !    !_ q T_G qA T  !    !,    !     @  '  *#@9 kT{EODWC_BgAo_g_WO{ h@9	 q  T q  TH 5   @          lh@9 4        *w <9'r= q!Zvxh@9 kT{DOCWB_Ag_WO{  v@**O h
@@	 q  T q T 507  q T q Tq  T!q T  BD  07  q T q  Tq  T!qa T  B?  U07  q T q  Tq@ T!q
 T  B:   q TE q	 T  B#   q TE q	 T  B$   q  TE q! T  B%    B,    B    B,    B    B,    B    B`@
 5   9 9    B`@
 -   92    B`@
 %   9 2 9h@9  5{BOAW_ E  !2@@ ? E@@   E> @@  5  !<2 ?  !P2 ?_WO{ ^  R Z w   8  NE z6x   > T7 Y*{COBWA__ E  !` 2@@ ? E  !2@@ ?og_WO{C    0**
@9	 q  T q  TH 5   `	               >A9  4   @9 4     * r=     q<)%!7[xx* 5
Z }S_ qM T_ q  T_q@ T_#qa T  !    !_ q T_G qA T  !    !,    !  |   @    *hk|8 4@R 7[xx 5
Z }S_ qM T_ q  T_q@ T_#qa T  !    !_ q T_G qA T  !    !,    !  N   @    *@9 kT{EODWC_BgAo_og_WO{C h>A9  4   qh@9	 q  T q  TH 5   @          lbh@9 4        *w x9<Z'r= qAQZvx*Mk{8  4@RM ZvxEh@9 kT{EODWC_BgAo_WO{  @**M 
@@	 q  T q T 5v07  q T q Tq  T!q T  BD  07  q T q  Tq  T!qA T  B>  6
07  q T q  Tq@ T!q	 T  B8   q TE q T  B#   q TE q T  B#   q TE q T  B#    B,    B    B,    B    B,    B    B@,   9    B@%  2    B@   2h 9@9h  4 2h 9{BOAW_ E@@   E> @@  5  !<2 ?  !P2 ?g_WO{ U	 * 2r R  v   8  AR    ?; q T 8  C wF9*. x h 9C 9 hF9  y@y! k T9   ?? qTy 9 {DOCWB_Ag E  !2@@ ? E  !@2@@ ? E  !` 2@@ ?   E     ?.O{C 3      !<A{AOJ O{C 3      !54{AOJ O{C  L h
@@  5`@AR @  {AO_ E  !2@@ ?   dE    @ (D@    )<JUr  " A O{C hA9t  6      PhF@ 6aN@   hF@ 7{AO_aJ@{A   OO{C  @L 
@@	 q T q T( 5@9  4h&@2h&  ;`"   h&@2  h&@2h& {AO_   2E     O{C _  q3   !  2*   !`2*   !2*   !2* {A  ! 2*O O{C 3   !x 2 2   !2 2   !2 2   !2 2 {A  !82 2O WO{ C  E @ u@L h
@@ q T) )(y	 `@ ` @ /  `@ @ C  h@9  4@92 9@92  h@9  4@92 9@92  h@9  4@92 9@92 94  `@* {2A    7c@    !Bx 2E h@9  4@9 2 9@9 2 9@   `@* {2A    7c@    !B 2E h@9  4@92 9@92 9@ @   {BOAW_5@H  4_{  E  !h2@@ ?    O{C _  q3   !  2*{   !`2*u   !2*o {A  !2*Og O{C 3   !x 2 2]   !2 2W   !2 2Q {A  !2 2OI WO{ C  E @ u@MK h
@@ q
 T) )a(y	 `@\` @ '  `@Z @ ;  h@9  4@92 9@92  h@9  4@92 9@92 94  `@* {2>A    7c@    !Bx 2D h@9  4@9 2 9@9 2 9@   `@* {2$A    7c@    !B 2D h@9  4@92 9@92 9@ @   {BOAW_y    &O{C _  q3   !l!2*   !  2* {A  !`2*O O{C 3   !!2 2    !x 2 2  {A  !2 2O  WO{ C  E @ u@J h
@@	 q@ T q  Th 5`@ @# ))  h@9  4F@92F 9B@92B 9,  `@  @# )  `@  c   h@9  4F@92F 9B@92B 9@
 @   `@  cx    h@9  4F@9 2F 9B@9 2B 9@ @ @   {BOAW_WO{  hB@y**	
) 	 4"H
  4      (h@9
	 ( Q q T) )(y	    7`@^`   @ a@!  ?A q! TbB {BOA   `2W{BOAW_  7`@K  @a {BOA   (Wva
@  a@  a@{BOA   (WkWO{  hB@y**	
)  4"H
  4   Z   (Vh@9
  Q q T) )1(y	    7`@`   @ a@  {BOAW_  7`@  @a {BOA   (W1a
@  a@  a@{BOA   (W&WO{  h"@y**	
)  4"H
  4      (hB@9
 	 q` T q Ta
@)? k T   7*`   @! a@  {BOAW_a
A)? k T H 7*  @ {BOA   (W{BOA   !Wa
@{BOA   (W_WO{ C  E@* {2  ?     7  ! 2/C @ @	@9? q`  T? q T  * {2w?     7  ! 2C @@9  4  ! 2C @   {COBWA__  A     wO{C    p"hA96hA9    )<Jr  A "hA9 6hA9    )<J r  b A "shA9 6hA9    )<Jr  A D#ghA96hA9    )<Jr  Ab #ZhA9 7{AO_hA9{A    )<Jr  A #OIO{C hA96hA9    )<Jr  A "9hA9 6hA9    )<J r  b A ",hA9 6hA9    )<Jr  A D# hA96hA9    )<Jr  Ab #hA9 7{AO_hA9{A    )<Jr  A #OO{C  @H 
@@ q T) )(y	 @bB E? @9  4hA9 2h9hA9 2&  @a b 9? @9  4hA92h9hA92  hA92h9@9 4hA92h9  hA92h9@9 4hA92h9	  @9  4hA92h9hA92h9{AO_@H  4_{  E  !D$2@@ ?  ` @ O{C        @  s&    !D&Bd&    !|&B&    !&B&{A@ROO{C h&@    )<J< q  A P'a"@ 4 2? q@ T2? q  T{A   'Or2}	 )A!ih{A   p=OgO{C h&@    )<J q  A 'Ya"@ 4 2? q@ T2? q  T{A   'OL2}	 )A!ih{A   p=OAWO{  u@G t@  !D&  4  !|& 2` 4  !&2 4  !' 2 4  !$'2  4  !<' R` 4 E  !'2@@ ? 2JA)	!@9 h@9h  4 2 {BOAW_  @#2@    g_WO{   H(*    < By 4    *(	R<= 	 q  T* q*U2 By kT{DOCWB_Ag__WO{ t    5 hBy 4    *	R5+*Q*2 hBy k  ThBykCT{COBWA__WO{  t@	RfBy>G h
@@% q( T	 )(y	 s@  !` 4  ! 52  s@  !0  4  !0 5*  bBy2  	RR	D8(7)2	R	 9 R
	-A9j@9R)
)
*	-9i*@	E   	RR	D8 7)2	R	 9 R
	-A9j@9R)
)
*	-9i*@	A {  	RR	D8i7j@9	RRj!9J Q_ q T 2j!k J )2	R	 9 R
	-A9j@9kR)
)	
*	-9^  	RR	D87)2	R	 9 R
	-A9j@9R  )
)
*	-9s@!*% 4  !*  5 2?  	RR	D8I 7) 2	R	 9 R
	-A9j@9))
*	-9`< R =`< =-  	RR	D87)2	R	 9 R
	-A9j@9R)
)
*	-9`< 	=`< =  fBy fy q T E  !`/2@@ ? 2  2bBy(*by  *	RR	(%9{BOAW_ E  !0+2@@ ? E  !+2@@ ? E  !-2@@ ? E  ! .2@@ ? E  !.2@@ ? E  !H,2@@ ? E  !,2@@ ? E  !0@@   E  !0@@   E  !<1@@2 ?{ 
@I1A(  47(}S h= Key 4)J-K_8  4l   4k K 4K_8  4 q  TK@9 6  K@9k6B J1_ T  7(}Sh 5{_ E  !32@@ ? E  !<62@@ ? E  !12@@ ? E  !22@@ ? E  !L32@@ ?g_WO{   H(* $   <G  By 4    *(	R<= 	 q  T* q*UCRT  By kT{DOCWB_Ag__WO{ t    5  hBy 4    *	R5+*Q*CR1  hBy k  ThBykCT{COBWA__O{C D9   7   (     (D9 7   )     (D9 7{AO_{A   P)O_WO{ @y** 	}S(6 (6   F@   x)@y	}S 6  6   B@   )@y	}S6 6   "A9   p* ( 7*   @   p=     *}@y6 X6   w&A9   *r q  T  5   *     *      +f@y6 H6   `  ) q  T@   @   q?   ?     )M@y  7{COBWA__ @6   B ) q  T@  B @   S?  B ? {COBWA    $*_+   )w=    @(	!@   <8!O{C h@9  6   Ta@{A   8OO{C  t@D h@9  4@ 2 h@ {AO_  +N=    @)O{C h@9  6   h@9t  7    9     8@9  4   9a@   09h@9 7   p9     L9h@9 7{AO_{A   9OO{C h@9  6   h@9 6   9h@9 6   9h@9t  6   0:@9  4   `:a@{A   :OO{C  t@ID h
@@ q T	 )(y	 h@9 4>@9 2	  >@92  >@92  >@92> 9{AO_  .<     .gWO{ C  E *$ q@ h T	 )(y @	  5h @ 7 2h   E  2@u  B 5h @72h   E  2@i@y2   5h @H72h  @y 2 yEazh ( @9 q` T q  T0   5h @72h  @y 2 yE`zh@  @9 q T q T*  9    6@J ;   5h @H 72h  @y 2 yEazh	 ( @9 q`	 T q 	 T2 6 E  !@>@2@bzi ? 5h @h(72h  @y 2 yE`zh  @9 q T q@ T*  9    6@R @     5h @072h  @y2  h @8722
  h @@72 2  h @hH72 2h   y  4@y 2 y@   2 {BOAW_ E  !X2@@ ? E  !(;2@@ ? E  !<2@@ ? E  !>2@@ ? E  !;2@@ ? E  !T<2@@ ? E  !=2@@ ? E  !h?2@@ ? E  ! 2@@ ? E  !P2@@ ? E  ! 2@@ ? E  !2@@ ? E  ! @2@bzi ?WO{    p*u N   p=Jh@y 6   Eh@yh	 6   @h"@6`  4   (9   eB  cd b   a  T]B  a* T   D  ]B    a   YB    ah@y6aN@  4   (   eB  cd b   a  T]B  a* T   D  ]B    a   YB    a  !<U h@y(6   h@y 6aJ@   (h@yH6  !<D aR@   (h@y6  !<:   a  (hA9 6   hA96aN@  4   (   eB  cd b   a  T]B  a* T   D  ]B    a   YB    ahA9 (6   hA9 7{BOAW_aR@{BOA   (WO{C h@yt  6   h@yh7   lh"@( 6cN@  `*! h@y(7{AO_   h"@( 6cN@  `*!  h@y(6bJ@cR@  ! 2  {A  a  0OibJ@cR@{A  ! 2O  @  	A@yi 7)2	A y_{  E  !
2@@ ?#mWO{ C  E  @ @N T@9 4    . 4    
 4   
 4   , 
 4   D	 4   X`	 4   p 	 4    4   @ 4    4    4     4    4   ` 4     4   0 4   D|@ 4   \w 4  -   h* 	`'  B            B        B      
  B        B@h* 	` a yh @   {COBWA#l_O{C  "@h  7}S     F@y q  T	 q  T q T   h          {AO 2q_WO{  @9***7  !<   <*     n  4   (*i   eBcd b   a  T]B  a* T   D  ]B    a   YB    aO  !<    G@9IR	
H 4 4*{COBWA   (_:{COBWA__ eB`cd b   a  T]B  a* T   D  ]B    a   YB    a{COBWA_  1 29     6O{C    ` !|R 2.x{AO_*c  *  O{C  t@@ h
@@) qH T	 )(y	 "@92	  "@9 2  "@92  "@92" 9h@9 4 2& 9  "@92  "@92" 9  J9   2J9{AO_`@9 H  4_{  E  !2@@ ?O{C    ` !|R 2 tBxt{AO_2  2_  AR  ARW  O{C  h@9*  4      h@9 6   h@9  6   h@9 6   h@9 6   {a"@  4   0vh@9 (6   dqa&@  4   |lh@9  6   g  a  chC9  5   ^hC9 q  T   DX* q  T
 q T`m:   `; {A    tOI{AO_O{C  h@9*  4   <h@9 6   7h@9  6   2h@9 6   -h@9 6   (a"@  4   0#h@9 (6   ha&@  4   h@9  6     a  * q  T
 qA T`%:   `Y;     hC9  5   <hC9 q  T{A   hO{AO_  @:?8    @O{C    {A  ` !<O#      !5  O{C  t@|? h
@@ qH T	 )A(y	 @9 2	  @92  @92  @92 9{AO_O{C  @9 6     B@96     B,@96     BT@9 7{AO_{A     BO   =7    r 29999_og_WO{C  @* q5   T q T qa. Th@9h2 7(?A!  2(? E @   4(CA 2(Ch@ 2h a h@9(17(?A2(? E @   4(CA2(Ch@2h O h@9/7 JEH(xhH, @9 q+ T q+ T(?A 2(?H)E6xh7@  !< 4  !L 4  !\  , 52     2    27 *2(+j4 *2c  !L 4  !
 4  !$  [ 6 2 2AR  |   8        4   X 2 2 4   22 4   { 2 2 4   t22 4   m R R  4   (f22 
 4   d_ 2 2@	 4   X22` 4   Q:R8R 4   JZRXR 4   CzRxR 4   0<22 4   T5RR  4   t.22  4   ' 2 2@ 4    22` 4   :R8R  4  * 2)'	@	}EJ)*	@@"
*(	 |	    2)'	@kx82 * z` kx8	 K	K*,(; q TK@9k T) J ?KT q  T2:i(8(;)*	@9"J**	 9  4);)		*5D9H*(59(;A (;  (	Z 9
9D9"J	*
99  4
5D9I	*	59   #T  !$, 	    2   *2a@?@  4(CA2(C E(@ ( @(@2(  2C{EODWC_BgAo_ E  !2@*@ ? E  !42@@ ? E  !D2@@ ? E  !2@@ ? E  !(2@@ ? E  !2@@ ? E  !p2@@ ? E  !<2@@ ?O{C    *>AH 6&@BA   0"|S *  >AH6"@BA   @"|S*  >A 7{AO_E9  6   {A*O  O{C hD9H 6hE9  6   h&@= }S? k  T   8z     vhD9t H6hE9 6   n@= }S? k  T   f     hbhD9 7{AO_hE9 6   X   U{A*O  WO{ bAR  b   8h@9*  4  !T3  y@9 4  !M3 @y y! kI T E  !2@@ ?  !=3  y y  ? 2 y{BOAWG_WO{     *** )<J<  q> Vw 5i> ? 2?
k  T  5{COBWA__   ("3k T   P5 5
Z   }S!`   @! > /     ` 4  >  @R"  
Z   }S!   @     p=    >  @Rh
Z   }S!@  @ {COBWA   p=_a> {COBWA   _og_WO{CC  h
AxA  q  T	 q  T q T   t          *      !z*iJ()	@  5  qiT     *iJ()	@? 1 T  qIT   C{EODWC_BgAoz   * 2Zs=~@)C)~i	)	@ *#)

 4h  4R  2i@  4   *_  2^2jv  T@Ub T q+ T2^A h	1D9? T5D99D9t  4@RFh (#	
  4@
 iv8H  5:h {   LT kaT    2Zs=   2 ATC{EODWC_BgAo_    24    !og_WO{CC  9E*9@ q  @` T q
 T E   2@ 21&@ 5u  42&  ZEHzh
 @9 q`
 T q 
 T E @L B T Hzh          &** j 2 ` 4 2` 5h~kh)2k(  h~kh) 2k(@{  L  T H@ 2 H i @(H  2C{EODWC_BgAo_ E  !l2@@ ? E  !!2@@ ? E  !x 2@@ ? E  !2@ 2@ ? E  !h2@2@ ?@  4_{  E  !!2@@ ?  !  d"   !  " _WO{  @* q` T q T E   2@ 2F@y	 I 5  4}S 2 9 Ezh( @9 q T q T E @  T 2zh @ 2  i {COBWA 2__ E  !!2@@ ? E  !x 2@@ ? E  !2@ 2@ ?  !  d"H   !  "D    @$_WO{  @* q T q@ T qa T E   2@ 2F@y	  5  4}S 2 9 Ezh @9 q@ T q  T E @6  T zh @ 2  i   @92 9{COBWA 2__ E  !!2@@ ? E  !x 2@@ ? E  !2@ 2@ ?O{C   a  d" h9 7{AO_{A   "OO{C   a  " h9 7{AO_{A   "Ow   @'X_WO{ C  E*@ Q% q  @h T	 )(y	 @9 5 52:  q T 4J@2J p   5J@2J k  U 4J@2J f  @9 5 q 2
  @9H 5u 5 2  @9 5 52 9 E @ /   
 6@ H  @9H 5 q 2  @9 5 5 2 9 E @ /    6@" /   E   2@ 2AF@y	 	
 5  4}S 2 9 Ezh @9 q T q@ T E @Z B T zh  @ 2  i @  2 {COBWA__ E  !(2@@ ? E  !!2@@ ? E  !l%2@@ ? E  !#2@@ ? E  !x 2@@ ? E  !2@ 2@ ? E  !<$2@@ ? E  !p'2@@ ? E  !&2@@ ? E  !0&2@@ ? E  !$2@@ ?      !d"B<       !"B5  WO{   E # @ a@yXh@    )<Jr  A -# Wh@( 4    ** r     8=!L=Jh
@ 4 r     8=!$Ah@h 4 r     8=!$8h@H 4 r     8=!$/h@( 4 r     8=!$&h@ 4 r     8=!$@   {BOAW_Hg_WO{C  9E9@     
@9 q T      &* 2*  
 9 2   4 2 5
@9  @y	@I#)!H* 9@_   
 _ qT 5@(( {DOCWB_Ag_ E  !l2@@ ? E  !h2@2@ ?og_WO{C  E # @ a@yh@9    )<J r  A -# h@y	 i 4          *}S&O= 2Z*{*:= q )#	
 rbi@y(}S)kT@( C{EODWC_BgAo_O{C  *@ 86   (h*@ 6   (b*@  6   D)\  " !P<  {A  b ! O  	 @9) Q? qH T
 J!Iy)
 @   )  _@   )  @   *  @   T*3  20     -O{C    $,%h@9  7{AO_{A   D,O(@9H  7_   D,O{C  t@7 h
@@  5@9 2 9{AO_   @.O{C    $,h@9  6   D,h@9 7{AO_{A   ,OO{C h@9  6   D,h@9 7{AO_{A   ,OO{C  t@z7 h
@@ q  T  5@9 2  @92 9{AO_   0O{C    $,h@9  6   D,h@9 6   ,h@9 7{AO_{A   -OO{C h@9  6   D,h@9 6   ,h@9 7{AO_{A   -OO{C  t@07 h
@@	 q  T q  TH 5@9 2  @92  @92 9{AO_   D0    5U   /    6OO{C    -3 d{Aa  !<Oi      !5e  O{C  t@h@9  4@y 2 y6 h
@@	 q@ T q Th 5s@  !</J 4  !X/E` 5 2 y  @ Q 	    `@iB a    y{AO_ E  !h/2@@ ?{ @
@y	@_ q T 5
`@97 E  !/2@@ ?
`@9J 4
	@)
k  T	 {_ E  !h12@@ ? E  !|02@@ ?O{C  @*= (`_ q T* 5@  @mB{Aj    J<k?rc  b ` .Oj    J<k?p  b  .
@b  5h@9  4{A   /O{AO_  2}/    :? 2D y__WO{ hB9u~@9vB9w 	  q jx8  4 cT_8qq  *h  i  <)< q  ! |2vB9 6   3 4t @9pq`  T q  TR@9 Q 5@R     T3y6 4  w f3@8r Q5   x3m  a  2ih"@=   4   2caF@y  }S  4   3\u  4hB9 7{COBWA__{COBWA   83_M_WO{ hB9u~@9vB9w 	  q jx8 4 cT_8i    )<J qAqq T   3+tB9   3' 4v @9pq`  T q  TR"@9  Q 5@R  h    <) q!   3vB9   T3	6 4  w f3@8 Q5   x3  a   4h"@=   4   ,4aF@y  }S  4   X4u  4hB9 7{COBWA__{COBWA   |4_og_WO{C  sE s@ *@@@}@9q5 
@@ q` T q T qA T@ ' T S 22 S9@9H 4 5v  @   4   q T***|8>  5qqa T@ k Tjh8	* (Q 9@  q  Tqqa Tr  > h  4*
  @  )	@8 ? qT 2 k* T> h 4@ kj T@	 k T@jy8U` 4js8R 4jy8  W C W 9js8!88_ 9[ 9w 4@	(Q 9jw8  q<  |8*	 (Q 9_ T{ kZ *T   4WB92  *S9@ @9sE@s@  4  4WB9 2   2W9@hH	 C{EODWC_BgAo_ E  !52@@ ? E  !62@@ ? E  !62@@ ? E  !472@@ ? E  !72@@ ? Ejy8@@   Ejs8@@  !72 ? Ejy8  !D8@2@ ?! E  !p52@@ ? E  !4 2@@ ?`@9H  4_{  E  !82@@ ?  "-    @ ? 2L yD y__WO{ C  E* Q@ q  T  )a(y @	 h@9( 7 E  @   4@9 2 9h@ 2Q  h@9h7 E  2@ 2Z*    6@ 9  4@92 9h@2;  h@97 E  @   4@92 9h@2-  h@97   :  9   :  9 4@92 9  h@97 E5xhu @9 q  T q T E @  9  9  4@92 9@  h@2h @  2 {COBWA__z E  !;2@@ ? E  !:2@@ ? E  !2@@ ? E  !;2@@ ?h E  !<2@@ ?h E  !(2@@ ?g_WO{    =*
h@9bF@yaB@y    0* h@9bN@yaJ@y   @* h@9iR@y
	*J  4" i  j  )<J< r  A =u@9  5}SvV@y~S	*	 4i  j  )<J< r  A H=  4    p=*<  5 4w t  *1r=* R)X	@	*) 

j4h  4R(|jh8
 25     
R 4 4u t  *1r=* R)W	@	*) 
j4h  4R|jh7
 25     
h@9! 4{DOCWB_A   g{DOCWB_Ag__WO{ aB@y  5hFy 1  Th@9  6`   vaB@ybF@y? k  T   8o     kaJ@y  5hNy 1  Th@9 6`   aaJ@ybN@y? k  T   Z     hVi@9hR@y*

*J  4 6`   Lh@9    =GB8  }St i@9*
* 4 6`   :   =7@9) 4u t  *1r=*6 R*7	@
*J 
i4h  4R)|jh!7
 25     
2i@9 4t s  *1sr=*5 R*6	@
*J 
i4h  4R
|jh6
 25{COBWA__{COBWA   
_WO{ AR     8h@9*  4  !(  y@9 4  !( @y y! kI Th E  !2@@ ?  !(  y y  ? 2 y{BOAWog_WO{C  !$  *v   |           b<1&:9s<Z<{<6  42 2 4-2 4( 2@ 4#2 4   < R 4   L2  4   
 2`  4  	@*{ *{EODWC_BgAo_h E  !<2@@ ?_WO{ i  j  *** )<J<  q> Vw 5i> ? 2?
k  T  5{COBWA__   (;"3k T   P55 5
Z   }S!`   @! > /     `& 4  >  !@R#"  
Z   }S!   @  `   p=    >  @Rh
Z   }S!@  @ {COBWA`   p=_a> {COBWA   _  %A*     O{C h@9i  j  )<J< q  A >aB@ybF@y? k  T{A   O{A    OO{C h@9i  j  )<J q  A >aB@ybF@y? k  T{A   O{A    OO{C  t@W1 hR@y y yh@9	 qa  ThV@y yh@9h  4 2 9{AO_  `()     	   ={20 2 9 =__WO{ C t E   4?@ h*@  5i.@* R/r?
k TR*5r*}2W4RJexrCH})}e  !k L?nh.@   ?	})e
}#(}eAkbh@9q  T   ?\`@9 h2@	 1  T   ?T`2@ 2; h"@( 4   ?Lh"@ h 4 /$B)A)@)  !  ?h&@{ 2	k  T   8 8h&@ h 4 $B)A)@)  !  +h@9	   7   h %h@9 6   |  @   {COBWA__Jg_WO{C v E@ h*@  5i.@* R/r?
k TR*4r*}2W4RJexrCH})}e  !k `h.@   	})e
}#(}eAkh2@	 1@ T   <w2@2  * 2 2	#)
) 4 h  4R**  qaTh@9q  T   p`@9W h"@  4 $B)A)@)    "  \!h&@  4 $B)A)@)    "  \!h@9  6   h@9 6   ,@ {DOCWB_Ag_og_WO{C { {E {@ u@&0 h
@@% q T  )A(y	 `@*    `@ 2    `@= 
   `@9    V@92V 9  t@* 4 x    s= 2>
@9H 4R n w K*S  2 24 	  *S  2 2+S # **@@9 q  T q  T  | q Th 5H#* h@9H 4({R   t@*  @9 4R 9    K*S 22<
 
  d  *S 22p=S # *@@9 4  S 2!  * q  S 2! * * q  S 2! * * q  S 2! :* *? q  S 2! [* *_ q  S 2!|* * q  S 2!*  q* 4w 4X 49 4 4  4  4-   4 2!*tR 9{ h@9{E{@ 4RR 9  h E   dR@ 2V@9 2V 9@h C{EODWC_BgAo_h E  !	@@  h E  !
@@2S  ?h E  !P
2@@ ?`@9  6@	!A)?kC  T_{ h E  !t2@@ ?O{C  *2js 7*  `     p=! ^ 2s6  4      `   p=  ! S s6  4      `   p=  ! H s 6  4      `   p=  ! = s(6  4      `   p=  ! 2 s06  4      `   p=  !'  87{AO_  4      `   p={A  !Oog_WO{C *2*  R    * 2rVR:9S 2i#)
 4 h  4R* 6*}c q T	 q  T qa T   ,	  *       D  Z _ q*T{EODWC_BgAo_g_WO{Cy 9E# BR 9@' @ 	@9? q  TiQ?q  TO  jQ_q	 Ti	 5i
 4  # BR@ 	@9? q  T2 q  T>  2 q Ti 5)	 4  # BR@ 	@9?Qq  T~ q  T.  ~ q Ti 5 4  # BR@ 	@9? q  T^ q  T  ^ q Ti 5 4  # BRs@ 	@9? q  T q  T   q Ti 5I 4  # BRc q  T@@9H 4h E  !D2@@ ?*** 2 2  *** 2  ***  *hQ Q#)[)c)     ! 23 =@C B`'@(h {DOCWB_Ag_   8h E  ! 2@@ ?cWO{ C v E BR @  ^ q T@	@9? q T  BR@ 	@9? q  T q  T   q T 5 4  BR q  T@@9h 4h E  !X2@@ ?*@R~	) 2"	   {BOAW_  @+2& O{C      s  c22  cX22  c22  c22  **c4{A@ROO{C    *@9h  4 R@9 5?@ q  T  B  ?  q  T  BX  ? q  T  B  ? q  T  B	    4{A   O  B4{A  a   !<OO{C h@9  4`   a@9{A   OzO{C  t@- h@9qA Th@9 9h@9h  4 2 9{AO_h E  !,2@@ ?O{C    P*X@9h  4 RX@9@93 5_ q T?@ q  T  B  ?  q  T  BX  ? q  T  B  ? q  T  B
    4 2{A   |O4  B4{A  a   !<O+O{C h@9  4`   "a@9b@9{A   OO{C  t@, h@9 9h@9 9h@9h  4 2
 9{AO_   1V%    @O{C     v_9  4`   {AOM O{C (t_93   4`      x{AO= og_WO{C t E @ u@|@ x, h@9 29  *Rs
 q	 **`@9  `@8@5h@9 4 5 q T s `@9 2 q@ T  4 q Ts *# S  k"  6@@ T@N:* `@85h@9 q Tt *# S  U"   6@ T@  @Z _/ q(] CT    q T q@ T q Th@8 q T 2	 9   q@ TqA T 2	 9
   9  h@8 q T2	 9s *# S  !" ` 6@  T@*}9 ?/ j*Tf  	@8? q T 499/ qTi )E@  !)@
K2)@ ?{ 4Z 4999/ q T@ C{EODWC_BgAo_h E@  !|@b	K2@ ?h E@@@b	K"  h E  !2@@ ?h E  !\2@@ ?h E@  !@b	K2@ ?5h E@@	K@  !2 ?h E@  !`@b	K2@ ?i )E@  !)@
K2)@ ?h E@  !@b	K2@ ?h E@  !p@b	K2@ ?h E@  !@b	K2@ ?h E@  !@b	K2@ ?i )E@  !)@
K2)@ ?i )E@  !8)@
K2)@ ?og_WO{C    3h^9(
 4          *RZ:FR*  4   ,|O@K8	 q T 2iO)M()@9*? q TH{ R  t  q  2rhO	}iii@9 	kTRg|OK8h 4*x  4R`hOM8	K)? k  TU  R@9 kTi^9h 	kT{EODWC_BgA@RoF  3#    @ O{C    *4@9F@yB@y    0*`  @9N@yJ@y   @*X  @9  4{A   O{AO_O{C aB@y  5hFy 1  Th@9  6`   aB@ybF@y? k  T   8      aJ@y  5hNy 1 Th@9 6`   aJ@ybN@y? k  T{A   O{A   hO{AO_O{C  t@* h
@@ q  Th 5h@9( 4"@9 2  h@9  4"@92" 9{AO__WO{ i  j  *** )<J<  q> Vw 5i> ? 2?
k  T  5{COBWA__   ("3k T   P5 5
Z   }S!^`   @! > /     ` 4  >  @R"  
Z   }S!H   @  `   p=    >  @Rh
Z   }S!6@  @ {COBWA`   p=_pa> {COBWA   _h{     D 	  (    #  	 	 	 ! \   {]   6#     /O{C     C. "@ 6   <h@ 7{AO_{A   O2O{C    0 * "@ 6   |#h@ 7{AO_{A   Og_WO{ h.@Ayy@ 2 q T 2J)!
 )
  q@  T*) h
@@	 q T 5h@9h6t E@h  5( @I Rir	kJ T`@  aR    R `  8AR   *K  (@2( {DOCWB_Ag_AR     AR   *2   4(@ 2( k * Q? 2	k TAR  R    Y Q? 2	kb T kK T
Z	Z}S)}S(K y)O y  
Z}S(O y(K y Th
 @ T 2 9(@R  2(    
?jU   9P%    = C<   I%    =  (  = C<{DOCWB_Agh E  !2@@ ?h E  !	2@@ ?h E  !2@@ ?h E  !2@@ ?h E  !2@@ ?h E  !@@  h E  !2@@ ?h E  !2@@ ?h E  !@@2 ?@  q  T@	@)2	 _WO{  h@ 6h 6`Ru Y$  `   p=tR 2  4M$     h@ 6Rh@6@RhJ@y   	Z}ShN@yiJ@y	k  T{BOAW_{BOA	Z  }S W  9!    @ O{C ` $ bA9    ` $ bA9{A    OO{C t   ! 2E`  5hA9 4$ bA9    Lt   ! 25`  5hA9H 4# bA9{A    O{AO_O{C  t@6( h
@@	 q  T qA T`<=h"A9 9  `<=h"A9 9{AO_  <K!    !\O{C      qh@9	 q  T q  TH 5   4      P       ba@9{A   (O\O{C h@9	 q  T q  TH 5               !Ia@9{A   (OCO{C  t@' h
@@	 q  T q  T  5 9  2   2 9{AO_`@9	 H  4_{ h E  !0!2@@ ?  ?      $2 9_O{C    "*  4a@9b@9   $"A  a@9? qa  T   2? q@ T2? q T 2 42? q@ T R? q  T2? q  T2? qa TI |)A!ih   p"h@9  6   "h@9 6   #h@9 6   L#h@9 6   |#h@9 (6   #h@9	R	
  4   #h.B8  4{A   #O{AO_   "O{C .B8  4   %+% a@9? q  T   @%h@9  6   %h@9 6   %h@9 6   &h@9 6   d&h@9 (7{AO_{A   &OO{C  t@(' h
@@ Q qH T  )a(y	 `@AR   h Ea  !52@@ ?@92  @92	  @92  @9 2  @92 9{AO_  &     )7O{C h@9h6   l(Jh@y   	Z}SDh@yi@y	k  T	Z  }S ;h@9 7{AO_{A   O1O{C h@96h@y   (	Z}S%h@yi@y	k  T	Z  }S h@9 7{AO_{A   |OWO{  t E  2@ h.@Ayu@ q T 2J)!
 )
  q@  T*& h
@@ q  T 5 4@s@*C 23 ? 2     7    !@(B( 2J  @(@9 q T 5@y	Z}SN yJ y  @2     *# ? 2   6'A)	k T    !@(B( 2*  @  {BOAW_)	Z	Z)}S}SJ yN yh E  !2@@ ?  r      P)!9O{C  t E @ `B<=!  @   p=`B<aB<  !n X n="  * 7`   -*   !  `   -x@  C {AO_O{C       *!9f{A*OO{C  t@ & @ 2 h*@i:@(
 i:@)* h.@i>@(

 i>@)* h2@iB@(
 iB@)* h6@iF@(
 iF@)*" {AO_      +O{C h@96   *)h@y   	Z}S#h@yi@y	k  T	Z  }S h@9 7{AO_{A   OO{C h@96    +h@y   	Z}Sh@yi@y	k  T	Z  }S h@9 7{AO_{A   |OWO{  u E  2@ i"EAy6@ q T 2J)!
 )
  q@  T*x% h
@@ q@ TH
 5T 4H  <t@ "@*C 3 2? 2"     7   1 T    !*B( 2 @(@9 q` T 5@y	Z}S y y%  h@9 6$    *# ? 2_ `  6@  @     1  T@ k" T    !*B( 2   	Z	Z}S)}S y yh@9 6"@2" @   {BOAW_h E  !2@@ ?  8 WO{    @-E   /B  sR+    !+B,,V  +  !,P    !l,B,J  !,F    !-B.@  !-<    !.B/6  !.2  v/  B/+({BOA@RW'2  _) @ 4 2? q T2? q  T 2? q  T? q2  I {)!ih   /	) @ 4 2? q T2? q  T 2? q  T? q2  I {)!ih   0WO{  v@$ t@ O    +
 4   ,{	 4t@ >    l,p 2` 4   ,i 2 4t@ +    -]2  4   -V2  4t@     .J 2 4   .C 2 4t@     t/82` 4h Eb@  !`0@2@ ?I )(@ {BOAW_  P    @0aO{C    0 u`"@ 6   |nh@ 7{AO_{A   Odg_WO{ h.@Ayy@ 2 q T 2J)!
 )
  q@  T*# h
@@	 q T 5h@9h6t E@h  5" @I Rir	kJ T`@P  aR N   R H`  8AR C  *K  (@2( {DOCWB_Ag_AR 1    AR +  *2   4(@ 2(  * Q? 2	k TAR  R     Q? 2	kb T kK T
Z	Z}S)}S(K y)O y  
Z}S(O y(K y Th
 @ T 2 9(@R  2(    
?jU   9    = C<       =  (  = C<{DOCWB_AgH E  !2@@ ?H Ea  !	2@@ ?H E  !2@@ ?H E  !,12@@ ?H E  !2@@ ?H E  !@@  H E  !2@@ ?H E  !2@@ ?H E  !@@2 ?  5    @2FO{C t   !2`  5hA9 4 bA9    LNt   !2`  5hA9H 4 bA9{A    O<{AO_      3WO{    2+cD)h@9T  U  << r 1  T * 4 k  T  a   T2!X$    a   t2!X$h@9c*@	*	 4 q  a   T2!hZ@y	   4   ,2h@9  }S  4{BOA`   W{BOAW_O{C h"@  5h&@ 1 Th@9I  J  )<J r  A 2a
D)? k  T`     `    h@9b*@b  5	 I 4I  J  )<J r  A 2h@9  4{A   3O{AO_O{C  t@Z" h
@@	 q T q  T 5h@9 qa  T@ h@9 46@9 26 9	   22 9  h@9  46@926 9{AO_      x32g_WO{   t6hJ@y 6b"@I  J  )<J<r  A 6zh@9 6   6uvA922u 4t     Qy 'R6(@y}Se!@9?q`  T` @a Q 9 65h@9! 4{DOCWB_A`   gN{DOCWB_Ag_g_WO{hJ@y 6b"@I  J  )<Jr  A 65h@9 6   $70uA9220 4x s     Qs'R6@y}S @9?q`  T   Q  55{DOCWB_Ag_og_WO{C y@! h
@@ q  T 5(@9 2<  `@ 
 t  u  ; R 	 v   8  AR     _?   T 8  B  \Sh{:xX  4:  h{zx	 	*   2h{:xZ _? h  T (@9: 92( 9{EODWC_BgAo_H Ea  !2@@ ?H E  !T72@@ ?H Ea  !` 2@@ ?H E  !72@@ ?_WO{ C V E* @  z@  T   Tw @ q Th@9h  4@9h 5@ * {COBWA__H E  !$8@@  H E  !L9@@  H E  !8@@2 ?     `    64 $ __WO{    (:DtVD)h@9W  X  << r 1  T * 4@     p=!D:2k  T   :*+     :**$hZ@y(6b*@2?!Hj   6hZ@y	}S 6   ,2hZ@y	}S 6   P:hZ@y	}S  6   l:	hZ@y	}S (6   :i@9! 4{COBWA`   _{COBWA__O{C h"@  5h&@ 1 Th@9I  J  )<J r  A :a
D)? k  T`     `    hZ@y6b*@I  J  )<Jr  A ;h@9 6   P;h@9 6   |;h@9  6   ;h@9 (7{AO_{A   ;OO{C  t@R  h
@@ q T  )(y	 h@9 qa  T@ h@9  46@9 26 92@9 2  h@9  46@926 92@92  2@92	  2@92  2@92  2@922 9{AO_  @     <2xog_WO{C   ?mh@9h 6     hh@9I  J  )<J< r  A P^a"@`   Zh@9 6   6UvA96 t    x R2'6 @Lk{x}SCk{8?q`  T> k!Th@9A 4{EODWC_BgA`   o/{EODWC_BgAo_g_WO{hJ@y 6b"@I  J  )<Jr  A   h@9 6   ` uA95 w s    R2s'6  jzx}Sjz8?q`  T k!T{DOCWB_Ag_og_WO{C y@ h
@@ q@ T 5h@9  4(@9 2( 9(@9 2<  `@ 
 T  u  ; R  v   8  AR    _?   T 8  B  \Sh{:xX  4:  h{zx	 	*   2h{:xZ _? h  T (@9: 92( 9{EODWC_BgAo_H Ea  !2@@ ?H E  ! 2@@ ?H Ea  !` 2@@ ?H E  !72@@ ?_WO{ C V E* @  W@  T   TT @ q Th@9h  4@9h 5@ * {COBWA__H E  ! @@  {H E  !p@@  H E  !8@@2 ?   #    @<(@9I )A5"@9(yh   L'(@9I )5"@9(yh    O{C  t@ h
@@	 q  T q  T  5h@9   2  2 9{AO_`@9	 H  4_{ H E  !<2@@ ?   &F _WO{    @>   W 7      s** v  QR(	_8J!@9?
k T	_8
%@9?
ka T	@9)@9?k  Tc_  c_  c_ C f T{COBWA@R_ 2 9__WO{    *h@9v@9t@9u@9  5I )7+) l_8k  Tl_8k  Tl@9k TJ kA _e T_e q! T  4@      *k  T   *  t  5q@ T   4**  J|"ijK  I  k<)< q`  ! vh@9 4{COBWA`   _l{COBWA__O{C h@9  6@   ^a@9   hZa@9  5h@9q  T{A   OP{AO_O{C  @ @b 	  @9  4h@9 2h 9{AO_og_WO{CC W EX 7@ 9Rv@    5?g q T*Z {C _g #T?g q T z@ |  6 IR ! U   9*s 2   h 6CZ 9  *s 2    6CZ8h 9h 9	  S9	!@9@x 9h y  2h y Z C{EODWC_BgAo_H E*)|ki@  !2@ ?H E  !h2@@ ?H E  !2@@ ?  (      O{C    *i@9h@9)*) I 4I  J  )<J< q`  A H=a@9  4     * h@9  4{A   O{AO_O{C h@9I  J  )<J q  A z`@9  h@9  4{A   Oq{AO_og_WO{C z@
 h
@@ q@ Th 5`@uA  !$ e *   X V    \  *C *b'M`   @yn  K 4G 2` 4  !$A2 4A  !*; 2
 4  !452 
 4  !:/ R`	 4  !L)2 4a  !# 2 4a  !02  4  !`(R` 4  !tHR 4  !|hR 4  !2  4  !R` 4  !2 4  ! 2 4  !2  4  !(R`  4G  !@9 4_ q 2 T_ q2@ T_ q 2 T_ q2 T R_ q  T_ q2  T_q 2`  T%  @9* Y 9(  4h@9  4 2H 9   2H 9{EODWC_BgAo_H E  !(2@@ ?H E  !2@@ ?H E  !L2@@ ?_WO{  * ( 4  V S  *bB sr=
  {COBWA`   
_v+    F87@9
4h  4Ro   4jh8   @     q 2` T q 2  T q2 T R q@ T q2  T q 2  T q2T|jhH7
 2T5{COBWA__  + _WO{        2W      Bs*U R6!@9)!@9	k  Tju  juB  T{COBWA@R_ 2 9__WO{    *h@9t@9v@9 qa  T	*) 4I  J   q)<J<2W@   p= 5v 42 q  T2
 q T2 q` T2 q  THR q T2 q@ T2 q  T`   *	  I |)A!ih@   p=k T@R 5t 42 q  T2
 q T2 q` T2 q  THR q T2 q@ T2 q  T`   *	  I |)A!ih@   p=h@9 4{COBWA`   _{COBWA__O{C a@9  5h@9q Th@9  6@   a@9b@9? k  T{A   O{A   O{{AO_WO{  v@ `@AR     8@9*h  4$   9@9 4  @9 9 k	 TH E  !T2@@ ?   9 9   2 9uh@9  4
@9 2
 9{BOAW_og_WO{CC W E  @ Y  9C~@2v@  5_C q  T  kA  T* {C C T_C qa T*  2   ( 6@  (S: !@9@( C{EODWC_BgAo_2H E  !2@@ ?  .A    `2~og_WO{C   ~hb@y	   7}Sx   b"@I  J   2)<J<!Hj  A ~C8tD)W  Y  <9<r6 1  T* 4`     (!~k! T`   P~`   *  `   `~v  *~@R~*~h@96     ~h@9`   Pr!~a.@`   ~h@9 6`   ,2~h@9  6    ~hD9( 4   Kt R2$^? @RcR~ *x~9 B _kAThb@yh (7}S     $m~@9A 4{EODWC_BgA`   oa~{EODWC_BgAo_og_WO{Chb@yh 6b"@I  J  )<Jr  A pF~h&@  5h*@ 1 Th@9I  J  )<Jr  A 7~aD)? k  T`   1~  `    -~hb@y6b.@I  J  )<Jr  A !~h@9 6   4~h@9  6   d~hD9( 4   Kt R2$^ @RcRw~ *~ B ?kATh@9(7{EODWC_BgAo_{EODWC_BgA   o}g_WO{ w@ h
@@ q T  )(y	 h@9  4F@9 2F 9B@9 2P  h@9 6@ 5F@9H 7`@}   R $R } v   8  @R~ q! T= ?  =  T9C V6
 }B@9R92#  h@9 qa  T@
 h@9  4F@92F 9B@92  h@9  4F@92F 9B@92  h@9 6@H 5F@9 7B@92  h@9h 6B@92B 9{DOCWB_Ag_H E  ! !2@@ ?H E  !2@@ ?H E  !2@@ ?H Ea  !` 2@@ ?H Ea  !72@@ ?H E  !H 2@@ ?og_WO{CH EY 9E @  2 @R 2 2} *472 2*} 1 8 T
RC 
R }!R2C  *}27c@ R(~ 2 *Rb}" C 2 } ~N 1 C I}N@C 
R!  }@N@!R"R# (! @@N@  } *7N@ > (!@ 4* 9 *8	
Ay )
?A( T@h  5@	Ay	 	)a@	9 @2	Q @U @ < =@y $@@(} (@ q  T@  	5@) Q	5 $@	 ( |@	Y@) Q	Y    @a  !#: | 42@  6)H?@ T 6j@)	? T 6n@)	? T 6r@)	?  TZS( 6v@( T R"  2} Y *2 | C 2|*@)3  *?3 )'* y  2R   2  2   2  22} 9
 I  Q):Yh*2| C 2||(3 *(#<3 X Ay@@l} Y  ???? < :; 5_)| 2:W)@	#(*	@9j  4:+   *@y_ qa T)!@	7}P?k  T2(+   ?+    2(+ 7@7 )#  @	Y@) 	Y N@
  
Ay(!@ WkT  |h  |2   2*@RrR	})e( q4rS!}     4Y : 9Ei  *W|:  4h@ T*
1@ 5:@	*J}Je_k T	*k}kekk  5@hY*) @TY @9E TF  @ T*@ qaTh@Ay` T	8a@>@I 4:@ 4@+ Q"}S  H 	}SHYb u@k T,7_ k  TL LYlu@KL6  *5  H Ea  !L. @{	@(@  @	  T
u@_khT
}@_kT 	5@) 	5 @aT   E  { @- q  T  {R  {x { cT{R      *{S sEs@  w{2    {S sE*s@{Zh C{EODWC_BgAo_H E@\{  @^{A   !HI{p|{_WO{ I )E  	`@{@  T@F   T @t{To{AT`@: i{`N@g{{COBWA_a{og_WO{C J JEI )E J@ `  A   	hN@ \"!!@{`  a "{aL)cM)ev@`   "{a
O)cP)e@`   #{iN@(!@. 4u  v  * 2RR42) 7A9/ 4**+A*  TkAy! j
_k#Tm `  	 <0z`   0z@R Rd{ zRz* 	}  q))}))!@(*J J#)	ZI	
  4 qKT	 ?q T*} ? qJJ}*J!@)*k K#J	Z) J
J4   1  T`   '*z  @R R3{ z@Rz`   0zB @R R'{ zRz* 	}  q))}))1@(*J J#)	ZI	
  4 qKT	 ?q T*} ? qJJ}*J1@)*k K#J	Z) J
J4   1  T`   '*z  @R Rz \z@Rzz`   0rzA9 qrzA9 qnzA9 qjzA9 qfzA9 qbzA9 q^zA9 qZzA9 qVzA9 qRzA9 qNzA9 qJzA9 qFzA9 qBzA9 q>zA9 q:zA9 q6z`  B 1.zA9 q.zA9 q*zA9 q&zA9 q"zA9 qzA9 qzA9 qzA9 qzA9 qzA9 q
zA9 qzA9 qzA9 qyA9 qyA9 qyA9 qyAy`   01yB9 6
B9`   l1yB9`   1yB9`   1yI`   2y@`   2yAyqc TRB4 y	@yAy4kTB('@xy@9H 4a  !y 5`    3  "@ 7`   3y  h  Y3? 1` Th  3? 1  Th  )  ? 13)<(`   (3y@RyiN@Ay(!@Y?kTI @)E)@(( C{EODWC_BgAo_H Ea  	K! 4 @iyzy{ I )E 	    {__WO{ C V E@  @  T@ T2@( 4B ey 4@T**  *@ 4 @@  TB Oy 4 q  T2@ 4  T   T@T
          @  {COBWA__Wy K (@kE 	K  T 
@_	  T
  A __  A _J @JE * 	@
  ?
  T	  A __  A _O{C I )E 	  F @ T h   x 2	   {AO_J JE *+@K h@*i	@)	  T ( __? _I )E 	^ q T  ) (y		(  < Ay !@_ 1 TH 	 jRI%I 6I )(h_Ay 	 _ _A __{ H Ea  !p/ @xy{ I )E 	#  0@ q{_x 2*	 {_O{C I )F 	  0@ 4 =`=8@_ 1 TH 	 jRI% 6I ) h  ax 2	   {AO_H Ea  !p/ @Fxmy_WO{ I )F *	 T Z@(k T=x  2*	 I  7x 2*	 C  a  T   _IkI T6@  @	 T Q5  F  T ) Q  4@TAy-y v ~~~~ 
 : x 2     4@  2"  Z@ Z ` 
  w 2*	   )x*{COBWA__WO{ hAy t.D8( 4!  !8<
 w 4!  !T<w@ 4!  !h<w 4!  !<w  4) )E 	^ 0@( 54  2h*  2)  @y q! Tb  {2  @y q! Tb     @y q! Tb  w2  @y q! Tb  {2" *  2  w R*	 {BOAW_w2  $   2h* ` 4@ 4  2 w R	 " *w 2`*  _WO{ ) )	F *	  Z@(ki T _Ik T6@  @	@ T Q5  Tw 2*	 E  Nw  2*	 ?  F  T ) Q  4@TAy Sx  ~~~~ 
 : w 2 @ 4@ R *@  q  T@  	5@) Q	5 @@  Ow 2` 
  w 2*	   Dw*{COBWA___WO{ ) )F 	 4 Ayx U ~~~~ 
 : |w 2   46@6  2"  Z@ Z `   v 2*	 
  v 2*	   w*{COBWA__ 2  og_WO{CC) )F *	H [ Ay w 4 ~~~~ 
 : 1w  4*@ q  T@  	5@) Q	5 F T' B # 2w 5B2w  52w 5'@2w 5b@b@
= _!)kA T*``*k T}S*}Sk *k! T*)}S}S	k T
*
IA9lB9?k TJA9kB9j
JI	
	 5
IA9lB9?kA TJAA9kAB9j
JI	
 5
 _= qT@@= ?!(k T}S?AHkA T@=  qC T@	R#@
C) HNxI@y?kA T@	 	 +   7vGA@@+@
 5  qa  T  i   2-
@9.ij8
ij8JJ
J  5* _T
'A)		?kCT*@*@_ k T= *_ q T  JA Iy)
 !@#@	k! TB  @y@y ?ka T	    u@@` 5@ q@ T( @ 2) 

@9@9
ij8J

J J 5*k _	T  @@	` T@aTuu*2  u*2  *C{EODWC_BgAo_u*  6u 2h@a  T@h h[@ Qh[ *@ q  T@  	5@) Q	5 &@	 ( u 2u u( Ea  !/ @~uv*O{C ) )F* 	  	X@*kI T Ik T4@  @  TJ Q5  ku *2  fu * 2	 #   HF
  T k Q  4@
Tj@
  T	@i 	X@) Q	X 	)@? q  T	@  *5@J Q*5 	)@* I yu 2` {AO_WO{ ) )F 	 4 F   T(@ @ q  T@  	5@) Q	5 $@	 ( Wu!T 2Z `   u 2*	 {BOAW_O{C ) )F 	 P@ qa  T2P F   T2
@_ qA  T	 @ AT 2`   t 2*	 {AO_O{C ) )!F* 	y  F  @   Ts Q5h   a  t  2	   t 2	 {AO_O{C ) )%F* 	U F  @  T Q5( 	@? qa  T2	  2`   t  2*	   t 2*	 {AO_WO{ ) ))F  	+  !  !T<t 4!  !8<t 4!  !h<t@ 4!  !<t 4 t   Tvt R*	   pt )R*	 {BOAW_2~u  *2tB 2xt 2 "5h*@ h*   h:@i*@%
qk  TX   2`  Ct 2*	 g_WO{C 7 E uB @ 2**   t @ H 5@@A 4t  ql  T @" A  T@h2@ 5@6@  @@ T2@  5B t  qM TT
@
 x h  @ {DOCWB_Ag_@	@3 i 2tWO{  `@: "th*@Rr
R	}	)e(
 q5rSt`     4: `"  *-tu:  4	@?  TR*rR-1@ 5n:@
*}ek T
*}en  5n@Y-J )@?T 2{BOAW_O{C ) )-F  	A  4@ 2h   s 2*	 {AO__WO{ C 6 E( 1F @  # T ( E  0@H 4~s R*	   xs2  ( -F	  4@ 4ls  2*	   fs 2*	 @  {COBWA__Z@  4Vs R*	 h@ T@i" 	`  Th    h*@B ** Q h*    "@ =   = TB ** | #@)	k  Ti@5y(  7^s 2` bs_WO{ C 7 E( 5F@     !  !T<s 4!  !8<s 4!  !h<s@ 4!  !<s 4 U ( E 0@ 4r 2*	   r )R*	 @  {COBWA__r2   Es    Tr R*	 B **    "@ =   = T C **  #@)	k  Ti@8y(  2rg 2` rWO{ ) )9F 	, t 2@( 4!  !8<r@ 4!  !T<r 4r R*	   ~r 2*	   {2   :   = 2=  * 2R ` {BOAW_og_WO{C ) )=F  	h@( 4@ T**u lFi]? qI  %)9@@J 	AT
%)@.AM aT[	  76   2  2R*Is 4 *rh@ |@s.  h| :s  *tr|dr)h@V hb@" y@?  To ORRR)3@(w@I 4) QJ)(- (3@)@ QJ(	A   	RH	r	 I
R	]yIRHr	
2 !!C 	Qy<rsF  h&@b:@@}rs@` Th*@	 q T q ThAya( !  ! i@)u@)  hAyi&@j:@a( I		! a(@Hyy9Qy)3@i  4);@  {2	  = <9@?AT*@OAo@LRHC6	RHr	r2K
R	A
xax!Ax*@`@!R2r`7q" @
 T    ) J 1@k 4)@ q Tl}@Lyk`
y@  .@y@y<  .@y@!@l@ k@%@k   y@ =`<lF  @ T@ qhT}@.y`	!@@.@!@y<  .@!@m@@ @q@ @!@<<@T`@!R"R*`r7.@uqsqqq 2  6q 2*	   0q2  	  ,q2    _q.@]q[q*C{EODWC_BgAo_ 	D( 
! {   TL_	  TL@ k  TJa lI k Y T
qiE 2(!
 	@__WO{  x"A*w"   5@@	Ay	 	)a@	9 h@2	Q h@I Q	U h@ < =h@
y $@i@(} (@ q  T@  	5@) Q	5 $@	 ( qh@	Y@) Q	Y v @2@r 	 5B C p  ql  T3@ 4h
@t
    t {COBWA__z> og_WO{C:@** "  4@YSYy  q  T 5aC p  hw@K  47:@ Q?k@ T4 4 q T@( [hu@K  @( [hA p` 6	  @(}S[y{  *5  ( Ea  !L.* @dp{EODWC_BgAo_( Ea  !.* @Up|qWO{  
c2	5 E) )E )@
k C @<"@!   *!0p~@=p@@Rp*)pO{C 3 sEh@	A 	  T_ph@ {AO_og_WO{CC  
  Z U{ku   { h{jh  *  {jyh  {q t  hK p; {Eh@	@)	 h@@w {p\ 4
@ q)) J
   TJ k@L@ QKh5	@@*b{cph@	A 	  Tph@ ~~   C{EODWC_BgAo_O{C `   4p ` `   $5p`@ ( E`   h5R@ 2R  `   <6p` ( E`   6R@ 2R{AOp{AO_ ( E  @  **_) )AF*	 *_{ ( Ea  b  !@8 @B8jo {*_O{C *  ) q  T	 q T( EF) )!	   ( EF) )	  ( E h@h  *  ( AF*h {AO_( Ea  b  !@8 @B89o  ( Ea  b  !\7 @B7/o{ o`  {_`   8=p 2'o{ Dp`  {_`   d92p 2o_WO{  7 E* @ u ( E @o<p 1 T 4 ;pAo@yR	jZ-  `  * 
4p *72 2*o 1 T2p  22*'p Q?q T|``		)`ji8_) q Tj)8  o    o*Co      @  {COBWA__`j(8*3ooh  A: r#  o 2n( E@n  @n!   !Hn 2no_WO{6 E * @e9h  6*  8 GF @@o 5@!@q! To  5C@	R	  T@b  @b  5* 2%9[ {DOCWB_Ao_ng_WO{C 9 9E9@  en   @@8n5H@9 qa  T*  * o@*? TS  i @*  T_ q T  * ( TT   s   2  (@9 q@)	) *{DOCWB_Ag_rng_WO{C 8 E*@ * !n   @@8n5H@9* q  T* [o@?  TT   @*  T_ q@ T q  L
*  7  7(@9 q  *S  ` @		) *{DOCWB_Ag_)n{ 2o   @y	Z }S{_  {__WO{ C 6 E @ m w  @8Wn5@9 q T* o@  T@? q  T	Pi  @9 4o  @y	Z }S@  {COBWA__( Ea  !L:2@@ ?m_WO{   	n  ~ ~ F q Tm 4 Qhjb8 q T{COBWA 2_m* 2m*   iJh8	 4? q`  T? qAT( Ea  !; @{COBWA_\m{COBWA__( Ea  !:2@ 2@ ?g_WO{*  mt B Ta  !=\m` 4a  !=Wm  4a  !Rm`  5s  s8 KF@7 9 : 9EZGF
@Dm  5@ 2 
@   @@"@"@    j  5	      j  5 2  * _)kb  T	   i  T 2  )}S*|S  5  4	 	  " .  _ q? qI	
) 6H  
@? q  TI@"@  5@@  
@H@@9@  4	
@I! _T@	 @ } A	 T	
@I!   V  @( E@  
@l  4@v q`	 T+  V@  Rm 7 RSmN   @  55 4 2  2m  @  2@	@l`  5B 9@@Z B 9   {DOCWB_Ag_( E) a  !@)E
@@ @l 2l( Ea  !=2@2@ ?( Ea  !=2@@ ?( E) a  !@)E
@@ @al 2cl`   d9tm 2^lg_WO{ h@9* 4!  !8<ll  4!  !T<gl` 4!  !h<bl  4!  !<]l`  5S  s-7 NF@ 8 9 E9GF
@Ol 5@ 2 
@   @@"@"@    j  5	      j  5 2  * _)kb  T	   i  T 2  )}S*|S  5  4	 	  " *  _ q? qI	
I 6H  
@? q  T)@"!@ ` 5@@  
@(@@9!@ @ 4	
@I! _T@	 @ }  T@  V  @V( E@  
@k  4@u q  T  @  5 4 2  2 {DOCWB_Ag_( E) a  !@)E
@@ @k 2k( EA  !d>2@@ ?( E) a  !t@)E
@@ @k 2kO{C  t@T !  !k  5t
@ lt b	 ThF@yqB
 TaF@a   h:@H 	@	 c
@ _ qb T	BhF@y  4) )EF)@)a@9	k  T( IF	@i  {AO_( E) a  !P@)E@ @]k 2_k( E) A  !>@)Ec
@d@9@ @( E) A  %  @)Ec
@!l?@ @Ak 2Ck( E) a  !L @)E@ @
  ( E) a  ! @)E@ @*k 2,kO{C *h Q	R	s Q5{AO_O{C  t@T !  !/k  5t
@ kt b	 ThF@yqB
 TaF@a   h:@H 	@	 c
@ _ qb T	BhF@y  4) )EF)@)a@9	k  T( MF	@i  {AO_( E) a  !P@)E@ @j 2j( E) a  !@)Ec
@d@9@ @( E) a  %  @)Ec
@!,@ @j 2j( E) a  !@)E@ @
  ( E) a  !@)E@ @j 2jO{C *h Q2	s Q5{AO_WO{  t@4 @T@  j@U @@ A  Tjj5 {BOAW_o{C C 
	) )Ec2C )@CC  +<)
 Q 3=_ q T  k!jyJ@ 6K!  q T\K! C@\K! J@j 4) )Ea  !X)@)@   6K!  qK T\K! C@\K! J@ 4) )Ea  !)@)@2 ? 6K!  q T\K! J@j	 5@( C {Ao_]j
]ij6JA _ q,T]J+]ij+6JA _ qT]J+) )E )@A@)@= ?	6*! _ q T]cii6)A ? q, T])*	  4j\*! #@\*! * JE$@a  !J@2I@ ?) )Ea  ! 2)@)@ ?O{C  @9@9@9@9 s%c  *cRk{AO_O{C 22 k`   @ h@2 	Zk`   @ d@9e@9f
@9g@9 %c  *cRj{AO_ @2 1 T	Z{2 *@ q	k`  T)ySK4_ q  _O{C  @ 1 T	Z2{2*D q	k`  T)ySK4_ q  T q  T  s<
    s%#  *c-Rj{AO_*  g_WO{ 9 9E *S 9@bRS  yiS RR 9i   9Ti   @8i5@9 q` TS # *S j@` Ti@? q  T T@9 5   A.9R ]i   9 @8i5@9 q` T*# oj@
 Ti@? q 
 T	 T@9 4L  * h  6G  i   @8i5@9 q T*# Pj@  Ti@? q  Th  T@9  4-   2 B.2B7)K  8" *Hi    B.  9R i 8  9 @8mi5@9 q T*# !j@  Ti@? q`  T T@( {DOCWB_Ag_2@9h  4 
 9  @8Fi5@9 q T*# i@  Ti@? q  Th  T@9  4h 9  BD&@RcR$iWO{  5 E  r.@HR #  `=# 22*< yi  4 BD&@RcRi @   {BOAW_h	(@)8A)*+	ZL	Z	Z	Z 6 k}}J})ySk7*j
*I	*? q	  _ 
-@)5A)*J	Zk	Z	Z	Z 6) J}k}}ySj7O{C **j
*_ q
 $ q@ T 1a T  s'RBD&@RcRi yh Rh    s<	   s'#  *c-Rti{AO_O{C   s'@R*i{A q`O_og_WO{C  Ec @R   %h 2    R  h`*|	i  i@ `  4 *{>  @8ph5R h w     Lh|@? T 2g  R2i98*i   8     h# h@  =*|   i<h@2!@! 	Th  5HGR 9S y    '@ 
 q T@ Q|i   `@i *)|` @@< `i<)A CT*|A  2j@) ?@y<@i<A CTH Q  @ = y<g   Z _kT@ c  E@ 4i@@ Q)ihKihi	
Ii(i@@)J)@K@i	
I i@@)J)	@K	@i	
I	 i@@)J)@K@A i	
I 5  @ @( C{EODWC_BgAo_ EA  !2@@ ?@   9  @   d9Dh 2.gug_WO{ C  E @   '@R7h q  T g u  @8g5@9 q  T* [h@   T@? q Th T@9( 5u 4 ~C> 2 2Wg2K` }S*Pg
 2(K"h 9	   > "    >~ @(  {COBWA__ EA  !2@@ ?g_WO{  E  '@@R URg qA T2g  = 2=h '  2 2#   W)  h 5@h@   h )@*2f u 4 *
@@<Z<@) hg@  {COBWA__f@   d9   EA  !2@@ ?@   8g 2nfWO{   !! g`  hj`8( 4@   3tf  !"g   E  "  T@ 2 gRef@8cfg  E@f{BOA@RWSf2Qf E@{BOAWfWO{ C  E @ .f v  @8f5@9 q T* ig@  T@? q  Th  T@9H 4A  !d'f  4 g   @X  *V  !  !f	 4!  !f 2 4!  !f2  4!  !
f 2` 4A  !0f2 4A  !=e R 4A  !=e2  4!  !e 2` 4A  !2e2 4A  !De(R 4A  !eHR  4A  !dehR` 4 EA  !t2@@ ?	 )E( !@9@   {BOAW_e  7I  )  	E?0( TI  ))J  J? r@etjjhC	R}	rD	  TI  J  )aJEhC}D	  TI  J  )JtjjhC}D	  TI  J  )JI  K  C)	k? r}D`seO{C   E s"(@ ) f 1 TA  `
!	S C 3 pe'B)@ kE]SA	
h @( C {AO_ E@   4	aR@ 2R`f sEh@	A 	  Tieh@  2%ele_WO{   E 2*@*  2 GF  2@a@9*qe *72 2*e 1@ T E 2 @Y# 2e@ 9#  e@9**e7*ae  d @ qa Tc  5 2  d @	 q  T @uq  T*Oe*   @qq T*He r@  {COBWA__ EA  !0 @de E@d  @d!   !H	   E@  @dA   !\d 2d E@  @dA   !og_WO{C t	  Z V{kv   { h{jh  * 29 )jih  {e 5 {Ke E	@*@J* @@h  4( Q @9 Q	 *A)  ? q	 i@)
	  y5*b{d*,~~   {EODWC_BgAo_WO{  t
@ 2@@I! 6@J	
  4j@I	
	 5I`  i@9) i  4  4
@  4 E@(  2u 9@	 Q?U qi  T`  	 )(Yh ?@i"@"(*h" {BOAW_ Eb@@A  @!(2@ ? Eb@@A  @!2@ ? Eb@@A  @!2@ ?{ # @    R*` ka#, rIA_? q TI@ 7)` "  I_?U q T% 7?) q  TdyiE@  TC@J c{_
 JEA  !h 2J@	*J@@?	 )EA  !)@)@  	 )EA  !)@)@ 2 ?	 )EA  !( 2)@)@ ?O{C  E@i>@ jF@h@K@ K  K@k TKC 	 )EA  !p 2)@*)@ ?  EJ   @ 9 h
@ hJ  h
@# h_3  ?#@h
 	  h&@  i@B  ce  	K ?^  C {AO_c{ I @   2	l@ma@9 6M!
 4M!
 4*k  T  @k  TC     q@P!1
q  4
 4q@1
  4*
?k  T  qTcC{_	 )E@A  !&)@)@  	 )E@A  !')@)@2 ?	 )EA  !2)@)@ ?O{C   E @hB@ i
@#  iV@)  i@# iN@  ?  h*@h  `@ ?bF@  `
@a@^  C {AO_<cog_WO{C E  !1@b  c 2c b    25D  bA   2! c  qHR2"C c@ ` T@q T 5@9Qc 4 @8Mc5@9 q  T(#H  @9 4  @c  5  	@9)5  @ T2 9c x  b  @   x   @8$c5@9 qT(#c 2b    b E@Z( C{EODWC_BgAo_    |c  bb E@T @
@bb3bO{C    `@fb  4s
@s    `
@{AO_  @k  T @_  @__WO{ C  E @ w
@
@ Q q  T  )'(h  @`@ 4}@)`?   H 6
@ Q q T  )"(y	 @9h 9b@96i*A)@Hi)8  @yhR yb@96i*A)@Hi)x  @h* b@96i*A)@Hi)  @h b@9 6i*A)@Hi)@h  {COBWA__ Eb@@A  @!2@ ?bog_WO{C  E     @9c#Z( l
@	@( Q*	K( qh1@) Q? q  T  J'Ti    k<i@@ @ 2m	 q( v@    * 9;
| ## "@9? q@  T  5  q   # C #  
 6@@9h  4 q T@j@9h
@_  T	@k Q q Tzk`k*8  {*x  {*  k
i J j 9
a@9
6
	@J Q_ qh T
{J@i 9  i y  i   i 	@@	 Q(J)? qH1@{@9( 4h@9 kT E@b@A  @#@!t2@* ?	 @)E)@( C{EODWC_BgAo_ E@b@A  @#@!H2@ ? E@b@A  @#@!\2@ ? EA  B  !@B0 2@ ?^aWO{ C  E  @ `@u
@a@i@	@ T@9 5"E)?k  T!c  aD Tc  a T` b@9 6h&A@ i(@(  {BOAW_ Eb@@A  @!P2@E) ?'aO{C  `@t
@ Sa@  4H|@  TB`b  4 H Tb@96@i*A)@a@  0T	`j38{AO_ EA  !<2@@ ? EA  !2@@ ?WO{   E  @ 2* 2 `@s 6t@*# S  2k@v 9h 9@(@9 q T  *# S  2^    6@h 9@@9H 4 EA  !d @@2 ?h
@t@!  !-@h 9a b! 4!  !Xa@ 4!  !a 4!  !
a 4!  !4a` 5  B       @9h 9@   {BOAW_` EA  !@@O{C   E  *@# S   )`@  H 6@(@9 qA T  *# C   6@@9 5@h* @h. @( C {AO_ EA  ! 2@b@@#@ ? EA  !t"2@b@@#@ ?F` EA  !!2@b@@#@ ?O{C C  E *@  2  `@`  6@  `@    ! &P0"R#R]a@  @9 i
@h 9)@ 6j@)`Hi)8@  C {AO_` Eb@A  !H#@2@ ?g_WO{ E  @#    FF@ a@9 `@a`
7 h@c2t a@9	 q2h"9@u *29 4@@	 q T) q T!    ~ @@	 q T) q T!    ! 	 q)~) q`` 4  ! 	 q)~) q` 2@X`h
@@ 6i@=` i<@h {DOCWB_Ag_ Eb@A  !#@2@ ? E@@`A   !#2`?_WO{  t@R l_ e_  R c_  8u qv ] t {BOAW_{BOAWd E!  !	2@@ ?O{C  `@h
@` 9@ 6i@` i(8{AO_WO{ C  E @  a@u
@ h`7@   	@?	 q T?) q T@H`` Eb@A  !$@2@ ?@-@xT`@
Z)}Sr(hR yb@9 6i*A)@Hi)x@   {BOAW__g_WO{  9E 9@ @
@^  S H@	A? q2U 7  ? 2x!5#  y8[__8    5	 ?k T	@9 4C  ` 	7@  	@?	 q  T?) q  T@H=  @-@x `@9   TI@
ZJ}S?rIz(x #  9._@9  q  TR@y2 9V yIc@9)6*A)@k@	_^@( {DOCWB_Ag_ E@C@A  @!t2*@ ?_ EA  !$2@@ ? E!  !	2@@ ? EA  B  !@B(% 2@ ?~^WO{ C E FF @223 @t
@ `@a@9c2	 qH	R	
*h"9    6@h"91  @2   a@9c C  `@v_`7@t (@!@	 q  T) q  T!    ! 	 q) q(~2"^@a@9) q  T	 q  TM  `"9@X_]   {BOAW_#^ Eb@@e"A9@A  *!p%@2 ?O{C  t
@
 
	A@9
  4? qH T2 	K!***F m: (  ****} "  ?qH T2 	K!**~)l>   ?q T2 i	K!*k~)  ?q T2 I	Kj! jF   
    	Z	Zk	ZJ	Zi2)k*)b@9 6i*A =(@@i<{AO_WO{ C  E  @2 Bt^ 9@	@9? q
 T	?	 L
 T  2g^ 9@	@9? q	 T	?	  T  2Z^
 9@	@9? qa T	?	  T  2M^ 9@	@9? q T	?	 l T  2@^ 9@	@9? q! T	?	  T  23^ 9@	@9 5	 L Th
@@ 6i@
@y(H
	 y@	 @  {BOAW_ EA  !&2@@ ?V])]        iptables-xml xml ip6tables main6 ip6tables-save save6 ip6tables-restore restore6 1.4.20 cvh re Can't open %s: %s Unknown arguments found on commandline <!-- line %d  COMMIT
  	
 %s: line %u table name invalid
 %s: line %u chain name invalid
 %s: line %u policy invalid
 Bad line %u: need ]
 : Bad line %u: need :
 ] -t --table Line %u seems to have a -t table option.
 -A %s: line %u failed
 %s: COMMIT expected at line %u
 verbose combine help Usage: %s [-c] [-v] [-h]
          [--combine ]
	   [ --verbose ]
	   [ --help ]
 <!--      <chain  name - policy packet-count byte-count %s=" "  &#%d; &amp; &lt; &gt; &quot; %s="%lld"    <table  [%llu:%llu] Combine action from next rule       <rule        </rule>
        </actions>
 -j --jump -g --goto ACCEPT DROP QUEUE RETURN                      ! -m match %s<%s  %s%s   </%s>
 %s goto call --module  invert="1" xptables-xml  -->   </table>     </chain>  /> /> > %s does not take any options
 can't alloc memory! option "%s" requires an argument unknown option "%s" Unknown arg "%s" ERROR: No valid subcommand given.
Valid subcommands:
  * %s
 malloc Another app is currently holding the xtables lock; waiting for it to exit...
 %s/%s Failed to initialize xtables
 bcdt: Unknown arguments found on commandline
 counters dump table modprobe Cannot initialize: %s
 # Generated by ip6tables-save v%s on %s *%s
 :%s  %s  [%llu:%llu]
 # Completed on %s /proc/net/ip6_tables_names Badly formed tablename `%s'
 COMMIT - [0:0] bcvthnwM:T: Can't open %s: %s
 Another app is currently holding the xtables lock. Perhaps you want to use the -w option?
 Invalid chain name `%s' (%u chars max) error flushing chain '%s':%s
 error creating chain '%s':%s
 invalid policy counters for chain '%s'
 Can't set policy `%s' on `%s' line %u: %s
 --set-counters binary test noflush wait Usage: %s [-b] [-c] [-v] [-t] [-h] [-w]
	   [ --binary ]
	   [ --counters ]
	   [ --verbose ]
	   [ --test ]
	   [ --help ]
	   [ --noflush ]
	   [ --wait ]
          [ --modprobe=<command>]
 %s: unable to initialize table '%s'
 Parser cannot handle more arguments
 The -t option (seen in line %u) cannot be used in ip6tables-restore.
 Parameter too long! filter ip6tables: %s. Run `dmesg' for more information.
 ip6tables: %s.
 %s v%s:  Perhaps ip6tables or your kernel needs to be upgraded.
 Flushing chain `%s'
 Deleting chain `%s'
 [%llu:%llu]  -A %s -s -d %s -? %d  !  -c %llu %llu Can't find library for target `%s'
  -j %s Target `%s' is missing save function
  -%c %s -:A:C:D:R:I:L::S::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:bvwnt:m:xc:g:46 -%c requires a rule number chain name not allowed to start with `%c'
 chain name may not clash with target name
 -%c requires old-chain-name and new-chain-name -%c requires a chain and a policy rule would never match protocol Warning: never matched protocol: %s. use extension match instead.
 Empty interface is likely to be undesired You cannot use `-w' from ip6tables-restore unexpected ! flag before --table Not %s ;-)
 %s v%s
 -%c requires packet and byte counter %llu -%c packet counter not numeric -%c byte counter not numeric This is the IPv6 version of ip6tables.
 multiple consecutive ! not allowed Bad argument `%s'
 unknown arguments found on commandline no command specified nothing appropriate following ! ::0/0 ! not allowed with multiple source or destination IP addresses Replacement rule does not specify a unique address chain name `%s' too long (must be under %u chars) can't initialize ip6tables table `%s': %s PREROUTING INPUT Can't use -%c with %s
 POSTROUTING OUTPUT Warning: using chain %s, not extension
 goto '%s' is not a chain
 append delete check insert replace list list-rules flush zero new-chain delete-chain rename-chain source destination src dst protocol in-interface jump numeric out-interface exact version line-numbers set-counters ipv4 ipv6 Error occurred at line: %d
 Try `%s -h' or '%s --help' for more information.
 %s %s %s /%s /%d %s -%c  %s -p %s %s -p %u  -m %s Can't find library for match `%s'
 unexpected '!' flag Cannot use -%c with -%c
 Invalid rule number `%s' %s v%s

Usage: %s -[ACD] chain rule-specification [options]
       %s -I chain [rulenum] rule-specification [options]
       %s -R chain rulenum rule-specification [options]
       %s -D chain rulenum [options]
       %s -[LS] [chain [rulenum]] [options]
       %s -[FZ] [chain] [options]
       %s -[NX] chain
       %s -E old-chain-name new-chain-name
       %s -P chain target [options]
       %s -h (print this help information)

 multiple -%c flags not allowed cannot have ! before -%c Invalid target name (too short) Invalid target name `%s' (%u chars max) Invalid target name `%s' Notice: The %s target is converted into %s target in rule listing and saving.
 unexpected ! flag before --match Notice: The %s match is converted into %s match in rule listing and saving.
 You need to supply the `-%c' option for this command
 Illegal option `-%c' with this command
 %u  %-4u  %-9s  %-5s %hu  %-5hu opt  in %s   %-6s  out %s  %-6s  %-19s  anywhere -> %s    [goto]  [%u bytes of unknown target data]  UNKNOWN match `%s'  Zeroing chain `%s'
 Chain %s  (policy %s packets,  bytes  (%u references)
 %-4s  num %5s  pkts %8s  %10s  target  prot  opt in out  %-19s  -P %s %s -N %s
 ) libxtables.so.10 AUDIT  AUDIT  accept drop reject  --type accept  --type drop  --type reject Bad action type value "%s" type CHECKSUM  CHECKSUM  fill  --checksum-fill checksum-fill CLASSIFY  CLASSIFY set  %x:%x  --set-class %.4x:%.4x Bad class value "%s" %x:%x set-class CONNMARK  CONNMARK set  /  CONNMARK save  mask   CONNMARK restore   ERROR: UNKNOWN CONNMARK MODE 0x%lx %s0x%lx  --set-mark   --save-mark  --mask   --restore-mark  CONNMARK target: No operation specified set-mark save-mark restore-mark mask  CONNMARK and 0x%x  CONNMARK or 0x%x  CONNMARK xor 0x%x  CONNMARK set 0x%x  CONNMARK xset 0x%x/0x%x  CONNMARK save  CONNMARK save mask 0x%x  CONNMARK save nfmask 0x%x ctmask ~0x%x  CONNMARK restore  CONNMARK restore mask 0x%x  CONNMARK restore ctmask 0x%x nfmask ~0x%x  --set-xmark 0x%x/0x%x  --save-mark --nfmask 0x%x --ctmask 0x%x  --restore-mark --nfmask 0x%x --ctmask 0x%x set-xmark and-mark or-mark xor-mark ctmask nfmask CONNSECMARK  CONNSECMARK  save restore CONNSECMARK target: invalid mode %hhu
  -- CONNSECMARK target: parameter required CT NOTRACK  CT  notrack  helper %s ctevents expevents zone %u   %s  , new related destroy reply assured protoinfo helper mark natseqinfo secmark  --notrack  --helper %s --ctevents --expevents  --zone %u Unknown event type "%s" notrack zone  NOTRACK  timeout %s  --timeout %s timeout DSCP  DSCP set  0x%02x  --set-dscp 0x%02x Invalid DSCP value `%s'
 CS0 CS1 CS2 CS3 CS4 CS5 CS6 CS7 BE AF11 AF12 AF13 AF21 AF22 AF23 AF31 AF32 AF33 AF41 AF42 AF43 EF DSCP target: Parameter --set-dscp is required set-dscp set-dscp-class HMARK  HMARK  mod %u  + 0x%x  ct,  src-prefix %u  dst-prefix %u  sport-mask 0x%x  dport-mask 0x%x  spi-mask 0x%x  sport 0x%x  dport 0x%x  spi 0x%x  proto-mask 0x%x  rnd 0x%x   --hmark-src-prefix %d  --hmark-dst-prefix %d  --hmark-sport-mask 0x%04x  --hmark-dport-mask 0x%04x  --hmark-spi-mask 0x%08x  --hmark-sport 0x%04x  --hmark-dport 0x%04x  --hmark-spi 0x%08x  --hmark-proto-mask 0x%02x  --hmark-rnd 0x%08x  --hmark-mod %u  --hmark-offset %u  --hmark-tuple ct Bad type "%s" "--hmark-tuple" requires a list of types with no spaces, e.g. src,dst,sport,dport,proto ct sport dport proto spi --hmark-mod is mandatory --hmark-rnd is mandatory you cannot use --hmark-spi-mask and --hmark-?port-mask,at the same time you have to specify --hmark-tuple at least hmark-tuple hmark-src-prefix hmark-dst-prefix hmark-sport-mask hmark-dport-mask hmark-spi-mask hmark-sport hmark-dport hmark-spi hmark-proto-mask hmark-rnd hmark-mod hmark-offset src-prefix %s  dst-prefix %s  IDLETIMER  timeout:%u  label:%s  send_nl_msg:%u  --timeout %u  --label %s  --send_nl_msg %u label send_nl_msg LED  led-trigger-id:"  led-delay:inf  led-delay:%dms  led-always-blink  --led-trigger-id "  --led-delay %d  --led-always-blink netfilter- inf Delay value must be within range 0..%u led-trigger-id led-delay led-always-blink MARK  MARK set  0x%lx  --set-mark MARK target: kernel too old for --%s MARK target: Parameter --set/and/or-mark is required  MARK and  MARK or  --and-mark  --or-mark  MARK and 0x%x  MARK or 0x%x  MARK xor 0x%x  MARK set 0x%x  MARK xset 0x%x/0x%x MARK: One of the --set-xmark, --{and,or,xor,set}-mark options is required NFLOG  %snflog-prefix   %snflog-group %u  %snflog-range %u  %snflog-threshold %u -- Newlines not allowed in --log-prefix nflog-group nflog-prefix nflog-range nflog-threshold NFQUEUE  NFQUEUE num %u  --queue-num %u NFQUEUE target: --queue-balance not supported (kernel too old?) queue-num queue-balance queue-bypass queue-cpu-fanout  NFQUEUE balance %u:%u  --queue-balance %u:%u Bad range "%s" %u should be less than %u  bypass  --queue-bypass  cpu-fanout  --queue-cpu-fanout RATEEST  %sname %s  %sinterval  %sewmalog  %.1fs  %.1fms  %uus --rateest- RATEEST: bad interval value "%s" RATEEST: bad ewmalog value "%s" s sec secs ms msec msecs us usec usecs RATEEST: interval value is too large RATEEST: ewmalog value is out of range rateest-name rateest-interval rateest-ewmalog SECMARK  SECMARK  selctx %s SECMARK target: invalid mode %hhu
 selctx SET add-set del-set --%s can be specified only once --%s requires two args. setname `%s' too long, max %d characters. Problem when communicating with ipset, errno=%d.
 Incorrect return size from kernel during ipset lookup, (want %zu, got %zu)
 Set %s doesn't exist.
 Can't open socket to ipset.
 Could not set close on exec: %s
 Kernel module xt_set is not loaded in.
 You must spefify (the comma separated list of) 'src' or 'dst'. Can't be more src/dst options than %i. You must specify either `--add-set' or `--del-set'  %s %s Set with index %i in kernel doesn't exist.
 --add-set --del-set Invalid value for option --timeout or out of range 0-%u Flag `--exist' can be used with `--add-set' only Option `--timeout' can be used with `--add-set' only  exist  timeout %u  --exist exist TCPMSS TCPMSS target mutually-exclusive options:
  --set-mss value               explicitly set MSS option to specified value
  --clamp-mss-to-pmtu           automatically clamp MSS value to (path_MTU - %d)
  TCPMSS clamp to PMTU  TCPMSS set %u  --clamp-mss-to-pmtu  --set-mss %u TCPMSS target: At least one parameter is required set-mss clamp-mss-to-pmtu TEE  TEE gw:%s  oif=%s  --gateway %s  --oif %s gateway oif TOS                         (0x%02x) %2u %s
 Minimize-Delay Maximize-Throughput Maximize-Reliability Minimize-Cost Normal-Service  TOS set  0x%02x  %s%s  --set-tos 0x%02x tos match: Your kernel is too old to support anything besides /0xFF as a mask. TOS: An action is required set-tos TOS target v%s options:
  --set-tos value[/mask]  Set Type of Service/Priority field to value
                          (Zero out bits in mask and XOR value into TOS)
  --set-tos symbol        Set TOS field (IPv4 only) by symbol
                          (this zeroes the 4-bit Precedence part!)
                          Accepted symbolic names for value are:
                             (0x%02x) %2u %s
  TOS set 0x%02x/0x%02x  TOS set  TOS and 0x%02x  TOS or 0x%02x  TOS xor 0x%02x  --set-tos 0x%02x/0x%02x and-tos or-tos xor-tos TPROXY  TPROXY redirect %s:%u mark 0x%x/0x%x  --on-port %u  --on-ip %s  --tproxy-mark 0x%x/0x%x on-port on-ip tproxy-mark TRACE addrtype                                 %s
 UNSPEC UNICAST LOCAL BROADCAST ANYCAST MULTICAST BLACKHOLE UNREACHABLE PROHIBIT THROW NAT XRESOLVE  ADDRTYPE match  src-type   dst-type  --src-type   --dst-type  addrtype: bad type `%s' addrtype: bad type "%s" addrtype: you must specify --src-type or --dst-type src-type dst-type  dst-type   limit-in  limit-out  --limit-iface-in  --limit-iface-out limit-iface-in limit-iface-out bpf match bpf  %hu %hhu %hhu %u, %hu %hhu %hhu %u  --bytecode "%hu, bpf: unknown option %hu%c bpf: error parsing program length bpf: illegal zero length program bpf: number of instructions exceeds maximum bpf: real program length exceeds the encoded length parameter bpf: error at instr %d bpf: parsed program length is less than the encoded length parameter bpf: missing --bytecode parameter bytecode cluster  cluster  !node_mask=0x%08x node_mask=0x%08x  total_nodes=%u hash_seed=0x%08x  ! --cluster-local-nodemask 0x%08x  --cluster-local-nodemask 0x%08x  --cluster-total-nodes %u --cluster-hash-seed 0x%08x cluster match: `--cluster-local-node' must be <= `--cluster-total-nodes' cluster match: `--cluster-local-nodemask' too big for `--cluster-total-nodes' cluster match: `--cluster-local-node' or`--cluster-local-nodemask' is missing cluster-total-nodes cluster-local-node cluster-local-nodemask cluster-hash-seed comment  /* %s */  --comment connbytes  connbytes mode  connbytes direction  %sconnbytes %llu :%llu  packets  bytes  avgpkt  unknown  original  reply  both  --connbytes-mode  --connbytes-dir %llu should be less than %llu original both Unknown --connbytes-dir `%s' packets avgpkt Unknown --connbytes-mode `%s' connbytes-dir connbytes-mode connlimit  #conn %s/%u %s %u <=  --connlimit-upto %u  --connlimit-above %u  --connlimit-mask %u  --connlimit-daddr  --connlimit-saddr xt_connlimit.0 does not support --connlimit-daddr You must specify "--connlimit-above" or "--connlimit-upto". connlimit-upto connlimit-above connlimit-mask connlimit-saddr connlimit-daddr connmark  CONNMARK match   0x%x/0x%x  0x%x  --mark  connmark match  conntrack state  %sctstate  %sctproto  %u  %sctorigsrc  %sctorigdst  %sctreplsrc  %sctrepldst  %sctstatus  %sctexpire  %lu %lu:%lu  %sctdir REPLY  %sctdir ORIGINAL %sINVALID %sNEW %sRELATED %sESTABLISHED %sUNTRACKED %sSNAT %sDNAT  %s %sEXPECTED %sSEEN_REPLY %sASSURED %sCONFIRMED %sNONE Bad ctstate "%s" "--ctstate" requires a list of states with no spaces, e.g. ESTABLISHED,RELATED INVALID NEW ESTABLISHED RELATED UNTRACKED SNAT DNAT Bad ctstatus "%s" NONE EXPECTED SEEN_REPLY ASSURED conntrack: At least one option is required ctstate ctproto ctorigsrc ctorigdst ctreplsrc ctrepldst ctstatus ctexpire  %sctproto %u ctorigsrcport ctorigdstport ctreplsrcport ctrepldstport %u %u:%u  anywhere  %s%s %u  %s%s %u:%u conntrack rev 1 does not support port ranges conntrack: rule would never match protocol ORIGINAL REPLY --ctdir CONFIRMED ctdir conntrack rev 2 does not support port ranges  state   --state  "--state" requires a list of states with no spaces, e.g. ESTABLISHED,RELATED Bad state "%s" cpu  cpu %s%u !  %s --cpu %u devgroup Warning: %s: %s
  %ssrc-group   %sdst-group  0x%x/0x%x 0x%x Bad group value "%s" Device group "%s" not found devgroup match: You must specify either '--src-group' or '--dst-group' src-group dst-group dscp  DSCP match %s0x%02x %s --dscp 0x%02x DSCP match: Parameter --dscp is required dscp-class ecn  ECN match  %sECE  %sCWR  %sECT=%d  --ecn-tcp-ece  --ecn-tcp-cwr  --ecn-ip-ect %d ECN match: some option required ecn-tcp-cwr ecn-tcp-ece ecn-ip-ect esp  esp  Unknown invflags: 0x%X  %s:%s%u  %ss:%s%u:%u %s --espspi  espspi hashlimit hashlimit match options:
--hashlimit <avg>		max average match rate
                                [Packets per second unless followed by 
                                /sec /minute /hour /day postfixes]
--hashlimit-mode <mode>		mode is a comma-separated list of
					dstip,srcip,dstport,srcport
--hashlimit-name <name>		name for /proc/net/ipt_hashlimit/
[--hashlimit-burst <num>]	number to match in a burst, default %u
[--hashlimit-htable-size <num>]	number of hashtable buckets
[--hashlimit-htable-max <num>]	number of hashtable entries
[--hashlimit-htable-gcinterval]	interval between garbage collection runs
[--hashlimit-htable-expire]	after which time are idle entries expired?
  limit: avg  burst %u  mode  htable-size %u  htable-max %u  htable-gcinterval %u  htable-expire %u  %f  %u/%s day hour min srcip srcport dstip dstport  --hashlimit  --hashlimit-burst %u  --hashlimit-mode  --hashlimit-name %s  --hashlimit-htable-size %u  --hashlimit-htable-max %u  --hashlimit-htable-gcinterval %u  --hashlimit-htable-expire %u --hashlimit-upto --hashlimit-mode second minute Rate too fast "%s"
 ,| You have to specify --hashlimit hashlimit-burst hashlimit-htable-size hashlimit-htable-max hashlimit-htable-gcinterval hashlimit-htable-expire hashlimit-mode hashlimit-name hashlimit match options:
  --hashlimit-upto <avg>           max average match rate
                                   [Packets per second unless followed by 
                                   /sec /minute /hour /day postfixes]
  --hashlimit-above <avg>          min average match rate
  --hashlimit-mode <mode>          mode is a comma-separated list of
                                   dstip,srcip,dstport,srcport (or none)
  --hashlimit-srcmask <length>     source address grouping prefix length
  --hashlimit-dstmask <length>     destination address grouping prefix length
  --hashlimit-name <name>          name for /proc/net/ipt_hashlimit
  --hashlimit-burst <num>	    number to match in a burst, default %u
  --hashlimit-htable-size <num>    number of hashtable buckets
  --hashlimit-htable-max <num>     number of hashtable entries
  --hashlimit-htable-gcinterval    interval between garbage collection runs
  --hashlimit-htable-expire        after which time are idle entries expired?

  limit: above  limit: up to  srcmask %u  dstmask %u  %llu%sb/s burst %llu%sb m k  --hashlimit-above  --hashlimit-upto --hashlimit-  --hashlimit-srcmask %u  --hashlimit-dstmask %u --hashlimit-above bad value for option "--hashlimit-burst", value "%s" too large (max %umb). bad value for option "--hashlimit-burst", or out of range (1-%u). b/s Rate value too large "%llu" (max %u)
 Rate too high "%s"
 burst cannot be smaller than %ub hashlimit-upto hashlimit-above hashlimit-srcmask hashlimit-dstmask  helper match %s"%s" %s --helper iprange  source IP range  destination IP range  %u.%u.%u.%u-%u.%u.%u.%u  --src-range  --dst-range --src-range --dst-range strdup xt_iprange: range %s-%s is reversed and will never match
 iprange match: You must specify `--src-range' or `--dst-range' src-range dst-range -%s  --src-range %s  --dst-range %s length  length %s %s --length  limit limit match options:
--limit avg			max average match rate: default 3/hour
                                [Packets per second unless followed by 
                                /sec /minute /hour /day postfixes]
--limit-burst number		number to match in a burst, default %u
 3/hour  --limit  --limit-burst %u bad rate "%s"' limit does not support invert limit-burst mac  MAC  %02X :%02X  --mac-source mac-source  MARK match  mark match multiport  multiport  sports  dports  ports  ERROR  tcp udp udplite sctp dccp  --sports   --dports   --ports  multiport.0 does not support invert multiport only works with TCP, UDP, UDPLITE, SCTP and DCCP multiport needs `-p tcp', `-p udp', `-p udplite', `-p sctp' or `-p dccp' strdup failed too many ports specified multiport expection an option source-ports sports destination-ports dports ports invalid portrange specified nfacct  %snfacct-name  Newlines not allowed in --nfacct-name nfacct-name osf  OS fingerprint match %s%s  --genre %s  --ttl %u  --log %u genre ttl log owner owner UID match owner GID match owner PID match owner SID match owner CMD match  %.*s --uid-owner --gid-owner --pid-owner --sid-owner --cmd-owner owner: At least one of --uid-owner, --gid-owner or --socket-exists is required uid-owner gid-owner pid-owner sid-owner cmd-owner owner socket exists  %u-%u --socket-exists socket-exists physdev  PHYSDEV match %s --physdev-is-in %s --physdev-in %s %s --physdev-is-out %s --physdev-out %s %s --physdev-is-bridged PHYSDEV: no physdev option specified physdev-in physdev-out physdev-is-in physdev-is-out physdev-is-bridged pkttype 	%-14s		%s
 unicast to us broadcast to all multicast to group bcast mcast host  PKTTYPE %s=  %d %s --pkt-type  Bad packet type '%s' pkt-type  policy match  [%u]  %sdir in  %sdir out  %spol none  %spol ipsec  %sstrict  %sreqid %u  %sspi 0x%x  %stunnel-dst %s%s  %stunnel-src %s%s  %sproto   %smode  transport tunnel ???  --next policy match: double --reqid option policy match: double --spi option policy match: double --tunnel-src option policy match: double --tunnel-dst option policy match: double --proto option policy match: protocol must be ah/esp/ipcomp policy match: double --mode option policy match: maximum policy depth reached policy_match: invalid dir "%s" none ipsec policy match: invalid policy "%s" policy match: invalid mode "%s" policy match: neither --dir in nor --dir out specified policy match: policy none but --strict given policy match: policy none but policy given policy match: empty policy element %u. --strict is in effect, but at least one of reqid, spi, tunnel-src, tunnel-dst, proto or mode is required. policy match: --tunnel-src/--tunnel-dst is only valid in tunnel mode dir pol strict reqid tunnel-src tunnel-dst mode next quota  quota: %llu bytes  --quota %llu quota2  counter  quota  %s:  %llu  packets  bytes  (no-change mode)   --grow   --no-change   --packets   --name %s   --quota %llu  grow no-change rateest rateest: rateest can't be inverted rateest: can't specify --rateest1 twice rateest: can't specify --rateest2 twice rateest: rateest-bps can't be inverted rateest: can't specify --rateest-bps1 twice rateest: could not parse rate `%s' rateest: rateest-pps can't be inverted rateest: can't specify --rateest-pps1 twice rateest: could not parse pps `%s' rateest: can't specify --rateest-bps2 twice rateest: can't specify --rateest-pps2 twice rateest: rateest-delta can't be inverted rateest: can't specify --rateest-delta twice rateest: can't specify lt/gt/eq twice bit Kibit kbit Mibit mbit Gibit gbit Tibit tbit Bps KiBps KBps MiBps MBps GiBps GBps TiBps TBps  rateest match   delta  bps  pps  %.0fMbit  %.0fKbit  %.0fbit  %seq  %slt  %sgt  --rateest-delta  --rateest1 %s  --rateest2 %s  --rateest %s bps pps  --rateest-%s1  --rateest-%s2  --rateest-%s rateest1 rateest2 rateest-bps1 rateest-pps1 rateest-bps2 rateest-pps2 rateest-bps rateest-pps rateest-delta rateest-lt rateest-gt rateest-eq rateest match: you need to specify some flags recent DEFAULT  recent:  SET  CHECK  UPDATE  REMOVE  seconds: %d  reap  hit_count: %d  TTL-Match  name: %s  side: source  side: dest  mask: %s  --set  --rcheck  --update  --remove  --seconds %d  --reap  --hitcount %d  --rttl  --name %s  --mask %s  --rsource  --rdest recent: you must specify one of `--set', `--rcheck' `--update' or `--remove' set rcheck update remove seconds reap hitcount rttl rsource rdest rpfilter  rpfilter loose validmark accept-local invert Only one `--source-port' allowed Only one `--destination-port' allowed Only one `--chunk-types' allowed --chunk-types requires two args invalid portrange (min > max) ANY ALL ONLY Match type has to be one of "ALL", "ANY" or "ONLY" Unknown sctp chunk `%s' Invalid flags for chunk type %d
 DATA ----IUBE INIT -------- INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT -------T SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN Number of chunk types with flags exceeds currently allowed limit.Increasing this limit involves changing IPT_NUM_SCTP_FLAGS andrecompiling both the kernel space and user space modules
  sctp spt dpt :%s s:%s  any  all  only  NONE  ALL 0x%04X  --sport %u:%u  --sport %u  --dport %u:%u  --dport %u  --chunk-types source-port destination-port chunk-types --set option deprecated, please use --match-set
 --match-set can be specified only once --match-set requires two args. You must specify `--match-set' with proper arguments match-set --match-set  return-nomatch  --return-nomatch return-nomatch only one of the --bytes-[eq|lt|gt] is allowed
 --bytes-gt option cannot be inverted
 --bytes-lt option cannot be inverted
 only one of the --packets-[eq|lt|gt] is allowed
 --packets-gt option cannot be inverted
 --packets-lt option cannot be inverted
 --return-nomatch flag cannot be inverted
 Cannot parse %s as a counter value
  %sreturn-nomatch  ! %supdate-counters  ! %supdate-subcounters  %s%s-eq %llu  ! %s%s-eq %llu  %s%s-lt %llu  %s%s-gt %llu update-counters packets-eq packets-lt packets-gt bytes-eq bytes-lt bytes-gt update-subcounters socket  socket  --transparent transparent  --nowildcard nowildcard  --restore-skmark restore-skmark standard statistic  statistic  %smode random%s %sprobability %.11f  %smode nth%s %severy %u  %spacket %u random nth Bad mode "%s" --probability must be specified when using random mode --every and --packet must be specified when using nth mode the --packet p must be 0 <= p <= n-1 probability every packet string  STRING match %s  ALGO name %s  FROM %u  TO %u  ICASE  "| %02x |"  " %s --hex-string %s --string  --algo %s  --from %u  --to %u  --icase Kernel doesn't support --icase STRING too long "%s" STRING must contain at least one char Cannot include literals in hex data Bad literal placement at end of string Odd number of hex digits Invalid hex block Invalid hex char '%c' %x Invalid hex char `%c' STRING match: You must specify `--string' or `--hex-string' from to algo hex-string icase Only one of `--syn' or `--tcp-flags'  allowed SYN,RST,ACK,FIN SYN --tcp-flags requires two args. Only one `--tcp-option' allowed Unknown TCP flag `%s' FIN RST PSH ACK URG Bad TCP option "%s"  tcp  option=%s%u  flags:%s 0x%02X/0x%02X  --tcp-option %u  --tcp-flags  syn tcp-flags tcp-option tcpmss  tcpmss match %s %s --mss  mss time  TIME  from %02u:%02u:%02u  to %02u:%02u:%02u  on  starting from  until date  UTC  contiguous ,%s Mon Tue Wed Thu Fri Sat Sun st nd rd th  %s %04u-%02u-%02uT%02u:%02u:%02u  %04u-%02u-%02u %02u:%02u:%02u  --timestart %02u:%02u:%02u  --timestop %02u:%02u:%02u  --monthdays  --weekdays --datestart --datestop  --kerneltz  --contiguous WARNING: --localtz is being replaced by --kerneltz, since "local" is ambiguous. Note the kernel timezone has caveats - see manpage for details.
 TZ UTC mktime mktime returned an error Invalid date "%s" specified. Should be YYYY[-MM[-DD[Thh[:mm[:ss]]]]] invalid time "%s" specified, should be hh:mm[:ss] format and within the boundaries %s is not a valid day for --monthdays %.*s No, the week does NOT begin with Sunday. %s is not a valid day specifier time: --contiguous only makes sense when stoptime is smaller than starttime datestart datestop timestart timestop contiguous weekdays monthdays localtz utc kerneltz tos                           (0x%02x) %2u %s
  tos match   --tos 0x%02x tos: Your kernel is too old to support anything besides /0xFF as a mask.  tos match 0x%02x/0x%02x  --tos 0x%02x/0x%02x u32  u32 && << >> 0x%x:0x%x  --u32 u32: abrupt end of input after location specifier u32: test ended with no value specified u32: at char %u: too many "&&"s u32: at char %u: location spec missing u32: at char %u: a second '<' was expected u32: at char %u: a second '>' was expected u32: at char %u: operator expected u32: at char %u: too many operators u32: at char %u: a second '&' was expected u32: at char %u: value spec missing u32: at char %u: expected "," or "&&" u32: at char %u: too many ","s u32: at char %d: not a number or out of range  udp  to:  random  persistent %hu -%hu  --to-destination   --random  --persistent DNAT: Multiple --to-destination not supported Invalid address format Need TCP, UDP, SCTP or DCCP with port specification Port `%s' not valid
 Invalid port:port syntax - use dash
 Port range `%s' funky
 Bad IP address "%s"
 to-destination persistent DNPT src-pfx %s/%u  dst-pfx %s/%u  --src-pfx %s/%u  --dst-pfx %s/%u  src-pfx dst-pfx HL  HL  set to decrement by increment by  --hl-set  --hl-dec  --hl-inc HL: You must specify an action hl-set hl-dec hl-inc LOG  LOG  flags %u level %u  level %s  UNKNOWN level %u  tcp-sequence  tcp-options  ip-options  uid  macdecode  unknown-flags  prefix "%s" alert crit debug emerg error info notice panic warning  --log-prefix  --log-level %d  --log-tcp-sequence  --log-tcp-options  --log-ip-options  --log-uid  --log-macdecode log-level log-prefix log-tcp-sequence log-tcp-options log-ip-options log-uid log-macdecode MASQUERADE  masq ports:   --to-ports %hu --to-ports to-ports NETMAP NETMAP target options:
  --%s address[/mask]
				Network address to map to.

  --%s  REDIRECT  redir ports   --to-ports  REJECT     %-25s	%s
     %-25s	alias
 icmp6-no-route no-route ICMPv6 no route icmp6-adm-prohibited adm-prohibited ICMPv6 administratively prohibited icmp6-addr-unreachable addr-unreach ICMPv6 address unreachable icmp6-port-unreachable port-unreach ICMPv6 port unreachable tcp-reset TCP RST packet  reject-with %s  --reject-with %s unknown reject type "%s" reject-with  --to-source  SNAT: Multiple --to-source not supported to-source SNPT ah  ah   reserved %s:%s%u %ss:%s%u:%u %s --ahspi  %s --ahlen %u  --ahres ahspi ahlen ahres dst match options:
[!] --dst-len length            total length of this header
  --dst-opts TYPE[:LEN][,TYPE[:LEN]...]
                                Options and its length (list, max: %d)
  dst  length:%s%u  opts :%d %s --dst-len %u  --dst-opts PAD0 hasn't got length too many addresses specified dst: no valid digits in %s `%s' %s `%s' specified too big: would overflow dst: error parsing %s `%s' dst-len dst-opts eui64 frag  frag  id  first  more  last :%s%u s:%s%u:%u %s --fragid  %s --fraglen %u  --fragres  --fragfirst  --fragmore  --fraglast fragid fraglen fragres fragfirst fragmore fraglast hbh hbh match options:
[!] --hbh-len length            total length of this header
  --hbh-opts TYPE[:LEN][,TYPE[:LEN]...] 
                                Options and its length (list, max: %d)
  hbh  length %s --hbh-len %u  --hbh-opts PAD0 has not got length hbh: no valid digits in %s `%s' hbh: error parsing %s `%s' hbh-len hbh-opts hl == != <  HL match HL %s %u --hl-eq ! --hl-eq --hl-lt --hl-gt  %s %u HL match: You must specify one of `--hl-eq', `--hl-lt', `--hl-gt' hl-lt hl-gt hl-eq icmp6 Valid ICMPv6 Types:  (%s) 
   %s 
%s destination-unreachable communication-prohibited address-unreachable port-unreachable packet-too-big time-exceeded ttl-exceeded ttl-zero-during-transit ttl-zero-during-reassembly parameter-problem bad-header unknown-header-type unknown-option echo-request ping echo-reply pong router-solicitation router-advertisement neighbour-solicitation neighbor-solicitation neighbour-advertisement neighbor-advertisement redirect  ipv6-icmp type %u  code %u  codes %u-%u  --icmpv6-type %u /%u Ambiguous ICMPv6 type `%s': `%s' or `%s'? Invalid ICMPv6 type `%s'
 Invalid ICMPv6 code `%s'
 icmpv6-type ipv6header  ipv6header 0x%02X  soft hop-by-hop hop route auth prot 0 60 43 44 51 50 59 255 %s --header   --soft ip6t_ipv6header: cannot parse header names unknown header `%d' specified unknown header `%s' specified header soft mh Valid MH types: binding-refresh-request brr home-test-init hoti careof-test-init coti home-test hot careof-test cot binding-update bu binding-acknowledgement ba binding-error be  mh  --mh-type %u:%u  --mh-type %u Invalid MH type range (min > max) Invalid MH type `%s'
 mh-type rt rt match options:
[!] --rt-type type             match the type
[!] --rt-segsleft num[:num]    match the Segments Left field (range)
[!] --rt-len length            total length of this header
 --rt-0-res                    check the reserved field too (type 0)
 --rt-0-addrs ADDR[,ADDR...]   Type=0 addresses (list, max: %d)
 --rt-0-not-strict             List of Type=0 addresses not a strict list
  rt  type:%s%d segsleft  0-addrs  0-not-strict %c%s %s --rt-type %u %s --rt-segsleft  %s --rt-len %u  --rt-0-res  --rt-0-addrs  --rt-0-not-strict `--rt-type 0' required before `--rt-0-res' `--rt-type 0' required before `--rt-0-addrs' `--rt-0-addr ...' required before `--rt-0-not-strict' bad address: %s rt-type rt-segsleft rt-len rt-0-res rt-0-addrs rt-0-not-strict libiptc v%s. %u bytes.
 Table `%s'
 Hooks: pre/in/fwd/out/post = %x/%x/%x/%x/%x
 Underflows: pre/in/fwd/out/post = %x/%x/%x/%x/%x
 Permission denied (you must be root) Module is wrong version Table does not exist (do you need to insmod?) Chain is not empty Can't delete built-in chain Can't delete chain with references left Chain already exists Index of insertion too big Index of replacement too big Index of deletion too big Index of counter too big Loop found in table Target problem Bad rule (does a matching rule exist in that chain?) Bad built-in chain name Bad policy name Incompatible with this kernel iptables who? (do you need to insmod?) Will be implemented real soon.  I promise ;) Memory allocation problem No chain/target/match by that name FORWARD ERROR: NULL pointer chain_index[%d]
 ERROR: %d not a valid bsearch type
 ERROR: %d not a valid target)
 ERROR: bad type %i
 Entry %u (%lu):
 SRC IP:  DST IP:  Interface: `%s'/ to `%s'/ 
Protocol: %u
 TOS: %u
 Flags: %02X
 Invflags: %02X
 Counters: %llu packets, %llu bytes
 Cache: %08X
 Target name: `%s' [%u]
 verdict=%s
 NF_ACCEPT NF_DROP UNKNOWN verdict=%u
 error=`%s'
 ERROR: offset %u not an entry!
 Match name: `%s'
 XTABLES_LIBDIR IPTABLES_LIB_DIR IPTABLES_LIB_DIR is deprecated, use XTABLES_LIBDIR.
 IP6TABLES_LIB_DIR IP6TABLES_LIB_DIR is deprecated, use XTABLES_LIBDIR.
 libxtables: unhandled NFPROTO in %s
 xtables_set_nfproto %s: Illegal global params
 xtables_set_params ip[6]tables: calloc failed ip[6]tables: malloc failed ip[6]tables: realloc failed -q invalid port/service `%s' specified interface name `%s' must be shorter than IFNAMSIZ (%i) Warning: weird character in interface `%s' ('/' and ' ' are not allowed by the kernel).
 Invalid match name "%s" (%u chars max) icmpv6 ipv6-icmp Couldn't find match `%s'
 Couldn't find target `%s'
 %s: match %s<%u> is missing a version
 %s: match "%s" has version "%s", but "%s" is required.
 %s: match `%s' has invalid name
 %s: BUG: match %s has invalid protocol family
 %s: target %s<%u> is missing a version
 %s: target "%s" has version "%s", but "%s" is required.
 %s: target `%s' has invalid name
 %s: BUG: target %s has invalid protocol family
 %s: "%s" option may only be specified once %s: "%s" option cannot be inverted %s: Bad value for "%s" option: "%s" %s: At most one action is possible %u.%u.%u.%u Hostname too long :: icmp ipv6-mh all unknown protocol "%s" specified %llu  %8llu  %5llu  %lluK  %4lluK  %lluM  %4lluM  %lluG  %4lluG  %lluT  %4lluT  Unable to retrieve kernel version.
 %d.%d.%d ip_tables /proc/net/ip_tables_names libipt_ ip6_tables libip6t_ /proc/sys/kernel/modprobe %s: Extension %s uses invalid option value %d
 %s: match `%s' already registered.
 %s: match `%s' has invalid size %u.
 %s: Could not determine whether revision %u is supported, assuming it is.
 Could not open socket to kernel: %s
 getsockopt failed strangely: %s
 %s: target `%s' already registered.
 %s: target `%s' has invalid size %u.
 invalid mask `%s' specified host/network `%s' not found %s: option "--%s" can only be used once.
 %s: option "--%s" cannot be inverted.
 %s: option "--%s" requires an argument.
 Extension %s uses invalid ID %u
 %s: ptroff for "--%s" is non-zero but no XTOPT_PUT is specified. Oversight? %s: entry type of option "--%s" cannot be combined with XTOPT_PUT
 %s: option "--%s" points to a memory block of wrong size (expected %zu, got %zu)
 Extension does not know id %u
 %s: option "--%s" must be specified
 0x %s: bad value for option "--%s", or out of range (%ju-%ju).
 %s: memory block does not have proper size
 xtopt_parse_mint %s: Too many components for option "--%s" (max: %u)
 %s: bad value for option "--%s" near "%s", or out of range (0-%ju).
 %s: Argument to "--%s" has unexpected characters near "%s".
 %s: bad value for option "--%s", or out of range (%u-%u).
 Argument must have a minimum length of %u characters
 Argument must have a maximum length of %u characters
 Symbolic name "%s" is unknown Illegal value: "%s" %s: bad mark value for option "--%s", or out of range.
 %s: bad mask value for option "--%s", or out of range.
 %s: trailing garbage after value for option "--%s".
 log level "%s" unknown
 getaddrinfo: %s
 %s resolves to more than one address
 Port "%s" does not resolve to anything.
 xtopt_parse_mport %s: bad value for option "--%s", neither a valid network mask nor valid CIDR (%u-%u).
 ether %s: option "--%s" also requires "--%s".
 %s: option "--%s" cannot be used together with "--%s".
       <iptables-rules version="1.0">  </iptables-rules>                      <actions>                       <conditions>                    </conditions>            Commands:
Either long or short options are allowed.
  --append  -A chain		Append to chain
  --check   -C chain		Check for the existence of a rule
  --delete  -D chain		Delete matching rule from chain
  --delete  -D chain rulenum
				Delete rule rulenum (1 = first) from chain
  --insert  -I chain [rulenum]
				Insert in chain as rulenum (default 1=first)
  --replace -R chain rulenum
				Replace rule rulenum (1 = first) in chain
  --list    -L [chain [rulenum]]
				List the rules in a chain or all chains
  --list-rules -S [chain [rulenum]]
				Print the rules in a chain or all chains
  --flush   -F [chain]		Delete all rules in  chain or all chains
  --zero    -Z [chain [rulenum]]
				Zero counters in chain or all chains
  --new     -N chain		Create a new user-defined chain
  --delete-chain
            -X [chain]		Delete a user-defined chain
  --policy  -P chain target
				Change policy on chain to target
  --rename-chain
            -E old-chain new-chain
				Change chain name, (moving any references)
Options:
    --ipv4	-4		Error (line is ignored by ip6tables-restore)
    --ipv6	-6		Nothing (line is ignored by iptables-restore)
[!] --protocol	-p proto	protocol: by number or name, eg. `tcp'
[!] --source	-s address[/mask][,...]
				source specification
[!] --destination -d address[/mask][,...]
				destination specification
[!] --in-interface -i input name[+]
				network interface name ([+] for wildcard)
  --jump	-j target
				target for rule (may load target extension)
  --goto	-g chain
				jump to chain with no return
  --match	-m match
				extended match (may load extension)
  --numeric	-n		numeric output of addresses and ports
[!] --out-interface -o output name[+]
				network interface name ([+] for wildcard)
  --table	-t table	table to manipulate (default: `filter')
  --verbose	-v		verbose mode
  --wait	-w		wait for the xtables lock
  --line-numbers		print line numbers when listing
  --exact	-x		expand numbers (display exact values)
  --modprobe=<command>		try to insert modules using this command
  --set-counters PKTS BYTES	set the counter during insert/append
[!] --version	-V		print package version.       (ERROR obtaining refs)         AUDIT target options
  --type TYPE		Action type to be recorded. CHECKSUM target options
  --checksum-fill			Fill in packet checksum.            CLASSIFY target options:
--set-class MAJOR:MINOR    Set skb->priority value (always hexadecimal!)               CONNMARK target options:
  --set-mark value[/mask]       Set conntrack mark value
  --save-mark [--mask mask]     Save the packet nfmark in the connection
  --restore-mark [--mask mask]  Restore saved nfmark value           CONNMARK target options:
  --set-xmark value[/ctmask]    Zero mask bits and XOR ctmark with value
  --save-mark [--ctmask mask] [--nfmask mask]
                                Copy ctmark to nfmark using masks
  --restore-mark [--ctmask mask] [--nfmask mask]
                                Copy nfmark to ctmark using masks
  --set-mark value[/mask]       Set conntrack mark value
  --save-mark [--mask mask]     Save the packet nfmark in the connection
  --restore-mark [--mask mask]  Restore saved nfmark value
  --and-mark value              Binary AND the ctmark with bits
  --or-mark value               Binary OR  the ctmark with bits
  --xor-mark value              Binary XOR the ctmark with bits               CONNSECMARK target options:
  --save                   Copy security mark from packet to conntrack
  --restore                Copy security mark from connection to packet      CT target options:
 --notrack			Don't track connection
 --helper name			Use conntrack helper 'name' for connection
 --ctevents event[,event...]	Generate specified conntrack events for connection
 --expevents event[,event...]	Generate specified expectation events for connection
 --zone ID			Assign/Lookup connection in zone ID          CT target options:
 --notrack			Don't track connection
 --helper name			Use conntrack helper 'name' for connection
 --timeout name 		Use timeout policy 'name' for connection
 --ctevents event[,event...]	Generate specified conntrack events for connection
 --expevents event[,event...]	Generate specified expectation events for connection
 --zone ID			Assign/Lookup connection in zone ID               DSCP target options
  --set-dscp value		Set DSCP field in packet header to value
  		                This value can be in decimal (ex: 32)
               		or in hex (ex: 0x20)
  --set-dscp-class class	Set the DSCP field in packet header to the
				value represented by the DiffServ class value.
				This class may be EF,BE or any of the CSxx
				or AFxx classes.

				These two options are mutually exclusive !     HMARK target options, i.e. modify hash calculation by:
  --hmark-tuple [src|dst|sport|dport|spi|proto|ct][,...]
  --hmark-mod value		    nfmark modulus value
  --hmark-offset value		    Last action add value to nfmark

  --hmark-rnd			    Random see for hashing
 Alternatively, fine tuning of what will be included in hash calculation
  --hmark-src-prefix length	    Source address mask CIDR prefix
  --hmark-dst-prefix length	    Dest address mask CIDR prefix
  --hmark-sport-mask value	    Mask src port with value
  --hmark-dport-mask value	    Mask dst port with value
  --hmark-spi-mask value	    For esp and ah AND spi with value
  --hmark-sport value		    OR src port with value
  --hmark-dport value		    OR dst port with value
  --hmark-spi value		    For esp and ah OR spi with value
  --hmark-proto-mask value	    Mask Protocol with value               IDLETIMER target options:
 --timeout time	Timeout until the notification is sent (in seconds)
 --label string	Unique rule identifier
 --send_nl_msg		(0/1) Enable netlink messages, and show remaining time in sysfs. Defaults to 0.
           LED target options:
--led-trigger-id name           suffix for led trigger name
--led-delay ms                  leave the LED on for this number of
                                milliseconds after triggering.
--led-always-blink              blink on arriving packets, even if
                                the LED is already on.    MARK target options:
  --set-mark value                   Set nfmark value
  --and-mark value                   Binary AND the nfmark with value
  --or-mark  value                   Binary OR  the nfmark with value          MARK target options:
  --set-xmark value[/mask]  Clear bits in mask and XOR value into nfmark
  --set-mark value[/mask]   Clear bits in mask and OR value into nfmark
  --and-mark bits           Binary AND the nfmark with bits
  --or-mark bits            Binary OR the nfmark with bits
  --xor-mask bits           Binary XOR the nfmark with bits
       NFLOG target options:
 --nflog-group NUM		NETLINK group used for logging
 --nflog-range NUM		Number of byte to copy
 --nflog-threshold NUM		Message threshold of in-kernel queue
 --nflog-prefix STRING		Prefix string for log messages         NFQUEUE target options
  --queue-num value		Send packet to QUEUE number <value>.
  		                Valid queue numbers are 0-65535              --queue-balance first:last	Balance flows between queues <value> to <value>.     --queue-bypass		Bypass Queueing if no queue instance exists.
  --queue-cpu-fanout	Use current CPU (no hashing)                  --queue-cpu-fanout	Use current CPU (no hashing)               RATEEST target options:
  --rateest-name name		Rate estimator name
  --rateest-interval sec	Rate measurement interval in seconds
  --rateest-ewmalog value	Rate measurement averaging time constant             SECMARK target options:
  --selctx value                     Set the SELinux security context   SET target options:
 --add-set name flags
 --del-set name flags
		add/del src/dst IP/port from/to named sets,
		where flags are the comma separated list of
		'src' and 'dst' specifications.   SET target options:
 --add-set name flags [--exist] [--timeout n]
 --del-set name flags
		add/del src/dst IP/port from/to named sets,
		where flags are the comma separated list of
		'src' and 'dst' specifications.           TEE target options:
  --gateway IPADDR    Route packet via the gateway given by address
  --oif NAME          Include oif in route calculation
 TOS target options:
  --set-tos value     Set Type of Service/Priority field to value
  --set-tos symbol    Set TOS field (IPv4 only) by symbol
                      Accepted symbolic names for value are:    
  --and-tos bits          Binary AND the TOS value with bits
  --or-tos  bits          Binary OR the TOS value with bits
  --xor-tos bits          Binary XOR the TOS value with bits          TPROXY target options:
  --on-port port		    Redirect connection to port, or the original port if 0
  --on-ip ip			    Optionally redirect to the given IP
  --tproxy-mark value[/mask]	    Mark packets with the given value/mask
             Address type match options:
 [!] --src-type type[,...]      Match source address type
 [!] --dst-type type[,...]      Match destination address type

Valid types:              Address type match options:
 [!] --src-type type[,...]      Match source address type
 [!] --dst-type type[,...]      Match destination address type
     --limit-iface-in           Match only on the packet's incoming device
     --limit-iface-out          Match only on the packet's outgoing device

Valid types:                        bpf match options:
--bytecode <program>	: a bpf program as generated by
  `nfbpf_compiler RAW <filter>`         cluster match options:
  --cluster-total-nodes <num>		Set number of total nodes in cluster
  [!] --cluster-local-node <num>	Set the local node number
  [!] --cluster-local-nodemask <num>	Set the local node mask
  --cluster-hash-seed <num>		Set seed value of the Jenkins hash              comment match options:
--comment COMMENT             Attach a comment to a rule connbytes match options:
 [!] --connbytes from:[to]
     --connbytes-dir [original, reply, both]
     --connbytes-mode [packets, bytes, avgpkt] connlimit match options:
  --connlimit-upto n     match if the number of existing connections is 0..n
  --connlimit-above n    match if the number of existing connections is >n
  --connlimit-mask n     group hosts using prefix length (default: max len)
  --connlimit-saddr      select source address for grouping
  --connlimit-daddr      select destination addresses for grouping     connmark match options:
[!] --mark value[/mask]    Match ctmark value with optional mask        conntrack match options:
[!] --ctstate {INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED|SNAT|DNAT}[,...]
                               State(s) to match
[!] --ctproto proto            Protocol to match; by number or name, e.g. "tcp"
[!] --ctorigsrc address[/mask]
[!] --ctorigdst address[/mask]
[!] --ctreplsrc address[/mask]
[!] --ctrepldst address[/mask]
                               Original/Reply source/destination address
[!] --ctorigsrcport port
[!] --ctorigdstport port
[!] --ctreplsrcport port
[!] --ctrepldstport port
                               TCP/UDP/SCTP orig./reply source/destination port
[!] --ctstatus {NONE|EXPECTED|SEEN_REPLY|ASSURED|CONFIRMED}[,...]
                               Status(es) to match
[!] --ctexpire time[:time]     Match remaining lifetime in seconds against
                               value or range of values (inclusive)
    --ctdir {ORIGINAL|REPLY}   Flow direction of packet        state match options:
 [!] --state [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED][,...]
				State(s) to match       cpu match options:
[!] --cpu number   Match CPU number          devgroup match options:
[!] --src-group value[/mask]	Match device group of incoming device
[!] --dst-group value[/mask]	Match device group of outgoing device   dscp match options
[!] --dscp value		Match DSCP codepoint with numerical value
  		                This value can be in decimal (ex: 32)
               		or in hex (ex: 0x20)
[!] --dscp-class name		Match the DiffServ class. This value may
				be any of the BE,EF, AFxx or CSx classes

				These two options are mutually exclusive !     ECN match options
[!] --ecn-tcp-cwr 		Match CWR bit of TCP header
[!] --ecn-tcp-ece		Match ECE bit of TCP header
[!] --ecn-ip-ect [0..3]	Match ECN codepoint in IPv4/IPv6 header                esp match options:
[!] --espspi spi[:spi]
				match spi (range) helper match options:
[!] --helper string        Match helper identified by string              iprange match options:
[!] --src-range ip[-ip]    Match source IP in the specified range
[!] --dst-range ip[-ip]    Match destination IP in the specified range length match options:
[!] --length length[:length]    Match packet length against value or range
                                of values (inclusive)          mac match options:
[!] --mac-source XX:XX:XX:XX:XX:XX
				Match source MAC address              mark match options:
[!] --mark value[/mask]    Match nfmark value with optional mask            multiport match options:
 --source-ports port[,port,port...]
 --sports ...
				match source port(s)
 --destination-ports port[,port,port...]
 --dports ...
				match destination port(s)
 --ports port[,port,port]
				match both source and destination port(s)
 NOTE: this kernel does not support port ranges in multiport.  multiport match options:
[!] --source-ports port[,port:port,port...]
 --sports ...
				match source port(s)
[!] --destination-ports port[,port:port,port...]
 --dports ...
				match destination port(s)
[!] --ports port[,port:port,port]
				match both source and destination port(s)        nfacct match options:
 --nfacct-name STRING		Name of accouting area             OS fingerprint match options:
[!] --genre string     Match a OS genre by passive fingerprinting.
--ttl level            Use some TTL check extensions to determine OS:
       0                       true ip and fingerprint TTL comparison. Works for LAN.
       1                       check if ip TTL is less than fingerprint one. Works for global addresses.
       2                       do not compare TTL at all. Allows to detect NMAP, but can produce false results.
--log level            Log determined genres into dmesg even if they do not match desired one:
       0                       log all matched or unknown signatures.
       1                       log only first one.
       2                       log all known matched signatures.  owner match options:
[!] --uid-owner userid       Match local UID
[!] --gid-owner groupid      Match local GID
[!] --pid-owner processid    Match local PID
[!] --sid-owner sessionid    Match local SID
[!] --cmd-owner name         Match local command name
NOTE: PID, SID and command matching are broken on SMP            owner match options:
[!] --uid-owner userid       Match local UID
[!] --gid-owner groupid      Match local GID
[!] --pid-owner processid    Match local PID
[!] --sid-owner sessionid    Match local SID
NOTE: PID and SID matching are broken on SMP           owner match options:
[!] --uid-owner userid[-userid]      Match local UID
[!] --gid-owner groupid[-groupid]    Match local GID
[!] --socket-exists                  Match if socket exists      physdev match options:
 [!] --physdev-in inputname[+]		bridge port name ([+] for wildcard)
 [!] --physdev-out outputname[+]	bridge port name ([+] for wildcard)
 [!] --physdev-is-in			arrived on a bridge device
 [!] --physdev-is-out			will leave on a bridge device
 [!] --physdev-is-bridged		it's a bridged packet        pkttype match options:
[!] --pkt-type packettype    match packet type           Valid packet types:             policy match options:
  --dir in|out			match policy applied during decapsulation/
				policy to be applied during encapsulation
  --pol none|ipsec		match policy
  --strict 			match entire policy instead of single element
				at any position
These options may be used repeatedly, to describe policy elements:
[!] --reqid reqid		match reqid
[!] --spi spi			match SPI
[!] --proto proto		match protocol (ah/esp/ipcomp)
[!] --mode mode 		match mode (transport/tunnel)
[!] --tunnel-src addr/mask	match tunnel source
[!] --tunnel-dst addr/mask	match tunnel destination
  --next 			begin next element in policy      quota match options:
[!] --quota quota		quota (bytes)           quota match options:
    --grow           provide an increasing counter
    --no-change      never change counter/quota value for matching packets
    --name name      name for the file in sysfs
[!] --quota quota    initial quota (bytes or packets)
    --packets        count packets instead of bytes    rateest match options:
 --rateest1 name		Rate estimator name
 --rateest2 name		Rate estimator name
 --rateest-delta		Compare difference(s) to given rate(s)
 --rateest-bps1 [bps]		Compare bps
 --rateest-pps1 [pps]		Compare pps
 --rateest-bps2 [bps]		Compare bps
 --rateest-pps2 [pps]		Compare pps
 [!] --rateest-lt		Match if rate is less than given rate/estimator
 [!] --rateest-gt		Match if rate is greater than given rate/estimator
 [!] --rateest-eq		Match if rate is equal to given rate/estimator              recent match options:
[!] --set                       Add source address to list, always matches.
[!] --rcheck                    Match if source address in list.
[!] --update                    Match if source address in list, also update last-seen time.
[!] --remove                    Match if source address in list, also removes that address from list.
    --seconds seconds           For check and update commands above.
                                Specifies that the match will only occur if source address last seen within
                                the last 'seconds' seconds.
    --reap                      Purge entries older then 'seconds'.
                                Can only be used in conjunction with the seconds option.
    --hitcount hits             For check and update commands above.
                                Specifies that the match will only occur if source address seen hits times.
                                May be used in conjunction with the seconds option.
    --rttl                      For check and update commands above.
                                Specifies that the match will only occur if the source address and the TTL
                                match between this packet and the one which was set.
                                Useful if you have problems with people spoofing their source address in order
                                to DoS you via this module.
    --name name                 Name of the recent list to be used.  DEFAULT used if none given.
    --rsource                   Match/Save the source address of each packet in the recent list table (default).
    --rdest                     Match/Save the destination address of each packet in the recent list table.
    --mask netmask              Netmask that will be applied to this recent list.
xt_recent by: Stephen Frost <sfrost@snowman.net>.  http://snowman.net/projects/ipt_recent/ rpfilter match options:
    --loose          permit reverse path via any interface
    --validmark      use skb nfmark when performing route lookup
    --accept-local   do not reject packets with a local source address
    --invert         match packets that failed the reverse path test sctp match options
[!] --source-port port[:port]                          match source port(s)
 --sport ...
[!] --destination-port port[:port]                     match destination port(s)
 --dport ...
[!] --chunk-types (all|any|none) (chunktype[:flags])+	match if all, any or none of
						        chunktypes are present
chunktypes - DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN ALL NONE               Never reach here                set match options:
 [!] --match-set name flags
		 'name' is the set name from to match,
		 'flags' are the comma separated list of
		 'src' and 'dst' specifications.           set match options:
 [!] --match-set name flags [--return-nomatch]
		 'name' is the set name from to match,
		 'flags' are the comma separated list of
		 'src' and 'dst' specifications.        set match options:
 [!] --match-set name flags [--return-nomatch]
   [! --update-counters] [! --update-subcounters]
   [[!] --packets-eq value | --packets-lt value | --packets-gt value
   [[!] --bytes-eq value | --bytes-lt value | --bytes-gt value
		 'name' is the set name from to match,
		 'flags' are the comma separated list of
		 'src' and 'dst' specifications.  socket match options:
  --transparent    Ignore non-transparent sockets
        socket match options:
  --nowildcard     Do not ignore LISTEN sockets bound on INADDR_ANY
  --transparent    Ignore non-transparent sockets
    socket match options:
  --nowildcard     Do not ignore LISTEN sockets bound on INADDR_ANY
  --transparent    Ignore non-transparent sockets
  --restore-skmark Set the packet mark to the socket mark if
                   the socket matches and transparent / 
                   nowildcard conditions are satisfied
       standard match options:
(If target is DROP, ACCEPT, RETURN or nothing)          statistic match options:
 --mode mode                    Match mode (random, nth)
 random mode:
[!] --probability p		 Probability
 nth mode:
[!] --every n			 Match every nth packet
 --packet p			 Initial counter value (0 <= p <= n-1, default 0)            string match options:
--from                       Offset to start searching from
--to                         Offset to stop searching
--algo                       Algorithm
--icase                      Ignore case (default: 0)
[!] --string string          Match a string in a packet
[!] --hex-string string      Match a hex string in a packet        tcp match options:
[!] --tcp-flags mask comp	match when TCP flags & mask == comp
				(Flags: SYN ACK FIN RST URG PSH ALL NONE)
[!] --syn			match when only SYN flag set
				(equivalent to --tcp-flags SYN,RST,ACK,FIN SYN)
[!] --source-port port[:port]
 --sport ...
				match source port(s)
[!] --destination-port port[:port]
 --dport ...
				match destination port(s)
[!] --tcp-option number        match if TCP option set            tcpmss match options:
[!] --mss value[:value]	Match TCP MSS range.
				(only valid for TCP SYN or SYN/ACK packets)              time match options:
    --datestart time     Start and stop time, to be given in ISO 8601
    --datestop time      (YYYY[-MM[-DD[Thh[:mm[:ss]]]]])
    --timestart time     Start and stop daytime (hh:mm[:ss])
    --timestop time      (between 00:00:00 and 23:59:59)
[!] --monthdays value    List of days on which to match, separated by comma
                         (Possible days: 1 to 31; defaults to all)
[!] --weekdays value     List of weekdays on which to match, sep. by comma
                         (Possible days: Mon,Tue,Wed,Thu,Fri,Sat,Sun or 1 to 7
                         Defaults to all weekdays.)
    --kerneltz           Work with the kernel timezone instead of UTC     tos match options:
[!] --tos value[/mask]    Match Type of Service/Priority field value
[!] --tos symbol          Match TOS field (IPv4 only) by symbol
                          Accepted symbolic names for value are:        u32 match options:
[!] --u32 tests
		tests := location "=" value | tests "&&" location "=" value
		value := range | value "," range
		range := number | number ":" number
		location := number | location operator number
		operator := "&" | "<<" | ">>" | "@" udp match options:
[!] --source-port port[:port]
 --sport ...
				match source port(s)
[!] --destination-port port[:port]
 --dport ...
				match destination port(s)            DNAT target options:
 --to-destination [<ipaddr>[-<ipaddr>]][:port[-port]]
				Address to map destination to.
[--random] [--persistent]         DNPT target options:
 --src-pfx prefix/length
 --dst-pfx prefix/length
         HL target options
  --hl-set value		Set HL to <value 0-255>
  --hl-dec value		Decrement HL by <value 1-255>
  --hl-inc value		Increment HL by <value 1-255>     LOG target options:
 --log-level level		Level of logging (numeric or see syslog.conf)
 --log-prefix prefix		Prefix log messages with this prefix.
 --log-tcp-sequence		Log TCP sequence numbers.
 --log-tcp-options		Log TCP options.
 --log-ip-options		Log IP options.
 --log-uid			Log UID owning the local socket.
 --log-macdecode		Decode MAC addresses and protocol.     MASQUERADE target options:
 --to-ports <port>[-<port>]
				Port (range) to map to.
 --random
				Randomize source port.         REDIRECT target options:
 --to-ports <port>[-<port>]
				Port (range) to map to.
 [--random]    REJECT target options:
--reject-with type              drop input packet and send back
                                a reply packet according to type:        Valid reject types:             SNAT target options:
 --to-source [<ipaddr>[-<ipaddr>]][:port[-port]]
				Address to map source to.
[--random] [--persistent]   SNPT target options:
 --src-pfx prefix/length
 --dst-pfx prefix/length
         ah match options:
[!] --ahspi spi[:spi]          match spi (range)
[!] --ahlen length             total length of this header
 --ahres                       check the reserved field too       frag match options:
[!] --fragid id[:id]           match the id (range)
[!] --fraglen length           total length of this header
 --fragres                     check the reserved field too
 --fragfirst                   matches on the first fragment
 [--fragmore|--fraglast]       there are more fragments or this
                               is the last one      hl match options:
[!] --hl-eq value	Match hop limit value
  --hl-lt value	Match HL < value
  --hl-gt value	Match HL > value     icmpv6 match options:
[!] --icmpv6-type typename	match icmpv6 type
				(or numeric type or type/code)           ipv6header match options:
[!] --header headers     Type of header to match, by name
                         names: hop,dst,route,frag,auth,esp,none,proto
                    long names: hop-by-hop,ipv6-opts,ipv6-route,
                                ipv6-frag,ah,esp,ipv6-nonxt,protocol
                       numbers: 0,60,43,44,51,50,59
--soft                    The header CONTAINS the specified extensions     mh match options:
[!] --mh-type type[:type]	match mh type   <(0$$$d$$$$$$$$$$$<$Xt<$$`$$$`$$$$($P$t$$$$$$$$$$$H $$$$$$8hIDDRALFZNXPESZCnsdpjvxio0cx     x  x x     x  xxxxxxx xxxxxx     x  x x     x  x  xxxx  xx xxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxx xxxxx xxxxxxxxxx xxxxxx     x  xx              (HH@8D\x(4p      @@    .A          eA      A       >L++p++==>$>DDDDX,XPXX@XL[[[[\8\t]t]t]t]`\\ppq@qtqqqr\rrr shs/etc/iproute2/group_map  4TlLd|Hd(L T$\`LXdpD xt     ,|T            Q              p''''''(***D;L;X;d;                $K|KXKdKpKK                Pffffff <@+ ,32;P$Xxp($8lL                _-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ "\'    t                                                                                                                                                       alert   crit    debug   emerg    error   info    notice  panic    warning                                                                             zR |           |}           ,   4   p}   d
      d   H    L   $          P
       ,      p   X
       $          T
   4        `
           $   <      P
          d  P    L   $        T
       $     T   P
            x    L   $        T
   $     (   X
      D             ,   \     \
   ,     ,   \
       4        d
           $     D   P
       $          T
          D  xt    L   ,   d      X
            h    L        h    L   ,         X
       $         X
   ,   ,  /   `
      \  \h    L   ,   |  L   `
           H                                            l    L        @              4      L      T                l                  tD    L                        (    L                                        <    L      ,             $   D      T
          l  $                                                    L            L        \|    L        8    X          4                L                d                |  X           $         L                                                xp    L        p    L      ,  H    L      L  @4    T          l  T                L                @   L        4   L             L                      	  xH   L      4	  $   L      T	                 l	                	             ,   	  8   `
      	                	                	  4    L      
             $   4
      T
      \
  $4    T          |
  8              
  0              
  $    L      
  d    L      
                      H          $  |    L      D  d    L      d  T   L        @P   L   $     pX   T
   $        P
            0                $              $  H    L   $   D  @H    L              l  `                T                H    L            L   $     T    L                                              4   4    L      T  4    L      t  (\    L        d4    T            xd    L        d    L         `    L        @              ,  4`              D  |              \  x    L      |  4    T                                                                                             d    L   $   4      P
          \                t                  |                t                lP    L        $    H                            0              ,  0              D      L      d  P0    H            `l    L        l    L        <    L        	<    H            0	    L      $  	    L   $   D  	    L              l  
                
           $     
L   P
       $     L   P
                L   $     \   T
HI ,   4  \   X
HI            d                 |                  `    L        H`    L                                        t                lT    H          <  0    P          \  8    L      |  8    L                        |    L        48    L        L8    L        d              ,  X           $   D  X4   T
          l  d    H            d    L        d    L   ,     P@   `
   $     `D   X
   $   $  |$   T
       $   L  xd   T
       $   t  <   X
   ,     D   `
   4        `
                                              4  (              L  (              d  <    L        4    T                                                            `    L        T    L      ,  D`    L   $   L  T    L              t                      L        04    L        D                <X    L        t8    X          $      L      D                 \                t      L        T                 L                 @ @    L        ` X    L         X    L      $   @    L      D   X    L      d  (!D    L        L!@    L   $     l!X    L                !                !                !    H            !    L      <   "    L      \  x"t    L      |  "8    X            "    H            "    L        #    L        ,$    L        $    L      <  h%   L   $   \  &    P
       $     '   P
            8)                ,)                 ),    L        ,)8    L   $     D)    X
      D  <+4    T       $   d  P+    P
            +                +                +\    L        +P    L        ,|    L        `,    H          <  -              T  ,              l  ,                ,0    L         -                ,           $     ,    P
       $     -    P
          $  8.   L      D  /              \   0              t  0                0                0                0|                0    L        t1                `18    X          ,  x1              D  <2   L   $   d  ,3    P
            3                3                3d    L        3h    L        84D    L         \4`    L      <   4d    L   $   \   4D    L                 4                 4                 4                 4                 4            $      4    P
          $!  74    T       $   D!  7    T
          l!  H8    P   $   !  8,   T
       $   !  9    T
          !  :    P      !  :               "  :           $   ,"  :   T
          T"  l;               l"  t;              "  x;               "  ;              "  ;              "  p;               "  x;              "  |;              #  p;,    L      4#  |;,    L      T#  ;L    L      t#  ;L    L      #  ;@    L   $   #   <4   P
          #  >    L   $   #  >    T
          $$  P?    L   $   D$  ?0   P
       $   l$  @    P
       $   $  pA   T
      $  E    L   $   $  F   P
       $   %  K0   P
       $   ,%  L    P
          T%  L    L   $   t%  TM    P
          %  N    L      %  N              %  N              %  N(              &  N(           $   &  N4    L              D&  N              \&  N              t&  Nx    L      &  O              &  N           $   &  N    T
          &  O4    T       $   '  OX   P
       $   4'  P   T
          \'  Q              t'  Q              '  Q,              '  Q,           ,   '  Q    X
          '  R4    T          (  R              $(  R              <(  R    L      \(  ,S    L      |(  S    L      (  <T4    T          (  PT              (  DT              (  8T    L      )  T    L   $   ,)  4UL    L              T)  XU              l)  PU              )  HU           $   )  DU   P
       $   )  V   P
          )  X    L      *   YP    p          ,*  0Y              D*  (Y               \*  0Y              t*  $Y           $   *  YL   T
          *  <[D   H          *  `\               *  h\              +  \\           $   +  P\   P
       $   D+  ,]L   T
   ,   l+  P^,   X
       $   +  L_L   P
       $   +  pa   P
       $   +  `b`   P
       $   ,  d    P
          <,  le,    H          \,  xe              t,  le              ,  `e,              ,  teH    L      ,  e4    L      ,  e              ,  e              -  e    P      4-  Pf    P   $   T-  f    T
          |-  g4    T          -  g    L      -  h    L      -  4i              -  $i    L      .  i    L      4.  tj           $   L.  dj    T
   $   t.  (k   T
   $   .  l    P
          .  l              .  l              .  xlp    L      /  lp    L   $   4/  mX    L              \/  Hm              t/  <m              /  4m4    L      /  Hm    L      /  n   L      /  o    L   $   0  po8   P
          40  p              L0  tp              d0  hp    L      0  p    L   $   0  @q4    L              0  Lq              0  Dq              0  8qh    L      1  qD    L      <1  qd    L      \1  q              t1  q              1  q              1  q              1  q              1  q4    T          1  q              2  q              $2  q              <2  q              T2  q              l2  q              2  q              2  q              2  q              2  q           ,   2  q   \
   ,   3  r    X
       $   D3  s\   P
       $   l3  u    T
   ,   3  hvd   \
   ,   3  x   \
   $   3  |y8   P
       ,   4  {p   X
          L4  |              d4  |              |4  |4    L      4  |4    L   $   4  |`    L              4  }              4  }              5  |,              ,5  }|    L      L5  l}    L      l5  }              5  }              5  }    L      5  0~    L   $   5  ~   T
          6  P4    T          $6  d              <6  X    L      \6  x    L   $   |6     T
          6                6  h    L      6  `    L   $   6  X   T
       $   $7  L<   P
       $   L7  `   P
       $   t7  L$   P
       $   7  H   X
      7  0              7  $              7  (   L      8      L      48     L      T8  4    T          t8                 8      L      8  x    L      8      L   $   8  h   P
          9  L              ,9  D           ,   D9  8    X
       $   t9      T
   $   9  8   P
          9  D   H       ,   9      X
       $   :  @    T
      <:      L   ,   \:  4   T
              :                 :                :                :   <    L      :  @    L      ;  <              ,;  0              D;  $    L      d;      L   $   ;  0    L              ;                ;  |           $   ;  p   T
       $   <     P
          ,<     L      L<  D    d       $   l<     X
HI    <  ,    L   $   <     T
      <                <                =  <    L      ,=  $              D=                \=      L      |=  8    X          =  H    L      =                =                =                >                >  X   L      <>  L   L      \>  0              t>  $              >  4    L      >  ,              >  $x    L      >  |    L      ?                ?                4?             ,   L?  <   `
      |?      L      ?      L   $   ?  \    P
       $   ?     T
   4   @  th   `
              D@                \@             ,   t@  |   `
      @  0    P          @                @             $   @  l   T
      A                 4A                LA             $   dA     T
      A  `H    L      A  H    L      A             $   A     X
      B  X              $B  X           $   <B  Xt   T
       ,   dB  `   \
       ,   B     `
      B      L      B  4t              B                C                ,C  |D    L      LC                dC  <    L      C                C  X    L      C  L    L      C  P    L      C  D              D  8l    L      4D  `    L      TD  d    L      tD                D                D                D                D  4    L      D                E      L      ,E      H       $   LE  4    L              tE                E                E             $   E     T
   $   E  @   T
   ,   F      `
      <F  8    X          \F                tF                F             $   F     X
   ,   F  8<   X
       $   F  DL   T
   $   $G  h    P
       ,   LG     \
   $   |G  t   T
      G                G                G  p    L      G  p    L   $   H  hT    L              <H                TH                lH  |            $   H     X
   ,   H  T   \
       ,   H  @H   `
      I  XD    d          ,I  |T   L   ,   LI     \
   ,   |I     \
       $   I     T
          I                I      L      J  d    L      ,J  <    L      LJ  $h    L      lJ  l    L      J   @    L      J  @D    L      J  d              J  X              J  LD    L      K  p@    L   ,   <K     `
   4   lK  P   \
              K                K                K      L      K       L      L  `    L   $   4L     T
      \L  \\    H          |L                L                L  d    L      L  d    L   ,   L     X
          M  $           $   4M      P
          \M                tM                M  P    L      M      L   $   M  4`    L              M  l              N  `              $N  Tp    L      DN  d    L      dN  X    L      N   8    X          N  8              N  ,              N                 N  x   L      O  l    L      ,O      L      LO                dO                |O      L      O  |    L   $   O  T   T
          O                O                P      P      4P  d@    L   $   TP      L              |P                P                P      L      P  L    L   $   P     T
          Q             $   ,Q     P
          TQ  x               lQ  l \              Q   \           $   Q      P
          Q                Q  |              Q  pd    L   ,   R     X
          DR  t              \R  h              tR  \    L      R                R             $   R     P
          R      L      S  d    L      ,S                DS             ,   \S      X
       ,   S  	    X
       ,   S  d
   \
   ,   S      X
              T                4T                LT                dT             $   |T  d   T
      T     L      T      L      T  x              T  l           ,   U  d@   \
   ,   DU  t    X
       ,   tU  $   \
   $   U      X
      U                U                U  $              V  $              ,V  X    L      LV  8    X          lV             $   V      T
      V             $   V  T   T
      V  h    L      W  H    L   4   ,W  @   `
              dW                |W                W      L      W  h    L   ,   W     \
   ,   X   4   T
              4X  $           $   LX      T
      tX             $   X     T
      X  H|    L   $   X      P
       ,   X  \ ,   `
      ,Y  X!              DY  L!           ,   \Y  D!P   \
   ,   Y  d#   \
   ,   Y  $   X
       ,   Y  D'   `
   $   Z  .    T
   ,   DZ  @/   `
      tZ  5,    H       $   Z  5D   X
      Z  7P              Z  H7H              Z  x7h    L      [  7P              $[  7             D[  8P    H          d[  8    L   $   [  `9   T
   $   [  :   P
       $   [  <   T
   $   [  >   T
      $\  >           ,   <\  >   `
      l\  C              \  C,   L   $   \  D    P
          \   E    L      \  E    L      ]   F    L   $   ,]  F|   P
       ,   T]  G0   \
       $   ]  H    P
          ]  I`    L   $   ]  I   X
   $   ]  K   X
   $   ^  M    P
       ,   D^  DN8   `
      t^  LSd           $   ^  S0   T
   4   ^  TT   \
           $   ^  U    T
          _  PV<    L   ,   4_  lV   `
      d_  W    L      _  hXt    D         _  X    L      _  |Y,    H          _  Y,    H       $   `  Y   X
   ,   ,`  <[    \
       ,   \`  [   \
       ,   `  \$   \
          `  ]0    H       $   `  ]    X
   $   a  ^   T
   ,   ,a  _   X
       ,   \a  4c    X
          a  f   L      a  g<    L      a  g   L      a  pi<    L   $   b  ip    P
          4b  i   P      Tb  llL    L      tb  l    L      b  lD              b  (m    L      b  m           ,   b  m0   \
          c  p           $   ,c  p    T
          Tc  qT              lc  Tq    H     c  r<    L   ,   c  8rp   `
   $   c  xu|   X
   $   d  v   X
   $   ,d  $x    P
       $   Td  x0   T
          |d  z             d  {    P   $   d  |   X
   ,   d  ~x   \
   $   e  H   P
          4e      H          Te     P      te  8   H          e      P   ,   e     `
      e  H    L      f   (           $   f     X
   ,   Df  h   `
   $   tf  <    T
          f      L   $   f     T
          f  (,   P      g  4    P   ,   $g     \
       $   Tg      P
          |g  (@    L   $   g  H    T
       ,   g  X   \
       $   g  <   T
          h  <   L   $   <h     T
          dh  l           ;@  $08##$04&`'/@00205X5x677D9<@HxIJKL8LXPQD 0Ph lx(@`x \t,8 D8XxX @Xp`L\h |@`` P h@P@ P\0Ptpx,DP(PxXdp  @`(8XxL`  4 @8LPThdtx(@`(4d@p(HHh@ HPp (8Xph  8Xx(\D0P,P 4P<L\(,@<XHp\h0Ph<t0Hh(\(P h,`  (@`T0p0|H`@(@<` 0(<@HXx(@DXx0(@X`d (8@PXhxx@8`(DLl 8Ph<h @8t`L $@`	T
< @Xp8`$40HH(p\((@p8DP d @Xp`8HXl ,H p$0|8XpH!t" $H%p8(4)`)l)x))()H *h0*<*++, - -@.`.x|/40<0(102 2H2`2xh3304<4L440t5P|6p7@8L8X88p9(9P9h9(:l:::: ;(;@ ;XT;xh;x;;;;;; ;8;P;h=P>@ACHDx4GHHH H $I@IhIIIDJJJJ xK@L`MN NNO P(P@DQ`QR8TLUpV WHW`WxXYZ [,[[0H\P\p]]^^`_ cH$ehe|fg8iDi(Pi@`iXixiiij@kk0kHk`pXsdttLww8y`yxyyyyz z 4{@D{XT{pd{t{|~$~0~d~0t~H~h   @xht(<HL`\xx0Ph Hh(4x 0@|`D (,@8Xlx|` (@hpp(P| (@(Xx\ht0`4 (0DXTpd8x0PhXH(@XxPD 0Ppp0Pxt0h(t@Xp   @Ph\p$d 0P,p8DXd H`xTDP\ 0H$p@p (HhD$ (Ph$Hl0HHp $8,X8X,|8@ph !'(X)@)X)pX**p++p,.0/X122778(x9P:p:@;<=>0H?P,Ax4CDLIIJ84LpL,MNxOO(PHPh$QRSTV@@V`8WPX\_`0 aPbp$ccLffg`g0gPgh(kDkkLl4mpm0p`\rst w xy8 {`x|}~$8Hh8< @h|0 p dHxX\                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \           -\           1\     |     ;\     |     A\     |      P\     |      V\           h\                           a                     c       a                     d       a                    t       !a                    M                                       c                     b       a                     c       ]                     v       #c                     t       ]                     h       (c                     n       0c                     w       !a                    M       a                    T                                       q     
                                                                                      Iq                                                                                            q     
                                                                                      |r                                           r                                           r                                           r        	                                                                                   t                                          |r                                           $t                                          -t                                          5t                                          r                                           r                                           >t                                       Et                                       r        	                                                                                 ft                                            kt                                                                                           u                                             7u     
                                   t     
                                      t     
                                      u                                                                                        u                                             7u     
                                   u     
                                    t     
                                      t     
                                      u                                                                                        u             u            u            u            %u            -u            7u            >u            Cu            Nu     	       u             v                                     ?   v     
                                                                                     #v             'v            +v            /v            3v             7v     (       ;v     0       ?v     8       Cv             Fv     
       Kv            Pv            Uv            Zv            _v            dv            iv            nv            sv     "       xv     $       }v     &       v     .       y     
                                      y                                          y                                        y                                         y                      "                  z                                         z                      $                  *z                      &                  6z                      $                  @z                      ,                  Qz        	              0                  [z        
           
   4                 ez                      8                                                                  u                    
                      z     
              
                     z                                                                                         {     
                                     {     
                                      {                                                                                            |r                                           $t                                          -t                                                                                          t                                          |r                                           $t                                          -t                                          5t                                                                                          }                                         }     
                    @              }                                         }                                                                                        3~                                         =~                                          K~                                            X~                                                                                                
               
                           
                                          
                                                                                     c     
               
                                                                     n                    1       v                    2                                       n                    1       v                    2       u                     3       u                    4                                                                                                                                                                                                                                                                                                                                   
                           
                                                                                   /                                                                                          /                                       ?   6                                          >                                          E                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                      	     
                                                                                           
                                      	     
                                     W                                           f                                                                                                
                                                                                                           
                                                                               	                                       
                                                                          
               
                                                                      )                                           A     
                                     O     
                                                                                     R                   	                     a                  	                     q                                                                                                                                                                               >u                                                                                                
                                                                                                                                                                                                              #                                          -     
   
                                  6                                                                                               
                                                                                                                                                                                                              #                                          -     
   
                                  6                                          M                                          [                                          i                                          w        	                                  &     
                                                                                           
                                                                                                                                                                                                              #                                          -     
   
                                  6                                          M                                          [                                          i                                          w        	                                  &     
                                                                                           
                                                                                                                                                                                     
                                           
                                                                                                        	                  ?   	     
                                                                                    #v             'v            +v            /v            3v             7v     (       ;v     0       ?v     8       Cv             Fv     
       Kv            Pv            Uv            Zv            _v            dv            iv            nv            sv     "       xv     $       }v     &       v     .                                                                                                                                                                                                           	                                                                           
                                      o                                   '                                                  	                                         
              $                                        (                       
                                          
              
                                                                          
                                          
                                         
                                                                                                                           o     
                                                                                      	                                         
              $                                        (                       
                                           
              
                                                                           3    "      Q%    '     '	          '      /            1            '_            7u     
                                                                                         
                                           
                                                                                     )                                                                                           H     
                                                                           '                                                        3    "      Q%    '     '	          '                                                                                                >u                                                                                           ]     
                                     j     
                                     q     
                                         
                                         
                                                                                         
               
                                                                      4     
                                      :                      ,                 >                      (                                                                 )     
                                      3     
                                     =                   	                 G                   	                 Q     
              	                                                                     )     
                                      3     
                                     =                   	                 G                   	                                                                 )     
                                      3     
                                                                                                                                6     
               	                      A     
              	                      M                                           [                                           j                                                                                           	     
                                                                                                                                                                                                         
                                            
                                                                                                                            y                                                                                                                              y                                               
                                              	                                                                                 	                                                                                                                                                                                 A^     
                                    	                    	                                                                                                                                                                         &                           /                            <                            I                            V                            c                            o                            {                                                                                                         	                                                  ?            @          @@           0A         .A           A         eA!           pB'        mB,            @0           @6          @@;           `AA         ^AF            BL         eAQ           BW        B                0                                           4                                          ;                                          B                                          I                                        Q                                           V                                        _            	                               A^     
                 
                  d         	                                   l         
                                                                                   0                                           4                                          ;                                          B                                          I                                        Q                                           V                                        _            	                               A^     
                 
                  d         	                                   l         
                                   r                                                                                                                                                                                                                                                                                                                                             1       y                    1                           2       
y                    2                           3                                                                                                                                              
                                  "                 /     	            5     
            A                 L                 U                 ]                 o                 v                                                      1       0                    2                                                           1       0                    2                            3                                                           1       0                    2                            3                            4                           5                           6                           7                           8                           9                           0                            a                                                                                                                                                                                   :                                                                                                                                          :                                            W                                                                                                 
                                           	                                                    	                                                                                                          c                                          h                                        k     
              
                          
                                     p     
                                    {                                                                                                                1       y                    1                           2       
y                    2                            3                           4                           5                                                                                        $            (             S     ?                                                                                                               )     
                                       3     
                                      <     
                                      F     
                                      O                                            Z     
                                     c     
                                     m                                           u                                          y         	                                                                                                                                                                                                                 ?                                                   B     
                                                                                                          	                      y                    	                                         	                     
y                   	                                                                          
                                                                                                                                                                                                                                                                                                                  k                                        r                                      y                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                               "            (            -            4             :            D     
                                                                                                                                   h                                                                                           D     
                                                                                                                                   1     
                                                                                                                   0            ?     b     y                                                             t     
                                                                                                                                                                                                                                                                                                                                      	                                         	                                                                                                                 n                    	                      v     
                                                                                                          	                                         	                                                                                                             %                                            .                                                                                           w                    	                           
                                                                                                                                                                                       	                                                                                                                            _                              
                                                                                      N                       f                                                                                                                      2          A           N           S           ^           c           w                                                                  q     
                                      x                                                                                                         j                         j     <            +            ,            3            2       "     ;                                     <            +            ,            3            2            ;                        
                                                                                                                                                                                                                                                                !            /            X                    	                      `                   	                     l                   	                     s                                            |     
                                                                                                                                  t                 t            ?     t            W           '                                                                 (                                  P            )                 C     P            C     (     (       \     (            p     H                                                                                \                    &       !                    N                    h                (          |                    i     i          i     i              _     _      _     _     _     z                  B   C            a          
)  D   E       6            F            :            >                        n     :       u     :            2            3                   }                                                 pG     pG     pG     pG     H     H     H     H     K     L     M     PO     |P     TQ     4S     S     (T     U     tW     Y     LZ            G            V            j                                                     l            	                                        p                   	              o    h                                                             
       P      o                  =             G                           s              0     !                     @                          P                                 o           o    0      o           o                                                                                                           h     0     @     P                   `     p                             X9     f             8u     ?     e             h          ?     ?                     ?     t                          `               `     (     x     (          T     H     P     |     0          P                                         ?     ?     ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \     q\                             ]                     v       ]                     c       ]                     h                                       <j                    A       Cj                    D       Jj                    C       Pj                    I       Wj                    R       _j                    L       dj                    S       oj                    F       uj                    Z       zj                    N       j                    X       j                    E       H^                    P       j                    s       j                    d       j                    s       j                    d       j                    p       j                    i       j                    j       a                    t       A_                    m       j                     n       j                    o       ]                     v       0c                     w       j                     x       j                     V       ]                    h       j                     0       !a                    M       k                    c       __                    g       k                     4       k                     6                                                       q\     p                  p             p                                   J                             J     DK                     K                                                                  p             q                                   0L                             <L     L                     L             0                                                     p             Wq                                   L                             L     M                     ,M                                                                  p             q                                   M     M                     M     N                     O     P                                                          p             q                                  HP     TP                     `P     \Q                     Q     P                                                           p             Lt                                   R                             R     S                     S     S                                                          p             t                     (               T                              T     4V                     @X                                                                  p             t                    H       @       X                             X     [                     @X                                                                  p             t                    H       @       X                             X     [     <]             @X                                                                  p             t     t             (                       \]                                                                                                                             p             t     t            H       @               \]                                                                                                                             p             t     t           H       @               h]                                                                                                                             p             t                                                                                                                                                                             p             u                                   ^                             ^     ^                     _     _                                                          p             v                    @       @       `                             `     `                     ,a     0a                                                          p             v               
     @       @       `                             a     b                     ,a     0a                                                          p             z                    0       (       ti                             i     i                     0?             0                                                     p             z                     (               j                             (j     j                     tk                                                                  p             {                                   ll                             xl     l                     l     <m                                                          p             {                                 ll                             pm     m                     8n     <m                                                          p             {                                  n                             n     o                     o     o     p                                                     p             }                     P       P       o     p                     p     p                     ,p                                                                  p             }                                   @q                             Lq     \q                     lq                                                                  p             }                                  q     q                     q     r                     Lr                                                                  p             }                                  r     q                     (s     s                      t                                                                  p             }                                  <t     q                     xt     t                     xu                                                                  p             ~                                    dv                             pv     w                     y     y     p                                                    p             $                                 |                             |     @}                     L             0                                                     p             j                    @       @       }     }     }      ~     P~     ~                                                                                          p             j                                  }     ~     ~      ~     L                                                                                               p             j                                                                                                                                                     p             {                                                                    <                     d                                                               p             {               
                                                     <                     d                                                                p                                (                                                  `                     0?                                                                  p                           
     (                                                                      0?                                                                  p                                               x                                   T                     d          @                                                     p                                                                                                                                                                     p             M                                  <                             H                                                                                            p             M                                   <                             8     x                                  P                                                     p             M              
                     <                                  T                                  P                                                     p                                                                                                                                                                                          p                                                                                                                                                             p                                                                                                      l                                                       p             v                                 4                             @     l                                                                            p                                                                                                       D                                                       p                                                                                                       0?                                                          p             )                                                                                                        @                                             p             ^                                   h     t                                                                                                       p             ^               
                    h     t                                                                                                       p             ^                                  h     t                                                                                                       p             ^              
                    h     t                                                                                                       p                                                                                                       x                                                           p                                                                                                                                                                 p                                 P       P                                                           0     0                                                  p                                                                           d                       |     0     0                                             p                           
                                                     <                  |     0     0                                             p                                                                                                       0     0                                             p                           
                                                     $                       0     0                                             p                                                                           @     `                  |     0                                                   p                           
                                                                       |     0                                                   p                                                                                                                p#                                             p                                                                                                  l             p#                                             p                                                                                                  l             p#                                             p                                                                                                                    p#                                             p                                                                                                                    #                                             p                                                X     d                                                          0$                                             p                                                |                                                                 $                                             p                                                                                                       l          &                                             p                                                \                             h                                       p'                                             p                                  @       0                                  $                               P     '                                            p                                8       0                                                                4     )                                            p                           
     8       0            x                                                    4     )                                            p             7u                     (               $                             0     \                                  `,                                             p                                                                                                                ,                                             p                                H       H                                                              T          ,                                             p                           
     H       H                                    \     4                               ,                                             p             )                                                                                                        P-                                             p             H                     (                                        8     ,                     4             -                                             p                                                                                                       (             .                                             p             >u                                   l                             x                                       .                                             p             >u                                  l                             $                                       .                                             p                                                                                                                  @/                                             p                            
                                                                             0          @/                                             p                                0       0       <                             H     \                     l          @/                                             p                           
     0       0       <                             |                                    @/                                             p                                  (               h                             t                                       `0                                             p                                 0       0       H                             T                                       0                                             p             B                    (       (                                         0                               1                                             p             B               
     (       (                                         X                               2                                             p             B                                                                                         \          3                                             p                                  H       H       D                             P     x                               P4                                             p             }                                                                h                                        p5                                             p             H^                    8      8                                          |!                     "     &     `6                                             p             H^               
     8      8                                    '     (                     "     &     `6                                             p             	                                   +                             ,     ,                     T,             p8                                             p             0                                   ,                             ,     d-                     -             8                                             p                                  H       8       .             .             <3     6             9             7                                                     p                                                L<     X<                     <     <                     <     l=     <                                             p                                              L<     =                     =     =                     <     l=      ?                                             p                           
                   L<     =                     >     >                     <     l=      ?                                             p             r                                   @                             @     A                     ,A             A                                             p             F                     (      (      XB     dB     |B             I     hJ             B                                                                     p             0                                    <P             HP     R     R     S             D                                                                     p             0                                  <P             S     R     T     T             D                                                                     p             0                                  T             T     R     0V     xV             PE                                                                     p             0                    0       0       V             V     R     Z     Z             E                                                                     p                                                                                                                                                                                 p                                               _                             _     0`                     H`             PG                                             p                                               `                             `     `                     4a             G                                             p                                               a                             a     a                     \b             @H                                             p             f                                   b                                                                                                                                     p             o                                   b                             b     $c                     4c     d      I                                             p                                                e     e                     e     hg                     (i     (m     I                                             p                                               e     e                     e     hg                     (i     (m     I                                             p             6                                   lm     xm     m             Hp     r             @K                                                                     p                                                x                             x     Py                     y             L                                             p                                                 z     ,z                     Lz     D|                     `~           M                                             p                                                                                 x                                  0O                                             p                                                                                                      0             O                                             p             B                                                                                                     O                                             p             :                                        xm                          8                                  PP                                             p                           
     (       (       d                             p                          8     (     @Q                                                     p                            
     (       "       D                             P                          D              R                                                     p                            
                                                     ,                               R                                                     p                            
                     ,     8                     D                          |             PS                                                     p                            
     (       (       D                             P                          T             `U                                                     p             M               
     (       (                                    (                                       U                                                     p                            
     (       (                                         \                                  PV                                                     p                            
                                                  x                                  V                                                     p                           
     (       (                                    p                               (     W                                                     p             ~               
     (       "                                    P                          D             X                                                     p                            
                                                                                       0Y                                             p             j               
     (       (       L                             \     |                     d             Y                                             p                            
                                                                                                                                                   p                            
                   P     \                     h                                       Z                                             p             7               
     (       (                                                                           [                                             p                            
                                                                           $     |     `\                                             p             #               
                                                                        h             ]                                             p                            
                                                     |                                  _                                             p             }               
                        P                     \     @                                  0a                                             p                            
                                                   4                                  b                                              GCC: (GNU) 4.9 20150123 (prerelease) Android clang version 3.8.256229  (based on LLVM 3.8.256229)     	      GNU gold 1.11    .shstrtab .interp .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .gnu.version .gnu.version_r .rela.dyn .rela.plt .text .rodata .eh_frame .eh_frame_hdr .preinit_array .init_array .fini_array .data.rel.ro .dynamic .got .got.plt .data .bss .comment .note.gnu.gold-version                                                                                  8      8                                                 P      P                                    '             h      h                                     :                         (                          B                         P                             J   o                     0                             T   o       0      0                                  a   o                     P                            p             p      p                                 z      B                   	                                                                                            x      x                                                \      \                                                @Z     @Z     xh                                                                                              0     0                                                @     @                                                P     P                                                `     `     Xl                                          h     X     0                                        j     Z                                               l     \     `                                           p      `     dl                                          h     d     |c                                  0               d     c                             	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * omap-usb-tll.c - The USB TLL driver for OMAP EHCI & OHCI
 *
 * Copyright (C) 2012-2013 Texas Instruments Incorporated - http://www.ti.com
 * Author: Keshava Munegowda <keshava_mgowda@ti.com>
 * Author: Roger Quadros <rogerq@ti.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2  of
 * the License as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/types.h>
#include <linux/slab.h>
#include <linux/spinlock.h>
#include <linux/platform_device.h>
#include <linux/clk.h>
#include <linux/io.h>
#include <linux/err.h>
#include <linux/pm_runtime.h>
#include <linux/platform_data/usb-omap.h>
#include <linux/of.h>

#define USBTLL_DRIVER_NAME	"usbhs_tll"

/* TLL Register Set */
#define	OMAP_USBTLL_REVISION				(0x00)
#define	OMAP_USBTLL_SYSCONFIG				(0x10)
#define	OMAP_USBTLL_SYSCONFIG_CACTIVITY			(1 << 8)
#define	OMAP_USBTLL_SYSCONFIG_SIDLEMODE			(1 << 3)
#define	OMAP_USBTLL_SYSCONFIG_ENAWAKEUP			(1 << 2)
#define	OMAP_USBTLL_SYSCONFIG_SOFTRESET			(1 << 1)
#define	OMAP_USBTLL_SYSCONFIG_AUTOIDLE			(1 << 0)

#define	OMAP_USBTLL_SYSSTATUS				(0x14)
#define	OMAP_USBTLL_SYSSTATUS_RESETDONE			(1 << 0)

#define	OMAP_USBTLL_IRQSTATUS				(0x18)
#define	OMAP_USBTLL_IRQENABLE				(0x1C)

#define	OMAP_TLL_SHARED_CONF				(0x30)
#define	OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN		(1 << 6)
#define	OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN		(1 << 5)
#define	OMAP_TLL_SHARED_CONF_USB_DIVRATION		(1 << 2)
#define	OMAP_TLL_SHARED_CONF_FCLK_REQ			(1 << 1)
#define	OMAP_TLL_SHARED_CONF_FCLK_IS_ON			(1 << 0)

#define	OMAP_TLL_CHANNEL_CONF(num)			(0x040 + 0x004 * num)
#define OMAP_TLL_CHANNEL_CONF_FSLSMODE_SHIFT		24
#define OMAP_TLL_CHANNEL_CONF_DRVVBUS			(1 << 16)
#define OMAP_TLL_CHANNEL_CONF_CHRGVBUS			(1 << 15)
#define	OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF		(1 << 11)
#define	OMAP_TLL_CHANNEL_CONF_ULPI_ULPIAUTOIDLE		(1 << 10)
#define	OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE		(1 << 9)
#define	OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE		(1 << 8)
#define OMAP_TLL_CHANNEL_CONF_MODE_TRANSPARENT_UTMI	(2 << 1)
#define OMAP_TLL_CHANNEL_CONF_CHANMODE_FSLS		(1 << 1)
#define	OMAP_TLL_CHANNEL_CONF_CHANEN			(1 << 0)

#define OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0		0x0
#define OMAP_TLL_FSLSMODE_6PIN_PHY_DP_DM		0x1
#define OMAP_TLL_FSLSMODE_3PIN_PHY			0x2
#define OMAP_TLL_FSLSMODE_4PIN_PHY			0x3
#define OMAP_TLL_FSLSMODE_6PIN_TLL_DAT_SE0		0x4
#define OMAP_TLL_FSLSMODE_6PIN_TLL_DP_DM		0x5
#define OMAP_TLL_FSLSMODE_3PIN_TLL			0x6
#define OMAP_TLL_FSLSMODE_4PIN_TLL			0x7
#define OMAP_TLL_FSLSMODE_2PIN_TLL_DAT_SE0		0xA
#define OMAP_TLL_FSLSMODE_2PIN_DAT_DP_DM		0xB

#define	OMAP_TLL_ULPI_FUNCTION_CTRL(num)		(0x804 + 0x100 * num)
#define	OMAP_TLL_ULPI_INTERFACE_CTRL(num)		(0x807 + 0x100 * num)
#define	OMAP_TLL_ULPI_OTG_CTRL(num)			(0x80A + 0x100 * num)
#define	OMAP_TLL_ULPI_INT_EN_RISE(num)			(0x80D + 0x100 * num)
#define	OMAP_TLL_ULPI_INT_EN_FALL(num)			(0x810 + 0x100 * num)
#define	OMAP_TLL_ULPI_INT_STATUS(num)			(0x813 + 0x100 * num)
#define	OMAP_TLL_ULPI_INT_LATCH(num)			(0x814 + 0x100 * num)
#define	OMAP_TLL_ULPI_DEBUG(num)			(0x815 + 0x100 * num)
#define	OMAP_TLL_ULPI_SCRATCH_REGISTER(num)		(0x816 + 0x100 * num)

#define OMAP_REV2_TLL_CHANNEL_COUNT			2
#define OMAP_TLL_CHANNEL_COUNT				3
#define OMAP_TLL_CHANNEL_1_EN_MASK			(1 << 0)
#define OMAP_TLL_CHANNEL_2_EN_MASK			(1 << 1)
#define OMAP_TLL_CHANNEL_3_EN_MASK			(1 << 2)

/* Values of USBTLL_REVISION - Note: these are not given in the TRM */
#define OMAP_USBTLL_REV1		0x00000015	/* OMAP3 */
#define OMAP_USBTLL_REV2		0x00000018	/* OMAP 3630 */
#define OMAP_USBTLL_REV3		0x00000004	/* OMAP4 */
#define OMAP_USBTLL_REV4		0x00000006	/* OMAP5 */

#define is_ehci_tll_mode(x)	(x == OMAP_EHCI_PORT_MODE_TLL)

/* only PHY and UNUSED modes don't need TLL */
#define omap_usb_mode_needs_tll(x)	((x) != OMAP_USBHS_PORT_MODE_UNUSED &&\
					 (x) != OMAP_EHCI_PORT_MODE_PHY)

struct usbtll_omap {
	int					nch;	/* num. of channels */
	struct clk				**ch_clk;
	void __iomem				*base;
};

/*-------------------------------------------------------------------------*/

static const char usbtll_driver_name[] = USBTLL_DRIVER_NAME;
static struct device	*tll_dev;
static DEFINE_SPINLOCK(tll_lock);	/* serialize access to tll_dev */

/*-------------------------------------------------------------------------*/

static inline void usbtll_write(void __iomem *base, u32 reg, u32 val)
{
	writel_relaxed(val, base + reg);
}

static inline u32 usbtll_read(void __iomem *base, u32 reg)
{
	return readl_relaxed(base + reg);
}

static inline void usbtll_writeb(void __iomem *base, u8 reg, u8 val)
{
	writeb_relaxed(val, base + reg);
}

static inline u8 usbtll_readb(void __iomem *base, u8 reg)
{
	return readb_relaxed(base + reg);
}

/*-------------------------------------------------------------------------*/

static bool is_ohci_port(enum usbhs_omap_port_mode pmode)
{
	switch (pmode) {
	case OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:
	case OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:
	case OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:
	case OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:
	case OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:
	case OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:
	case OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:
	case OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:
	case OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:
	case OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:
		return true;

	default:
		return false;
	}
}

/*
 * convert the port-mode enum to a value we can use in the FSLSMODE
 * field of USBTLL_CHANNEL_CONF
 */
static unsigned ohci_omap3_fslsmode(enum usbhs_omap_port_mode mode)
{
	switch (mode) {
	case OMAP_USBHS_PORT_MODE_UNUSED:
	case OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:
		return OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0;

	case OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:
		return OMAP_TLL_FSLSMODE_6PIN_PHY_DP_DM;

	case OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:
		return OMAP_TLL_FSLSMODE_3PIN_PHY;

	case OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:
		return OMAP_TLL_FSLSMODE_4PIN_PHY;

	case OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:
		return OMAP_TLL_FSLSMODE_6PIN_TLL_DAT_SE0;

	case OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:
		return OMAP_TLL_FSLSMODE_6PIN_TLL_DP_DM;

	case OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:
		return OMAP_TLL_FSLSMODE_3PIN_TLL;

	case OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:
		return OMAP_TLL_FSLSMODE_4PIN_TLL;

	case OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:
		return OMAP_TLL_FSLSMODE_2PIN_TLL_DAT_SE0;

	case OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:
		return OMAP_TLL_FSLSMODE_2PIN_DAT_DP_DM;
	default:
		pr_warn("Invalid port mode, using default\n");
		return OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0;
	}
}

/**
 * usbtll_omap_probe - initialize TI-based HCDs
 *
 * Allocates basic resources for this USB host controller.
 */
static int usbtll_omap_probe(struct platform_device *pdev)
{
	struct device				*dev =  &pdev->dev;
	struct resource				*res;
	struct usbtll_omap			*tll;
	int					ret = 0;
	int					i, ver;

	dev_dbg(dev, "starting TI HSUSB TLL Controller\n");

	tll = devm_kzalloc(dev, sizeof(struct usbtll_omap), GFP_KERNEL);
	if (!tll) {
		dev_err(dev, "Memory allocation failed\n");
		return -ENOMEM;
	}

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	tll->base = devm_ioremap_resource(dev, res);
	if (IS_ERR(tll->base))
		return PTR_ERR(tll->base);

	platform_set_drvdata(pdev, tll);
	pm_runtime_enable(dev);
	pm_runtime_get_sync(dev);

	ver =  usbtll_read(tll->base, OMAP_USBTLL_REVISION);
	switch (ver) {
	case OMAP_USBTLL_REV1:
	case OMAP_USBTLL_REV4:
		tll->nch = OMAP_TLL_CHANNEL_COUNT;
		break;
	case OMAP_USBTLL_REV2:
	case OMAP_USBTLL_REV3:
		tll->nch = OMAP_REV2_TLL_CHANNEL_COUNT;
		break;
	default:
		tll->nch = OMAP_TLL_CHANNEL_COUNT;
		dev_dbg(dev,
		 "USB TLL Rev : 0x%x not recognized, assuming %d channels\n",
			ver, tll->nch);
		break;
	}

	tll->ch_clk = devm_kzalloc(dev, sizeof(struct clk *) * tll->nch,
						GFP_KERNEL);
	if (!tll->ch_clk) {
		ret = -ENOMEM;
		dev_err(dev, "Couldn't allocate memory for channel clocks\n");
		goto err_clk_alloc;
	}

	for (i = 0; i < tll->nch; i++) {
		char clkname[] = "usb_tll_hs_usb_chx_clk";

		snprintf(clkname, sizeof(clkname),
					"usb_tll_hs_usb_ch%d_clk", i);
		tll->ch_clk[i] = clk_get(dev, clkname);

		if (IS_ERR(tll->ch_clk[i]))
			dev_dbg(dev, "can't get clock : %s\n", clkname);
		else
			clk_prepare(tll->ch_clk[i]);
	}

	pm_runtime_put_sync(dev);
	/* only after this can omap_tll_enable/disable work */
	spin_lock(&tll_lock);
	tll_dev = dev;
	spin_unlock(&tll_lock);

	return 0;

err_clk_alloc:
	pm_runtime_put_sync(dev);
	pm_runtime_disable(dev);

	return ret;
}

/**
 * usbtll_omap_remove - shutdown processing for UHH & TLL HCDs
 * @pdev: USB Host Controller being removed
 *
 * Reverses the effect of usbtll_omap_probe().
 */
static int usbtll_omap_remove(struct platform_device *pdev)
{
	struct usbtll_omap *tll = platform_get_drvdata(pdev);
	int i;

	spin_lock(&tll_lock);
	tll_dev = NULL;
	spin_unlock(&tll_lock);

	for (i = 0; i < tll->nch; i++) {
		if (!IS_ERR(tll->ch_clk[i])) {
			clk_unprepare(tll->ch_clk[i]);
			clk_put(tll->ch_clk[i]);
		}
	}

	pm_runtime_disable(&pdev->dev);
	return 0;
}

static const struct of_device_id usbtll_omap_dt_ids[] = {
	{ .compatible = "ti,usbhs-tll" },
	{ }
};

MODULE_DEVICE_TABLE(of, usbtll_omap_dt_ids);

static struct platform_driver usbtll_omap_driver = {
	.driver = {
		.name		= (char *)usbtll_driver_name,
		.owner		= THIS_MODULE,
		.of_match_table = usbtll_omap_dt_ids,
	},
	.probe		= usbtll_omap_probe,
	.remove		= usbtll_omap_remove,
};

int omap_tll_init(struct usbhs_omap_platform_data *pdata)
{
	int i;
	bool needs_tll;
	unsigned reg;
	struct usbtll_omap *tll;

	if (!tll_dev)
		return -ENODEV;

	pm_runtime_get_sync(tll_dev);

	spin_lock(&tll_lock);
	tll = dev_get_drvdata(tll_dev);
	needs_tll = false;
	for (i = 0; i < tll->nch; i++)
		needs_tll |= omap_usb_mode_needs_tll(pdata->port_mode[i]);

	if (needs_tll) {
		void __iomem *base = tll->base;

		/* Program Common TLL register */
		reg = usbtll_read(base, OMAP_TLL_SHARED_CONF);
		reg |= (OMAP_TLL_SHARED_CONF_FCLK_IS_ON
			| OMAP_TLL_SHARED_CONF_USB_DIVRATION);
		reg &= ~OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN;
		reg &= ~OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN;

		usbtll_write(base, OMAP_TLL_SHARED_CONF, reg);

		/* Enable channels now */
		for (i = 0; i < tll->nch; i++) {
			reg = usbtll_read(base,	OMAP_TLL_CHANNEL_CONF(i));

			if (is_ohci_port(pdata->port_mode[i])) {
				reg |= ohci_omap3_fslsmode(pdata->port_mode[i])
				<< OMAP_TLL_CHANNEL_CONF_FSLSMODE_SHIFT;
				reg |= OMAP_TLL_CHANNEL_CONF_CHANMODE_FSLS;
			} else if (pdata->port_mode[i] ==
					OMAP_EHCI_PORT_MODE_TLL) {
				/*
				 * Disable AutoIdle, BitStuffing
				 * and use SDR Mode
				 */
				reg &= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
					| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
				reg |= OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;
			} else if (pdata->port_mode[i] ==
					OMAP_EHCI_PORT_MODE_HSIC) {
				/*
				 * HSIC Mode requires UTMI port configurations
				 */
				reg |= OMAP_TLL_CHANNEL_CONF_DRVVBUS
				 | OMAP_TLL_CHANNEL_CONF_CHRGVBUS
				 | OMAP_TLL_CHANNEL_CONF_MODE_TRANSPARENT_UTMI
				 | OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;
			} else {
				continue;
			}
			reg |= OMAP_TLL_CHANNEL_CONF_CHANEN;
			usbtll_write(base, OMAP_TLL_CHANNEL_CONF(i), reg);

			usbtll_writeb(base,
				      OMAP_TLL_ULPI_SCRATCH_REGISTER(i),
				      0xbe);
		}
	}

	spin_unlock(&tll_lock);
	pm_runtime_put_sync(tll_dev);

	return 0;
}
EXPORT_SYMBOL_GPL(omap_tll_init);

int omap_tll_enable(struct usbhs_omap_platform_data *pdata)
{
	int i;
	struct usbtll_omap *tll;

	if (!tll_dev)
		return -ENODEV;

	pm_runtime_get_sync(tll_dev);

	spin_lock(&tll_lock);
	tll = dev_get_drvdata(tll_dev);

	for (i = 0; i < tll->nch; i++) {
		if (omap_usb_mode_needs_tll(pdata->port_mode[i])) {
			int r;

			if (IS_ERR(tll->ch_clk[i]))
				continue;

			r = clk_enable(tll->ch_clk[i]);
			if (r) {
				dev_err(tll_dev,
				 "Error enabling ch %d clock: %d\n", i, r);
			}
		}
	}

	spin_unlock(&tll_lock);

	return 0;
}
EXPORT_SYMBOL_GPL(omap_tll_enable);

int omap_tll_disable(struct usbhs_omap_platform_data *pdata)
{
	int i;
	struct usbtll_omap *tll;

	if (!tll_dev)
		return -ENODEV;

	spin_lock(&tll_lock);
	tll = dev_get_drvdata(tll_dev);

	for (i = 0; i < tll->nch; i++) {
		if (omap_usb_mode_needs_tll(pdata->port_mode[i])) {
			if (!IS_ERR(tll->ch_clk[i]))
				clk_disable(tll->ch_clk[i]);
		}
	}

	spin_unlock(&tll_lock);
	pm_runtime_put_sync(tll_dev);

	return 0;
}
EXPORT_SYMBOL_GPL(omap_tll_disable);

MODULE_AUTHOR("Keshava Munegowda <keshava_mgowda@ti.com>");
MODULE_AUTHOR("Roger Quadros <rogerq@ti.com>");
MODULE_ALIAS("platform:" USBHS_DRIVER_NAME);
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("usb tll driver for TI OMAP EHCI and OHCI controllers");

static int __init omap_usbtll_drvinit(void)
{
	return platform_driver_register(&usbtll_omap_driver);
}

/*
 * init before usbhs core driver;
 * The usbtll driver should be initialized before
 * the usbhs core driver probe function is called.
 */
fs_initcall(omap_usbtll_drvinit);

static void __exit omap_usbtll_drvexit(void)
{
	platform_driver_unregister(&usbtll_omap_driver);
}
module_exit(omap_usbtll_drvexit);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Copyright (C) 2015 MediaTek Inc.
 * Copyright (C) 2018 XiaoMi, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/device.h>
#include <linux/cpumask.h>
#include <linux/list.h>
#include <linux/printk.h>
#include <linux/platform_device.h>
#include <linux/kallsyms.h>
#include <linux/of_address.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <mt-plat/mt_chip.h>
#include <mt-plat/mt_debug_latch.h>
#include "lastbus.h"

static const struct of_device_id lastbus_of_ids[] = {
	{}
};

static int lastbus_probe(struct platform_device *pdev);
static int lastbus_remove(struct platform_device *pdev);
static int lastbus_suspend(struct platform_device *pdev, pm_message_t state);
static int lastbus_resume(struct platform_device *pdev);

static char *lastbus_dump_buf;

static struct lastbus lastbus_drv = {
	.plt_drv = {
		.driver = {
			.name = "lastbus",
			.bus = &platform_bus_type,
			.owner = THIS_MODULE,
			.of_match_table = lastbus_of_ids,
		},
		.probe = lastbus_probe,
		.remove = lastbus_remove,
		.suspend = lastbus_suspend,
		.resume = lastbus_resume,
	},
};

static int lastbus_probe(struct platform_device *pdev)
{
	struct lastbus_plt *plt = NULL;

	pr_debug("%s:%d: enter\n", __func__, __LINE__);

	plt = lastbus_drv.cur_plt;

	if (plt && plt->ops && plt->ops->probe)
		return plt->ops->probe(plt, pdev);

	lastbus_drv.mcu_base = of_iomap(pdev->dev.of_node, 0);
	lastbus_drv.peri_base = of_iomap(pdev->dev.of_node, 1);
	if (!lastbus_drv.mcu_base || !lastbus_drv.peri_base)
		return -ENODEV;

	return 0;
}

static int lastbus_remove(struct platform_device *pdev)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	pr_debug("%s:%d: enter\n", __func__, __LINE__);

	if (plt && plt->ops && plt->ops->remove)
		return plt->ops->remove(plt, pdev);

	return 0;
}

static int lastbus_suspend(struct platform_device *pdev, pm_message_t state)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	pr_debug("%s:%d: enter\n", __func__, __LINE__);

	if (plt && plt->ops && plt->ops->suspend)
		return plt->ops->suspend(plt, pdev, state);

	return 0;
}

static int lastbus_resume(struct platform_device *pdev)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	pr_debug("%s:%d: enter\n", __func__, __LINE__);

	if (plt && plt->ops && plt->ops->resume)
		return plt->ops->resume(plt, pdev);

	return 0;
}

int lastbus_register(struct lastbus_plt *plt)
{
	if (!plt) {
		pr_warn("%s%d: plt is NULL\n", __func__, __LINE__);
		return -EINVAL;
	}

	plt->common = &lastbus_drv;
	lastbus_drv.cur_plt = plt;

	return 0;
}

int lastbus_dump(char *buf, int len)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	if (!buf) {
		pr_warn("%s:%d: buf is NULL\n", __func__, __LINE__);
		return -EINVAL;
	}

	if (!plt) {
		pr_warn("%s:%d: plt is NULL\n", __func__, __LINE__);
		return -ENODEV;
	}

	if (!plt->common) {
		pr_warn("%s:%d: plt->common is NULL\n", __func__, __LINE__);
		return -ENODEV;
	}

	if (!plt->common->mcu_base)
		pr_warn("%s:%d: plt->common->mcu_base is NULL\n", __func__, __LINE__);

	if (!plt->common->peri_base)
		pr_warn("%s:%d: plt->common->peri_base is NULL\n", __func__, __LINE__);

	if (!plt->common->mcu_base && !plt->common->peri_base)
		return -ENODEV;

	if (plt->ops && plt->ops->dump)
		return plt->ops->dump(plt, buf, len);

	pr_warn("no dump function implemented\n");

	return 0;
}

int lastbus_enable(void)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	if (!plt) {
		pr_warn("%s:%d: plt is NULL\n", __func__, __LINE__);
		return -ENODEV;
	}

	if (!plt->common) {
		pr_warn("%s:%d: plt->common is NULL\n", __func__, __LINE__);
		return -ENODEV;
	}

	if (!plt->common->mcu_base)
		pr_warn("%s:%d: plt->common->mcu_base is NULL\n", __func__, __LINE__);

	if (!plt->common->peri_base)
		pr_warn("%s:%d: plt->common->peri_base is NULL\n", __func__, __LINE__);

	if (!plt->common->mcu_base && !plt->common->peri_base)
		return -ENODEV;

	if (plt->ops && plt->ops->enable)
		return plt->ops->enable(plt);

	pr_warn("no enable function implemented\n");

	return 0;
}

int lastbus_dump_min_len(void)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	if (!plt) {
		pr_warn("%s:%d: plt is NULL\n", __func__, __LINE__);
		return -ENODEV;
	}

	if (!plt->min_buf_len)
		pr_warn("%s:%d: min_buf_len is 0\n", __func__, __LINE__);

	return plt->min_buf_len;
}

int mt_lastbus_dump(char *buf)
{
	strncpy(buf, lastbus_dump_buf, strlen(lastbus_dump_buf)+1);
	return 0;
}

static ssize_t lastbus_dump_show(struct device_driver *driver, char *buf)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;
	int ret = 0;

	ret = plt->ops->dump(plt, buf, -1);
	if (ret)
		pr_err("%s:%d: dump failed\n", __func__, __LINE__);

	return strlen(buf);
}

static ssize_t lastbus_dump_store(struct device_driver *driver, const char *buf, size_t count)
{
	return count;
}

DRIVER_ATTR(lastbus_dump, 0664, lastbus_dump_show, lastbus_dump_store);

static ssize_t lastbus_test_show(struct device_driver *driver, char *buf)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	if (plt && plt->ops)
		return plt->ops->test_show(buf);

	return -ENODEV;
}

static ssize_t lastbus_test_store(struct device_driver *driver, const char *buf, size_t count)
{
	return count;
}

DRIVER_ATTR(lastbus_test, 0664, lastbus_test_show, lastbus_test_store);

static int lastbus_start(void)
{
	struct lastbus_plt *plt = lastbus_drv.cur_plt;

	if (!plt)
		return -ENODEV;

	if (!plt->ops) {
		pr_err("%s:%d: ops not installed\n", __func__, __LINE__);
		return -ENODEV;
	}

	if (plt->ops->start)
		return plt->ops->start(plt);

	return 0;
}

static int __init lastbus_init(void)
{
	struct device_node *node;
	int ret = 0;

	node = of_find_compatible_node(NULL, NULL, "mediatek,lastbus");
	if (node) {
		lastbus_drv.mcu_base = of_iomap(node, 0);
		lastbus_drv.peri_base = of_iomap(node, 1);
	} else {
		pr_err("can't find compatible node for lastbus\n");
		return -1;
	}

	ret = lastbus_start();
	if (ret) {
		pr_err("%s:%d: lastbus_start failed\n", __func__, __LINE__);
		return -ENODEV;
	}

	/* since kernel already populates dts, our probe would be callback after this registration */
	ret = platform_driver_register(&lastbus_drv.plt_drv);
	if (ret) {
		pr_err("%s:%d: platform_driver_register failed\n", __func__, __LINE__);
		return -ENODEV;
	}

	ret = driver_create_file(&lastbus_drv.plt_drv.driver, &driver_attr_lastbus_dump);
	if (ret)
		pr_err("%s:%d: driver_create_file failed.\n", __func__, __LINE__);

	ret = driver_create_file(&lastbus_drv.plt_drv.driver, &driver_attr_lastbus_test);
	if (ret)
		pr_err("%s:%d: driver_create_file failed.\n", __func__, __LINE__);

	lastbus_dump_buf = kzalloc(lastbus_drv.cur_plt->min_buf_len, GFP_KERNEL);
	if (!lastbus_dump_buf)
		return -ENOMEM;

	/* we dump here and then return lastbus_dump_buf
		to users to prevent lastbus values cleaned by low power mechanism
		(MCUSYS might be turned off before lastbus_dump()) */
	lastbus_dump(lastbus_dump_buf, lastbus_drv.cur_plt->min_buf_len);
	lastbus_enable();

	return 0;
}

postcore_initcall(lastbus_init);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 *
 * (C) COPYRIGHT 2012-2014 ARM Limited. All rights reserved.
 *
 * This program is free software and is provided to you under the terms of the
 * GNU General Public License version 2 as published by the Free Software
 * Foundation, and any use by you of this program is subject to the terms
 * of such GNU licence.
 *
 * A copy of the licence is included with the program, and can also be obtained
 * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 */





#include <mali_kbase.h>

static struct kbasep_debug_assert_cb kbasep_debug_assert_registered_cb = {
	NULL,
	NULL
};

void kbase_debug_assert_register_hook(kbase_debug_assert_hook *func, void *param)
{
	kbasep_debug_assert_registered_cb.func = func;
	kbasep_debug_assert_registered_cb.param = param;
}

void kbasep_debug_assert_call_hook(void)
{
	if (kbasep_debug_assert_registered_cb.func != NULL)
		kbasep_debug_assert_registered_cb.func(kbasep_debug_assert_registered_cb.param);
}
KBASE_EXPORT_SYMBOL(kbasep_debug_assert_call_hook);

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*************************************************************************/ /*!
@File
@Title          System Description Header
@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
@Description    This header provides system-specific declarations and macros
@License        Dual MIT/GPLv2

The contents of this file are subject to the MIT license as set out below.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Alternatively, the contents of this file may be used under the terms of
the GNU General Public License Version 2 ("GPL") in which case the provisions
of GPL are applicable instead of those above.

If you wish to allow use of your version of this file only under the terms of
GPL, and not to allow others to use your version of this file under the terms
of the MIT license, indicate your decision by deleting the provisions above
and replace them with the notice and other provisions required by GPL as set
out in the file called "GPL-COPYING" included in this distribution. If you do
not delete the provisions above, a recipient may use your version of this file
under the terms of either the MIT license or GPL.

This License is also included in this distribution in the file called
"MIT-COPYING".

EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ /**************************************************************************/

#if !defined(__SYSINFO_H__)
#define __SYSINFO_H__



/*!< System specific poll/timeout details */
#if defined(PVR_LINUX_USING_WORKQUEUES)
#define MAX_HW_TIME_US				(1000000)
#define DEVICES_WATCHDOG_POWER_ON_SLEEP_TIMEOUT  (10000)
#define DEVICES_WATCHDOG_POWER_OFF_SLEEP_TIMEOUT (3600000)
#define WAIT_TRY_COUNT				(20000)
#else
#define MAX_HW_TIME_US				(5000000)
#define DEVICES_WATCHDOG_POWER_ON_SLEEP_TIMEOUT  (10000)
#define DEVICES_WATCHDOG_POWER_OFF_SLEEP_TIMEOUT (3600000)
#define WAIT_TRY_COUNT				(100000)
#endif

#define SYS_DEVICE_COUNT 3 /* RGX, DISPLAY (external), BUFFER (external) */

#define SYS_PHYS_HEAP_COUNT		1

#define SYS_RGX_OF_COMPATIBLE "mediatek,mt8173-han"

#if defined(__linux__)
#define SYS_RGX_DEV_NAME    "pvrsrvkm"
// #if defined(SUPPORT_DRM)
/*
 * Use the static bus ID for the platform DRM device.
 */
#if defined(PVR_DRM_DEV_BUS_ID)
#define	SYS_RGX_DEV_DRM_BUS_ID	PVR_DRM_DEV_BUS_ID
#else
#define SYS_RGX_DEV_DRM_BUS_ID	"platform:pvrsrvkm"
#endif	/* defined(PVR_DRM_DEV_BUS_ID) */
// #endif	/* defined(SUPPORT_DRM) */
#endif

#endif	/* !defined(__SYSINFO_H__) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include <linux/slab.h>
#include <linux/delay.h>
#include <linux/mutex.h>
#include <linux/semaphore.h>
#include <linux/types.h>
#include <linux/cpu.h>
#include "nt_smc_call.h"
#include "backward_driver.h"
#include "teei_id.h"

#define BDRV_CALL       0x03

#define VFS_SYS_NO      0x08
#define REETIME_SYS_NO  0x07

struct bdrv_call_struct {
	int bdrv_call_type;
	struct service_handler *handler;
	int retVal;
};

extern int add_work_entry(int work_type, unsigned long buff);
static long register_shared_param_buf(struct service_handler *handler);

void set_ack_vdrv_cmd(unsigned int sys_num)
{
	if (boot_soter_flag == START_STATUS) {

		struct message_head msg_head;
		struct ack_vdrv_struct ack_body;

		memset(&msg_head, 0, sizeof(struct message_head));

		msg_head.invalid_flag = VALID_TYPE;
		msg_head.message_type = STANDARD_CALL_TYPE;
		msg_head.child_type = N_ACK_T_INVOKE_DRV;
		msg_head.param_length = sizeof(struct ack_vdrv_struct);

		ack_body.sysno = sys_num;

		memcpy(message_buff, &msg_head, sizeof(struct message_head));
		memcpy(message_buff + sizeof(struct message_head), &ack_body, sizeof(struct ack_vdrv_struct));

		Flush_Dcache_By_Area((unsigned long)message_buff, (unsigned long)message_buff + MESSAGE_SIZE);
	} else {
		*((int *)bdrv_message_buff) = sys_num;
		Flush_Dcache_By_Area((unsigned long)bdrv_message_buff, (unsigned long)bdrv_message_buff + MESSAGE_SIZE);
	}

	return;
}



static void secondary_invoke_fastcall(void *info)
{
	n_invoke_t_fast_call(0, 0, 0);
}


void invoke_fastcall(void)
{
	int cpu_id = 0;

	get_online_cpus();
	cpu_id = get_current_cpuid();
	smp_call_function_single(cpu_id, secondary_invoke_fastcall, NULL, 1);
	put_online_cpus();
}

static long register_shared_param_buf(struct service_handler *handler)
{

	long retVal = 0;
	unsigned long irq_flag = 0;
	struct message_head msg_head;
	struct create_vdrv_struct msg_body;
	struct ack_fast_call_struct msg_ack;

	if (message_buff == NULL) {
		pr_err("[%s][%d]: There is NO command buffer!.\n", __func__, __LINE__);
		return -EINVAL;
	}

	if (handler->size > VDRV_MAX_SIZE) {
		pr_err("[%s][%d]: The vDrv buffer is too large, DO NOT Allow to create it.\n", __FILE__, __LINE__);
		return -EINVAL;
	}

#ifdef UT_DMA_ZONE
	handler->param_buf = (unsigned long) __get_free_pages(GFP_KERNEL | GFP_DMA, get_order(ROUND_UP(handler->size, SZ_4K)));
#else
	handler->param_buf = (unsigned long) __get_free_pages(GFP_KERNEL, get_order(ROUND_UP(handler->size, SZ_4K)));
#endif
	if (handler->param_buf == NULL) {
		pr_err("[%s][%d]: kmalloc vdrv_buffer failed.\n", __FILE__, __LINE__);
		return -ENOMEM;
	}

	memset(&msg_head, 0, sizeof(struct message_head));
	memset(&msg_body, 0, sizeof(struct create_vdrv_struct));
	memset(&msg_ack, 0, sizeof(struct ack_fast_call_struct));

	msg_head.invalid_flag = VALID_TYPE;
	msg_head.message_type = FAST_CALL_TYPE;
	msg_head.child_type = FAST_CREAT_VDRV;
	msg_head.param_length = sizeof(struct create_vdrv_struct);

	msg_body.vdrv_type = handler->sysno;
	msg_body.vdrv_phy_addr = virt_to_phys(handler->param_buf);
	msg_body.vdrv_size = handler->size;

	//local_irq_save(irq_flag);

	/* Notify the T_OS that there is ctl_buffer to be created. */
	memcpy(message_buff, &msg_head, sizeof(struct message_head));
	memcpy(message_buff + sizeof(struct message_head), &msg_body, sizeof(struct create_vdrv_struct));
	Flush_Dcache_By_Area((unsigned long)message_buff, (unsigned long)message_buff + MESSAGE_SIZE);

	down(&(smc_lock));

	invoke_fastcall();

	down(&(boot_sema));

	Invalidate_Dcache_By_Area((unsigned long)message_buff, (unsigned long)message_buff + MESSAGE_SIZE);
	memcpy(&msg_head, message_buff, sizeof(struct message_head));
	memcpy(&msg_ack, message_buff + sizeof(struct message_head), sizeof(struct ack_fast_call_struct));

	//local_irq_restore(irq_flag);

	/* Check the response from T_OS. */
	if ((msg_head.message_type == FAST_CALL_TYPE) && (msg_head.child_type == FAST_ACK_CREAT_VDRV)) {
		retVal = msg_ack.retVal;

		if (retVal == 0) {
			/* pr_debug("[%s][%d]: %s end.\n", __FILE__, __LINE__, __func__); */
			return retVal;
		}
	} else {
		retVal = -EAGAIN;
	}

	/* Release the resource and return. */
	free_pages(handler->param_buf, get_order(ROUND_UP(handler->size, SZ_4K)));
	handler->param_buf = NULL;

	return retVal;
}

/******************************TIME**************************************/
#include <linux/time.h>

struct service_handler reetime;
static long reetime_init(struct service_handler *handler)
{
	return register_shared_param_buf(handler);
}

static void reetime_deinit(struct service_handler *handler)
{
	return;
}

int __reetime_handle(struct service_handler *handler)
{
	struct timeval tv;
	void *ptr = NULL;
	int tv_sec;
	int tv_usec;
	do_gettimeofday(&tv);
	ptr = handler->param_buf;
	tv_sec = tv.tv_sec;
	*((int *)ptr) = tv_sec;
	tv_usec = tv.tv_usec;
	*((int *)ptr + 1) = tv_usec;

	Flush_Dcache_By_Area((unsigned long)handler->param_buf, (unsigned long)handler->param_buf + handler->size);

	set_ack_vdrv_cmd(handler->sysno);
	teei_vfs_flag = 0;

	n_ack_t_invoke_drv(0, 0, 0);

	return 0;
}

static void secondary_reetime_handle(void *info)
{
	struct reetime_handle_struct *cd = (struct reetime_handle_struct *)info;

	/* with a rmb() */
	rmb();

	cd->retVal = __reetime_handle(cd->handler);

	/* with a wmb() */
	wmb();
}

static int reetime_handle(struct service_handler *handler)
{
	int cpu_id = 0;
	int retVal = 0;
	struct bdrv_call_struct *reetime_bdrv_ent = NULL;

	down(&smc_lock);

#if 0
	reetime_handle_entry.handler = handler;
#else
	reetime_bdrv_ent = (struct bdrv_call_struct *)kmalloc(sizeof(struct bdrv_call_struct), GFP_KERNEL);
	reetime_bdrv_ent->handler = handler;
	reetime_bdrv_ent->bdrv_call_type = REETIME_SYS_NO;
#endif
	/* with a wmb() */
	wmb();

#if 0
	get_online_cpus();
	cpu_id = get_current_cpuid();
	smp_call_function_single(cpu_id, secondary_reetime_handle, (void *)(&reetime_handle_entry), 1);
	put_online_cpus();
#else
	retVal = add_work_entry(BDRV_CALL, (unsigned long)reetime_bdrv_ent);
	if (retVal != 0) {
		up(&smc_lock);
		return retVal;
	}
#endif
	/* with a rmb() */
	rmb();
#if 0
	return reetime_handle_entry.retVal;
#else
	return 0;
#endif
}

/********************************************************************
 *                      VFS functions                               *
 ********************************************************************/
struct service_handler vfs_handler;
static unsigned long para_vaddr;
static unsigned long buff_vaddr;


int vfs_thread_function(unsigned long virt_addr, unsigned long para_vaddr, unsigned long buff_vaddr)
{
	Invalidate_Dcache_By_Area((unsigned long)virt_addr, virt_addr + VFS_SIZE);
	daulOS_VFS_share_mem = virt_addr;
#ifdef VFS_RDWR_SEM
	up(&VFS_rd_sem);
	down_interruptible(&VFS_wr_sem);
#else
	complete(&VFS_rd_comp);
	wait_for_completion_interruptible(&VFS_wr_comp);
#endif

}

static long vfs_init(struct service_handler *handler) /*! init service */
{
	long retVal = 0;

	retVal = register_shared_param_buf(handler);
	vfs_flush_address = handler->param_buf;

	return retVal;
}

static void vfs_deinit(struct service_handler *handler) /*! stop service  */
{
	return;
}

int __vfs_handle(struct service_handler *handler) /*! invoke handler */
{
	Flush_Dcache_By_Area((unsigned long)handler->param_buf, (unsigned long)handler->param_buf + handler->size);

	set_ack_vdrv_cmd(handler->sysno);
	teei_vfs_flag = 0;

	n_ack_t_invoke_drv(0, 0, 0);

	return 0;
}

static void secondary_vfs_handle(void *info)
{
	struct vfs_handle_struct *cd = (struct vfs_handle_struct *)info;
	/* with a rmb() */
	rmb();

	cd->retVal = __vfs_handle(cd->handler);

	/* with a wmb() */
	wmb();
}

static int vfs_handle(struct service_handler *handler)
{
	int cpu_id = 0;

	int retVal = 0;

	struct bdrv_call_struct *vfs_bdrv_ent = NULL;

	vfs_thread_function(handler->param_buf, para_vaddr, buff_vaddr);
	down(&smc_lock);
#if 0
	vfs_handle_entry.handler = handler;
#else
	vfs_bdrv_ent = (struct bdrv_call_struct *)kmalloc(sizeof(struct bdrv_call_struct), GFP_KERNEL);
	vfs_bdrv_ent->handler = handler;
	vfs_bdrv_ent->bdrv_call_type = VFS_SYS_NO;
#endif
	/* with a wmb() */
	wmb();
#if 0
	get_online_cpus();
	cpu_id = get_current_cpuid();
	smp_call_function_single(cpu_id, secondary_vfs_handle, (void *)(&vfs_handle_entry), 1);
	put_online_cpus();
#else
	Flush_Dcache_By_Area((unsigned long)vfs_bdrv_ent, (unsigned long)vfs_bdrv_ent + sizeof(struct bdrv_call_struct));
	retVal = add_work_entry(BDRV_CALL, (unsigned long)vfs_bdrv_ent);
	if (retVal != 0) {
		up(&smc_lock);
		return retVal;
	}

#endif

	/* with a rmb() */
	rmb();

#if 0
	return vfs_handle_entry.retVal;
#else
	return 0;
#endif
}

long init_all_service_handlers(void)
{
	long retVal = 0;

	reetime.init = reetime_init;
	reetime.deinit = reetime_deinit;
	reetime.handle = reetime_handle;
	reetime.size = 0x1000;
	reetime.sysno  = 7;

	vfs_handler.init = vfs_init;
	vfs_handler.deinit = vfs_deinit;
	vfs_handler.handle = vfs_handle;
	vfs_handler.size = 0x80000;
	vfs_handler.sysno = 8;

	pr_debug("[%s][%d] begin to init reetime service!\n", __func__, __LINE__);
	retVal = reetime.init(&reetime);
	if (retVal < 0) {
		pr_err("[%s][%d] init reetime service failed!\n", __func__, __LINE__);
		return retVal;
	}
	pr_debug("[%s][%d] init reetime service successfully!\n", __func__, __LINE__);

	pr_debug("[%s][%d] begin to init vfs service!\n", __func__, __LINE__);
	retVal = vfs_handler.init(&vfs_handler);
	if (retVal < 0) {
		pr_err("[%s][%d] init vfs service failed!\n", __func__, __LINE__);
		return retVal;
	}
	pr_debug("[%s][%d] init vfs service successfully!\n", __func__, __LINE__);

	return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* bnx2x_dcb.h: Broadcom Everest network driver.
 *
 * Copyright 2009-2013 Broadcom Corporation
 *
 * Unless you and Broadcom execute a separate written software license
 * agreement governing use of this software, this software is licensed to you
 * under the terms of the GNU General Public License version 2, available
 * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").
 *
 * Notwithstanding the above, under no circumstances may you combine this
 * software in any way with any other Broadcom software provided under a
 * license other than the GPL, without Broadcom's express prior written
 * consent.
 *
 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>
 * Written by: Dmitry Kravkov
 *
 */
#ifndef BNX2X_DCB_H
#define BNX2X_DCB_H

#include "bnx2x_hsi.h"

#define LLFC_DRIVER_TRAFFIC_TYPE_MAX 3 /* NW, iSCSI, FCoE */
struct bnx2x_dcbx_app_params {
	u32 enabled;
	u32 traffic_type_priority[LLFC_DRIVER_TRAFFIC_TYPE_MAX];
};

#define DCBX_COS_MAX_NUM_E2	DCBX_E2E3_MAX_NUM_COS
/* bnx2x currently limits numbers of supported COSes to 3 to be extended to 6 */
#define BNX2X_MAX_COS_SUPPORT	3
#define DCBX_COS_MAX_NUM_E3B0	BNX2X_MAX_COS_SUPPORT
#define DCBX_COS_MAX_NUM	BNX2X_MAX_COS_SUPPORT

struct bnx2x_dcbx_cos_params {
	u32	bw_tbl;
	u32	pri_bitmask;
	/*
	 * strict priority: valid values are 0..5; 0 is highest priority.
	 * There can't be two COSes with the same priority.
	 */
	u8	strict;
#define BNX2X_DCBX_STRICT_INVALID			DCBX_COS_MAX_NUM
#define BNX2X_DCBX_STRICT_COS_HIGHEST			0
#define BNX2X_DCBX_STRICT_COS_NEXT_LOWER_PRI(sp)	((sp) + 1)
	u8	pauseable;
};

struct bnx2x_dcbx_pg_params {
	u32 enabled;
	u8 num_of_cos; /* valid COS entries */
	struct bnx2x_dcbx_cos_params	cos_params[DCBX_COS_MAX_NUM];
};

struct bnx2x_dcbx_pfc_params {
	u32 enabled;
	u32 priority_non_pauseable_mask;
};

struct bnx2x_dcbx_port_params {
	struct bnx2x_dcbx_pfc_params pfc;
	struct bnx2x_dcbx_pg_params  ets;
	struct bnx2x_dcbx_app_params app;
};

#define BNX2X_DCBX_CONFIG_INV_VALUE			(0xFFFFFFFF)
#define BNX2X_DCBX_OVERWRITE_SETTINGS_DISABLE		0
#define BNX2X_DCBX_OVERWRITE_SETTINGS_ENABLE		1
#define BNX2X_DCBX_OVERWRITE_SETTINGS_INVALID	(BNX2X_DCBX_CONFIG_INV_VALUE)
#define BNX2X_IS_ETS_ENABLED(bp) ((bp)->dcb_state == BNX2X_DCB_STATE_ON &&\
				  (bp)->dcbx_port_params.ets.enabled)

struct bnx2x_config_lldp_params {
	u32 overwrite_settings;
	u32 msg_tx_hold;
	u32 msg_fast_tx;
	u32 tx_credit_max;
	u32 msg_tx_interval;
	u32 tx_fast;
};

struct bnx2x_admin_priority_app_table {
		u32 valid;
		u32 priority;
#define INVALID_TRAFFIC_TYPE_PRIORITY	(0xFFFFFFFF)
		u32 traffic_type;
#define TRAFFIC_TYPE_ETH		0
#define TRAFFIC_TYPE_PORT		1
		u32 app_id;
};

#define DCBX_CONFIG_MAX_APP_PROTOCOL 4
struct bnx2x_config_dcbx_params {
	u32 overwrite_settings;
	u32 admin_dcbx_version;
	u32 admin_ets_enable;
	u32 admin_pfc_enable;
	u32 admin_tc_supported_tx_enable;
	u32 admin_ets_configuration_tx_enable;
	u32 admin_ets_recommendation_tx_enable;
	u32 admin_pfc_tx_enable;
	u32 admin_application_priority_tx_enable;
	u32 admin_ets_willing;
	u32 admin_ets_reco_valid;
	u32 admin_pfc_willing;
	u32 admin_app_priority_willing;
	u32 admin_configuration_bw_precentage[8];
	u32 admin_configuration_ets_pg[8];
	u32 admin_recommendation_bw_precentage[8];
	u32 admin_recommendation_ets_pg[8];
	u32 admin_pfc_bitmap;
	struct bnx2x_admin_priority_app_table
		admin_priority_app_table[DCBX_CONFIG_MAX_APP_PROTOCOL];
	u32 admin_default_priority;
};

#define GET_FLAGS(flags, bits)		((flags) & (bits))
#define SET_FLAGS(flags, bits)		((flags) |= (bits))
#define RESET_FLAGS(flags, bits)	((flags) &= ~(bits))

enum {
	DCBX_READ_LOCAL_MIB,
	DCBX_READ_REMOTE_MIB
};

#define ETH_TYPE_FCOE		(0x8906)
#define TCP_PORT_ISCSI		(0xCBC)

#define PFC_VALUE_FRAME_SIZE				(512)
#define PFC_QUANTA_IN_NANOSEC_FROM_SPEED_MEGA(mega_speed)  \
				((1000 * PFC_VALUE_FRAME_SIZE)/(mega_speed))

#define PFC_BRB1_REG_HIGH_LLFC_LOW_THRESHOLD			130
#define PFC_BRB1_REG_HIGH_LLFC_HIGH_THRESHOLD			170

struct cos_entry_help_data {
	u32			pri_join_mask;
	u32			cos_bw;
	u8			strict;
	bool			pausable;
};

struct cos_help_data {
	struct cos_entry_help_data	data[DCBX_COS_MAX_NUM];
	u8				num_of_cos;
};

#define DCBX_ILLEGAL_PG				(0xFF)
#define DCBX_PFC_PRI_MASK			(0xFF)
#define DCBX_STRICT_PRIORITY			(15)
#define DCBX_INVALID_COS_BW			(0xFFFFFFFF)
#define DCBX_PFC_PRI_NON_PAUSE_MASK(bp)		\
			((bp)->dcbx_port_params.pfc.priority_non_pauseable_mask)
#define DCBX_PFC_PRI_PAUSE_MASK(bp)		\
					((u8)~DCBX_PFC_PRI_NON_PAUSE_MASK(bp))
#define DCBX_PFC_PRI_GET_PAUSE(bp, pg_pri)	\
				((pg_pri) & (DCBX_PFC_PRI_PAUSE_MASK(bp)))
#define DCBX_PFC_PRI_GET_NON_PAUSE(bp, pg_pri)	\
			(DCBX_PFC_PRI_NON_PAUSE_MASK(bp) & (pg_pri))
#define DCBX_IS_PFC_PRI_SOME_PAUSE(bp, pg_pri)	\
			(0 != DCBX_PFC_PRI_GET_PAUSE(bp, pg_pri))
#define IS_DCBX_PFC_PRI_ONLY_PAUSE(bp, pg_pri)	\
			(pg_pri == DCBX_PFC_PRI_GET_PAUSE((bp), (pg_pri)))
#define IS_DCBX_PFC_PRI_ONLY_NON_PAUSE(bp, pg_pri)\
			((pg_pri) == DCBX_PFC_PRI_GET_NON_PAUSE((bp), (pg_pri)))
#define IS_DCBX_PFC_PRI_MIX_PAUSE(bp, pg_pri)	\
			(!(IS_DCBX_PFC_PRI_ONLY_NON_PAUSE((bp), (pg_pri)) || \
			 IS_DCBX_PFC_PRI_ONLY_PAUSE((bp), (pg_pri))))

struct pg_entry_help_data {
	u8	num_of_dif_pri;
	u8	pg;
	u32	pg_priority;
};

struct pg_help_data {
	struct pg_entry_help_data	data[LLFC_DRIVER_TRAFFIC_TYPE_MAX];
	u8				num_of_pg;
};

/* forward DCB/PFC related declarations */
struct bnx2x;
void bnx2x_dcbx_update(struct work_struct *work);
void bnx2x_dcbx_init_params(struct bnx2x *bp);
void bnx2x_dcbx_set_state(struct bnx2x *bp, bool dcb_on, u32 dcbx_enabled);

enum {
	BNX2X_DCBX_STATE_NEG_RECEIVED = 0x1,
	BNX2X_DCBX_STATE_TX_PAUSED,
	BNX2X_DCBX_STATE_TX_RELEASED
};

void bnx2x_dcbx_set_params(struct bnx2x *bp, u32 state);
void bnx2x_dcbx_pmf_update(struct bnx2x *bp);
/* DCB netlink */
#ifdef BCM_DCBNL
extern const struct dcbnl_rtnl_ops bnx2x_dcbnl_ops;
int bnx2x_dcbnl_update_applist(struct bnx2x *bp, bool delall);
#endif /* BCM_DCBNL */

int bnx2x_dcbx_stop_hw_tx(struct bnx2x *bp);
int bnx2x_dcbx_resume_hw_tx(struct bnx2x *bp);

#endif /* BNX2X_DCB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Copyright (c) 2004-2008 Reyk Floeter <reyk@openbsd.org>
 * Copyright (c) 2006-2008 Nick Kossifidis <mickflemm@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

/****************\
  GPIO Functions
\****************/

#include "ath5k.h"
#include "reg.h"
#include "debug.h"


/**
 * DOC: GPIO/LED functions
 *
 * Here we control the 6 bidirectional GPIO pins provided by the hw.
 * We can set a GPIO pin to be an input or an output pin on GPIO control
 * register and then read or set its status from GPIO data input/output
 * registers.
 *
 * We also control the two LED pins provided by the hw, LED_0 is our
 * "power" LED and LED_1 is our "network activity" LED but many scenarios
 * are available from hw. Vendors might also provide LEDs connected to the
 * GPIO pins, we handle them through the LED subsystem on led.c
 */


/**
 * ath5k_hw_set_ledstate() - Set led state
 * @ah: The &struct ath5k_hw
 * @state: One of AR5K_LED_*
 *
 * Used to set the LED blinking state. This only
 * works for the LED connected to the LED_0, LED_1 pins,
 * not the GPIO based.
 */
void
ath5k_hw_set_ledstate(struct ath5k_hw *ah, unsigned int state)
{
	u32 led;
	/*5210 has different led mode handling*/
	u32 led_5210;

	/*Reset led status*/
	if (ah->ah_version != AR5K_AR5210)
		AR5K_REG_DISABLE_BITS(ah, AR5K_PCICFG,
			AR5K_PCICFG_LEDMODE |  AR5K_PCICFG_LED);
	else
		AR5K_REG_DISABLE_BITS(ah, AR5K_PCICFG, AR5K_PCICFG_LED);

	/*
	 * Some blinking values, define at your wish
	 */
	switch (state) {
	case AR5K_LED_SCAN:
	case AR5K_LED_AUTH:
		led = AR5K_PCICFG_LEDMODE_PROP | AR5K_PCICFG_LED_PEND;
		led_5210 = AR5K_PCICFG_LED_PEND | AR5K_PCICFG_LED_BCTL;
		break;

	case AR5K_LED_INIT:
		led = AR5K_PCICFG_LEDMODE_PROP | AR5K_PCICFG_LED_NONE;
		led_5210 = AR5K_PCICFG_LED_PEND;
		break;

	case AR5K_LED_ASSOC:
	case AR5K_LED_RUN:
		led = AR5K_PCICFG_LEDMODE_PROP | AR5K_PCICFG_LED_ASSOC;
		led_5210 = AR5K_PCICFG_LED_ASSOC;
		break;

	default:
		led = AR5K_PCICFG_LEDMODE_PROM | AR5K_PCICFG_LED_NONE;
		led_5210 = AR5K_PCICFG_LED_PEND;
		break;
	}

	/*Write new status to the register*/
	if (ah->ah_version != AR5K_AR5210)
		AR5K_REG_ENABLE_BITS(ah, AR5K_PCICFG, led);
	else
		AR5K_REG_ENABLE_BITS(ah, AR5K_PCICFG, led_5210);
}

/**
 * ath5k_hw_set_gpio_input() - Set GPIO inputs
 * @ah: The &struct ath5k_hw
 * @gpio: GPIO pin to set as input
 */
int
ath5k_hw_set_gpio_input(struct ath5k_hw *ah, u32 gpio)
{
	if (gpio >= AR5K_NUM_GPIO)
		return -EINVAL;

	ath5k_hw_reg_write(ah,
		(ath5k_hw_reg_read(ah, AR5K_GPIOCR) & ~AR5K_GPIOCR_OUT(gpio))
		| AR5K_GPIOCR_IN(gpio), AR5K_GPIOCR);

	return 0;
}

/**
 * ath5k_hw_set_gpio_output() - Set GPIO outputs
 * @ah: The &struct ath5k_hw
 * @gpio: The GPIO pin to set as output
 */
int
ath5k_hw_set_gpio_output(struct ath5k_hw *ah, u32 gpio)
{
	if (gpio >= AR5K_NUM_GPIO)
		return -EINVAL;

	ath5k_hw_reg_write(ah,
		(ath5k_hw_reg_read(ah, AR5K_GPIOCR) & ~AR5K_GPIOCR_OUT(gpio))
		| AR5K_GPIOCR_OUT(gpio), AR5K_GPIOCR);

	return 0;
}

/**
 * ath5k_hw_get_gpio() - Get GPIO state
 * @ah: The &struct ath5k_hw
 * @gpio: The GPIO pin to read
 */
u32
ath5k_hw_get_gpio(struct ath5k_hw *ah, u32 gpio)
{
	if (gpio >= AR5K_NUM_GPIO)
		return 0xffffffff;

	/* GPIO input magic */
	return ((ath5k_hw_reg_read(ah, AR5K_GPIODI) & AR5K_GPIODI_M) >> gpio) &
		0x1;
}

/**
 * ath5k_hw_set_gpio() - Set GPIO state
 * @ah: The &struct ath5k_hw
 * @gpio: The GPIO pin to set
 * @val: Value to set (boolean)
 */
int
ath5k_hw_set_gpio(struct ath5k_hw *ah, u32 gpio, u32 val)
{
	u32 data;

	if (gpio >= AR5K_NUM_GPIO)
		return -EINVAL;

	/* GPIO output magic */
	data = ath5k_hw_reg_read(ah, AR5K_GPIODO);

	data &= ~(1 << gpio);
	data |= (val & 1) << gpio;

	ath5k_hw_reg_write(ah, data, AR5K_GPIODO);

	return 0;
}

/**
 * ath5k_hw_set_gpio_intr() - Initialize the GPIO interrupt (RFKill switch)
 * @ah: The &struct ath5k_hw
 * @gpio: The GPIO pin to use
 * @interrupt_level: True to generate interrupt on active pin (high)
 *
 * This function is used to set up the GPIO interrupt for the hw RFKill switch.
 * That switch is connected to a GPIO pin and it's number is stored on EEPROM.
 * It can either open or close the circuit to indicate that we should disable
 * RF/Wireless to save power (we also get that from EEPROM).
 */
void
ath5k_hw_set_gpio_intr(struct ath5k_hw *ah, unsigned int gpio,
		u32 interrupt_level)
{
	u32 data;

	if (gpio >= AR5K_NUM_GPIO)
		return;

	/*
	 * Set the GPIO interrupt
	 */
	data = (ath5k_hw_reg_read(ah, AR5K_GPIOCR) &
		~(AR5K_GPIOCR_INT_SEL(gpio) | AR5K_GPIOCR_INT_SELH |
		AR5K_GPIOCR_INT_ENA | AR5K_GPIOCR_OUT(gpio))) |
		(AR5K_GPIOCR_INT_SEL(gpio) | AR5K_GPIOCR_INT_ENA);

	ath5k_hw_reg_write(ah, interrupt_level ? data :
		(data | AR5K_GPIOCR_INT_SELH), AR5K_GPIOCR);

	ah->ah_imr |= AR5K_IMR_GPIO;

	/* Enable GPIO interrupts */
	AR5K_REG_ENABLE_BITS(ah, AR5K_PIMR, AR5K_IMR_GPIO);
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * This file is part of wl1251
 *
 * Copyright (C) 2008 Nokia Corporation
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

#include <linux/slab.h>

#include "reg.h"
#include "boot.h"
#include "io.h"
#include "spi.h"
#include "event.h"
#include "acx.h"

void wl1251_boot_target_enable_interrupts(struct wl1251 *wl)
{
	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));
	wl1251_reg_write32(wl, HI_CFG, HI_CFG_DEF_VAL);
}

int wl1251_boot_soft_reset(struct wl1251 *wl)
{
	unsigned long timeout;
	u32 boot_data;

	/* perform soft reset */
	wl1251_reg_write32(wl, ACX_REG_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);

	/* SOFT_RESET is self clearing */
	timeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);
	while (1) {
		boot_data = wl1251_reg_read32(wl, ACX_REG_SLV_SOFT_RESET);
		wl1251_debug(DEBUG_BOOT, "soft reset bootdata 0x%x", boot_data);
		if ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)
			break;

		if (time_after(jiffies, timeout)) {
			/* 1.2 check pWhalBus->uSelfClearTime if the
			 * timeout was reached */
			wl1251_error("soft reset timeout");
			return -1;
		}

		udelay(SOFT_RESET_STALL_TIME);
	}

	/* disable Rx/Tx */
	wl1251_reg_write32(wl, ENABLE, 0x0);

	/* disable auto calibration on start*/
	wl1251_reg_write32(wl, SPARE_A2, 0xffff);

	return 0;
}

int wl1251_boot_init_seq(struct wl1251 *wl)
{
	u32 scr_pad6, init_data, tmp, elp_cmd, ref_freq;

	/*
	 * col #1: INTEGER_DIVIDER
	 * col #2: FRACTIONAL_DIVIDER
	 * col #3: ATTN_BB
	 * col #4: ALPHA_BB
	 * col #5: STOP_TIME_BB
	 * col #6: BB_PLL_LOOP_FILTER
	 */
	static const u32 LUT[REF_FREQ_NUM][LUT_PARAM_NUM] = {

		{   83, 87381,  0xB, 5, 0xF00,  3}, /* REF_FREQ_19_2*/
		{   61, 141154, 0xB, 5, 0x1450, 2}, /* REF_FREQ_26_0*/
		{   41, 174763, 0xC, 6, 0x2D00, 1}, /* REF_FREQ_38_4*/
		{   40, 0,      0xC, 6, 0x2EE0, 1}, /* REF_FREQ_40_0*/
		{   47, 162280, 0xC, 6, 0x2760, 1}  /* REF_FREQ_33_6        */
	};

	/* read NVS params */
	scr_pad6 = wl1251_reg_read32(wl, SCR_PAD6);
	wl1251_debug(DEBUG_BOOT, "scr_pad6 0x%x", scr_pad6);

	/* read ELP_CMD */
	elp_cmd = wl1251_reg_read32(wl, ELP_CMD);
	wl1251_debug(DEBUG_BOOT, "elp_cmd 0x%x", elp_cmd);

	/* set the BB calibration time to be 300 usec (PLL_CAL_TIME) */
	ref_freq = scr_pad6 & 0x000000FF;
	wl1251_debug(DEBUG_BOOT, "ref_freq 0x%x", ref_freq);

	wl1251_reg_write32(wl, PLL_CAL_TIME, 0x9);

	/*
	 * PG 1.2: set the clock buffer time to be 210 usec (CLK_BUF_TIME)
	 */
	wl1251_reg_write32(wl, CLK_BUF_TIME, 0x6);

	/*
	 * set the clock detect feature to work in the restart wu procedure
	 * (ELP_CFG_MODE[14]) and Select the clock source type
	 * (ELP_CFG_MODE[13:12])
	 */
	tmp = ((scr_pad6 & 0x0000FF00) << 4) | 0x00004000;
	wl1251_reg_write32(wl, ELP_CFG_MODE, tmp);

	/* PG 1.2: enable the BB PLL fix. Enable the PLL_LIMP_CLK_EN_CMD */
	elp_cmd |= 0x00000040;
	wl1251_reg_write32(wl, ELP_CMD, elp_cmd);

	/* PG 1.2: Set the BB PLL stable time to be 1000usec
	 * (PLL_STABLE_TIME) */
	wl1251_reg_write32(wl, CFG_PLL_SYNC_CNT, 0x20);

	/* PG 1.2: read clock request time */
	init_data = wl1251_reg_read32(wl, CLK_REQ_TIME);

	/*
	 * PG 1.2: set the clock request time to be ref_clk_settling_time -
	 * 1ms = 4ms
	 */
	if (init_data > 0x21)
		tmp = init_data - 0x21;
	else
		tmp = 0;
	wl1251_reg_write32(wl, CLK_REQ_TIME, tmp);

	/* set BB PLL configurations in RF AFE */
	wl1251_reg_write32(wl, 0x003058cc, 0x4B5);

	/* set RF_AFE_REG_5 */
	wl1251_reg_write32(wl, 0x003058d4, 0x50);

	/* set RF_AFE_CTRL_REG_2 */
	wl1251_reg_write32(wl, 0x00305948, 0x11c001);

	/*
	 * change RF PLL and BB PLL divider for VCO clock and adjust VCO
	 * bais current(RF_AFE_REG_13)
	 */
	wl1251_reg_write32(wl, 0x003058f4, 0x1e);

	/* set BB PLL configurations */
	tmp = LUT[ref_freq][LUT_PARAM_INTEGER_DIVIDER] | 0x00017000;
	wl1251_reg_write32(wl, 0x00305840, tmp);

	/* set fractional divider according to Appendix C-BB PLL
	 * Calculations
	 */
	tmp = LUT[ref_freq][LUT_PARAM_FRACTIONAL_DIVIDER];
	wl1251_reg_write32(wl, 0x00305844, tmp);

	/* set the initial data for the sigma delta */
	wl1251_reg_write32(wl, 0x00305848, 0x3039);

	/*
	 * set the accumulator attenuation value, calibration loop1
	 * (alpha), calibration loop2 (beta), calibration loop3 (gamma) and
	 * the VCO gain
	 */
	tmp = (LUT[ref_freq][LUT_PARAM_ATTN_BB] << 16) |
		(LUT[ref_freq][LUT_PARAM_ALPHA_BB] << 12) | 0x1;
	wl1251_reg_write32(wl, 0x00305854, tmp);

	/*
	 * set the calibration stop time after holdoff time expires and set
	 * settling time HOLD_OFF_TIME_BB
	 */
	tmp = LUT[ref_freq][LUT_PARAM_STOP_TIME_BB] | 0x000A0000;
	wl1251_reg_write32(wl, 0x00305858, tmp);

	/*
	 * set BB PLL Loop filter capacitor3- BB_C3[2:0] and set BB PLL
	 * constant leakage current to linearize PFD to 0uA -
	 * BB_ILOOPF[7:3]
	 */
	tmp = LUT[ref_freq][LUT_PARAM_BB_PLL_LOOP_FILTER] | 0x00000030;
	wl1251_reg_write32(wl, 0x003058f8, tmp);

	/*
	 * set regulator output voltage for n divider to
	 * 1.35-BB_REFDIV[1:0], set charge pump current- BB_CPGAIN[4:2],
	 * set BB PLL Loop filter capacitor2- BB_C2[7:5], set gain of BB
	 * PLL auto-call to normal mode- BB_CALGAIN_3DB[8]
	 */
	wl1251_reg_write32(wl, 0x003058f0, 0x29);

	/* enable restart wakeup sequence (ELP_CMD[0]) */
	wl1251_reg_write32(wl, ELP_CMD, elp_cmd | 0x1);

	/* restart sequence completed */
	udelay(2000);

	return 0;
}

static void wl1251_boot_set_ecpu_ctrl(struct wl1251 *wl, u32 flag)
{
	u32 cpu_ctrl;

	/* 10.5.0 run the firmware (I) */
	cpu_ctrl = wl1251_reg_read32(wl, ACX_REG_ECPU_CONTROL);

	/* 10.5.1 run the firmware (II) */
	cpu_ctrl &= ~flag;
	wl1251_reg_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
}

int wl1251_boot_run_firmware(struct wl1251 *wl)
{
	int loop, ret;
	u32 chip_id, acx_intr;

	wl1251_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);

	chip_id = wl1251_reg_read32(wl, CHIP_ID_B);

	wl1251_debug(DEBUG_BOOT, "chip id after firmware boot: 0x%x", chip_id);

	if (chip_id != wl->chip_id) {
		wl1251_error("chip id doesn't match after firmware boot");
		return -EIO;
	}

	/* wait for init to complete */
	loop = 0;
	while (loop++ < INIT_LOOP) {
		udelay(INIT_LOOP_DELAY);
		acx_intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);

		if (acx_intr == 0xffffffff) {
			wl1251_error("error reading hardware complete "
				     "init indication");
			return -EIO;
		}
		/* check that ACX_INTR_INIT_COMPLETE is enabled */
		else if (acx_intr & WL1251_ACX_INTR_INIT_COMPLETE) {
			wl1251_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
					   WL1251_ACX_INTR_INIT_COMPLETE);
			break;
		}
	}

	if (loop > INIT_LOOP) {
		wl1251_error("timeout waiting for the hardware to "
			     "complete initialization");
		return -EIO;
	}

	/* get hardware config command mail box */
	wl->cmd_box_addr = wl1251_reg_read32(wl, REG_COMMAND_MAILBOX_PTR);

	/* get hardware config event mail box */
	wl->event_box_addr = wl1251_reg_read32(wl, REG_EVENT_MAILBOX_PTR);

	/* set the working partition to its "running" mode offset */
	wl1251_set_partition(wl, WL1251_PART_WORK_MEM_START,
			     WL1251_PART_WORK_MEM_SIZE,
			     WL1251_PART_WORK_REG_START,
			     WL1251_PART_WORK_REG_SIZE);

	wl1251_debug(DEBUG_MAILBOX, "cmd_box_addr 0x%x event_box_addr 0x%x",
		     wl->cmd_box_addr, wl->event_box_addr);

	wl1251_acx_fw_version(wl, wl->fw_ver, sizeof(wl->fw_ver));

	/*
	 * in case of full asynchronous mode the firmware event must be
	 * ready to receive event from the command mailbox
	 */

	/* enable gpio interrupts */
	wl1251_enable_interrupts(wl);

	/* Enable target's interrupts */
	wl->intr_mask = WL1251_ACX_INTR_RX0_DATA |
		WL1251_ACX_INTR_RX1_DATA |
		WL1251_ACX_INTR_TX_RESULT |
		WL1251_ACX_INTR_EVENT_A |
		WL1251_ACX_INTR_EVENT_B |
		WL1251_ACX_INTR_INIT_COMPLETE;
	wl1251_boot_target_enable_interrupts(wl);

	wl->event_mask = SCAN_COMPLETE_EVENT_ID | BSS_LOSE_EVENT_ID |
		SYNCHRONIZATION_TIMEOUT_EVENT_ID |
		ROAMING_TRIGGER_LOW_RSSI_EVENT_ID |
		ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID |
		REGAINED_BSS_EVENT_ID | BT_PTA_SENSE_EVENT_ID |
		BT_PTA_PREDICTION_EVENT_ID | JOIN_EVENT_COMPLETE_ID |
		PS_REPORT_EVENT_ID;

	ret = wl1251_event_unmask(wl);
	if (ret < 0) {
		wl1251_error("EVENT mask setting failed");
		return ret;
	}

	wl1251_event_mbox_config(wl);

	/* firmware startup completed */
	return 0;
}

static int wl1251_boot_upload_firmware(struct wl1251 *wl)
{
	int addr, chunk_num, partition_limit;
	size_t fw_data_len, len;
	u8 *p, *buf;

	/* whal_FwCtrl_LoadFwImageSm() */

	wl1251_debug(DEBUG_BOOT, "chip id before fw upload: 0x%x",
		     wl1251_reg_read32(wl, CHIP_ID_B));

	/* 10.0 check firmware length and set partition */
	fw_data_len =  (wl->fw[4] << 24) | (wl->fw[5] << 16) |
		(wl->fw[6] << 8) | (wl->fw[7]);

	wl1251_debug(DEBUG_BOOT, "fw_data_len %zu chunk_size %d", fw_data_len,
		CHUNK_SIZE);

	if ((fw_data_len % 4) != 0) {
		wl1251_error("firmware length not multiple of four");
		return -EIO;
	}

	buf = kmalloc(CHUNK_SIZE, GFP_KERNEL);
	if (!buf) {
		wl1251_error("allocation for firmware upload chunk failed");
		return -ENOMEM;
	}

	wl1251_set_partition(wl, WL1251_PART_DOWN_MEM_START,
			     WL1251_PART_DOWN_MEM_SIZE,
			     WL1251_PART_DOWN_REG_START,
			     WL1251_PART_DOWN_REG_SIZE);

	/* 10.1 set partition limit and chunk num */
	chunk_num = 0;
	partition_limit = WL1251_PART_DOWN_MEM_SIZE;

	while (chunk_num < fw_data_len / CHUNK_SIZE) {
		/* 10.2 update partition, if needed */
		addr = WL1251_PART_DOWN_MEM_START +
			(chunk_num + 2) * CHUNK_SIZE;
		if (addr > partition_limit) {
			addr = WL1251_PART_DOWN_MEM_START +
				chunk_num * CHUNK_SIZE;
			partition_limit = chunk_num * CHUNK_SIZE +
				WL1251_PART_DOWN_MEM_SIZE;
			wl1251_set_partition(wl,
					     addr,
					     WL1251_PART_DOWN_MEM_SIZE,
					     WL1251_PART_DOWN_REG_START,
					     WL1251_PART_DOWN_REG_SIZE);
		}

		/* 10.3 upload the chunk */
		addr = WL1251_PART_DOWN_MEM_START + chunk_num * CHUNK_SIZE;
		p = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;
		wl1251_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",
			     p, addr);

		/* need to copy the chunk for dma */
		len = CHUNK_SIZE;
		memcpy(buf, p, len);
		wl1251_mem_write(wl, addr, buf, len);

		chunk_num++;
	}

	/* 10.4 upload the last chunk */
	addr = WL1251_PART_DOWN_MEM_START + chunk_num * CHUNK_SIZE;
	p = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;

	/* need to copy the chunk for dma */
	len = fw_data_len % CHUNK_SIZE;
	memcpy(buf, p, len);

	wl1251_debug(DEBUG_BOOT, "uploading fw last chunk (%zu B) 0x%p to 0x%x",
		     len, p, addr);
	wl1251_mem_write(wl, addr, buf, len);

	kfree(buf);

	return 0;
}

static int wl1251_boot_upload_nvs(struct wl1251 *wl)
{
	size_t nvs_len, nvs_bytes_written, burst_len;
	int nvs_start, i;
	u32 dest_addr, val;
	u8 *nvs_ptr, *nvs;

	nvs = wl->nvs;
	if (nvs == NULL)
		return -ENODEV;

	nvs_ptr = nvs;

	nvs_len = wl->nvs_len;
	nvs_start = wl->fw_len;

	/*
	 * Layout before the actual NVS tables:
	 * 1 byte : burst length.
	 * 2 bytes: destination address.
	 * n bytes: data to burst copy.
	 *
	 * This is ended by a 0 length, then the NVS tables.
	 */

	while (nvs_ptr[0]) {
		burst_len = nvs_ptr[0];
		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));

		/* We move our pointer to the data */
		nvs_ptr += 3;

		for (i = 0; i < burst_len; i++) {
			val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
			       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));

			wl1251_debug(DEBUG_BOOT,
				     "nvs burst write 0x%x: 0x%x",
				     dest_addr, val);
			wl1251_mem_write32(wl, dest_addr, val);

			nvs_ptr += 4;
			dest_addr += 4;
		}
	}

	/*
	 * We've reached the first zero length, the first NVS table
	 * is 7 bytes further.
	 */
	nvs_ptr += 7;
	nvs_len -= nvs_ptr - nvs;
	nvs_len = ALIGN(nvs_len, 4);

	/* Now we must set the partition correctly */
	wl1251_set_partition(wl, nvs_start,
			     WL1251_PART_DOWN_MEM_SIZE,
			     WL1251_PART_DOWN_REG_START,
			     WL1251_PART_DOWN_REG_SIZE);

	/* And finally we upload the NVS tables */
	nvs_bytes_written = 0;
	while (nvs_bytes_written < nvs_len) {
		val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
		       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));

		wl1251_debug(DEBUG_BOOT,
			     "nvs write table 0x%x: 0x%x",
			     nvs_start, val);
		wl1251_mem_write32(wl, nvs_start, val);

		nvs_ptr += 4;
		nvs_bytes_written += 4;
		nvs_start += 4;
	}

	return 0;
}

int wl1251_boot(struct wl1251 *wl)
{
	int ret = 0, minor_minor_e2_ver;
	u32 tmp, boot_data;

	/* halt embedded ARM CPU while loading firmware */
	wl1251_reg_write32(wl, ACX_REG_ECPU_CONTROL, ECPU_CONTROL_HALT);

	ret = wl1251_boot_soft_reset(wl);
	if (ret < 0)
		goto out;

	/* 2. start processing NVS file */
	if (wl->use_eeprom) {
		wl1251_reg_write32(wl, ACX_REG_EE_START, START_EEPROM_MGR);
		/* Wait for EEPROM NVS burst read to complete */
		msleep(40);
		wl1251_reg_write32(wl, ACX_EEPROMLESS_IND_REG, USE_EEPROM);
	} else {
		ret = wl1251_boot_upload_nvs(wl);
		if (ret < 0)
			goto out;

		/* write firmware's last address (ie. it's length) to
		 * ACX_EEPROMLESS_IND_REG */
		wl1251_reg_write32(wl, ACX_EEPROMLESS_IND_REG, wl->fw_len);
	}

	/* 6. read the EEPROM parameters */
	tmp = wl1251_reg_read32(wl, SCR_PAD2);

	/* 7. read bootdata */
	wl->boot_attr.radio_type = (tmp & 0x0000FF00) >> 8;
	wl->boot_attr.major = (tmp & 0x00FF0000) >> 16;
	tmp = wl1251_reg_read32(wl, SCR_PAD3);

	/* 8. check bootdata and call restart sequence */
	wl->boot_attr.minor = (tmp & 0x00FF0000) >> 16;
	minor_minor_e2_ver = (tmp & 0xFF000000) >> 24;

	wl1251_debug(DEBUG_BOOT, "radioType 0x%x majorE2Ver 0x%x "
		     "minorE2Ver 0x%x minor_minor_e2_ver 0x%x",
		     wl->boot_attr.radio_type, wl->boot_attr.major,
		     wl->boot_attr.minor, minor_minor_e2_ver);

	ret = wl1251_boot_init_seq(wl);
	if (ret < 0)
		goto out;

	/* 9. NVS processing done */
	boot_data = wl1251_reg_read32(wl, ACX_REG_ECPU_CONTROL);

	wl1251_debug(DEBUG_BOOT, "halt boot_data 0x%x", boot_data);

	/* 10. check that ECPU_CONTROL_HALT bits are set in
	 * pWhalBus->uBootData and start uploading firmware
	 */
	if ((boot_data & ECPU_CONTROL_HALT) == 0) {
		wl1251_error("boot failed, ECPU_CONTROL_HALT not set");
		ret = -EIO;
		goto out;
	}

	ret = wl1251_boot_upload_firmware(wl);
	if (ret < 0)
		goto out;

	/* 10.5 start firmware */
	ret = wl1251_boot_run_firmware(wl);
	if (ret < 0)
		goto out;

out:
	return ret;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           INDX( 	                 (                           [    h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 [    c3,2d3c3 @      1             
 k e y b o a r d . c                 [    c3,2d3c3 @      1              
 k e y b o a r d . c                 [    c3,2d3c3 @      1              
 k e y b o a r d . c                 h V     [    c3,2d3c3 @      1              
 k e y b o a r d . c                 [    c3,2d3c3 @      1              
 k e y b o a r d . c                 [    c3,2d3c3  @      1              
 k e y b o a r d . c                 [    c3,2d3c3 @      1              
 k e y b o a r d . c                 [    c3,2d3c3 @      1              
 k e y b o a r d . c                 [    c3,2d3c3 @      1              
 k e y b o a r d . c                 c3,2d3c3 @      1              
 k e y b o a r d . c                 [    Id3,2H)d3Dd3                      
 k e y b o a r d . h   [    h R     [    a3$2a3a3                      M a k e f i l e       [    h X     [    #/d3,2Fd3"/d3 P      A               m o n r e a d e r . c [    h X     [    
Md3,2gbd3Md3 0      9&               m o n w r i t e r . c [    h T     [    Nhd3,2d3Hhd3                     	 r a w 3 2 7 0 . c     [    h T     [    xd3,2pd3 rd3 0                     	 r a w 3 2 7 0 . h     [    ` N     [    qd3,2d3pd3       (               s c l p . c   [    ` N     [    d3,2dd3d3        F               s c l p . h   [    p Z     [    ^d3,2d3Zd3                       s c l p _ a s y n c . c       [    h V     [     e3,2e3 e3 @      a?              
 s c l p _ c m d . c   [    h V     [    e3,22e3 e3 0      >"              
 s c l p _ c o n . c   [    p \     [    8e3,2Je38e3                      s c l p _ c o n f i g . c     [    h V     [    Pe3,2be3Pe3                     
 s c l p _ c p i . c   [    p ^     [    he3,2}e3he3 0      9"               s c l p _ c p i _ s y s . c   [    p ^     [    e3,2te3e3X      U               s c l p _ c p i _ s y s . h   [    h V    [    me3,2e3de3                     
 s c l p _ c t l . c   [    h X     [    e3,2e3e3       5               s c l p _ d i a g . h [    p Z     [    e3,2j3e3                       s c l p _ e a r l y . c       [    h V     [    	j3,2j3	j3        x              
 s c l p _ f t p . c                                                                                                        INDX( 	                (              t t l           [    h V     [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 h V     [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 h V     [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 h V     [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 h V     [    *$j3,2 8j3"$j30      ,              
 s c l p _ f  p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 h V     [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 *$j3,2 8j3"$j30      ,              
 s c l p _ f  p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c l p _ f t p . h                 [    *$j3,2 8j3"$j30      ,              
 s c  p _ f t p . h                 [    >j3,2Rj3>j3                     
 s c l p _ o c f . c   [    p ^     [    [j3,2oj3[j3                      s c l p _ q u i e s c e . c   [    h T     [    vj3,2j3zvj3 @      1              	 s c l p _ r w . c     [    h T     [    j3,2j3j3       :
              	 s c l p _ r w . h     [    p Z     [    j3,2j3j3                      s c l p _ s d i a s . c       [    p Z     [    j3,2{j3j3       +               s c l p _ s d i a s . h       [    h V     [    j3,20k3j3 @      ;              
 s c l p _ t t y . c   [    h V     [    k3,2k3k3h      f              
 s c l p _ t t y . h   [    p Z     [    !k3l]2l>k3!k3 `      %X               s c l p _ v t 2 2 0 . c       [    ` N     [    -Ek3l]2 C\k3(Ek3 0      w(               t a p e . h   [    h X     [    bk3l]2Xk3bk3       4               t a p e _ 3 4 x x . c [    h X     [    k3l]2k3k3                      t a p e _ 3 5 9 0 . c [    h X     [    k3l]2k3k3                      t a p e _ 3 5 9 0 . h [    h X     [    \k3l]2k3Zk3 0      m-               t a p e _ c h a r . c [    p Z     [    k3l]2 l3k3                      t a p e _ c l a s s . c       [    p Z     [    )
l3l]2l3&
l3                       t a p e _ c l a s s . h       [    h X     [    $l3l]22*p3$l3                      t a p e _ c o r e . c [    h X     [    6p3l]2Rp36p3       "               t a p e _ p r o c . c [    h V     [    \]p3l]2p3V]p3 P      PH              
 t a p e _ s t d . c                INDX( 	                (            U                [    ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    s3l]2s3s3 P      G               z c o r e . c               [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    s3l]2s3s3U  P      G               z c o r e . c               [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3U  P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3U l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    s3l]2s3s3 P      G               z c o r e . c               [    ` P     [   U s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    ` P     [    s3l]2s3s3 P      G               z c o r e . c       U       ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c               [    ` P     [    s3l]2s3s3 P      G               z c o r e . c               ` P     [    s3l]2s3s3 P      G               z c o r e . c                                                                                             U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               U /*
 * gsc_hpdi.c
 * Comedi driver the General Standards Corporation
 * High Speed Parallel Digital Interface rs485 boards.
 *
 * Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
 * Copyright (C) 2003 Coherent Imaging Systems
 *
 * COMEDI - Linux Control and Measurement Device Interface
 * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/*
 * Driver: gsc_hpdi
 * Description: General Standards Corporation High
 *    Speed Parallel Digital Interface rs485 boards
 * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
 * Status: only receive mode works, transmit not supported
 * Updated: Thu, 01 Nov 2012 16:17:38 +0000
 * Devices: [General Standards Corporation] PCI-HPDI32 (gsc_hpdi),
 *   PMC-HPDI32
 *
 * Configuration options:
 *    None.
 *
 * Manual configuration of supported devices is not supported; they are
 * configured automatically.
 *
 * There are some additional hpdi models available from GSC for which
 * support could be added to this driver.
 */

#include <linux/module.h>
#include <linux/pci.h>
#include <linux/delay.h>
#include <linux/interrupt.h>

#include "../comedidev.h"

#include "plx9080.h"
#include "comedi_fc.h"

/*
 * PCI BAR2 Register map (dev->mmio)
 */
#define FIRMWARE_REV_REG			0x00
#define FEATURES_REG_PRESENT_BIT		(1 << 15)
#define BOARD_CONTROL_REG			0x04
#define BOARD_RESET_BIT				(1 << 0)
#define TX_FIFO_RESET_BIT			(1 << 1)
#define RX_FIFO_RESET_BIT			(1 << 2)
#define TX_ENABLE_BIT				(1 << 4)
#define RX_ENABLE_BIT				(1 << 5)
#define DEMAND_DMA_DIRECTION_TX_BIT		(1 << 6)  /* ch 0 only */
#define LINE_VALID_ON_STATUS_VALID_BIT		(1 << 7)
#define START_TX_BIT				(1 << 8)
#define CABLE_THROTTLE_ENABLE_BIT		(1 << 9)
#define TEST_MODE_ENABLE_BIT			(1 << 31)
#define BOARD_STATUS_REG			0x08
#define COMMAND_LINE_STATUS_MASK		(0x7f << 0)
#define TX_IN_PROGRESS_BIT			(1 << 7)
#define TX_NOT_EMPTY_BIT			(1 << 8)
#define TX_NOT_ALMOST_EMPTY_BIT			(1 << 9)
#define TX_NOT_ALMOST_FULL_BIT			(1 << 10)
#define TX_NOT_FULL_BIT				(1 << 11)
#define RX_NOT_EMPTY_BIT			(1 << 12)
#define RX_NOT_ALMOST_EMPTY_BIT			(1 << 13)
#define RX_NOT_ALMOST_FULL_BIT			(1 << 14)
#define RX_NOT_FULL_BIT				(1 << 15)
#define BOARD_JUMPER0_INSTALLED_BIT		(1 << 16)
#define BOARD_JUMPER1_INSTALLED_BIT		(1 << 17)
#define TX_OVERRUN_BIT				(1 << 21)
#define RX_UNDERRUN_BIT				(1 << 22)
#define RX_OVERRUN_BIT				(1 << 23)
#define TX_PROG_ALMOST_REG			0x0c
#define RX_PROG_ALMOST_REG			0x10
#define ALMOST_EMPTY_BITS(x)			(((x) & 0xffff) << 0)
#define ALMOST_FULL_BITS(x)			(((x) & 0xff) << 16)
#define FEATURES_REG				0x14
#define FIFO_SIZE_PRESENT_BIT			(1 << 0)
#define FIFO_WORDS_PRESENT_BIT			(1 << 1)
#define LEVEL_EDGE_INTERRUPTS_PRESENT_BIT	(1 << 2)
#define GPIO_SUPPORTED_BIT			(1 << 3)
#define PLX_DMA_CH1_SUPPORTED_BIT		(1 << 4)
#define OVERRUN_UNDERRUN_SUPPORTED_BIT		(1 << 5)
#define FIFO_REG				0x18
#define TX_STATUS_COUNT_REG			0x1c
#define TX_LINE_VALID_COUNT_REG			0x20,
#define TX_LINE_INVALID_COUNT_REG		0x24
#define RX_STATUS_COUNT_REG			0x28
#define RX_LINE_COUNT_REG			0x2c
#define INTERRUPT_CONTROL_REG			0x30
#define FRAME_VALID_START_INTR			(1 << 0)
#define FRAME_VALID_END_INTR			(1 << 1)
#define TX_FIFO_EMPTY_INTR			(1 << 8)
#define TX_FIFO_ALMOST_EMPTY_INTR		(1 << 9)
#define TX_FIFO_ALMOST_FULL_INTR		(1 << 10)
#define TX_FIFO_FULL_INTR			(1 << 11)
#define RX_EMPTY_INTR				(1 << 12)
#define RX_ALMOST_EMPTY_INTR			(1 << 13)
#define RX_ALMOST_FULL_INTR			(1 << 14)
#define RX_FULL_INTR				(1 << 15)
#define INTERRUPT_STATUS_REG			0x34
#define TX_CLOCK_DIVIDER_REG			0x38
#define TX_FIFO_SIZE_REG			0x40
#define RX_FIFO_SIZE_REG			0x44
#define FIFO_SIZE_MASK				(0xfffff << 0)
#define TX_FIFO_WORDS_REG			0x48
#define RX_FIFO_WORDS_REG			0x4c
#define INTERRUPT_EDGE_LEVEL_REG		0x50
#define INTERRUPT_POLARITY_REG			0x54

#define TIMER_BASE				50	/* 20MHz master clock */
#define DMA_BUFFER_SIZE				0x10000
#define NUM_DMA_BUFFERS				4
#define NUM_DMA_DESCRIPTORS			256

struct hpdi_board {
	const char *name;
	int device_id;
	int subdevice_id;
};

static const struct hpdi_board hpdi_boards[] = {
	{
		.name		= "pci-hpdi32",
		.device_id	= PCI_DEVICE_ID_PLX_9080,
		.subdevice_id	= 0x2400,
	 },
#if 0
	{
		.name		= "pxi-hpdi32",
		.device_id	= 0x9656,
		.subdevice_id	= 0x2705,
	 },
#endif
};

struct hpdi_private {
	void __iomem *plx9080_mmio;
	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
	/* physical addresses of dma buffers */
	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
	/* array of dma descriptors read by plx9080, allocated to get proper
	 * alignment */
	struct plx_dma_desc *dma_desc;
	/* physical address of dma descriptor array */
	dma_addr_t dma_desc_phys_addr;
	unsigned int num_dma_descriptors;
	/* pointer to start of buffers indexed by descriptor */
	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];
	/* index of the dma descriptor that is currently being used */
	unsigned int dma_desc_index;
	unsigned int tx_fifo_size;
	unsigned int rx_fifo_size;
	unsigned long dio_count;
	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
	unsigned int block_size;
};

static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
{
	struct hpdi_private *devpriv = dev->private;
	struct comedi_subdevice *s = dev->read_subdev;
	struct comedi_cmd *cmd = &s->async->cmd;
	unsigned int idx;
	unsigned int start;
	unsigned int desc;
	unsigned int size;
	unsigned int next;

	if (channel)
		next = readl(devpriv->plx9080_mmio + PLX_DMA1_PCI_ADDRESS_REG);
	else
		next = readl(devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);

	idx = devpriv->dma_desc_index;
	start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);
	/* loop until we have read all the full buffers */
	for (desc = 0; (next < start || next >= start + devpriv->block_size) &&
	     desc < devpriv->num_dma_descriptors; desc++) {
		/* transfer data from dma buffer to comedi buffer */
		size = devpriv->block_size / sizeof(uint32_t);
		if (cmd->stop_src == TRIG_COUNT) {
			if (size > devpriv->dio_count)
				size = devpriv->dio_count;
			devpriv->dio_count -= size;
		}
		cfc_write_array_to_buffer(s, devpriv->desc_dio_buffer[idx],
					  size * sizeof(uint32_t));
		idx++;
		idx %= devpriv->num_dma_descriptors;
		start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);

		devpriv->dma_desc_index = idx;
	}
	/*  XXX check for buffer overrun somehow */
}

static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
{
	struct comedi_device *dev = d;
	struct hpdi_private *devpriv = dev->private;
	struct comedi_subdevice *s = dev->read_subdev;
	struct comedi_async *async = s->async;
	uint32_t hpdi_intr_status, hpdi_board_status;
	uint32_t plx_status;
	uint32_t plx_bits;
	uint8_t dma0_status, dma1_status;
	unsigned long flags;

	if (!dev->attached)
		return IRQ_NONE;

	plx_status = readl(devpriv->plx9080_mmio + PLX_INTRCS_REG);
	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
		return IRQ_NONE;

	hpdi_intr_status = readl(dev->mmio + INTERRUPT_STATUS_REG);
	hpdi_board_status = readl(dev->mmio + BOARD_STATUS_REG);

	if (hpdi_intr_status)
		writel(hpdi_intr_status, dev->mmio + INTERRUPT_STATUS_REG);

	/*  spin lock makes sure no one else changes plx dma control reg */
	spin_lock_irqsave(&dev->spinlock, flags);
	dma0_status = readb(devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
		       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);

		if (dma0_status & PLX_DMA_EN_BIT)
			gsc_hpdi_drain_dma(dev, 0);
	}
	spin_unlock_irqrestore(&dev->spinlock, flags);

	/*  spin lock makes sure no one else changes plx dma control reg */
	spin_lock_irqsave(&dev->spinlock, flags);
	dma1_status = readb(devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
		       devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
	}
	spin_unlock_irqrestore(&dev->spinlock, flags);

	/*  clear possible plx9080 interrupt sources */
	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
		plx_bits = readl(devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
		writel(plx_bits, devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
	}

	if (hpdi_board_status & RX_OVERRUN_BIT) {
		dev_err(dev->class_dev, "rx fifo overrun\n");
		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
	}

	if (hpdi_board_status & RX_UNDERRUN_BIT) {
		dev_err(dev->class_dev, "rx fifo underrun\n");
		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
	}

	if (devpriv->dio_count == 0)
		async->events |= COMEDI_CB_EOA;

	cfc_handle_events(dev, s);

	return IRQ_HANDLED;
}

static void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)
{
	struct hpdi_private *devpriv = dev->private;
	unsigned long flags;

	/*  spinlock for plx dma control/status reg */
	spin_lock_irqsave(&dev->spinlock, flags);

	plx9080_abort_dma(devpriv->plx9080_mmio, channel);

	spin_unlock_irqrestore(&dev->spinlock, flags);
}

static int gsc_hpdi_cancel(struct comedi_device *dev,
			   struct comedi_subdevice *s)
{
	writel(0, dev->mmio + BOARD_CONTROL_REG);
	writel(0, dev->mmio + INTERRUPT_CONTROL_REG);

	gsc_hpdi_abort_dma(dev, 0);

	return 0;
}

static int gsc_hpdi_cmd(struct comedi_device *dev,
			struct comedi_subdevice *s)
{
	struct hpdi_private *devpriv = dev->private;
	struct comedi_async *async = s->async;
	struct comedi_cmd *cmd = &async->cmd;
	unsigned long flags;
	uint32_t bits;

	if (s->io_bits)
		return -EINVAL;

	writel(RX_FIFO_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);

	gsc_hpdi_abort_dma(dev, 0);

	devpriv->dma_desc_index = 0;

	/*
	 * These register are supposedly unused during chained dma,
	 * but I have found that left over values from last operation
	 * occasionally cause problems with transfer of first dma
	 * block.  Initializing them to zero seems to fix the problem.
	 */
	writel(0, devpriv->plx9080_mmio + PLX_DMA0_TRANSFER_SIZE_REG);
	writel(0, devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);
	writel(0, devpriv->plx9080_mmio + PLX_DMA0_LOCAL_ADDRESS_REG);

	/* give location of first dma descriptor */
	bits = devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
	       PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
	writel(bits, devpriv->plx9080_mmio + PLX_DMA0_DESCRIPTOR_REG);

	/* enable dma transfer */
	spin_lock_irqsave(&dev->spinlock, flags);
	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
	       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
	spin_unlock_irqrestore(&dev->spinlock, flags);

	if (cmd->stop_src == TRIG_COUNT)
		devpriv->dio_count = cmd->stop_arg;
	else
		devpriv->dio_count = 1;

	/* clear over/under run status flags */
	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT, dev->mmio + BOARD_STATUS_REG);

	/* enable interrupts */
	writel(RX_FULL_INTR, dev->mmio + INTERRUPT_CONTROL_REG);

	writel(RX_ENABLE_BIT, dev->mmio + BOARD_CONTROL_REG);

	return 0;
}

static int gsc_hpdi_check_chanlist(struct comedi_device *dev,
				   struct comedi_subdevice *s,
				   struct comedi_cmd *cmd)
{
	int i;

	for (i = 0; i < cmd->chanlist_len; i++) {
		unsigned int chan = CR_CHAN(cmd->chanlist[i]);

		if (chan != i) {
			dev_dbg(dev->class_dev,
				"chanlist must be ch 0 to 31 in order\n");
			return -EINVAL;
		}
	}

	return 0;
}

static int gsc_hpdi_cmd_test(struct comedi_device *dev,
			     struct comedi_subdevice *s,
			     struct comedi_cmd *cmd)
{
	int err = 0;

	if (s->io_bits)
		return -EINVAL;

	/* Step 1 : check if triggers are trivially valid */

	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);

	if (err)
		return 1;

	/* Step 2a : make sure trigger sources are unique */

	err |= cfc_check_trigger_is_unique(cmd->stop_src);

	/* Step 2b : and mutually compatible */

	if (err)
		return 2;

	/* Step 3: check if arguments are trivially valid */

	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);

	if (!cmd->chanlist_len || !cmd->chanlist) {
		cmd->chanlist_len = 32;
		err |= -EINVAL;
	}
	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);

	if (cmd->stop_src == TRIG_COUNT)
		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
	else	/* TRIG_NONE */
		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);

	if (err)
		return 3;

	/* Step 4: fix up any arguments */

	/* Step 5: check channel list if it exists */

	if (cmd->chanlist && cmd->chanlist_len > 0)
		err |= gsc_hpdi_check_chanlist(dev, s, cmd);

	if (err)
		return 5;

	return 0;

}

/* setup dma descriptors so a link completes every 'len' bytes */
static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
					  unsigned int len)
{
	struct hpdi_private *devpriv = dev->private;
	dma_addr_t phys_addr = devpriv->dma_desc_phys_addr;
	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
			     PLX_XFER_LOCAL_TO_PCI;
	unsigned int offset = 0;
	unsigned int idx = 0;
	unsigned int i;

	if (len > DMA_BUFFER_SIZE)
		len = DMA_BUFFER_SIZE;
	len -= len % sizeof(uint32_t);
	if (len == 0)
		return -EINVAL;

	for (i = 0; i < NUM_DMA_DESCRIPTORS && idx < NUM_DMA_BUFFERS; i++) {
		devpriv->dma_desc[i].pci_start_addr =
		    cpu_to_le32(devpriv->dio_buffer_phys_addr[idx] + offset);
		devpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
		devpriv->dma_desc[i].transfer_size = cpu_to_le32(len);
		devpriv->dma_desc[i].next = cpu_to_le32((phys_addr +
			(i + 1) * sizeof(devpriv->dma_desc[0])) | next_bits);

		devpriv->desc_dio_buffer[i] = devpriv->dio_buffer[idx] +
					      (offset / sizeof(uint32_t));

		offset += len;
		if (len + offset > DMA_BUFFER_SIZE) {
			offset = 0;
			idx++;
		}
	}
	devpriv->num_dma_descriptors = i;
	/* fix last descriptor to point back to first */
	devpriv->dma_desc[i - 1].next = cpu_to_le32(phys_addr | next_bits);

	devpriv->block_size = len;

	return len;
}

static int gsc_hpdi_dio_insn_config(struct comedi_device *dev,
				    struct comedi_subdevice *s,
				    struct comedi_insn *insn,
				    unsigned int *data)
{
	int ret;

	switch (data[0]) {
	case INSN_CONFIG_BLOCK_SIZE:
		ret = gsc_hpdi_setup_dma_descriptors(dev, data[1]);
		if (ret)
			return ret;

		data[1] = ret;
		break;
	default:
		ret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);
		if (ret)
			return ret;
		break;
	}

	return insn->n;
}

static void gsc_hpdi_free_dma(struct comedi_device *dev)
{
	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
	struct hpdi_private *devpriv = dev->private;
	int i;

	if (!devpriv)
		return;

	/* free pci dma buffers */
	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
		if (devpriv->dio_buffer[i])
			pci_free_consistent(pcidev,
					    DMA_BUFFER_SIZE,
					    devpriv->dio_buffer[i],
					    devpriv->dio_buffer_phys_addr[i]);
	}
	/* free dma descriptors */
	if (devpriv->dma_desc)
		pci_free_consistent(pcidev,
				    sizeof(struct plx_dma_desc) *
				    NUM_DMA_DESCRIPTORS,
				    devpriv->dma_desc,
				    devpriv->dma_desc_phys_addr);
}

static int gsc_hpdi_init(struct comedi_device *dev)
{
	struct hpdi_private *devpriv = dev->private;
	uint32_t plx_intcsr_bits;

	/* wait 10usec after reset before accessing fifos */
	writel(BOARD_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);
	udelay(10);

	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
	       dev->mmio + RX_PROG_ALMOST_REG);
	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
	       dev->mmio + TX_PROG_ALMOST_REG);

	devpriv->tx_fifo_size = readl(dev->mmio + TX_FIFO_SIZE_REG) &
				FIFO_SIZE_MASK;
	devpriv->rx_fifo_size = readl(dev->mmio + RX_FIFO_SIZE_REG) &
				FIFO_SIZE_MASK;

	writel(0, dev->mmio + INTERRUPT_CONTROL_REG);

	/*  enable interrupts */
	plx_intcsr_bits =
	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
	    ICS_DMA0_E;
	writel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_INTRCS_REG);

	return 0;
}

static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
{
	struct hpdi_private *devpriv = dev->private;
	uint32_t bits;
	void __iomem *plx_iobase = devpriv->plx9080_mmio;

#ifdef __BIG_ENDIAN
	bits = BIGEND_DMA0 | BIGEND_DMA1;
#else
	bits = 0;
#endif
	writel(bits, devpriv->plx9080_mmio + PLX_BIGEND_REG);

	writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);

	gsc_hpdi_abort_dma(dev, 0);
	gsc_hpdi_abort_dma(dev, 1);

	/*  configure dma0 mode */
	bits = 0;
	/*  enable ready input */
	bits |= PLX_DMA_EN_READYIN_BIT;
	/*  enable dma chaining */
	bits |= PLX_EN_CHAIN_BIT;
	/*  enable interrupt on dma done
	 *  (probably don't need this, since chain never finishes) */
	bits |= PLX_EN_DMA_DONE_INTR_BIT;
	/*  don't increment local address during transfers
	 *  (we are transferring from a fixed fifo register) */
	bits |= PLX_LOCAL_ADDR_CONST_BIT;
	/*  route dma interrupt to pci bus */
	bits |= PLX_DMA_INTR_PCI_BIT;
	/*  enable demand mode */
	bits |= PLX_DEMAND_MODE_BIT;
	/*  enable local burst mode */
	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
}

static const struct hpdi_board *gsc_hpdi_find_board(struct pci_dev *pcidev)
{
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(hpdi_boards); i++)
		if (pcidev->device == hpdi_boards[i].device_id &&
		    pcidev->subsystem_device == hpdi_boards[i].subdevice_id)
			return &hpdi_boards[i];
	return NULL;
}

static int gsc_hpdi_auto_attach(struct comedi_device *dev,
				unsigned long context_unused)
{
	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
	const struct hpdi_board *thisboard;
	struct hpdi_private *devpriv;
	struct comedi_subdevice *s;
	int i;
	int retval;

	thisboard = gsc_hpdi_find_board(pcidev);
	if (!thisboard) {
		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
			pci_name(pcidev));
		return -EINVAL;
	}
	dev->board_ptr = thisboard;
	dev->board_name = thisboard->name;

	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
	if (!devpriv)
		return -ENOMEM;

	retval = comedi_pci_enable(dev);
	if (retval)
		return retval;
	pci_set_master(pcidev);

	devpriv->plx9080_mmio = pci_ioremap_bar(pcidev, 0);
	dev->mmio = pci_ioremap_bar(pcidev, 2);
	if (!devpriv->plx9080_mmio || !dev->mmio) {
		dev_warn(dev->class_dev, "failed to remap io memory\n");
		return -ENOMEM;
	}

	gsc_hpdi_init_plx9080(dev);

	/*  get irq */
	if (request_irq(pcidev->irq, gsc_hpdi_interrupt, IRQF_SHARED,
			dev->board_name, dev)) {
		dev_warn(dev->class_dev,
			 "unable to allocate irq %u\n", pcidev->irq);
		return -EINVAL;
	}
	dev->irq = pcidev->irq;

	dev_dbg(dev->class_dev, " irq %u\n", dev->irq);

	/*  allocate pci dma buffers */
	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
		devpriv->dio_buffer[i] =
		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
					 &devpriv->dio_buffer_phys_addr[i]);
	}
	/*  allocate dma descriptors */
	devpriv->dma_desc = pci_alloc_consistent(pcidev,
						 sizeof(struct plx_dma_desc) *
						 NUM_DMA_DESCRIPTORS,
						 &devpriv->dma_desc_phys_addr);
	if (devpriv->dma_desc_phys_addr & 0xf) {
		dev_warn(dev->class_dev,
			 " dma descriptors not quad-word aligned (bug)\n");
		return -EIO;
	}

	retval = gsc_hpdi_setup_dma_descriptors(dev, 0x1000);
	if (retval < 0)
		return retval;

	retval = comedi_alloc_subdevices(dev, 1);
	if (retval)
		return retval;

	/* Digital I/O subdevice */
	s = &dev->subdevices[0];
	dev->read_subdev = s;
	s->type		= COMEDI_SUBD_DIO;
	s->subdev_flags	= SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL |
			  SDF_CMD_READ;
	s->n_chan	= 32;
	s->len_chanlist	= 32;
	s->maxdata	= 1;
	s->range_table	= &range_digital;
	s->insn_config	= gsc_hpdi_dio_insn_config;
	s->do_cmd	= gsc_hpdi_cmd;
	s->do_cmdtest	= gsc_hpdi_cmd_test;
	s->cancel	= gsc_hpdi_cancel;

	return gsc_hpdi_init(dev);
}

static void gsc_hpdi_detach(struct comedi_device *dev)
{
	struct hpdi_private *devpriv = dev->private;

	if (dev->irq)
		free_irq(dev->irq, dev);
	if (devpriv) {
		if (devpriv->plx9080_mmio) {
			writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
			iounmap(devpriv->plx9080_mmio);
		}
		if (dev->mmio)
			iounmap(dev->mmio);
	}
	comedi_pci_disable(dev);
	gsc_hpdi_free_dma(dev);
}

static struct comedi_driver gsc_hpdi_driver = {
	.driver_name	= "gsc_hpdi",
	.module		= THIS_MODULE,
	.auto_attach	= gsc_hpdi_auto_attach,
	.detach		= gsc_hpdi_detach,
};

static int gsc_hpdi_pci_probe(struct pci_dev *dev,
			      const struct pci_device_id *id)
{
	return comedi_pci_auto_config(dev, &gsc_hpdi_driver, id->driver_data);
}

static const struct pci_device_id gsc_hpdi_pci_table[] = {
	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
		    0x2400, 0, 0, 0},
	{ 0 }
};
MODULE_DEVICE_TABLE(pci, gsc_hpdi_pci_table);

static struct pci_driver gsc_hpdi_pci_driver = {
	.name		= "gsc_hpdi",
	.id_table	= gsc_hpdi_pci_table,
	.probe		= gsc_hpdi_pci_probe,
	.remove		= comedi_pci_auto_unconfig,
};
module_comedi_pci_driver(gsc_hpdi_driver, gsc_hpdi_pci_driver);

MODULE_AUTHOR("Comedi http://www.comedi.org");
MODULE_DESCRIPTION("Comedi low-level driver");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #include <linux/slab.h> /* for kmalloc */
#include <linux/consolemap.h>
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <linux/device.h> /* for dev_warn */
#include <linux/selection.h>
#include <linux/workqueue.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <asm/cmpxchg.h>

#include "speakup.h"

/* ------ cut and paste ----- */
/* Don't take this from <ctype.h>: 011-015 on the screen aren't spaces */
#define ishardspace(c)      ((c) == ' ')

unsigned short spk_xs, spk_ys, spk_xe, spk_ye; /* our region points */

/* Variables for selection control. */
/* must not be deallocated */
struct vc_data *spk_sel_cons;
/* cleared by clear_selection */
static int sel_start = -1;
static int sel_end;
static int sel_buffer_lth;
static char *sel_buffer;

static unsigned char sel_pos(int n)
{
	return inverse_translate(spk_sel_cons,
		screen_glyph(spk_sel_cons, n), 0);
}

void speakup_clear_selection(void)
{
	sel_start = -1;
}

/* does screen address p correspond to character at LH/RH edge of screen? */
static int atedge(const int p, int size_row)
{
	return !(p % size_row) || !((p + 2) % size_row);
}

/* constrain v such that v <= u */
static unsigned short limit(const unsigned short v, const unsigned short u)
{
	return (v > u) ? u : v;
}

int speakup_set_selection(struct tty_struct *tty)
{
	int new_sel_start, new_sel_end;
	char *bp, *obp;
	int i, ps, pe;
	struct vc_data *vc = vc_cons[fg_console].d;

	spk_xs = limit(spk_xs, vc->vc_cols - 1);
	spk_ys = limit(spk_ys, vc->vc_rows - 1);
	spk_xe = limit(spk_xe, vc->vc_cols - 1);
	spk_ye = limit(spk_ye, vc->vc_rows - 1);
	ps = spk_ys * vc->vc_size_row + (spk_xs << 1);
	pe = spk_ye * vc->vc_size_row + (spk_xe << 1);

	if (ps > pe) {
		/* make sel_start <= sel_end */
		int tmp = ps;

		ps = pe;
		pe = tmp;
	}

	if (spk_sel_cons != vc_cons[fg_console].d) {
		speakup_clear_selection();
		spk_sel_cons = vc_cons[fg_console].d;
		dev_warn(tty->dev,
			"Selection: mark console not the same as cut\n");
		return -EINVAL;
	}

	new_sel_start = ps;
	new_sel_end = pe;

	/* select to end of line if on trailing space */
	if (new_sel_end > new_sel_start &&
	    !atedge(new_sel_end, vc->vc_size_row) &&
	    ishardspace(sel_pos(new_sel_end))) {
		for (pe = new_sel_end + 2; ; pe += 2)
			if (!ishardspace(sel_pos(pe)) ||
			    atedge(pe, vc->vc_size_row))
				break;
		if (ishardspace(sel_pos(pe)))
			new_sel_end = pe;
	}
	if ((new_sel_start == sel_start) && (new_sel_end == sel_end))
		return 0; /* no action required */

	sel_start = new_sel_start;
	sel_end = new_sel_end;
	/* Allocate a new buffer before freeing the old one ... */
	bp = kmalloc((sel_end-sel_start)/2+1, GFP_ATOMIC);
	if (!bp) {
		speakup_clear_selection();
		return -ENOMEM;
	}
	kfree(sel_buffer);
	sel_buffer = bp;

	obp = bp;
	for (i = sel_start; i <= sel_end; i += 2) {
		*bp = sel_pos(i);
		if (!ishardspace(*bp++))
			obp = bp;
		if (!((i + 2) % vc->vc_size_row)) {
			/* strip trailing blanks from line and add newline,
			   unless non-space at end of line. */
			if (obp != bp) {
				bp = obp;
				*bp++ = '\r';
			}
			obp = bp;
		}
	}
	sel_buffer_lth = bp - sel_buffer;
	return 0;
}

struct speakup_paste_work {
	struct work_struct work;
	struct tty_struct *tty;
};

static void __speakup_paste_selection(struct work_struct *work)
{
	struct speakup_paste_work *spw =
		container_of(work, struct speakup_paste_work, work);
	struct tty_struct *tty = xchg(&spw->tty, NULL);
	struct vc_data *vc = (struct vc_data *) tty->driver_data;
	int pasted = 0, count;
	struct tty_ldisc *ld;
	DECLARE_WAITQUEUE(wait, current);

	ld = tty_ldisc_ref(tty);
	if (!ld)
		goto tty_unref;
	tty_buffer_lock_exclusive(&vc->port);

	add_wait_queue(&vc->paste_wait, &wait);
	while (sel_buffer && sel_buffer_lth > pasted) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (test_bit(TTY_THROTTLED, &tty->flags)) {
			schedule();
			continue;
		}
		count = sel_buffer_lth - pasted;
		count = tty_ldisc_receive_buf(ld, sel_buffer + pasted, NULL,
					      count);
		pasted += count;
	}
	remove_wait_queue(&vc->paste_wait, &wait);
	current->state = TASK_RUNNING;

	tty_buffer_unlock_exclusive(&vc->port);
	tty_ldisc_deref(ld);
tty_unref:
	tty_kref_put(tty);
}

static struct speakup_paste_work speakup_paste_work = {
	.work = __WORK_INITIALIZER(speakup_paste_work.work,
				   __speakup_paste_selection)
};

int speakup_paste_selection(struct tty_struct *tty)
{
	if (cmpxchg(&speakup_paste_work.tty, NULL, tty) != NULL)
		return -EBUSY;

	tty_kref_get(tty);
	schedule_work_on(WORK_CPU_UNBOUND, &speakup_paste_work.work);
	return 0;
}

void speakup_cancel_paste(void)
{
	cancel_work_sync(&speakup_paste_work.work);
	tty_kref_put(speakup_paste_work.tty);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * WUSB devices
 * sysfs bindings
 *
 * Copyright (C) 2007 Intel Corporation
 * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *
 *
 * Get them out of the way...
 */

#include <linux/jiffies.h>
#include <linux/ctype.h>
#include <linux/workqueue.h>
#include "wusbhc.h"

static ssize_t wusb_disconnect_store(struct device *dev,
				     struct device_attribute *attr,
				     const char *buf, size_t size)
{
	struct usb_device *usb_dev;
	struct wusbhc *wusbhc;
	unsigned command;
	u8 port_idx;

	if (sscanf(buf, "%u", &command) != 1)
		return -EINVAL;
	if (command == 0)
		return size;
	usb_dev = to_usb_device(dev);
	wusbhc = wusbhc_get_by_usb_dev(usb_dev);
	if (wusbhc == NULL)
		return -ENODEV;

	mutex_lock(&wusbhc->mutex);
	port_idx = wusb_port_no_to_idx(usb_dev->portnum);
	__wusbhc_dev_disable(wusbhc, port_idx);
	mutex_unlock(&wusbhc->mutex);
	wusbhc_put(wusbhc);
	return size;
}
static DEVICE_ATTR(wusb_disconnect, 0200, NULL, wusb_disconnect_store);

static ssize_t wusb_cdid_show(struct device *dev,
			      struct device_attribute *attr, char *buf)
{
	ssize_t result;
	struct wusb_dev *wusb_dev;

	wusb_dev = wusb_dev_get_by_usb_dev(to_usb_device(dev));
	if (wusb_dev == NULL)
		return -ENODEV;
	result = ckhdid_printf(buf, PAGE_SIZE, &wusb_dev->cdid);
	strcat(buf, "\n");
	wusb_dev_put(wusb_dev);
	return result + 1;
}
static DEVICE_ATTR(wusb_cdid, 0444, wusb_cdid_show, NULL);

static ssize_t wusb_ck_store(struct device *dev,
			     struct device_attribute *attr,
			     const char *buf, size_t size)
{
	int result;
	struct usb_device *usb_dev;
	struct wusbhc *wusbhc;
	struct wusb_ckhdid ck;

	result = sscanf(buf,
			"%02hhx %02hhx %02hhx %02hhx "
			"%02hhx %02hhx %02hhx %02hhx "
			"%02hhx %02hhx %02hhx %02hhx "
			"%02hhx %02hhx %02hhx %02hhx\n",
			&ck.data[0] , &ck.data[1],
			&ck.data[2] , &ck.data[3],
			&ck.data[4] , &ck.data[5],
			&ck.data[6] , &ck.data[7],
			&ck.data[8] , &ck.data[9],
			&ck.data[10], &ck.data[11],
			&ck.data[12], &ck.data[13],
			&ck.data[14], &ck.data[15]);
	if (result != 16)
		return -EINVAL;

	usb_dev = to_usb_device(dev);
	wusbhc = wusbhc_get_by_usb_dev(usb_dev);
	if (wusbhc == NULL)
		return -ENODEV;
	result = wusb_dev_4way_handshake(wusbhc, usb_dev->wusb_dev, &ck);
	memset(&ck, 0, sizeof(ck));
	wusbhc_put(wusbhc);
	return result < 0 ? result : size;
}
static DEVICE_ATTR(wusb_ck, 0200, NULL, wusb_ck_store);

static struct attribute *wusb_dev_attrs[] = {
		&dev_attr_wusb_disconnect.attr,
		&dev_attr_wusb_cdid.attr,
		&dev_attr_wusb_ck.attr,
		NULL,
};

static struct attribute_group wusb_dev_attr_group = {
	.name = NULL,	/* we want them in the same directory */
	.attrs = wusb_dev_attrs,
};

int wusb_dev_sysfs_add(struct wusbhc *wusbhc, struct usb_device *usb_dev,
		       struct wusb_dev *wusb_dev)
{
	int result = sysfs_create_group(&usb_dev->dev.kobj,
					&wusb_dev_attr_group);
	struct device *dev = &usb_dev->dev;
	if (result < 0)
		dev_err(dev, "Cannot register WUSB-dev attributes: %d\n",
			result);
	return result;
}

void wusb_dev_sysfs_rm(struct wusb_dev *wusb_dev)
{
	struct usb_device *usb_dev = wusb_dev->usb_dev;
	if (usb_dev)
		sysfs_remove_group(&usb_dev->dev.kobj, &wusb_dev_attr_group);
}
                                                                                                                                                                                                                                                    /*
 * Copyright (C) 2012 Alexander Block.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License v2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 021110-1307, USA.
 */

#include <linux/bsearch.h>
#include <linux/fs.h>
#include <linux/file.h>
#include <linux/sort.h>
#include <linux/mount.h>
#include <linux/xattr.h>
#include <linux/posix_acl_xattr.h>
#include <linux/radix-tree.h>
#include <linux/vmalloc.h>
#include <linux/string.h>

#include "send.h"
#include "backref.h"
#include "hash.h"
#include "locking.h"
#include "disk-io.h"
#include "btrfs_inode.h"
#include "transaction.h"

static int g_verbose = 0;

#define verbose_printk(...) if (g_verbose) printk(__VA_ARGS__)

/*
 * A fs_path is a helper to dynamically build path names with unknown size.
 * It reallocates the internal buffer on demand.
 * It allows fast adding of path elements on the right side (normal path) and
 * fast adding to the left side (reversed path). A reversed path can also be
 * unreversed if needed.
 */
struct fs_path {
	union {
		struct {
			char *start;
			char *end;

			char *buf;
			unsigned short buf_len:15;
			unsigned short reversed:1;
			char inline_buf[];
		};
		/*
		 * Average path length does not exceed 200 bytes, we'll have
		 * better packing in the slab and higher chance to satisfy
		 * a allocation later during send.
		 */
		char pad[256];
	};
};
#define FS_PATH_INLINE_SIZE \
	(sizeof(struct fs_path) - offsetof(struct fs_path, inline_buf))


/* reused for each extent */
struct clone_root {
	struct btrfs_root *root;
	u64 ino;
	u64 offset;

	u64 found_refs;
};

#define SEND_CTX_MAX_NAME_CACHE_SIZE 128
#define SEND_CTX_NAME_CACHE_CLEAN_SIZE (SEND_CTX_MAX_NAME_CACHE_SIZE * 2)

struct send_ctx {
	struct file *send_filp;
	loff_t send_off;
	char *send_buf;
	u32 send_size;
	u32 send_max_size;
	u64 total_send_size;
	u64 cmd_send_size[BTRFS_SEND_C_MAX + 1];
	u64 flags;	/* 'flags' member of btrfs_ioctl_send_args is u64 */

	struct btrfs_root *send_root;
	struct btrfs_root *parent_root;
	struct clone_root *clone_roots;
	int clone_roots_cnt;

	/* current state of the compare_tree call */
	struct btrfs_path *left_path;
	struct btrfs_path *right_path;
	struct btrfs_key *cmp_key;

	/*
	 * infos of the currently processed inode. In case of deleted inodes,
	 * these are the values from the deleted inode.
	 */
	u64 cur_ino;
	u64 cur_inode_gen;
	int cur_inode_new;
	int cur_inode_new_gen;
	int cur_inode_deleted;
	u64 cur_inode_size;
	u64 cur_inode_mode;
	u64 cur_inode_rdev;
	u64 cur_inode_last_extent;

	u64 send_progress;

	struct list_head new_refs;
	struct list_head deleted_refs;

	struct radix_tree_root name_cache;
	struct list_head name_cache_list;
	int name_cache_size;

	struct file_ra_state ra;

	char *read_buf;

	/*
	 * We process inodes by their increasing order, so if before an
	 * incremental send we reverse the parent/child relationship of
	 * directories such that a directory with a lower inode number was
	 * the parent of a directory with a higher inode number, and the one
	 * becoming the new parent got renamed too, we can't rename/move the
	 * directory with lower inode number when we finish processing it - we
	 * must process the directory with higher inode number first, then
	 * rename/move it and then rename/move the directory with lower inode
	 * number. Example follows.
	 *
	 * Tree state when the first send was performed:
	 *
	 * .
	 * |-- a                   (ino 257)
	 *     |-- b               (ino 258)
	 *         |
	 *         |
	 *         |-- c           (ino 259)
	 *         |   |-- d       (ino 260)
	 *         |
	 *         |-- c2          (ino 261)
	 *
	 * Tree state when the second (incremental) send is performed:
	 *
	 * .
	 * |-- a                   (ino 257)
	 *     |-- b               (ino 258)
	 *         |-- c2          (ino 261)
	 *             |-- d2      (ino 260)
	 *                 |-- cc  (ino 259)
	 *
	 * The sequence of steps that lead to the second state was:
	 *
	 * mv /a/b/c/d /a/b/c2/d2
	 * mv /a/b/c /a/b/c2/d2/cc
	 *
	 * "c" has lower inode number, but we can't move it (2nd mv operation)
	 * before we move "d", which has higher inode number.
	 *
	 * So we just memorize which move/rename operations must be performed
	 * later when their respective parent is processed and moved/renamed.
	 */

	/* Indexed by parent directory inode number. */
	struct rb_root pending_dir_moves;

	/*
	 * Reverse index, indexed by the inode number of a directory that
	 * is waiting for the move/rename of its immediate parent before its
	 * own move/rename can be performed.
	 */
	struct rb_root waiting_dir_moves;

	/*
	 * A directory that is going to be rm'ed might have a child directory
	 * which is in the pending directory moves index above. In this case,
	 * the directory can only be removed after the move/rename of its child
	 * is performed. Example:
	 *
	 * Parent snapshot:
	 *
	 * .                        (ino 256)
	 * |-- a/                   (ino 257)
	 *     |-- b/               (ino 258)
	 *         |-- c/           (ino 259)
	 *         |   |-- x/       (ino 260)
	 *         |
	 *         |-- y/           (ino 261)
	 *
	 * Send snapshot:
	 *
	 * .                        (ino 256)
	 * |-- a/                   (ino 257)
	 *     |-- b/               (ino 258)
	 *         |-- YY/          (ino 261)
	 *              |-- x/      (ino 260)
	 *
	 * Sequence of steps that lead to the send snapshot:
	 * rm -f /a/b/c/foo.txt
	 * mv /a/b/y /a/b/YY
	 * mv /a/b/c/x /a/b/YY
	 * rmdir /a/b/c
	 *
	 * When the child is processed, its move/rename is delayed until its
	 * parent is processed (as explained above), but all other operations
	 * like update utimes, chown, chgrp, etc, are performed and the paths
	 * that it uses for those operations must use the orphanized name of
	 * its parent (the directory we're going to rm later), so we need to
	 * memorize that name.
	 *
	 * Indexed by the inode number of the directory to be deleted.
	 */
	struct rb_root orphan_dirs;
};

struct pending_dir_move {
	struct rb_node node;
	struct list_head list;
	u64 parent_ino;
	u64 ino;
	u64 gen;
	struct list_head update_refs;
};

struct waiting_dir_move {
	struct rb_node node;
	u64 ino;
	/*
	 * There might be some directory that could not be removed because it
	 * was waiting for this directory inode to be moved first. Therefore
	 * after this directory is moved, we can try to rmdir the ino rmdir_ino.
	 */
	u64 rmdir_ino;
};

struct orphan_dir_info {
	struct rb_node node;
	u64 ino;
	u64 gen;
};

struct name_cache_entry {
	struct list_head list;
	/*
	 * radix_tree has only 32bit entries but we need to handle 64bit inums.
	 * We use the lower 32bit of the 64bit inum to store it in the tree. If
	 * more then one inum would fall into the same entry, we use radix_list
	 * to store the additional entries. radix_list is also used to store
	 * entries where two entries have the same inum but different
	 * generations.
	 */
	struct list_head radix_list;
	u64 ino;
	u64 gen;
	u64 parent_ino;
	u64 parent_gen;
	int ret;
	int need_later_update;
	int name_len;
	char name[];
};

static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);

static struct waiting_dir_move *
get_waiting_dir_move(struct send_ctx *sctx, u64 ino);

static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);

static int need_send_hole(struct send_ctx *sctx)
{
	return (sctx->parent_root && !sctx->cur_inode_new &&
		!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&
		S_ISREG(sctx->cur_inode_mode));
}

static void fs_path_reset(struct fs_path *p)
{
	if (p->reversed) {
		p->start = p->buf + p->buf_len - 1;
		p->end = p->start;
		*p->start = 0;
	} else {
		p->start = p->buf;
		p->end = p->start;
		*p->start = 0;
	}
}

static struct fs_path *fs_path_alloc(void)
{
	struct fs_path *p;

	p = kmalloc(sizeof(*p), GFP_NOFS);
	if (!p)
		return NULL;
	p->reversed = 0;
	p->buf = p->inline_buf;
	p->buf_len = FS_PATH_INLINE_SIZE;
	fs_path_reset(p);
	return p;
}

static struct fs_path *fs_path_alloc_reversed(void)
{
	struct fs_path *p;

	p = fs_path_alloc();
	if (!p)
		return NULL;
	p->reversed = 1;
	fs_path_reset(p);
	return p;
}

static void fs_path_free(struct fs_path *p)
{
	if (!p)
		return;
	if (p->buf != p->inline_buf)
		kfree(p->buf);
	kfree(p);
}

static int fs_path_len(struct fs_path *p)
{
	return p->end - p->start;
}

static int fs_path_ensure_buf(struct fs_path *p, int len)
{
	char *tmp_buf;
	int path_len;
	int old_buf_len;

	len++;

	if (p->buf_len >= len)
		return 0;

	if (len > PATH_MAX) {
		WARN_ON(1);
		return -ENOMEM;
	}

	path_len = p->end - p->start;
	old_buf_len = p->buf_len;

	/*
	 * First time the inline_buf does not suffice
	 */
	if (p->buf == p->inline_buf) {
		tmp_buf = kmalloc(len, GFP_NOFS);
		if (tmp_buf)
			memcpy(tmp_buf, p->buf, old_buf_len);
	} else {
		tmp_buf = krealloc(p->buf, len, GFP_NOFS);
	}
	if (!tmp_buf)
		return -ENOMEM;
	p->buf = tmp_buf;
	/*
	 * The real size of the buffer is bigger, this will let the fast path
	 * happen most of the time
	 */
	p->buf_len = ksize(p->buf);

	if (p->reversed) {
		tmp_buf = p->buf + old_buf_len - path_len - 1;
		p->end = p->buf + p->buf_len - 1;
		p->start = p->end - path_len;
		memmove(p->start, tmp_buf, path_len + 1);
	} else {
		p->start = p->buf;
		p->end = p->start + path_len;
	}
	return 0;
}

static int fs_path_prepare_for_add(struct fs_path *p, int name_len,
				   char **prepared)
{
	int ret;
	int new_len;

	new_len = p->end - p->start + name_len;
	if (p->start != p->end)
		new_len++;
	ret = fs_path_ensure_buf(p, new_len);
	if (ret < 0)
		goto out;

	if (p->reversed) {
		if (p->start != p->end)
			*--p->start = '/';
		p->start -= name_len;
		*prepared = p->start;
	} else {
		if (p->start != p->end)
			*p->end++ = '/';
		*prepared = p->end;
		p->end += name_len;
		*p->end = 0;
	}

out:
	return ret;
}

static int fs_path_add(struct fs_path *p, const char *name, int name_len)
{
	int ret;
	char *prepared;

	ret = fs_path_prepare_for_add(p, name_len, &prepared);
	if (ret < 0)
		goto out;
	memcpy(prepared, name, name_len);

out:
	return ret;
}

static int fs_path_add_path(struct fs_path *p, struct fs_path *p2)
{
	int ret;
	char *prepared;

	ret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);
	if (ret < 0)
		goto out;
	memcpy(prepared, p2->start, p2->end - p2->start);

out:
	return ret;
}

static int fs_path_add_from_extent_buffer(struct fs_path *p,
					  struct extent_buffer *eb,
					  unsigned long off, int len)
{
	int ret;
	char *prepared;

	ret = fs_path_prepare_for_add(p, len, &prepared);
	if (ret < 0)
		goto out;

	read_extent_buffer(eb, prepared, off, len);

out:
	return ret;
}

static int fs_path_copy(struct fs_path *p, struct fs_path *from)
{
	int ret;

	p->reversed = from->reversed;
	fs_path_reset(p);

	ret = fs_path_add_path(p, from);

	return ret;
}


static void fs_path_unreverse(struct fs_path *p)
{
	char *tmp;
	int len;

	if (!p->reversed)
		return;

	tmp = p->start;
	len = p->end - p->start;
	p->start = p->buf;
	p->end = p->start + len;
	memmove(p->start, tmp, len + 1);
	p->reversed = 0;
}

static struct btrfs_path *alloc_path_for_send(void)
{
	struct btrfs_path *path;

	path = btrfs_alloc_path();
	if (!path)
		return NULL;
	path->search_commit_root = 1;
	path->skip_locking = 1;
	path->need_commit_sem = 1;
	return path;
}

static int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)
{
	int ret;
	mm_segment_t old_fs;
	u32 pos = 0;

	old_fs = get_fs();
	set_fs(KERNEL_DS);

	while (pos < len) {
		ret = vfs_write(filp, (__force const char __user *)buf + pos,
				len - pos, off);
		/* TODO handle that correctly */
		/*if (ret == -ERESTARTSYS) {
			continue;
		}*/
		if (ret < 0)
			goto out;
		if (ret == 0) {
			ret = -EIO;
			goto out;
		}
		pos += ret;
	}

	ret = 0;

out:
	set_fs(old_fs);
	return ret;
}

static int tlv_put(struct send_ctx *sctx, u16 attr, const void *data, int len)
{
	struct btrfs_tlv_header *hdr;
	int total_len = sizeof(*hdr) + len;
	int left = sctx->send_max_size - sctx->send_size;

	if (unlikely(left < total_len))
		return -EOVERFLOW;

	hdr = (struct btrfs_tlv_header *) (sctx->send_buf + sctx->send_size);
	hdr->tlv_type = cpu_to_le16(attr);
	hdr->tlv_len = cpu_to_le16(len);
	memcpy(hdr + 1, data, len);
	sctx->send_size += total_len;

	return 0;
}

#define TLV_PUT_DEFINE_INT(bits) \
	static int tlv_put_u##bits(struct send_ctx *sctx,	 	\
			u##bits attr, u##bits value)			\
	{								\
		__le##bits __tmp = cpu_to_le##bits(value);		\
		return tlv_put(sctx, attr, &__tmp, sizeof(__tmp));	\
	}

TLV_PUT_DEFINE_INT(64)

static int tlv_put_string(struct send_ctx *sctx, u16 attr,
			  const char *str, int len)
{
	if (len == -1)
		len = strlen(str);
	return tlv_put(sctx, attr, str, len);
}

static int tlv_put_uuid(struct send_ctx *sctx, u16 attr,
			const u8 *uuid)
{
	return tlv_put(sctx, attr, uuid, BTRFS_UUID_SIZE);
}

static int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,
				  struct extent_buffer *eb,
				  struct btrfs_timespec *ts)
{
	struct btrfs_timespec bts;
	read_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));
	return tlv_put(sctx, attr, &bts, sizeof(bts));
}


#define TLV_PUT(sctx, attrtype, attrlen, data) \
	do { \
		ret = tlv_put(sctx, attrtype, attrlen, data); \
		if (ret < 0) \
			goto tlv_put_failure; \
	} while (0)

#define TLV_PUT_INT(sctx, attrtype, bits, value) \
	do { \
		ret = tlv_put_u##bits(sctx, attrtype, value); \
		if (ret < 0) \
			goto tlv_put_failure; \
	} while (0)

#define TLV_PUT_U8(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 8, data)
#define TLV_PUT_U16(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 16, data)
#define TLV_PUT_U32(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 32, data)
#define TLV_PUT_U64(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 64, data)
#define TLV_PUT_STRING(sctx, attrtype, str, len) \
	do { \
		ret = tlv_put_string(sctx, attrtype, str, len); \
		if (ret < 0) \
			goto tlv_put_failure; \
	} while (0)
#define TLV_PUT_PATH(sctx, attrtype, p) \
	do { \
		ret = tlv_put_string(sctx, attrtype, p->start, \
			p->end - p->start); \
		if (ret < 0) \
			goto tlv_put_failure; \
	} while(0)
#define TLV_PUT_UUID(sctx, attrtype, uuid) \
	do { \
		ret = tlv_put_uuid(sctx, attrtype, uuid); \
		if (ret < 0) \
			goto tlv_put_failure; \
	} while (0)
#define TLV_PUT_BTRFS_TIMESPEC(sctx, attrtype, eb, ts) \
	do { \
		ret = tlv_put_btrfs_timespec(sctx, attrtype, eb, ts); \
		if (ret < 0) \
			goto tlv_put_failure; \
	} while (0)

static int send_header(struct send_ctx *sctx)
{
	struct btrfs_stream_header hdr;

	strcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);
	hdr.version = cpu_to_le32(BTRFS_SEND_STREAM_VERSION);

	return write_buf(sctx->send_filp, &hdr, sizeof(hdr),
					&sctx->send_off);
}

/*
 * For each command/item we want to send to userspace, we call this function.
 */
static int begin_cmd(struct send_ctx *sctx, int cmd)
{
	struct btrfs_cmd_header *hdr;

	if (WARN_ON(!sctx->send_buf))
		return -EINVAL;

	BUG_ON(sctx->send_size);

	sctx->send_size += sizeof(*hdr);
	hdr = (struct btrfs_cmd_header *)sctx->send_buf;
	hdr->cmd = cpu_to_le16(cmd);

	return 0;
}

static int send_cmd(struct send_ctx *sctx)
{
	int ret;
	struct btrfs_cmd_header *hdr;
	u32 crc;

	hdr = (struct btrfs_cmd_header *)sctx->send_buf;
	hdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));
	hdr->crc = 0;

	crc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);
	hdr->crc = cpu_to_le32(crc);

	ret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,
					&sctx->send_off);

	sctx->total_send_size += sctx->send_size;
	sctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;
	sctx->send_size = 0;

	return ret;
}

/*
 * Sends a move instruction to user space
 */
static int send_rename(struct send_ctx *sctx,
		     struct fs_path *from, struct fs_path *to)
{
	int ret;

verbose_printk("btrfs: send_rename %s -> %s\n", from->start, to->start);

	ret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	return ret;
}

/*
 * Sends a link instruction to user space
 */
static int send_link(struct send_ctx *sctx,
		     struct fs_path *path, struct fs_path *lnk)
{
	int ret;

verbose_printk("btrfs: send_link %s -> %s\n", path->start, lnk->start);

	ret = begin_cmd(sctx, BTRFS_SEND_C_LINK);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	return ret;
}

/*
 * Sends an unlink instruction to user space
 */
static int send_unlink(struct send_ctx *sctx, struct fs_path *path)
{
	int ret;

verbose_printk("btrfs: send_unlink %s\n", path->start);

	ret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	return ret;
}

/*
 * Sends a rmdir instruction to user space
 */
static int send_rmdir(struct send_ctx *sctx, struct fs_path *path)
{
	int ret;

verbose_printk("btrfs: send_rmdir %s\n", path->start);

	ret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	return ret;
}

/*
 * Helper function to retrieve some fields from an inode item.
 */
static int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,
			  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,
			  u64 *gid, u64 *rdev)
{
	int ret;
	struct btrfs_inode_item *ii;
	struct btrfs_key key;

	key.objectid = ino;
	key.type = BTRFS_INODE_ITEM_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
	if (ret) {
		if (ret > 0)
			ret = -ENOENT;
		return ret;
	}

	ii = btrfs_item_ptr(path->nodes[0], path->slots[0],
			struct btrfs_inode_item);
	if (size)
		*size = btrfs_inode_size(path->nodes[0], ii);
	if (gen)
		*gen = btrfs_inode_generation(path->nodes[0], ii);
	if (mode)
		*mode = btrfs_inode_mode(path->nodes[0], ii);
	if (uid)
		*uid = btrfs_inode_uid(path->nodes[0], ii);
	if (gid)
		*gid = btrfs_inode_gid(path->nodes[0], ii);
	if (rdev)
		*rdev = btrfs_inode_rdev(path->nodes[0], ii);

	return ret;
}

static int get_inode_info(struct btrfs_root *root,
			  u64 ino, u64 *size, u64 *gen,
			  u64 *mode, u64 *uid, u64 *gid,
			  u64 *rdev)
{
	struct btrfs_path *path;
	int ret;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;
	ret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,
			       rdev);
	btrfs_free_path(path);
	return ret;
}

typedef int (*iterate_inode_ref_t)(int num, u64 dir, int index,
				   struct fs_path *p,
				   void *ctx);

/*
 * Helper function to iterate the entries in ONE btrfs_inode_ref or
 * btrfs_inode_extref.
 * The iterate callback may return a non zero value to stop iteration. This can
 * be a negative value for error codes or 1 to simply stop it.
 *
 * path must point to the INODE_REF or INODE_EXTREF when called.
 */
static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,
			     struct btrfs_key *found_key, int resolve,
			     iterate_inode_ref_t iterate, void *ctx)
{
	struct extent_buffer *eb = path->nodes[0];
	struct btrfs_item *item;
	struct btrfs_inode_ref *iref;
	struct btrfs_inode_extref *extref;
	struct btrfs_path *tmp_path;
	struct fs_path *p;
	u32 cur = 0;
	u32 total;
	int slot = path->slots[0];
	u32 name_len;
	char *start;
	int ret = 0;
	int num = 0;
	int index;
	u64 dir;
	unsigned long name_off;
	unsigned long elem_size;
	unsigned long ptr;

	p = fs_path_alloc_reversed();
	if (!p)
		return -ENOMEM;

	tmp_path = alloc_path_for_send();
	if (!tmp_path) {
		fs_path_free(p);
		return -ENOMEM;
	}


	if (found_key->type == BTRFS_INODE_REF_KEY) {
		ptr = (unsigned long)btrfs_item_ptr(eb, slot,
						    struct btrfs_inode_ref);
		item = btrfs_item_nr(slot);
		total = btrfs_item_size(eb, item);
		elem_size = sizeof(*iref);
	} else {
		ptr = btrfs_item_ptr_offset(eb, slot);
		total = btrfs_item_size_nr(eb, slot);
		elem_size = sizeof(*extref);
	}

	while (cur < total) {
		fs_path_reset(p);

		if (found_key->type == BTRFS_INODE_REF_KEY) {
			iref = (struct btrfs_inode_ref *)(ptr + cur);
			name_len = btrfs_inode_ref_name_len(eb, iref);
			name_off = (unsigned long)(iref + 1);
			index = btrfs_inode_ref_index(eb, iref);
			dir = found_key->offset;
		} else {
			extref = (struct btrfs_inode_extref *)(ptr + cur);
			name_len = btrfs_inode_extref_name_len(eb, extref);
			name_off = (unsigned long)&extref->name;
			index = btrfs_inode_extref_index(eb, extref);
			dir = btrfs_inode_extref_parent(eb, extref);
		}

		if (resolve) {
			start = btrfs_ref_to_path(root, tmp_path, name_len,
						  name_off, eb, dir,
						  p->buf, p->buf_len);
			if (IS_ERR(start)) {
				ret = PTR_ERR(start);
				goto out;
			}
			if (start < p->buf) {
				/* overflow , try again with larger buffer */
				ret = fs_path_ensure_buf(p,
						p->buf_len + p->buf - start);
				if (ret < 0)
					goto out;
				start = btrfs_ref_to_path(root, tmp_path,
							  name_len, name_off,
							  eb, dir,
							  p->buf, p->buf_len);
				if (IS_ERR(start)) {
					ret = PTR_ERR(start);
					goto out;
				}
				BUG_ON(start < p->buf);
			}
			p->start = start;
		} else {
			ret = fs_path_add_from_extent_buffer(p, eb, name_off,
							     name_len);
			if (ret < 0)
				goto out;
		}

		cur += elem_size + name_len;
		ret = iterate(num, dir, index, p, ctx);
		if (ret)
			goto out;
		num++;
	}

out:
	btrfs_free_path(tmp_path);
	fs_path_free(p);
	return ret;
}

typedef int (*iterate_dir_item_t)(int num, struct btrfs_key *di_key,
				  const char *name, int name_len,
				  const char *data, int data_len,
				  u8 type, void *ctx);

/*
 * Helper function to iterate the entries in ONE btrfs_dir_item.
 * The iterate callback may return a non zero value to stop iteration. This can
 * be a negative value for error codes or 1 to simply stop it.
 *
 * path must point to the dir item when called.
 */
static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,
			    struct btrfs_key *found_key,
			    iterate_dir_item_t iterate, void *ctx)
{
	int ret = 0;
	struct extent_buffer *eb;
	struct btrfs_item *item;
	struct btrfs_dir_item *di;
	struct btrfs_key di_key;
	char *buf = NULL;
	int buf_len;
	u32 name_len;
	u32 data_len;
	u32 cur;
	u32 len;
	u32 total;
	int slot;
	int num;
	u8 type;

	/*
	 * Start with a small buffer (1 page). If later we end up needing more
	 * space, which can happen for xattrs on a fs with a leaf size greater
	 * then the page size, attempt to increase the buffer. Typically xattr
	 * values are small.
	 */
	buf_len = PATH_MAX;
	buf = kmalloc(buf_len, GFP_NOFS);
	if (!buf) {
		ret = -ENOMEM;
		goto out;
	}

	eb = path->nodes[0];
	slot = path->slots[0];
	item = btrfs_item_nr(slot);
	di = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);
	cur = 0;
	len = 0;
	total = btrfs_item_size(eb, item);

	num = 0;
	while (cur < total) {
		name_len = btrfs_dir_name_len(eb, di);
		data_len = btrfs_dir_data_len(eb, di);
		type = btrfs_dir_type(eb, di);
		btrfs_dir_item_key_to_cpu(eb, di, &di_key);

		if (type == BTRFS_FT_XATTR) {
			if (name_len > XATTR_NAME_MAX) {
				ret = -ENAMETOOLONG;
				goto out;
			}
			if (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {
				ret = -E2BIG;
				goto out;
			}
		} else {
			/*
			 * Path too long
			 */
			if (name_len + data_len > PATH_MAX) {
				ret = -ENAMETOOLONG;
				goto out;
			}
		}

		if (name_len + data_len > buf_len) {
			buf_len = name_len + data_len;
			if (is_vmalloc_addr(buf)) {
				vfree(buf);
				buf = NULL;
			} else {
				char *tmp = krealloc(buf, buf_len,
						     GFP_NOFS | __GFP_NOWARN);

				if (!tmp)
					kfree(buf);
				buf = tmp;
			}
			if (!buf) {
				buf = vmalloc(buf_len);
				if (!buf) {
					ret = -ENOMEM;
					goto out;
				}
			}
		}

		read_extent_buffer(eb, buf, (unsigned long)(di + 1),
				name_len + data_len);

		len = sizeof(*di) + name_len + data_len;
		di = (struct btrfs_dir_item *)((char *)di + len);
		cur += len;

		ret = iterate(num, &di_key, buf, name_len, buf + name_len,
				data_len, type, ctx);
		if (ret < 0)
			goto out;
		if (ret) {
			ret = 0;
			goto out;
		}

		num++;
	}

out:
	kvfree(buf);
	return ret;
}

static int __copy_first_ref(int num, u64 dir, int index,
			    struct fs_path *p, void *ctx)
{
	int ret;
	struct fs_path *pt = ctx;

	ret = fs_path_copy(pt, p);
	if (ret < 0)
		return ret;

	/* we want the first only */
	return 1;
}

/*
 * Retrieve the first path of an inode. If an inode has more then one
 * ref/hardlink, this is ignored.
 */
static int get_inode_path(struct btrfs_root *root,
			  u64 ino, struct fs_path *path)
{
	int ret;
	struct btrfs_key key, found_key;
	struct btrfs_path *p;

	p = alloc_path_for_send();
	if (!p)
		return -ENOMEM;

	fs_path_reset(path);

	key.objectid = ino;
	key.type = BTRFS_INODE_REF_KEY;
	key.offset = 0;

	ret = btrfs_search_slot_for_read(root, &key, p, 1, 0);
	if (ret < 0)
		goto out;
	if (ret) {
		ret = 1;
		goto out;
	}
	btrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);
	if (found_key.objectid != ino ||
	    (found_key.type != BTRFS_INODE_REF_KEY &&
	     found_key.type != BTRFS_INODE_EXTREF_KEY)) {
		ret = -ENOENT;
		goto out;
	}

	ret = iterate_inode_ref(root, p, &found_key, 1,
				__copy_first_ref, path);
	if (ret < 0)
		goto out;
	ret = 0;

out:
	btrfs_free_path(p);
	return ret;
}

struct backref_ctx {
	struct send_ctx *sctx;

	struct btrfs_path *path;
	/* number of total found references */
	u64 found;

	/*
	 * used for clones found in send_root. clones found behind cur_objectid
	 * and cur_offset are not considered as allowed clones.
	 */
	u64 cur_objectid;
	u64 cur_offset;

	/* may be truncated in case it's the last extent in a file */
	u64 extent_len;

	/* Just to check for bugs in backref resolving */
	int found_itself;
};

static int __clone_root_cmp_bsearch(const void *key, const void *elt)
{
	u64 root = (u64)(uintptr_t)key;
	struct clone_root *cr = (struct clone_root *)elt;

	if (root < cr->root->objectid)
		return -1;
	if (root > cr->root->objectid)
		return 1;
	return 0;
}

static int __clone_root_cmp_sort(const void *e1, const void *e2)
{
	struct clone_root *cr1 = (struct clone_root *)e1;
	struct clone_root *cr2 = (struct clone_root *)e2;

	if (cr1->root->objectid < cr2->root->objectid)
		return -1;
	if (cr1->root->objectid > cr2->root->objectid)
		return 1;
	return 0;
}

/*
 * Called for every backref that is found for the current extent.
 * Results are collected in sctx->clone_roots->ino/offset/found_refs
 */
static int __iterate_backrefs(u64 ino, u64 offset, u64 root, void *ctx_)
{
	struct backref_ctx *bctx = ctx_;
	struct clone_root *found;
	int ret;
	u64 i_size;

	/* First check if the root is in the list of accepted clone sources */
	found = bsearch((void *)(uintptr_t)root, bctx->sctx->clone_roots,
			bctx->sctx->clone_roots_cnt,
			sizeof(struct clone_root),
			__clone_root_cmp_bsearch);
	if (!found)
		return 0;

	if (found->root == bctx->sctx->send_root &&
	    ino == bctx->cur_objectid &&
	    offset == bctx->cur_offset) {
		bctx->found_itself = 1;
	}

	/*
	 * There are inodes that have extents that lie behind its i_size. Don't
	 * accept clones from these extents.
	 */
	ret = __get_inode_info(found->root, bctx->path, ino, &i_size, NULL, NULL,
			       NULL, NULL, NULL);
	btrfs_release_path(bctx->path);
	if (ret < 0)
		return ret;

	if (offset + bctx->extent_len > i_size)
		return 0;

	/*
	 * Make sure we don't consider clones from send_root that are
	 * behind the current inode/offset.
	 */
	if (found->root == bctx->sctx->send_root) {
		/*
		 * TODO for the moment we don't accept clones from the inode
		 * that is currently send. We may change this when
		 * BTRFS_IOC_CLONE_RANGE supports cloning from and to the same
		 * file.
		 */
		if (ino >= bctx->cur_objectid)
			return 0;
#if 0
		if (ino > bctx->cur_objectid)
			return 0;
		if (offset + bctx->extent_len > bctx->cur_offset)
			return 0;
#endif
	}

	bctx->found++;
	found->found_refs++;
	if (ino < found->ino) {
		found->ino = ino;
		found->offset = offset;
	} else if (found->ino == ino) {
		/*
		 * same extent found more then once in the same file.
		 */
		if (found->offset > offset + bctx->extent_len)
			found->offset = offset;
	}

	return 0;
}

/*
 * Given an inode, offset and extent item, it finds a good clone for a clone
 * instruction. Returns -ENOENT when none could be found. The function makes
 * sure that the returned clone is usable at the point where sending is at the
 * moment. This means, that no clones are accepted which lie behind the current
 * inode+offset.
 *
 * path must point to the extent item when called.
 */
static int find_extent_clone(struct send_ctx *sctx,
			     struct btrfs_path *path,
			     u64 ino, u64 data_offset,
			     u64 ino_size,
			     struct clone_root **found)
{
	int ret;
	int extent_type;
	u64 logical;
	u64 disk_byte;
	u64 num_bytes;
	u64 extent_item_pos;
	u64 flags = 0;
	struct btrfs_file_extent_item *fi;
	struct extent_buffer *eb = path->nodes[0];
	struct backref_ctx *backref_ctx = NULL;
	struct clone_root *cur_clone_root;
	struct btrfs_key found_key;
	struct btrfs_path *tmp_path;
	int compressed;
	u32 i;

	tmp_path = alloc_path_for_send();
	if (!tmp_path)
		return -ENOMEM;

	/* We only use this path under the commit sem */
	tmp_path->need_commit_sem = 0;

	backref_ctx = kmalloc(sizeof(*backref_ctx), GFP_NOFS);
	if (!backref_ctx) {
		ret = -ENOMEM;
		goto out;
	}

	backref_ctx->path = tmp_path;

	if (data_offset >= ino_size) {
		/*
		 * There may be extents that lie behind the file's size.
		 * I at least had this in combination with snapshotting while
		 * writing large files.
		 */
		ret = 0;
		goto out;
	}

	fi = btrfs_item_ptr(eb, path->slots[0],
			struct btrfs_file_extent_item);
	extent_type = btrfs_file_extent_type(eb, fi);
	if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
		ret = -ENOENT;
		goto out;
	}
	compressed = btrfs_file_extent_compression(eb, fi);

	num_bytes = btrfs_file_extent_num_bytes(eb, fi);
	disk_byte = btrfs_file_extent_disk_bytenr(eb, fi);
	if (disk_byte == 0) {
		ret = -ENOENT;
		goto out;
	}
	logical = disk_byte + btrfs_file_extent_offset(eb, fi);

	down_read(&sctx->send_root->fs_info->commit_root_sem);
	ret = extent_from_logical(sctx->send_root->fs_info, disk_byte, tmp_path,
				  &found_key, &flags);
	up_read(&sctx->send_root->fs_info->commit_root_sem);
	btrfs_release_path(tmp_path);

	if (ret < 0)
		goto out;
	if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {
		ret = -EIO;
		goto out;
	}

	/*
	 * Setup the clone roots.
	 */
	for (i = 0; i < sctx->clone_roots_cnt; i++) {
		cur_clone_root = sctx->clone_roots + i;
		cur_clone_root->ino = (u64)-1;
		cur_clone_root->offset = 0;
		cur_clone_root->found_refs = 0;
	}

	backref_ctx->sctx = sctx;
	backref_ctx->found = 0;
	backref_ctx->cur_objectid = ino;
	backref_ctx->cur_offset = data_offset;
	backref_ctx->found_itself = 0;
	backref_ctx->extent_len = num_bytes;

	/*
	 * The last extent of a file may be too large due to page alignment.
	 * We need to adjust extent_len in this case so that the checks in
	 * __iterate_backrefs work.
	 */
	if (data_offset + num_bytes >= ino_size)
		backref_ctx->extent_len = ino_size - data_offset;

	/*
	 * Now collect all backrefs.
	 */
	if (compressed == BTRFS_COMPRESS_NONE)
		extent_item_pos = logical - found_key.objectid;
	else
		extent_item_pos = 0;
	ret = iterate_extent_inodes(sctx->send_root->fs_info,
					found_key.objectid, extent_item_pos, 1,
					__iterate_backrefs, backref_ctx);

	if (ret < 0)
		goto out;

	if (!backref_ctx->found_itself) {
		/* found a bug in backref code? */
		ret = -EIO;
		btrfs_err(sctx->send_root->fs_info, "did not find backref in "
				"send_root. inode=%llu, offset=%llu, "
				"disk_byte=%llu found extent=%llu",
				ino, data_offset, disk_byte, found_key.objectid);
		goto out;
	}

verbose_printk(KERN_DEBUG "btrfs: find_extent_clone: data_offset=%llu, "
		"ino=%llu, "
		"num_bytes=%llu, logical=%llu\n",
		data_offset, ino, num_bytes, logical);

	if (!backref_ctx->found)
		verbose_printk("btrfs:    no clones found\n");

	cur_clone_root = NULL;
	for (i = 0; i < sctx->clone_roots_cnt; i++) {
		if (sctx->clone_roots[i].found_refs) {
			if (!cur_clone_root)
				cur_clone_root = sctx->clone_roots + i;
			else if (sctx->clone_roots[i].root == sctx->send_root)
				/* prefer clones from send_root over others */
				cur_clone_root = sctx->clone_roots + i;
		}

	}

	if (cur_clone_root) {
		if (compressed != BTRFS_COMPRESS_NONE) {
			/*
			 * Offsets given by iterate_extent_inodes() are relative
			 * to the start of the extent, we need to add logical
			 * offset from the file extent item.
			 * (See why at backref.c:check_extent_in_eb())
			 */
			cur_clone_root->offset += btrfs_file_extent_offset(eb,
									   fi);
		}
		*found = cur_clone_root;
		ret = 0;
	} else {
		ret = -ENOENT;
	}

out:
	btrfs_free_path(tmp_path);
	kfree(backref_ctx);
	return ret;
}

static int read_symlink(struct btrfs_root *root,
			u64 ino,
			struct fs_path *dest)
{
	int ret;
	struct btrfs_path *path;
	struct btrfs_key key;
	struct btrfs_file_extent_item *ei;
	u8 type;
	u8 compression;
	unsigned long off;
	int len;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	key.objectid = ino;
	key.type = BTRFS_EXTENT_DATA_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
	if (ret < 0)
		goto out;
	if (ret) {
		/*
		 * An empty symlink inode. Can happen in rare error paths when
		 * creating a symlink (transaction committed before the inode
		 * eviction handler removed the symlink inode items and a crash
		 * happened in between or the subvol was snapshoted in between).
		 * Print an informative message to dmesg/syslog so that the user
		 * can delete the symlink.
		 */
		btrfs_err(root->fs_info,
			  "Found empty symlink inode %llu at root %llu",
			  ino, root->root_key.objectid);
		ret = -EIO;
		goto out;
	}

	ei = btrfs_item_ptr(path->nodes[0], path->slots[0],
			struct btrfs_file_extent_item);
	type = btrfs_file_extent_type(path->nodes[0], ei);
	compression = btrfs_file_extent_compression(path->nodes[0], ei);
	BUG_ON(type != BTRFS_FILE_EXTENT_INLINE);
	BUG_ON(compression);

	off = btrfs_file_extent_inline_start(ei);
	len = btrfs_file_extent_inline_len(path->nodes[0], path->slots[0], ei);

	ret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);

out:
	btrfs_free_path(path);
	return ret;
}

/*
 * Helper function to generate a file name that is unique in the root of
 * send_root and parent_root. This is used to generate names for orphan inodes.
 */
static int gen_unique_name(struct send_ctx *sctx,
			   u64 ino, u64 gen,
			   struct fs_path *dest)
{
	int ret = 0;
	struct btrfs_path *path;
	struct btrfs_dir_item *di;
	char tmp[64];
	int len;
	u64 idx = 0;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	while (1) {
		len = snprintf(tmp, sizeof(tmp), "o%llu-%llu-%llu",
				ino, gen, idx);
		ASSERT(len < sizeof(tmp));

		di = btrfs_lookup_dir_item(NULL, sctx->send_root,
				path, BTRFS_FIRST_FREE_OBJECTID,
				tmp, strlen(tmp), 0);
		btrfs_release_path(path);
		if (IS_ERR(di)) {
			ret = PTR_ERR(di);
			goto out;
		}
		if (di) {
			/* not unique, try again */
			idx++;
			continue;
		}

		if (!sctx->parent_root) {
			/* unique */
			ret = 0;
			break;
		}

		di = btrfs_lookup_dir_item(NULL, sctx->parent_root,
				path, BTRFS_FIRST_FREE_OBJECTID,
				tmp, strlen(tmp), 0);
		btrfs_release_path(path);
		if (IS_ERR(di)) {
			ret = PTR_ERR(di);
			goto out;
		}
		if (di) {
			/* not unique, try again */
			idx++;
			continue;
		}
		/* unique */
		break;
	}

	ret = fs_path_add(dest, tmp, strlen(tmp));

out:
	btrfs_free_path(path);
	return ret;
}

enum inode_state {
	inode_state_no_change,
	inode_state_will_create,
	inode_state_did_create,
	inode_state_will_delete,
	inode_state_did_delete,
};

static int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)
{
	int ret;
	int left_ret;
	int right_ret;
	u64 left_gen;
	u64 right_gen;

	ret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,
			NULL, NULL);
	if (ret < 0 && ret != -ENOENT)
		goto out;
	left_ret = ret;

	if (!sctx->parent_root) {
		right_ret = -ENOENT;
	} else {
		ret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,
				NULL, NULL, NULL, NULL);
		if (ret < 0 && ret != -ENOENT)
			goto out;
		right_ret = ret;
	}

	if (!left_ret && !right_ret) {
		if (left_gen == gen && right_gen == gen) {
			ret = inode_state_no_change;
		} else if (left_gen == gen) {
			if (ino < sctx->send_progress)
				ret = inode_state_did_create;
			else
				ret = inode_state_will_create;
		} else if (right_gen == gen) {
			if (ino < sctx->send_progress)
				ret = inode_state_did_delete;
			else
				ret = inode_state_will_delete;
		} else  {
			ret = -ENOENT;
		}
	} else if (!left_ret) {
		if (left_gen == gen) {
			if (ino < sctx->send_progress)
				ret = inode_state_did_create;
			else
				ret = inode_state_will_create;
		} else {
			ret = -ENOENT;
		}
	} else if (!right_ret) {
		if (right_gen == gen) {
			if (ino < sctx->send_progress)
				ret = inode_state_did_delete;
			else
				ret = inode_state_will_delete;
		} else {
			ret = -ENOENT;
		}
	} else {
		ret = -ENOENT;
	}

out:
	return ret;
}

static int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)
{
	int ret;

	if (ino == BTRFS_FIRST_FREE_OBJECTID)
		return 1;

	ret = get_cur_inode_state(sctx, ino, gen);
	if (ret < 0)
		goto out;

	if (ret == inode_state_no_change ||
	    ret == inode_state_did_create ||
	    ret == inode_state_will_delete)
		ret = 1;
	else
		ret = 0;

out:
	return ret;
}

/*
 * Helper function to lookup a dir item in a dir.
 */
static int lookup_dir_item_inode(struct btrfs_root *root,
				 u64 dir, const char *name, int name_len,
				 u64 *found_inode,
				 u8 *found_type)
{
	int ret = 0;
	struct btrfs_dir_item *di;
	struct btrfs_key key;
	struct btrfs_path *path;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	di = btrfs_lookup_dir_item(NULL, root, path,
			dir, name, name_len, 0);
	if (!di) {
		ret = -ENOENT;
		goto out;
	}
	if (IS_ERR(di)) {
		ret = PTR_ERR(di);
		goto out;
	}
	btrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);
	if (key.type == BTRFS_ROOT_ITEM_KEY) {
		ret = -ENOENT;
		goto out;
	}
	*found_inode = key.objectid;
	*found_type = btrfs_dir_type(path->nodes[0], di);

out:
	btrfs_free_path(path);
	return ret;
}

/*
 * Looks up the first btrfs_inode_ref of a given ino. It returns the parent dir,
 * generation of the parent dir and the name of the dir entry.
 */
static int get_first_ref(struct btrfs_root *root, u64 ino,
			 u64 *dir, u64 *dir_gen, struct fs_path *name)
{
	int ret;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct btrfs_path *path;
	int len;
	u64 parent_dir;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	key.objectid = ino;
	key.type = BTRFS_INODE_REF_KEY;
	key.offset = 0;

	ret = btrfs_search_slot_for_read(root, &key, path, 1, 0);
	if (ret < 0)
		goto out;
	if (!ret)
		btrfs_item_key_to_cpu(path->nodes[0], &found_key,
				path->slots[0]);
	if (ret || found_key.objectid != ino ||
	    (found_key.type != BTRFS_INODE_REF_KEY &&
	     found_key.type != BTRFS_INODE_EXTREF_KEY)) {
		ret = -ENOENT;
		goto out;
	}

	if (found_key.type == BTRFS_INODE_REF_KEY) {
		struct btrfs_inode_ref *iref;
		iref = btrfs_item_ptr(path->nodes[0], path->slots[0],
				      struct btrfs_inode_ref);
		len = btrfs_inode_ref_name_len(path->nodes[0], iref);
		ret = fs_path_add_from_extent_buffer(name, path->nodes[0],
						     (unsigned long)(iref + 1),
						     len);
		parent_dir = found_key.offset;
	} else {
		struct btrfs_inode_extref *extref;
		extref = btrfs_item_ptr(path->nodes[0], path->slots[0],
					struct btrfs_inode_extref);
		len = btrfs_inode_extref_name_len(path->nodes[0], extref);
		ret = fs_path_add_from_extent_buffer(name, path->nodes[0],
					(unsigned long)&extref->name, len);
		parent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);
	}
	if (ret < 0)
		goto out;
	btrfs_release_path(path);

	if (dir_gen) {
		ret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,
				     NULL, NULL, NULL);
		if (ret < 0)
			goto out;
	}

	*dir = parent_dir;

out:
	btrfs_free_path(path);
	return ret;
}

static int is_first_ref(struct btrfs_root *root,
			u64 ino, u64 dir,
			const char *name, int name_len)
{
	int ret;
	struct fs_path *tmp_name;
	u64 tmp_dir;

	tmp_name = fs_path_alloc();
	if (!tmp_name)
		return -ENOMEM;

	ret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);
	if (ret < 0)
		goto out;

	if (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {
		ret = 0;
		goto out;
	}

	ret = !memcmp(tmp_name->start, name, name_len);

out:
	fs_path_free(tmp_name);
	return ret;
}

/*
 * Used by process_recorded_refs to determine if a new ref would overwrite an
 * already existing ref. In case it detects an overwrite, it returns the
 * inode/gen in who_ino/who_gen.
 * When an overwrite is detected, process_recorded_refs does proper orphanizing
 * to make sure later references to the overwritten inode are possible.
 * Orphanizing is however only required for the first ref of an inode.
 * process_recorded_refs does an additional is_first_ref check to see if
 * orphanizing is really required.
 */
static int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,
			      const char *name, int name_len,
			      u64 *who_ino, u64 *who_gen)
{
	int ret = 0;
	u64 gen;
	u64 other_inode = 0;
	u8 other_type = 0;

	if (!sctx->parent_root)
		goto out;

	ret = is_inode_existent(sctx, dir, dir_gen);
	if (ret <= 0)
		goto out;

	/*
	 * If we have a parent root we need to verify that the parent dir was
	 * not delted and then re-created, if it was then we have no overwrite
	 * and we can just unlink this entry.
	 */
	if (sctx->parent_root && dir != BTRFS_FIRST_FREE_OBJECTID) {
		ret = get_inode_info(sctx->parent_root, dir, NULL, &gen, NULL,
				     NULL, NULL, NULL);
		if (ret < 0 && ret != -ENOENT)
			goto out;
		if (ret) {
			ret = 0;
			goto out;
		}
		if (gen != dir_gen)
			goto out;
	}

	ret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,
			&other_inode, &other_type);
	if (ret < 0 && ret != -ENOENT)
		goto out;
	if (ret) {
		ret = 0;
		goto out;
	}

	/*
	 * Check if the overwritten ref was already processed. If yes, the ref
	 * was already unlinked/moved, so we can safely assume that we will not
	 * overwrite anything at this point in time.
	 */
	if (other_inode > sctx->send_progress) {
		ret = get_inode_info(sctx->parent_root, other_inode, NULL,
				who_gen, NULL, NULL, NULL, NULL);
		if (ret < 0)
			goto out;

		ret = 1;
		*who_ino = other_inode;
	} else {
		ret = 0;
	}

out:
	return ret;
}

/*
 * Checks if the ref was overwritten by an already processed inode. This is
 * used by __get_cur_name_and_parent to find out if the ref was orphanized and
 * thus the orphan name needs be used.
 * process_recorded_refs also uses it to avoid unlinking of refs that were
 * overwritten.
 */
static int did_overwrite_ref(struct send_ctx *sctx,
			    u64 dir, u64 dir_gen,
			    u64 ino, u64 ino_gen,
			    const char *name, int name_len)
{
	int ret = 0;
	u64 gen;
	u64 ow_inode;
	u8 other_type;

	if (!sctx->parent_root)
		goto out;

	ret = is_inode_existent(sctx, dir, dir_gen);
	if (ret <= 0)
		goto out;

	/* check if the ref was overwritten by another ref */
	ret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,
			&ow_inode, &other_type);
	if (ret < 0 && ret != -ENOENT)
		goto out;
	if (ret) {
		/* was never and will never be overwritten */
		ret = 0;
		goto out;
	}

	ret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,
			NULL, NULL);
	if (ret < 0)
		goto out;

	if (ow_inode == ino && gen == ino_gen) {
		ret = 0;
		goto out;
	}

	/* we know that it is or will be overwritten. check this now */
	if (ow_inode < sctx->send_progress)
		ret = 1;
	else
		ret = 0;

out:
	return ret;
}

/*
 * Same as did_overwrite_ref, but also checks if it is the first ref of an inode
 * that got overwritten. This is used by process_recorded_refs to determine
 * if it has to use the path as returned by get_cur_path or the orphan name.
 */
static int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)
{
	int ret = 0;
	struct fs_path *name = NULL;
	u64 dir;
	u64 dir_gen;

	if (!sctx->parent_root)
		goto out;

	name = fs_path_alloc();
	if (!name)
		return -ENOMEM;

	ret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);
	if (ret < 0)
		goto out;

	ret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,
			name->start, fs_path_len(name));

out:
	fs_path_free(name);
	return ret;
}

/*
 * Insert a name cache entry. On 32bit kernels the radix tree index is 32bit,
 * so we need to do some special handling in case we have clashes. This function
 * takes care of this with the help of name_cache_entry::radix_list.
 * In case of error, nce is kfreed.
 */
static int name_cache_insert(struct send_ctx *sctx,
			     struct name_cache_entry *nce)
{
	int ret = 0;
	struct list_head *nce_head;

	nce_head = radix_tree_lookup(&sctx->name_cache,
			(unsigned long)nce->ino);
	if (!nce_head) {
		nce_head = kmalloc(sizeof(*nce_head), GFP_NOFS);
		if (!nce_head) {
			kfree(nce);
			return -ENOMEM;
		}
		INIT_LIST_HEAD(nce_head);

		ret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head);
		if (ret < 0) {
			kfree(nce_head);
			kfree(nce);
			return ret;
		}
	}
	list_add_tail(&nce->radix_list, nce_head);
	list_add_tail(&nce->list, &sctx->name_cache_list);
	sctx->name_cache_size++;

	return ret;
}

static void name_cache_delete(struct send_ctx *sctx,
			      struct name_cache_entry *nce)
{
	struct list_head *nce_head;

	nce_head = radix_tree_lookup(&sctx->name_cache,
			(unsigned long)nce->ino);
	if (!nce_head) {
		btrfs_err(sctx->send_root->fs_info,
	      "name_cache_delete lookup failed ino %llu cache size %d, leaking memory",
			nce->ino, sctx->name_cache_size);
	}

	list_del(&nce->radix_list);
	list_del(&nce->list);
	sctx->name_cache_size--;

	/*
	 * We may not get to the final release of nce_head if the lookup fails
	 */
	if (nce_head && list_empty(nce_head)) {
		radix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);
		kfree(nce_head);
	}
}

static struct name_cache_entry *name_cache_search(struct send_ctx *sctx,
						    u64 ino, u64 gen)
{
	struct list_head *nce_head;
	struct name_cache_entry *cur;

	nce_head = radix_tree_lookup(&sctx->name_cache, (unsigned long)ino);
	if (!nce_head)
		return NULL;

	list_for_each_entry(cur, nce_head, radix_list) {
		if (cur->ino == ino && cur->gen == gen)
			return cur;
	}
	return NULL;
}

/*
 * Removes the entry from the list and adds it back to the end. This marks the
 * entry as recently used so that name_cache_clean_unused does not remove it.
 */
static void name_cache_used(struct send_ctx *sctx, struct name_cache_entry *nce)
{
	list_del(&nce->list);
	list_add_tail(&nce->list, &sctx->name_cache_list);
}

/*
 * Remove some entries from the beginning of name_cache_list.
 */
static void name_cache_clean_unused(struct send_ctx *sctx)
{
	struct name_cache_entry *nce;

	if (sctx->name_cache_size < SEND_CTX_NAME_CACHE_CLEAN_SIZE)
		return;

	while (sctx->name_cache_size > SEND_CTX_MAX_NAME_CACHE_SIZE) {
		nce = list_entry(sctx->name_cache_list.next,
				struct name_cache_entry, list);
		name_cache_delete(sctx, nce);
		kfree(nce);
	}
}

static void name_cache_free(struct send_ctx *sctx)
{
	struct name_cache_entry *nce;

	while (!list_empty(&sctx->name_cache_list)) {
		nce = list_entry(sctx->name_cache_list.next,
				struct name_cache_entry, list);
		name_cache_delete(sctx, nce);
		kfree(nce);
	}
}

/*
 * Used by get_cur_path for each ref up to the root.
 * Returns 0 if it succeeded.
 * Returns 1 if the inode is not existent or got overwritten. In that case, the
 * name is an orphan name. This instructs get_cur_path to stop iterating. If 1
 * is returned, parent_ino/parent_gen are not guaranteed to be valid.
 * Returns <0 in case of error.
 */
static int __get_cur_name_and_parent(struct send_ctx *sctx,
				     u64 ino, u64 gen,
				     u64 *parent_ino,
				     u64 *parent_gen,
				     struct fs_path *dest)
{
	int ret;
	int nce_ret;
	struct name_cache_entry *nce = NULL;

	/*
	 * First check if we already did a call to this function with the same
	 * ino/gen. If yes, check if the cache entry is still up-to-date. If yes
	 * return the cached result.
	 */
	nce = name_cache_search(sctx, ino, gen);
	if (nce) {
		if (ino < sctx->send_progress && nce->need_later_update) {
			name_cache_delete(sctx, nce);
			kfree(nce);
			nce = NULL;
		} else {
			name_cache_used(sctx, nce);
			*parent_ino = nce->parent_ino;
			*parent_gen = nce->parent_gen;
			ret = fs_path_add(dest, nce->name, nce->name_len);
			if (ret < 0)
				goto out;
			ret = nce->ret;
			goto out;
		}
	}

	/*
	 * If the inode is not existent yet, add the orphan name and return 1.
	 * This should only happen for the parent dir that we determine in
	 * __record_new_ref
	 */
	ret = is_inode_existent(sctx, ino, gen);
	if (ret < 0)
		goto out;

	if (!ret) {
		ret = gen_unique_name(sctx, ino, gen, dest);
		if (ret < 0)
			goto out;
		ret = 1;
		goto out_cache;
	}

	/*
	 * Depending on whether the inode was already processed or not, use
	 * send_root or parent_root for ref lookup.
	 */
	if (ino < sctx->send_progress)
		ret = get_first_ref(sctx->send_root, ino,
				    parent_ino, parent_gen, dest);
	else
		ret = get_first_ref(sctx->parent_root, ino,
				    parent_ino, parent_gen, dest);
	if (ret < 0)
		goto out;

	/*
	 * Check if the ref was overwritten by an inode's ref that was processed
	 * earlier. If yes, treat as orphan and return 1.
	 */
	ret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,
			dest->start, dest->end - dest->start);
	if (ret < 0)
		goto out;
	if (ret) {
		fs_path_reset(dest);
		ret = gen_unique_name(sctx, ino, gen, dest);
		if (ret < 0)
			goto out;
		ret = 1;
	}

out_cache:
	/*
	 * Store the result of the lookup in the name cache.
	 */
	nce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);
	if (!nce) {
		ret = -ENOMEM;
		goto out;
	}

	nce->ino = ino;
	nce->gen = gen;
	nce->parent_ino = *parent_ino;
	nce->parent_gen = *parent_gen;
	nce->name_len = fs_path_len(dest);
	nce->ret = ret;
	strcpy(nce->name, dest->start);

	if (ino < sctx->send_progress)
		nce->need_later_update = 0;
	else
		nce->need_later_update = 1;

	nce_ret = name_cache_insert(sctx, nce);
	if (nce_ret < 0)
		ret = nce_ret;
	name_cache_clean_unused(sctx);

out:
	return ret;
}

/*
 * Magic happens here. This function returns the first ref to an inode as it
 * would look like while receiving the stream at this point in time.
 * We walk the path up to the root. For every inode in between, we check if it
 * was already processed/sent. If yes, we continue with the parent as found
 * in send_root. If not, we continue with the parent as found in parent_root.
 * If we encounter an inode that was deleted at this point in time, we use the
 * inodes "orphan" name instead of the real name and stop. Same with new inodes
 * that were not created yet and overwritten inodes/refs.
 *
 * When do we have have orphan inodes:
 * 1. When an inode is freshly created and thus no valid refs are available yet
 * 2. When a directory lost all it's refs (deleted) but still has dir items
 *    inside which were not processed yet (pending for move/delete). If anyone
 *    tried to get the path to the dir items, it would get a path inside that
 *    orphan directory.
 * 3. When an inode is moved around or gets new links, it may overwrite the ref
 *    of an unprocessed inode. If in that case the first ref would be
 *    overwritten, the overwritten inode gets "orphanized". Later when we
 *    process this overwritten inode, it is restored at a new place by moving
 *    the orphan inode.
 *
 * sctx->send_progress tells this function at which point in time receiving
 * would be.
 */
static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,
			struct fs_path *dest)
{
	int ret = 0;
	struct fs_path *name = NULL;
	u64 parent_inode = 0;
	u64 parent_gen = 0;
	int stop = 0;

	name = fs_path_alloc();
	if (!name) {
		ret = -ENOMEM;
		goto out;
	}

	dest->reversed = 1;
	fs_path_reset(dest);

	while (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {
		fs_path_reset(name);

		if (is_waiting_for_rm(sctx, ino)) {
			ret = gen_unique_name(sctx, ino, gen, name);
			if (ret < 0)
				goto out;
			ret = fs_path_add_path(dest, name);
			break;
		}

		if (is_waiting_for_move(sctx, ino)) {
			ret = get_first_ref(sctx->parent_root, ino,
					    &parent_inode, &parent_gen, name);
		} else {
			ret = __get_cur_name_and_parent(sctx, ino, gen,
							&parent_inode,
							&parent_gen, name);
			if (ret)
				stop = 1;
		}

		if (ret < 0)
			goto out;

		ret = fs_path_add_path(dest, name);
		if (ret < 0)
			goto out;

		ino = parent_inode;
		gen = parent_gen;
	}

out:
	fs_path_free(name);
	if (!ret)
		fs_path_unreverse(dest);
	return ret;
}

/*
 * Sends a BTRFS_SEND_C_SUBVOL command/item to userspace
 */
static int send_subvol_begin(struct send_ctx *sctx)
{
	int ret;
	struct btrfs_root *send_root = sctx->send_root;
	struct btrfs_root *parent_root = sctx->parent_root;
	struct btrfs_path *path;
	struct btrfs_key key;
	struct btrfs_root_ref *ref;
	struct extent_buffer *leaf;
	char *name = NULL;
	int namelen;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;

	name = kmalloc(BTRFS_PATH_NAME_MAX, GFP_NOFS);
	if (!name) {
		btrfs_free_path(path);
		return -ENOMEM;
	}

	key.objectid = send_root->objectid;
	key.type = BTRFS_ROOT_BACKREF_KEY;
	key.offset = 0;

	ret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,
				&key, path, 1, 0);
	if (ret < 0)
		goto out;
	if (ret) {
		ret = -ENOENT;
		goto out;
	}

	leaf = path->nodes[0];
	btrfs_item_key_to_cpu(leaf, &key, path->slots[0]);
	if (key.type != BTRFS_ROOT_BACKREF_KEY ||
	    key.objectid != send_root->objectid) {
		ret = -ENOENT;
		goto out;
	}
	ref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);
	namelen = btrfs_root_ref_name_len(leaf, ref);
	read_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);
	btrfs_release_path(path);

	if (parent_root) {
		ret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);
		if (ret < 0)
			goto out;
	} else {
		ret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);
		if (ret < 0)
			goto out;
	}

	TLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);
	TLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,
			sctx->send_root->root_item.uuid);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,
		    le64_to_cpu(sctx->send_root->root_item.ctransid));
	if (parent_root) {
		TLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,
				sctx->parent_root->root_item.uuid);
		TLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,
			    le64_to_cpu(sctx->parent_root->root_item.ctransid));
	}

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	btrfs_free_path(path);
	kfree(name);
	return ret;
}

static int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)
{
	int ret = 0;
	struct fs_path *p;

verbose_printk("btrfs: send_truncate %llu size=%llu\n", ino, size);

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, ino, gen, p);
	if (ret < 0)
		goto out;
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	return ret;
}

static int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)
{
	int ret = 0;
	struct fs_path *p;

verbose_printk("btrfs: send_chmod %llu mode=%llu\n", ino, mode);

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, ino, gen, p);
	if (ret < 0)
		goto out;
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	return ret;
}

static int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)
{
	int ret = 0;
	struct fs_path *p;

verbose_printk("btrfs: send_chown %llu uid=%llu, gid=%llu\n", ino, uid, gid);

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, ino, gen, p);
	if (ret < 0)
		goto out;
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	return ret;
}

static int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)
{
	int ret = 0;
	struct fs_path *p = NULL;
	struct btrfs_inode_item *ii;
	struct btrfs_path *path = NULL;
	struct extent_buffer *eb;
	struct btrfs_key key;
	int slot;

verbose_printk("btrfs: send_utimes %llu\n", ino);

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	path = alloc_path_for_send();
	if (!path) {
		ret = -ENOMEM;
		goto out;
	}

	key.objectid = ino;
	key.type = BTRFS_INODE_ITEM_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);
	if (ret < 0)
		goto out;

	eb = path->nodes[0];
	slot = path->slots[0];
	ii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);

	ret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, ino, gen, p);
	if (ret < 0)
		goto out;
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb,
			btrfs_inode_atime(ii));
	TLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb,
			btrfs_inode_mtime(ii));
	TLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb,
			btrfs_inode_ctime(ii));
	/* TODO Add otime support when the otime patches get into upstream */

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	btrfs_free_path(path);
	return ret;
}

/*
 * Sends a BTRFS_SEND_C_MKXXX or SYMLINK command to user space. We don't have
 * a valid path yet because we did not process the refs yet. So, the inode
 * is created as orphan.
 */
static int send_create_inode(struct send_ctx *sctx, u64 ino)
{
	int ret = 0;
	struct fs_path *p;
	int cmd;
	u64 gen;
	u64 mode;
	u64 rdev;

verbose_printk("btrfs: send_create_inode %llu\n", ino);

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	if (ino != sctx->cur_ino) {
		ret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,
				     NULL, NULL, &rdev);
		if (ret < 0)
			goto out;
	} else {
		gen = sctx->cur_inode_gen;
		mode = sctx->cur_inode_mode;
		rdev = sctx->cur_inode_rdev;
	}

	if (S_ISREG(mode)) {
		cmd = BTRFS_SEND_C_MKFILE;
	} else if (S_ISDIR(mode)) {
		cmd = BTRFS_SEND_C_MKDIR;
	} else if (S_ISLNK(mode)) {
		cmd = BTRFS_SEND_C_SYMLINK;
	} else if (S_ISCHR(mode) || S_ISBLK(mode)) {
		cmd = BTRFS_SEND_C_MKNOD;
	} else if (S_ISFIFO(mode)) {
		cmd = BTRFS_SEND_C_MKFIFO;
	} else if (S_ISSOCK(mode)) {
		cmd = BTRFS_SEND_C_MKSOCK;
	} else {
		printk(KERN_WARNING "btrfs: unexpected inode type %o",
				(int)(mode & S_IFMT));
		ret = -ENOTSUPP;
		goto out;
	}

	ret = begin_cmd(sctx, cmd);
	if (ret < 0)
		goto out;

	ret = gen_unique_name(sctx, ino, gen, p);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);

	if (S_ISLNK(mode)) {
		fs_path_reset(p);
		ret = read_symlink(sctx->send_root, ino, p);
		if (ret < 0)
			goto out;
		TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);
	} else if (S_ISCHR(mode) || S_ISBLK(mode) ||
		   S_ISFIFO(mode) || S_ISSOCK(mode)) {
		TLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));
		TLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);
	}

	ret = send_cmd(sctx);
	if (ret < 0)
		goto out;


tlv_put_failure:
out:
	fs_path_free(p);
	return ret;
}

/*
 * We need some special handling for inodes that get processed before the parent
 * directory got created. See process_recorded_refs for details.
 * This function does the check if we already created the dir out of order.
 */
static int did_create_dir(struct send_ctx *sctx, u64 dir)
{
	int ret = 0;
	struct btrfs_path *path = NULL;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct btrfs_key di_key;
	struct extent_buffer *eb;
	struct btrfs_dir_item *di;
	int slot;

	path = alloc_path_for_send();
	if (!path) {
		ret = -ENOMEM;
		goto out;
	}

	key.objectid = dir;
	key.type = BTRFS_DIR_INDEX_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);
	if (ret < 0)
		goto out;

	while (1) {
		eb = path->nodes[0];
		slot = path->slots[0];
		if (slot >= btrfs_header_nritems(eb)) {
			ret = btrfs_next_leaf(sctx->send_root, path);
			if (ret < 0) {
				goto out;
			} else if (ret > 0) {
				ret = 0;
				break;
			}
			continue;
		}

		btrfs_item_key_to_cpu(eb, &found_key, slot);
		if (found_key.objectid != key.objectid ||
		    found_key.type != key.type) {
			ret = 0;
			goto out;
		}

		di = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);
		btrfs_dir_item_key_to_cpu(eb, di, &di_key);

		if (di_key.type != BTRFS_ROOT_ITEM_KEY &&
		    di_key.objectid < sctx->send_progress) {
			ret = 1;
			goto out;
		}

		path->slots[0]++;
	}

out:
	btrfs_free_path(path);
	return ret;
}

/*
 * Only creates the inode if it is:
 * 1. Not a directory
 * 2. Or a directory which was not created already due to out of order
 *    directories. See did_create_dir and process_recorded_refs for details.
 */
static int send_create_inode_if_needed(struct send_ctx *sctx)
{
	int ret;

	if (S_ISDIR(sctx->cur_inode_mode)) {
		ret = did_create_dir(sctx, sctx->cur_ino);
		if (ret < 0)
			goto out;
		if (ret) {
			ret = 0;
			goto out;
		}
	}

	ret = send_create_inode(sctx, sctx->cur_ino);
	if (ret < 0)
		goto out;

out:
	return ret;
}

struct recorded_ref {
	struct list_head list;
	char *dir_path;
	char *name;
	struct fs_path *full_path;
	u64 dir;
	u64 dir_gen;
	int dir_path_len;
	int name_len;
};

/*
 * We need to process new refs before deleted refs, but compare_tree gives us
 * everything mixed. So we first record all refs and later process them.
 * This function is a helper to record one ref.
 */
static int __record_ref(struct list_head *head, u64 dir,
		      u64 dir_gen, struct fs_path *path)
{
	struct recorded_ref *ref;

	ref = kmalloc(sizeof(*ref), GFP_NOFS);
	if (!ref)
		return -ENOMEM;

	ref->dir = dir;
	ref->dir_gen = dir_gen;
	ref->full_path = path;

	ref->name = (char *)kbasename(ref->full_path->start);
	ref->name_len = ref->full_path->end - ref->name;
	ref->dir_path = ref->full_path->start;
	if (ref->name == ref->full_path->start)
		ref->dir_path_len = 0;
	else
		ref->dir_path_len = ref->full_path->end -
				ref->full_path->start - 1 - ref->name_len;

	list_add_tail(&ref->list, head);
	return 0;
}

static int dup_ref(struct recorded_ref *ref, struct list_head *list)
{
	struct recorded_ref *new;

	new = kmalloc(sizeof(*ref), GFP_NOFS);
	if (!new)
		return -ENOMEM;

	new->dir = ref->dir;
	new->dir_gen = ref->dir_gen;
	new->full_path = NULL;
	INIT_LIST_HEAD(&new->list);
	list_add_tail(&new->list, list);
	return 0;
}

static void __free_recorded_refs(struct list_head *head)
{
	struct recorded_ref *cur;

	while (!list_empty(head)) {
		cur = list_entry(head->next, struct recorded_ref, list);
		fs_path_free(cur->full_path);
		list_del(&cur->list);
		kfree(cur);
	}
}

static void free_recorded_refs(struct send_ctx *sctx)
{
	__free_recorded_refs(&sctx->new_refs);
	__free_recorded_refs(&sctx->deleted_refs);
}

/*
 * Renames/moves a file/dir to its orphan name. Used when the first
 * ref of an unprocessed inode gets overwritten and for all non empty
 * directories.
 */
static int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,
			  struct fs_path *path)
{
	int ret;
	struct fs_path *orphan;

	orphan = fs_path_alloc();
	if (!orphan)
		return -ENOMEM;

	ret = gen_unique_name(sctx, ino, gen, orphan);
	if (ret < 0)
		goto out;

	ret = send_rename(sctx, path, orphan);

out:
	fs_path_free(orphan);
	return ret;
}

static struct orphan_dir_info *
add_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)
{
	struct rb_node **p = &sctx->orphan_dirs.rb_node;
	struct rb_node *parent = NULL;
	struct orphan_dir_info *entry, *odi;

	odi = kmalloc(sizeof(*odi), GFP_NOFS);
	if (!odi)
		return ERR_PTR(-ENOMEM);
	odi->ino = dir_ino;
	odi->gen = 0;

	while (*p) {
		parent = *p;
		entry = rb_entry(parent, struct orphan_dir_info, node);
		if (dir_ino < entry->ino) {
			p = &(*p)->rb_left;
		} else if (dir_ino > entry->ino) {
			p = &(*p)->rb_right;
		} else {
			kfree(odi);
			return entry;
		}
	}

	rb_link_node(&odi->node, parent, p);
	rb_insert_color(&odi->node, &sctx->orphan_dirs);
	return odi;
}

static struct orphan_dir_info *
get_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)
{
	struct rb_node *n = sctx->orphan_dirs.rb_node;
	struct orphan_dir_info *entry;

	while (n) {
		entry = rb_entry(n, struct orphan_dir_info, node);
		if (dir_ino < entry->ino)
			n = n->rb_left;
		else if (dir_ino > entry->ino)
			n = n->rb_right;
		else
			return entry;
	}
	return NULL;
}

static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)
{
	struct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);

	return odi != NULL;
}

static void free_orphan_dir_info(struct send_ctx *sctx,
				 struct orphan_dir_info *odi)
{
	if (!odi)
		return;
	rb_erase(&odi->node, &sctx->orphan_dirs);
	kfree(odi);
}

/*
 * Returns 1 if a directory can be removed at this point in time.
 * We check this by iterating all dir items and checking if the inode behind
 * the dir item was already processed.
 */
static int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,
		     u64 send_progress)
{
	int ret = 0;
	struct btrfs_root *root = sctx->parent_root;
	struct btrfs_path *path;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct btrfs_key loc;
	struct btrfs_dir_item *di;

	/*
	 * Don't try to rmdir the top/root subvolume dir.
	 */
	if (dir == BTRFS_FIRST_FREE_OBJECTID)
		return 0;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	key.objectid = dir;
	key.type = BTRFS_DIR_INDEX_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
	if (ret < 0)
		goto out;

	while (1) {
		struct waiting_dir_move *dm;

		if (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {
			ret = btrfs_next_leaf(root, path);
			if (ret < 0)
				goto out;
			else if (ret > 0)
				break;
			continue;
		}
		btrfs_item_key_to_cpu(path->nodes[0], &found_key,
				      path->slots[0]);
		if (found_key.objectid != key.objectid ||
		    found_key.type != key.type)
			break;

		di = btrfs_item_ptr(path->nodes[0], path->slots[0],
				struct btrfs_dir_item);
		btrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);

		dm = get_waiting_dir_move(sctx, loc.objectid);
		if (dm) {
			struct orphan_dir_info *odi;

			odi = add_orphan_dir_info(sctx, dir);
			if (IS_ERR(odi)) {
				ret = PTR_ERR(odi);
				goto out;
			}
			odi->gen = dir_gen;
			dm->rmdir_ino = dir;
			ret = 0;
			goto out;
		}

		if (loc.objectid > send_progress) {
			ret = 0;
			goto out;
		}

		path->slots[0]++;
	}

	ret = 1;

out:
	btrfs_free_path(path);
	return ret;
}

static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)
{
	struct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);

	return entry != NULL;
}

static int add_waiting_dir_move(struct send_ctx *sctx, u64 ino)
{
	struct rb_node **p = &sctx->waiting_dir_moves.rb_node;
	struct rb_node *parent = NULL;
	struct waiting_dir_move *entry, *dm;

	dm = kmalloc(sizeof(*dm), GFP_NOFS);
	if (!dm)
		return -ENOMEM;
	dm->ino = ino;
	dm->rmdir_ino = 0;

	while (*p) {
		parent = *p;
		entry = rb_entry(parent, struct waiting_dir_move, node);
		if (ino < entry->ino) {
			p = &(*p)->rb_left;
		} else if (ino > entry->ino) {
			p = &(*p)->rb_right;
		} else {
			kfree(dm);
			return -EEXIST;
		}
	}

	rb_link_node(&dm->node, parent, p);
	rb_insert_color(&dm->node, &sctx->waiting_dir_moves);
	return 0;
}

static struct waiting_dir_move *
get_waiting_dir_move(struct send_ctx *sctx, u64 ino)
{
	struct rb_node *n = sctx->waiting_dir_moves.rb_node;
	struct waiting_dir_move *entry;

	while (n) {
		entry = rb_entry(n, struct waiting_dir_move, node);
		if (ino < entry->ino)
			n = n->rb_left;
		else if (ino > entry->ino)
			n = n->rb_right;
		else
			return entry;
	}
	return NULL;
}

static void free_waiting_dir_move(struct send_ctx *sctx,
				  struct waiting_dir_move *dm)
{
	if (!dm)
		return;
	rb_erase(&dm->node, &sctx->waiting_dir_moves);
	kfree(dm);
}

static int add_pending_dir_move(struct send_ctx *sctx,
				u64 ino,
				u64 ino_gen,
				u64 parent_ino,
				struct list_head *new_refs,
				struct list_head *deleted_refs)
{
	struct rb_node **p = &sctx->pending_dir_moves.rb_node;
	struct rb_node *parent = NULL;
	struct pending_dir_move *entry = NULL, *pm;
	struct recorded_ref *cur;
	int exists = 0;
	int ret;

	pm = kmalloc(sizeof(*pm), GFP_NOFS);
	if (!pm)
		return -ENOMEM;
	pm->parent_ino = parent_ino;
	pm->ino = ino;
	pm->gen = ino_gen;
	INIT_LIST_HEAD(&pm->list);
	INIT_LIST_HEAD(&pm->update_refs);
	RB_CLEAR_NODE(&pm->node);

	while (*p) {
		parent = *p;
		entry = rb_entry(parent, struct pending_dir_move, node);
		if (parent_ino < entry->parent_ino) {
			p = &(*p)->rb_left;
		} else if (parent_ino > entry->parent_ino) {
			p = &(*p)->rb_right;
		} else {
			exists = 1;
			break;
		}
	}

	list_for_each_entry(cur, deleted_refs, list) {
		ret = dup_ref(cur, &pm->update_refs);
		if (ret < 0)
			goto out;
	}
	list_for_each_entry(cur, new_refs, list) {
		ret = dup_ref(cur, &pm->update_refs);
		if (ret < 0)
			goto out;
	}

	ret = add_waiting_dir_move(sctx, pm->ino);
	if (ret)
		goto out;

	if (exists) {
		list_add_tail(&pm->list, &entry->list);
	} else {
		rb_link_node(&pm->node, parent, p);
		rb_insert_color(&pm->node, &sctx->pending_dir_moves);
	}
	ret = 0;
out:
	if (ret) {
		__free_recorded_refs(&pm->update_refs);
		kfree(pm);
	}
	return ret;
}

static struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,
						      u64 parent_ino)
{
	struct rb_node *n = sctx->pending_dir_moves.rb_node;
	struct pending_dir_move *entry;

	while (n) {
		entry = rb_entry(n, struct pending_dir_move, node);
		if (parent_ino < entry->parent_ino)
			n = n->rb_left;
		else if (parent_ino > entry->parent_ino)
			n = n->rb_right;
		else
			return entry;
	}
	return NULL;
}

static int path_loop(struct send_ctx *sctx, struct fs_path *name,
		     u64 ino, u64 gen, u64 *ancestor_ino)
{
	int ret = 0;
	u64 parent_inode = 0;
	u64 parent_gen = 0;
	u64 start_ino = ino;

	*ancestor_ino = 0;
	while (ino != BTRFS_FIRST_FREE_OBJECTID) {
		fs_path_reset(name);

		if (is_waiting_for_rm(sctx, ino))
			break;
		if (is_waiting_for_move(sctx, ino)) {
			if (*ancestor_ino == 0)
				*ancestor_ino = ino;
			ret = get_first_ref(sctx->parent_root, ino,
					    &parent_inode, &parent_gen, name);
		} else {
			ret = __get_cur_name_and_parent(sctx, ino, gen,
							&parent_inode,
							&parent_gen, name);
			if (ret > 0) {
				ret = 0;
				break;
			}
		}
		if (ret < 0)
			break;
		if (parent_inode == start_ino) {
			ret = 1;
			if (*ancestor_ino == 0)
				*ancestor_ino = ino;
			break;
		}
		ino = parent_inode;
		gen = parent_gen;
	}
	return ret;
}

static int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)
{
	struct fs_path *from_path = NULL;
	struct fs_path *to_path = NULL;
	struct fs_path *name = NULL;
	u64 orig_progress = sctx->send_progress;
	struct recorded_ref *cur;
	u64 parent_ino, parent_gen;
	struct waiting_dir_move *dm = NULL;
	u64 rmdir_ino = 0;
	int ret;
	u64 ancestor = 0;

	name = fs_path_alloc();
	from_path = fs_path_alloc();
	if (!name || !from_path) {
		ret = -ENOMEM;
		goto out;
	}

	dm = get_waiting_dir_move(sctx, pm->ino);
	ASSERT(dm);
	rmdir_ino = dm->rmdir_ino;
	free_waiting_dir_move(sctx, dm);

	ret = get_first_ref(sctx->parent_root, pm->ino,
			    &parent_ino, &parent_gen, name);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, parent_ino, parent_gen,
			   from_path);
	if (ret < 0)
		goto out;
	ret = fs_path_add_path(from_path, name);
	if (ret < 0)
		goto out;

	sctx->send_progress = sctx->cur_ino + 1;
	ret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);
	if (ret) {
		LIST_HEAD(deleted_refs);
		ASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);
		ret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,
					   &pm->update_refs, &deleted_refs);
		if (ret < 0)
			goto out;
		if (rmdir_ino) {
			dm = get_waiting_dir_move(sctx, pm->ino);
			ASSERT(dm);
			dm->rmdir_ino = rmdir_ino;
		}
		goto out;
	}
	fs_path_reset(name);
	to_path = name;
	name = NULL;
	ret = get_cur_path(sctx, pm->ino, pm->gen, to_path);
	if (ret < 0)
		goto out;

	ret = send_rename(sctx, from_path, to_path);
	if (ret < 0)
		goto out;

	if (rmdir_ino) {
		struct orphan_dir_info *odi;

		odi = get_orphan_dir_info(sctx, rmdir_ino);
		if (!odi) {
			/* already deleted */
			goto finish;
		}
		ret = can_rmdir(sctx, rmdir_ino, odi->gen, sctx->cur_ino + 1);
		if (ret < 0)
			goto out;
		if (!ret)
			goto finish;

		name = fs_path_alloc();
		if (!name) {
			ret = -ENOMEM;
			goto out;
		}
		ret = get_cur_path(sctx, rmdir_ino, odi->gen, name);
		if (ret < 0)
			goto out;
		ret = send_rmdir(sctx, name);
		if (ret < 0)
			goto out;
		free_orphan_dir_info(sctx, odi);
	}

finish:
	ret = send_utimes(sctx, pm->ino, pm->gen);
	if (ret < 0)
		goto out;

	/*
	 * After rename/move, need to update the utimes of both new parent(s)
	 * and old parent(s).
	 */
	list_for_each_entry(cur, &pm->update_refs, list) {
		if (cur->dir == rmdir_ino)
			continue;
		ret = send_utimes(sctx, cur->dir, cur->dir_gen);
		if (ret < 0)
			goto out;
	}

out:
	fs_path_free(name);
	fs_path_free(from_path);
	fs_path_free(to_path);
	sctx->send_progress = orig_progress;

	return ret;
}

static void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)
{
	if (!list_empty(&m->list))
		list_del(&m->list);
	if (!RB_EMPTY_NODE(&m->node))
		rb_erase(&m->node, &sctx->pending_dir_moves);
	__free_recorded_refs(&m->update_refs);
	kfree(m);
}

static void tail_append_pending_moves(struct pending_dir_move *moves,
				      struct list_head *stack)
{
	if (list_empty(&moves->list)) {
		list_add_tail(&moves->list, stack);
	} else {
		LIST_HEAD(list);
		list_splice_init(&moves->list, &list);
		list_add_tail(&moves->list, stack);
		list_splice_tail(&list, stack);
	}
}

static int apply_children_dir_moves(struct send_ctx *sctx)
{
	struct pending_dir_move *pm;
	struct list_head stack;
	u64 parent_ino = sctx->cur_ino;
	int ret = 0;

	pm = get_pending_dir_moves(sctx, parent_ino);
	if (!pm)
		return 0;

	INIT_LIST_HEAD(&stack);
	tail_append_pending_moves(pm, &stack);

	while (!list_empty(&stack)) {
		pm = list_first_entry(&stack, struct pending_dir_move, list);
		parent_ino = pm->ino;
		ret = apply_dir_move(sctx, pm);
		free_pending_move(sctx, pm);
		if (ret)
			goto out;
		pm = get_pending_dir_moves(sctx, parent_ino);
		if (pm)
			tail_append_pending_moves(pm, &stack);
	}
	return 0;

out:
	while (!list_empty(&stack)) {
		pm = list_first_entry(&stack, struct pending_dir_move, list);
		free_pending_move(sctx, pm);
	}
	return ret;
}

static int wait_for_parent_move(struct send_ctx *sctx,
				struct recorded_ref *parent_ref)
{
	int ret = 0;
	u64 ino = parent_ref->dir;
	u64 parent_ino_before, parent_ino_after;
	struct fs_path *path_before = NULL;
	struct fs_path *path_after = NULL;
	int len1, len2;

	path_after = fs_path_alloc();
	path_before = fs_path_alloc();
	if (!path_after || !path_before) {
		ret = -ENOMEM;
		goto out;
	}

	/*
	 * Our current directory inode may not yet be renamed/moved because some
	 * ancestor (immediate or not) has to be renamed/moved first. So find if
	 * such ancestor exists and make sure our own rename/move happens after
	 * that ancestor is processed.
	 */
	while (ino > BTRFS_FIRST_FREE_OBJECTID) {
		if (is_waiting_for_move(sctx, ino)) {
			ret = 1;
			break;
		}

		fs_path_reset(path_before);
		fs_path_reset(path_after);

		ret = get_first_ref(sctx->send_root, ino, &parent_ino_after,
				    NULL, path_after);
		if (ret < 0)
			goto out;
		ret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,
				    NULL, path_before);
		if (ret < 0 && ret != -ENOENT) {
			goto out;
		} else if (ret == -ENOENT) {
			ret = 0;
			break;
		}

		len1 = fs_path_len(path_before);
		len2 = fs_path_len(path_after);
		if (ino > sctx->cur_ino &&
		    (parent_ino_before != parent_ino_after || len1 != len2 ||
		     memcmp(path_before->start, path_after->start, len1))) {
			ret = 1;
			break;
		}
		ino = parent_ino_after;
	}

out:
	fs_path_free(path_before);
	fs_path_free(path_after);

	if (ret == 1) {
		ret = add_pending_dir_move(sctx,
					   sctx->cur_ino,
					   sctx->cur_inode_gen,
					   ino,
					   &sctx->new_refs,
					   &sctx->deleted_refs);
		if (!ret)
			ret = 1;
	}

	return ret;
}

/*
 * This does all the move/link/unlink/rmdir magic.
 */
static int process_recorded_refs(struct send_ctx *sctx, int *pending_move)
{
	int ret = 0;
	struct recorded_ref *cur;
	struct recorded_ref *cur2;
	struct list_head check_dirs;
	struct fs_path *valid_path = NULL;
	u64 ow_inode = 0;
	u64 ow_gen;
	int did_overwrite = 0;
	int is_orphan = 0;
	u64 last_dir_ino_rm = 0;

verbose_printk("btrfs: process_recorded_refs %llu\n", sctx->cur_ino);

	/*
	 * This should never happen as the root dir always has the same ref
	 * which is always '..'
	 */
	BUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);
	INIT_LIST_HEAD(&check_dirs);

	valid_path = fs_path_alloc();
	if (!valid_path) {
		ret = -ENOMEM;
		goto out;
	}

	/*
	 * First, check if the first ref of the current inode was overwritten
	 * before. If yes, we know that the current inode was already orphanized
	 * and thus use the orphan name. If not, we can use get_cur_path to
	 * get the path of the first ref as it would like while receiving at
	 * this point in time.
	 * New inodes are always orphan at the beginning, so force to use the
	 * orphan name in this case.
	 * The first ref is stored in valid_path and will be updated if it
	 * gets moved around.
	 */
	if (!sctx->cur_inode_new) {
		ret = did_overwrite_first_ref(sctx, sctx->cur_ino,
				sctx->cur_inode_gen);
		if (ret < 0)
			goto out;
		if (ret)
			did_overwrite = 1;
	}
	if (sctx->cur_inode_new || did_overwrite) {
		ret = gen_unique_name(sctx, sctx->cur_ino,
				sctx->cur_inode_gen, valid_path);
		if (ret < 0)
			goto out;
		is_orphan = 1;
	} else {
		ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,
				valid_path);
		if (ret < 0)
			goto out;
	}

	list_for_each_entry(cur, &sctx->new_refs, list) {
		/*
		 * We may have refs where the parent directory does not exist
		 * yet. This happens if the parent directories inum is higher
		 * the the current inum. To handle this case, we create the
		 * parent directory out of order. But we need to check if this
		 * did already happen before due to other refs in the same dir.
		 */
		ret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);
		if (ret < 0)
			goto out;
		if (ret == inode_state_will_create) {
			ret = 0;
			/*
			 * First check if any of the current inodes refs did
			 * already create the dir.
			 */
			list_for_each_entry(cur2, &sctx->new_refs, list) {
				if (cur == cur2)
					break;
				if (cur2->dir == cur->dir) {
					ret = 1;
					break;
				}
			}

			/*
			 * If that did not happen, check if a previous inode
			 * did already create the dir.
			 */
			if (!ret)
				ret = did_create_dir(sctx, cur->dir);
			if (ret < 0)
				goto out;
			if (!ret) {
				ret = send_create_inode(sctx, cur->dir);
				if (ret < 0)
					goto out;
			}
		}

		/*
		 * Check if this new ref would overwrite the first ref of
		 * another unprocessed inode. If yes, orphanize the
		 * overwritten inode. If we find an overwritten ref that is
		 * not the first ref, simply unlink it.
		 */
		ret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,
				cur->name, cur->name_len,
				&ow_inode, &ow_gen);
		if (ret < 0)
			goto out;
		if (ret) {
			ret = is_first_ref(sctx->parent_root,
					   ow_inode, cur->dir, cur->name,
					   cur->name_len);
			if (ret < 0)
				goto out;
			if (ret) {
				ret = orphanize_inode(sctx, ow_inode, ow_gen,
						cur->full_path);
				if (ret < 0)
					goto out;
			} else {
				ret = send_unlink(sctx, cur->full_path);
				if (ret < 0)
					goto out;
			}
		}

		/*
		 * link/move the ref to the new place. If we have an orphan
		 * inode, move it and update valid_path. If not, link or move
		 * it depending on the inode mode.
		 */
		if (is_orphan) {
			ret = send_rename(sctx, valid_path, cur->full_path);
			if (ret < 0)
				goto out;
			is_orphan = 0;
			ret = fs_path_copy(valid_path, cur->full_path);
			if (ret < 0)
				goto out;
		} else {
			if (S_ISDIR(sctx->cur_inode_mode)) {
				/*
				 * Dirs can't be linked, so move it. For moved
				 * dirs, we always have one new and one deleted
				 * ref. The deleted ref is ignored later.
				 */
				ret = wait_for_parent_move(sctx, cur);
				if (ret < 0)
					goto out;
				if (ret) {
					*pending_move = 1;
				} else {
					ret = send_rename(sctx, valid_path,
							  cur->full_path);
					if (!ret)
						ret = fs_path_copy(valid_path,
							       cur->full_path);
				}
				if (ret < 0)
					goto out;
			} else {
				ret = send_link(sctx, cur->full_path,
						valid_path);
				if (ret < 0)
					goto out;
			}
		}
		ret = dup_ref(cur, &check_dirs);
		if (ret < 0)
			goto out;
	}

	if (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {
		/*
		 * Check if we can already rmdir the directory. If not,
		 * orphanize it. For every dir item inside that gets deleted
		 * later, we do this check again and rmdir it then if possible.
		 * See the use of check_dirs for more details.
		 */
		ret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,
				sctx->cur_ino);
		if (ret < 0)
			goto out;
		if (ret) {
			ret = send_rmdir(sctx, valid_path);
			if (ret < 0)
				goto out;
		} else if (!is_orphan) {
			ret = orphanize_inode(sctx, sctx->cur_ino,
					sctx->cur_inode_gen, valid_path);
			if (ret < 0)
				goto out;
			is_orphan = 1;
		}

		list_for_each_entry(cur, &sctx->deleted_refs, list) {
			ret = dup_ref(cur, &check_dirs);
			if (ret < 0)
				goto out;
		}
	} else if (S_ISDIR(sctx->cur_inode_mode) &&
		   !list_empty(&sctx->deleted_refs)) {
		/*
		 * We have a moved dir. Add the old parent to check_dirs
		 */
		cur = list_entry(sctx->deleted_refs.next, struct recorded_ref,
				list);
		ret = dup_ref(cur, &check_dirs);
		if (ret < 0)
			goto out;
	} else if (!S_ISDIR(sctx->cur_inode_mode)) {
		/*
		 * We have a non dir inode. Go through all deleted refs and
		 * unlink them if they were not already overwritten by other
		 * inodes.
		 */
		list_for_each_entry(cur, &sctx->deleted_refs, list) {
			ret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,
					sctx->cur_ino, sctx->cur_inode_gen,
					cur->name, cur->name_len);
			if (ret < 0)
				goto out;
			if (!ret) {
				ret = send_unlink(sctx, cur->full_path);
				if (ret < 0)
					goto out;
			}
			ret = dup_ref(cur, &check_dirs);
			if (ret < 0)
				goto out;
		}
		/*
		 * If the inode is still orphan, unlink the orphan. This may
		 * happen when a previous inode did overwrite the first ref
		 * of this inode and no new refs were added for the current
		 * inode. Unlinking does not mean that the inode is deleted in
		 * all cases. There may still be links to this inode in other
		 * places.
		 */
		if (is_orphan) {
			ret = send_unlink(sctx, valid_path);
			if (ret < 0)
				goto out;
		}
	}

	/*
	 * We did collect all parent dirs where cur_inode was once located. We
	 * now go through all these dirs and check if they are pending for
	 * deletion and if it's finally possible to perform the rmdir now.
	 * We also update the inode stats of the parent dirs here.
	 */
	list_for_each_entry(cur, &check_dirs, list) {
		/*
		 * In case we had refs into dirs that were not processed yet,
		 * we don't need to do the utime and rmdir logic for these dirs.
		 * The dir will be processed later.
		 */
		if (cur->dir > sctx->cur_ino)
			continue;

		ret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);
		if (ret < 0)
			goto out;

		if (ret == inode_state_did_create ||
		    ret == inode_state_no_change) {
			/* TODO delayed utimes */
			ret = send_utimes(sctx, cur->dir, cur->dir_gen);
			if (ret < 0)
				goto out;
		} else if (ret == inode_state_did_delete &&
			   cur->dir != last_dir_ino_rm) {
			ret = can_rmdir(sctx, cur->dir, cur->dir_gen,
					sctx->cur_ino);
			if (ret < 0)
				goto out;
			if (ret) {
				ret = get_cur_path(sctx, cur->dir,
						   cur->dir_gen, valid_path);
				if (ret < 0)
					goto out;
				ret = send_rmdir(sctx, valid_path);
				if (ret < 0)
					goto out;
				last_dir_ino_rm = cur->dir;
			}
		}
	}

	ret = 0;

out:
	__free_recorded_refs(&check_dirs);
	free_recorded_refs(sctx);
	fs_path_free(valid_path);
	return ret;
}

static int record_ref(struct btrfs_root *root, int num, u64 dir, int index,
		      struct fs_path *name, void *ctx, struct list_head *refs)
{
	int ret = 0;
	struct send_ctx *sctx = ctx;
	struct fs_path *p;
	u64 gen;

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,
			NULL, NULL);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, dir, gen, p);
	if (ret < 0)
		goto out;
	ret = fs_path_add_path(p, name);
	if (ret < 0)
		goto out;

	ret = __record_ref(refs, dir, gen, p);

out:
	if (ret)
		fs_path_free(p);
	return ret;
}

static int __record_new_ref(int num, u64 dir, int index,
			    struct fs_path *name,
			    void *ctx)
{
	struct send_ctx *sctx = ctx;
	return record_ref(sctx->send_root, num, dir, index, name,
			  ctx, &sctx->new_refs);
}


static int __record_deleted_ref(int num, u64 dir, int index,
				struct fs_path *name,
				void *ctx)
{
	struct send_ctx *sctx = ctx;
	return record_ref(sctx->parent_root, num, dir, index, name,
			  ctx, &sctx->deleted_refs);
}

static int record_new_ref(struct send_ctx *sctx)
{
	int ret;

	ret = iterate_inode_ref(sctx->send_root, sctx->left_path,
				sctx->cmp_key, 0, __record_new_ref, sctx);
	if (ret < 0)
		goto out;
	ret = 0;

out:
	return ret;
}

static int record_deleted_ref(struct send_ctx *sctx)
{
	int ret;

	ret = iterate_inode_ref(sctx->parent_root, sctx->right_path,
				sctx->cmp_key, 0, __record_deleted_ref, sctx);
	if (ret < 0)
		goto out;
	ret = 0;

out:
	return ret;
}

struct find_ref_ctx {
	u64 dir;
	u64 dir_gen;
	struct btrfs_root *root;
	struct fs_path *name;
	int found_idx;
};

static int __find_iref(int num, u64 dir, int index,
		       struct fs_path *name,
		       void *ctx_)
{
	struct find_ref_ctx *ctx = ctx_;
	u64 dir_gen;
	int ret;

	if (dir == ctx->dir && fs_path_len(name) == fs_path_len(ctx->name) &&
	    strncmp(name->start, ctx->name->start, fs_path_len(name)) == 0) {
		/*
		 * To avoid doing extra lookups we'll only do this if everything
		 * else matches.
		 */
		ret = get_inode_info(ctx->root, dir, NULL, &dir_gen, NULL,
				     NULL, NULL, NULL);
		if (ret)
			return ret;
		if (dir_gen != ctx->dir_gen)
			return 0;
		ctx->found_idx = num;
		return 1;
	}
	return 0;
}

static int find_iref(struct btrfs_root *root,
		     struct btrfs_path *path,
		     struct btrfs_key *key,
		     u64 dir, u64 dir_gen, struct fs_path *name)
{
	int ret;
	struct find_ref_ctx ctx;

	ctx.dir = dir;
	ctx.name = name;
	ctx.dir_gen = dir_gen;
	ctx.found_idx = -1;
	ctx.root = root;

	ret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);
	if (ret < 0)
		return ret;

	if (ctx.found_idx == -1)
		return -ENOENT;

	return ctx.found_idx;
}

static int __record_changed_new_ref(int num, u64 dir, int index,
				    struct fs_path *name,
				    void *ctx)
{
	u64 dir_gen;
	int ret;
	struct send_ctx *sctx = ctx;

	ret = get_inode_info(sctx->send_root, dir, NULL, &dir_gen, NULL,
			     NULL, NULL, NULL);
	if (ret)
		return ret;

	ret = find_iref(sctx->parent_root, sctx->right_path,
			sctx->cmp_key, dir, dir_gen, name);
	if (ret == -ENOENT)
		ret = __record_new_ref(num, dir, index, name, sctx);
	else if (ret > 0)
		ret = 0;

	return ret;
}

static int __record_changed_deleted_ref(int num, u64 dir, int index,
					struct fs_path *name,
					void *ctx)
{
	u64 dir_gen;
	int ret;
	struct send_ctx *sctx = ctx;

	ret = get_inode_info(sctx->parent_root, dir, NULL, &dir_gen, NULL,
			     NULL, NULL, NULL);
	if (ret)
		return ret;

	ret = find_iref(sctx->send_root, sctx->left_path, sctx->cmp_key,
			dir, dir_gen, name);
	if (ret == -ENOENT)
		ret = __record_deleted_ref(num, dir, index, name, sctx);
	else if (ret > 0)
		ret = 0;

	return ret;
}

static int record_changed_ref(struct send_ctx *sctx)
{
	int ret = 0;

	ret = iterate_inode_ref(sctx->send_root, sctx->left_path,
			sctx->cmp_key, 0, __record_changed_new_ref, sctx);
	if (ret < 0)
		goto out;
	ret = iterate_inode_ref(sctx->parent_root, sctx->right_path,
			sctx->cmp_key, 0, __record_changed_deleted_ref, sctx);
	if (ret < 0)
		goto out;
	ret = 0;

out:
	return ret;
}

/*
 * Record and process all refs at once. Needed when an inode changes the
 * generation number, which means that it was deleted and recreated.
 */
static int process_all_refs(struct send_ctx *sctx,
			    enum btrfs_compare_tree_result cmd)
{
	int ret;
	struct btrfs_root *root;
	struct btrfs_path *path;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct extent_buffer *eb;
	int slot;
	iterate_inode_ref_t cb;
	int pending_move = 0;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	if (cmd == BTRFS_COMPARE_TREE_NEW) {
		root = sctx->send_root;
		cb = __record_new_ref;
	} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {
		root = sctx->parent_root;
		cb = __record_deleted_ref;
	} else {
		btrfs_err(sctx->send_root->fs_info,
				"Wrong command %d in process_all_refs", cmd);
		ret = -EINVAL;
		goto out;
	}

	key.objectid = sctx->cmp_key->objectid;
	key.type = BTRFS_INODE_REF_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
	if (ret < 0)
		goto out;

	while (1) {
		eb = path->nodes[0];
		slot = path->slots[0];
		if (slot >= btrfs_header_nritems(eb)) {
			ret = btrfs_next_leaf(root, path);
			if (ret < 0)
				goto out;
			else if (ret > 0)
				break;
			continue;
		}

		btrfs_item_key_to_cpu(eb, &found_key, slot);

		if (found_key.objectid != key.objectid ||
		    (found_key.type != BTRFS_INODE_REF_KEY &&
		     found_key.type != BTRFS_INODE_EXTREF_KEY))
			break;

		ret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);
		if (ret < 0)
			goto out;

		path->slots[0]++;
	}
	btrfs_release_path(path);

	ret = process_recorded_refs(sctx, &pending_move);
	/* Only applicable to an incremental send. */
	ASSERT(pending_move == 0);

out:
	btrfs_free_path(path);
	return ret;
}

static int send_set_xattr(struct send_ctx *sctx,
			  struct fs_path *path,
			  const char *name, int name_len,
			  const char *data, int data_len)
{
	int ret = 0;

	ret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);
	TLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);
	TLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	return ret;
}

static int send_remove_xattr(struct send_ctx *sctx,
			  struct fs_path *path,
			  const char *name, int name_len)
{
	int ret = 0;

	ret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);
	TLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	return ret;
}

static int __process_new_xattr(int num, struct btrfs_key *di_key,
			       const char *name, int name_len,
			       const char *data, int data_len,
			       u8 type, void *ctx)
{
	int ret;
	struct send_ctx *sctx = ctx;
	struct fs_path *p;
	posix_acl_xattr_header dummy_acl;

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	/*
	 * This hack is needed because empty acl's are stored as zero byte
	 * data in xattrs. Problem with that is, that receiving these zero byte
	 * acl's will fail later. To fix this, we send a dummy acl list that
	 * only contains the version number and no entries.
	 */
	if (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||
	    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {
		if (data_len == 0) {
			dummy_acl.a_version =
					cpu_to_le32(POSIX_ACL_XATTR_VERSION);
			data = (char *)&dummy_acl;
			data_len = sizeof(dummy_acl);
		}
	}

	ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);
	if (ret < 0)
		goto out;

	ret = send_set_xattr(sctx, p, name, name_len, data, data_len);

out:
	fs_path_free(p);
	return ret;
}

static int __process_deleted_xattr(int num, struct btrfs_key *di_key,
				   const char *name, int name_len,
				   const char *data, int data_len,
				   u8 type, void *ctx)
{
	int ret;
	struct send_ctx *sctx = ctx;
	struct fs_path *p;

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);
	if (ret < 0)
		goto out;

	ret = send_remove_xattr(sctx, p, name, name_len);

out:
	fs_path_free(p);
	return ret;
}

static int process_new_xattr(struct send_ctx *sctx)
{
	int ret = 0;

	ret = iterate_dir_item(sctx->send_root, sctx->left_path,
			       sctx->cmp_key, __process_new_xattr, sctx);

	return ret;
}

static int process_deleted_xattr(struct send_ctx *sctx)
{
	int ret;

	ret = iterate_dir_item(sctx->parent_root, sctx->right_path,
			       sctx->cmp_key, __process_deleted_xattr, sctx);

	return ret;
}

struct find_xattr_ctx {
	const char *name;
	int name_len;
	int found_idx;
	char *found_data;
	int found_data_len;
};

static int __find_xattr(int num, struct btrfs_key *di_key,
			const char *name, int name_len,
			const char *data, int data_len,
			u8 type, void *vctx)
{
	struct find_xattr_ctx *ctx = vctx;

	if (name_len == ctx->name_len &&
	    strncmp(name, ctx->name, name_len) == 0) {
		ctx->found_idx = num;
		ctx->found_data_len = data_len;
		ctx->found_data = kmemdup(data, data_len, GFP_NOFS);
		if (!ctx->found_data)
			return -ENOMEM;
		return 1;
	}
	return 0;
}

static int find_xattr(struct btrfs_root *root,
		      struct btrfs_path *path,
		      struct btrfs_key *key,
		      const char *name, int name_len,
		      char **data, int *data_len)
{
	int ret;
	struct find_xattr_ctx ctx;

	ctx.name = name;
	ctx.name_len = name_len;
	ctx.found_idx = -1;
	ctx.found_data = NULL;
	ctx.found_data_len = 0;

	ret = iterate_dir_item(root, path, key, __find_xattr, &ctx);
	if (ret < 0)
		return ret;

	if (ctx.found_idx == -1)
		return -ENOENT;
	if (data) {
		*data = ctx.found_data;
		*data_len = ctx.found_data_len;
	} else {
		kfree(ctx.found_data);
	}
	return ctx.found_idx;
}


static int __process_changed_new_xattr(int num, struct btrfs_key *di_key,
				       const char *name, int name_len,
				       const char *data, int data_len,
				       u8 type, void *ctx)
{
	int ret;
	struct send_ctx *sctx = ctx;
	char *found_data = NULL;
	int found_data_len  = 0;

	ret = find_xattr(sctx->parent_root, sctx->right_path,
			 sctx->cmp_key, name, name_len, &found_data,
			 &found_data_len);
	if (ret == -ENOENT) {
		ret = __process_new_xattr(num, di_key, name, name_len, data,
				data_len, type, ctx);
	} else if (ret >= 0) {
		if (data_len != found_data_len ||
		    memcmp(data, found_data, data_len)) {
			ret = __process_new_xattr(num, di_key, name, name_len,
					data, data_len, type, ctx);
		} else {
			ret = 0;
		}
	}

	kfree(found_data);
	return ret;
}

static int __process_changed_deleted_xattr(int num, struct btrfs_key *di_key,
					   const char *name, int name_len,
					   const char *data, int data_len,
					   u8 type, void *ctx)
{
	int ret;
	struct send_ctx *sctx = ctx;

	ret = find_xattr(sctx->send_root, sctx->left_path, sctx->cmp_key,
			 name, name_len, NULL, NULL);
	if (ret == -ENOENT)
		ret = __process_deleted_xattr(num, di_key, name, name_len, data,
				data_len, type, ctx);
	else if (ret >= 0)
		ret = 0;

	return ret;
}

static int process_changed_xattr(struct send_ctx *sctx)
{
	int ret = 0;

	ret = iterate_dir_item(sctx->send_root, sctx->left_path,
			sctx->cmp_key, __process_changed_new_xattr, sctx);
	if (ret < 0)
		goto out;
	ret = iterate_dir_item(sctx->parent_root, sctx->right_path,
			sctx->cmp_key, __process_changed_deleted_xattr, sctx);

out:
	return ret;
}

static int process_all_new_xattrs(struct send_ctx *sctx)
{
	int ret;
	struct btrfs_root *root;
	struct btrfs_path *path;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct extent_buffer *eb;
	int slot;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	root = sctx->send_root;

	key.objectid = sctx->cmp_key->objectid;
	key.type = BTRFS_XATTR_ITEM_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
	if (ret < 0)
		goto out;

	while (1) {
		eb = path->nodes[0];
		slot = path->slots[0];
		if (slot >= btrfs_header_nritems(eb)) {
			ret = btrfs_next_leaf(root, path);
			if (ret < 0) {
				goto out;
			} else if (ret > 0) {
				ret = 0;
				break;
			}
			continue;
		}

		btrfs_item_key_to_cpu(eb, &found_key, slot);
		if (found_key.objectid != key.objectid ||
		    found_key.type != key.type) {
			ret = 0;
			goto out;
		}

		ret = iterate_dir_item(root, path, &found_key,
				       __process_new_xattr, sctx);
		if (ret < 0)
			goto out;

		path->slots[0]++;
	}

out:
	btrfs_free_path(path);
	return ret;
}

static ssize_t fill_read_buf(struct send_ctx *sctx, u64 offset, u32 len)
{
	struct btrfs_root *root = sctx->send_root;
	struct btrfs_fs_info *fs_info = root->fs_info;
	struct inode *inode;
	struct page *page;
	char *addr;
	struct btrfs_key key;
	pgoff_t index = offset >> PAGE_CACHE_SHIFT;
	pgoff_t last_index;
	unsigned pg_offset = offset & ~PAGE_CACHE_MASK;
	ssize_t ret = 0;

	key.objectid = sctx->cur_ino;
	key.type = BTRFS_INODE_ITEM_KEY;
	key.offset = 0;

	inode = btrfs_iget(fs_info->sb, &key, root, NULL);
	if (IS_ERR(inode))
		return PTR_ERR(inode);

	if (offset + len > i_size_read(inode)) {
		if (offset > i_size_read(inode))
			len = 0;
		else
			len = offset - i_size_read(inode);
	}
	if (len == 0)
		goto out;

	last_index = (offset + len - 1) >> PAGE_CACHE_SHIFT;

	/* initial readahead */
	memset(&sctx->ra, 0, sizeof(struct file_ra_state));
	file_ra_state_init(&sctx->ra, inode->i_mapping);
	btrfs_force_ra(inode->i_mapping, &sctx->ra, NULL, index,
		       last_index - index + 1);

	while (index <= last_index) {
		unsigned cur_len = min_t(unsigned, len,
					 PAGE_CACHE_SIZE - pg_offset);
		page = find_or_create_page(inode->i_mapping, index, GFP_NOFS);
		if (!page) {
			ret = -ENOMEM;
			break;
		}

		if (!PageUptodate(page)) {
			btrfs_readpage(NULL, page);
			lock_page(page);
			if (!PageUptodate(page)) {
				unlock_page(page);
				page_cache_release(page);
				ret = -EIO;
				break;
			}
		}

		addr = kmap(page);
		memcpy(sctx->read_buf + ret, addr + pg_offset, cur_len);
		kunmap(page);
		unlock_page(page);
		page_cache_release(page);
		index++;
		pg_offset = 0;
		len -= cur_len;
		ret += cur_len;
	}
out:
	iput(inode);
	return ret;
}

/*
 * Read some bytes from the current inode/file and send a write command to
 * user space.
 */
static int send_write(struct send_ctx *sctx, u64 offset, u32 len)
{
	int ret = 0;
	struct fs_path *p;
	ssize_t num_read = 0;

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

verbose_printk("btrfs: send_write offset=%llu, len=%d\n", offset, len);

	num_read = fill_read_buf(sctx, offset, len);
	if (num_read <= 0) {
		if (num_read < 0)
			ret = num_read;
		goto out;
	}

	ret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);
	TLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, num_read);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	if (ret < 0)
		return ret;
	return num_read;
}

/*
 * Send a clone command to user space.
 */
static int send_clone(struct send_ctx *sctx,
		      u64 offset, u32 len,
		      struct clone_root *clone_root)
{
	int ret = 0;
	struct fs_path *p;
	u64 gen;

verbose_printk("btrfs: send_clone offset=%llu, len=%d, clone_root=%llu, "
	       "clone_inode=%llu, clone_offset=%llu\n", offset, len,
		clone_root->root->objectid, clone_root->ino,
		clone_root->offset);

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);
	if (ret < 0)
		goto out;

	TLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);

	if (clone_root->root == sctx->send_root) {
		ret = get_inode_info(sctx->send_root, clone_root->ino, NULL,
				&gen, NULL, NULL, NULL, NULL);
		if (ret < 0)
			goto out;
		ret = get_cur_path(sctx, clone_root->ino, gen, p);
	} else {
		ret = get_inode_path(clone_root->root, clone_root->ino, p);
	}
	if (ret < 0)
		goto out;

	TLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,
			clone_root->root->root_item.uuid);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,
		    le64_to_cpu(clone_root->root->root_item.ctransid));
	TLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,
			clone_root->offset);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	return ret;
}

/*
 * Send an update extent command to user space.
 */
static int send_update_extent(struct send_ctx *sctx,
			      u64 offset, u32 len)
{
	int ret = 0;
	struct fs_path *p;

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;

	ret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);
	if (ret < 0)
		goto out;

	ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);
	if (ret < 0)
		goto out;

	TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);
	TLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);

	ret = send_cmd(sctx);

tlv_put_failure:
out:
	fs_path_free(p);
	return ret;
}

static int send_hole(struct send_ctx *sctx, u64 end)
{
	struct fs_path *p = NULL;
	u64 offset = sctx->cur_inode_last_extent;
	u64 len;
	int ret = 0;

	p = fs_path_alloc();
	if (!p)
		return -ENOMEM;
	ret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);
	if (ret < 0)
		goto tlv_put_failure;
	memset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);
	while (offset < end) {
		len = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);

		ret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);
		if (ret < 0)
			break;
		TLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);
		TLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);
		TLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);
		ret = send_cmd(sctx);
		if (ret < 0)
			break;
		offset += len;
	}
tlv_put_failure:
	fs_path_free(p);
	return ret;
}

static int send_write_or_clone(struct send_ctx *sctx,
			       struct btrfs_path *path,
			       struct btrfs_key *key,
			       struct clone_root *clone_root)
{
	int ret = 0;
	struct btrfs_file_extent_item *ei;
	u64 offset = key->offset;
	u64 pos = 0;
	u64 len;
	u32 l;
	u8 type;
	u64 bs = sctx->send_root->fs_info->sb->s_blocksize;

	ei = btrfs_item_ptr(path->nodes[0], path->slots[0],
			struct btrfs_file_extent_item);
	type = btrfs_file_extent_type(path->nodes[0], ei);
	if (type == BTRFS_FILE_EXTENT_INLINE) {
		len = btrfs_file_extent_inline_len(path->nodes[0],
						   path->slots[0], ei);
		/*
		 * it is possible the inline item won't cover the whole page,
		 * but there may be items after this page.  Make
		 * sure to send the whole thing
		 */
		len = PAGE_CACHE_ALIGN(len);
	} else {
		len = btrfs_file_extent_num_bytes(path->nodes[0], ei);
	}

	if (offset + len > sctx->cur_inode_size)
		len = sctx->cur_inode_size - offset;
	if (len == 0) {
		ret = 0;
		goto out;
	}

	if (clone_root && IS_ALIGNED(offset + len, bs)) {
		ret = send_clone(sctx, offset, len, clone_root);
	} else if (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA) {
		ret = send_update_extent(sctx, offset, len);
	} else {
		while (pos < len) {
			l = len - pos;
			if (l > BTRFS_SEND_READ_SIZE)
				l = BTRFS_SEND_READ_SIZE;
			ret = send_write(sctx, pos + offset, l);
			if (ret < 0)
				goto out;
			if (!ret)
				break;
			pos += ret;
		}
		ret = 0;
	}
out:
	return ret;
}

static int is_extent_unchanged(struct send_ctx *sctx,
			       struct btrfs_path *left_path,
			       struct btrfs_key *ekey)
{
	int ret = 0;
	struct btrfs_key key;
	struct btrfs_path *path = NULL;
	struct extent_buffer *eb;
	int slot;
	struct btrfs_key found_key;
	struct btrfs_file_extent_item *ei;
	u64 left_disknr;
	u64 right_disknr;
	u64 left_offset;
	u64 right_offset;
	u64 left_offset_fixed;
	u64 left_len;
	u64 right_len;
	u64 left_gen;
	u64 right_gen;
	u8 left_type;
	u8 right_type;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	eb = left_path->nodes[0];
	slot = left_path->slots[0];
	ei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);
	left_type = btrfs_file_extent_type(eb, ei);

	if (left_type != BTRFS_FILE_EXTENT_REG) {
		ret = 0;
		goto out;
	}
	left_disknr = btrfs_file_extent_disk_bytenr(eb, ei);
	left_len = btrfs_file_extent_num_bytes(eb, ei);
	left_offset = btrfs_file_extent_offset(eb, ei);
	left_gen = btrfs_file_extent_generation(eb, ei);

	/*
	 * Following comments will refer to these graphics. L is the left
	 * extents which we are checking at the moment. 1-8 are the right
	 * extents that we iterate.
	 *
	 *       |-----L-----|
	 * |-1-|-2a-|-3-|-4-|-5-|-6-|
	 *
	 *       |-----L-----|
	 * |--1--|-2b-|...(same as above)
	 *
	 * Alternative situation. Happens on files where extents got split.
	 *       |-----L-----|
	 * |-----------7-----------|-6-|
	 *
	 * Alternative situation. Happens on files which got larger.
	 *       |-----L-----|
	 * |-8-|
	 * Nothing follows after 8.
	 */

	key.objectid = ekey->objectid;
	key.type = BTRFS_EXTENT_DATA_KEY;
	key.offset = ekey->offset;
	ret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);
	if (ret < 0)
		goto out;
	if (ret) {
		ret = 0;
		goto out;
	}

	/*
	 * Handle special case where the right side has no extents at all.
	 */
	eb = path->nodes[0];
	slot = path->slots[0];
	btrfs_item_key_to_cpu(eb, &found_key, slot);
	if (found_key.objectid != key.objectid ||
	    found_key.type != key.type) {
		/* If we're a hole then just pretend nothing changed */
		ret = (left_disknr) ? 0 : 1;
		goto out;
	}

	/*
	 * We're now on 2a, 2b or 7.
	 */
	key = found_key;
	while (key.offset < ekey->offset + left_len) {
		ei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);
		right_type = btrfs_file_extent_type(eb, ei);
		if (right_type != BTRFS_FILE_EXTENT_REG &&
		    right_type != BTRFS_FILE_EXTENT_INLINE) {
			ret = 0;
			goto out;
		}

		right_disknr = btrfs_file_extent_disk_bytenr(eb, ei);
		if (right_type == BTRFS_FILE_EXTENT_INLINE) {
			right_len = btrfs_file_extent_inline_len(eb, slot, ei);
			right_len = PAGE_ALIGN(right_len);
		} else {
			right_len = btrfs_file_extent_num_bytes(eb, ei);
		}
		right_offset = btrfs_file_extent_offset(eb, ei);
		right_gen = btrfs_file_extent_generation(eb, ei);

		/*
		 * Are we at extent 8? If yes, we know the extent is changed.
		 * This may only happen on the first iteration.
		 */
		if (found_key.offset + right_len <= ekey->offset) {
			/* If we're a hole just pretend nothing changed */
			ret = (left_disknr) ? 0 : 1;
			goto out;
		}

		/*
		 * We just wanted to see if when we have an inline extent, what
		 * follows it is a regular extent (wanted to check the above
		 * condition for inline extents too). This should normally not
		 * happen but it's possible for example when we have an inline
		 * compressed extent representing data with a size matching
		 * the page size (currently the same as sector size).
		 */
		if (right_type == BTRFS_FILE_EXTENT_INLINE) {
			ret = 0;
			goto out;
		}

		left_offset_fixed = left_offset;
		if (key.offset < ekey->offset) {
			/* Fix the right offset for 2a and 7. */
			right_offset += ekey->offset - key.offset;
		} else {
			/* Fix the left offset for all behind 2a and 2b */
			left_offset_fixed += key.offset - ekey->offset;
		}

		/*
		 * Check if we have the same extent.
		 */
		if (left_disknr != right_disknr ||
		    left_offset_fixed != right_offset ||
		    left_gen != right_gen) {
			ret = 0;
			goto out;
		}

		/*
		 * Go to the next extent.
		 */
		ret = btrfs_next_item(sctx->parent_root, path);
		if (ret < 0)
			goto out;
		if (!ret) {
			eb = path->nodes[0];
			slot = path->slots[0];
			btrfs_item_key_to_cpu(eb, &found_key, slot);
		}
		if (ret || found_key.objectid != key.objectid ||
		    found_key.type != key.type) {
			key.offset += right_len;
			break;
		}
		if (found_key.offset != key.offset + right_len) {
			ret = 0;
			goto out;
		}
		key = found_key;
	}

	/*
	 * We're now behind the left extent (treat as unchanged) or at the end
	 * of the right side (treat as changed).
	 */
	if (key.offset >= ekey->offset + left_len)
		ret = 1;
	else
		ret = 0;


out:
	btrfs_free_path(path);
	return ret;
}

static int get_last_extent(struct send_ctx *sctx, u64 offset)
{
	struct btrfs_path *path;
	struct btrfs_root *root = sctx->send_root;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	u64 extent_end;
	u8 type;
	int ret;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	sctx->cur_inode_last_extent = 0;

	key.objectid = sctx->cur_ino;
	key.type = BTRFS_EXTENT_DATA_KEY;
	key.offset = offset;
	ret = btrfs_search_slot_for_read(root, &key, path, 0, 1);
	if (ret < 0)
		goto out;
	ret = 0;
	btrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);
	if (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)
		goto out;

	fi = btrfs_item_ptr(path->nodes[0], path->slots[0],
			    struct btrfs_file_extent_item);
	type = btrfs_file_extent_type(path->nodes[0], fi);
	if (type == BTRFS_FILE_EXTENT_INLINE) {
		u64 size = btrfs_file_extent_inline_len(path->nodes[0],
							path->slots[0], fi);
		extent_end = ALIGN(key.offset + size,
				   sctx->send_root->sectorsize);
	} else {
		extent_end = key.offset +
			btrfs_file_extent_num_bytes(path->nodes[0], fi);
	}
	sctx->cur_inode_last_extent = extent_end;
out:
	btrfs_free_path(path);
	return ret;
}

static int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,
			   struct btrfs_key *key)
{
	struct btrfs_file_extent_item *fi;
	u64 extent_end;
	u8 type;
	int ret = 0;

	if (sctx->cur_ino != key->objectid || !need_send_hole(sctx))
		return 0;

	if (sctx->cur_inode_last_extent == (u64)-1) {
		ret = get_last_extent(sctx, key->offset - 1);
		if (ret)
			return ret;
	}

	fi = btrfs_item_ptr(path->nodes[0], path->slots[0],
			    struct btrfs_file_extent_item);
	type = btrfs_file_extent_type(path->nodes[0], fi);
	if (type == BTRFS_FILE_EXTENT_INLINE) {
		u64 size = btrfs_file_extent_inline_len(path->nodes[0],
							path->slots[0], fi);
		extent_end = ALIGN(key->offset + size,
				   sctx->send_root->sectorsize);
	} else {
		extent_end = key->offset +
			btrfs_file_extent_num_bytes(path->nodes[0], fi);
	}

	if (path->slots[0] == 0 &&
	    sctx->cur_inode_last_extent < key->offset) {
		/*
		 * We might have skipped entire leafs that contained only
		 * file extent items for our current inode. These leafs have
		 * a generation number smaller (older) than the one in the
		 * current leaf and the leaf our last extent came from, and
		 * are located between these 2 leafs.
		 */
		ret = get_last_extent(sctx, key->offset - 1);
		if (ret)
			return ret;
	}

	if (sctx->cur_inode_last_extent < key->offset)
		ret = send_hole(sctx, key->offset);
	sctx->cur_inode_last_extent = extent_end;
	return ret;
}

static int process_extent(struct send_ctx *sctx,
			  struct btrfs_path *path,
			  struct btrfs_key *key)
{
	struct clone_root *found_clone = NULL;
	int ret = 0;

	if (S_ISLNK(sctx->cur_inode_mode))
		return 0;

	if (sctx->parent_root && !sctx->cur_inode_new) {
		ret = is_extent_unchanged(sctx, path, key);
		if (ret < 0)
			goto out;
		if (ret) {
			ret = 0;
			goto out_hole;
		}
	} else {
		struct btrfs_file_extent_item *ei;
		u8 type;

		ei = btrfs_item_ptr(path->nodes[0], path->slots[0],
				    struct btrfs_file_extent_item);
		type = btrfs_file_extent_type(path->nodes[0], ei);
		if (type == BTRFS_FILE_EXTENT_PREALLOC ||
		    type == BTRFS_FILE_EXTENT_REG) {
			/*
			 * The send spec does not have a prealloc command yet,
			 * so just leave a hole for prealloc'ed extents until
			 * we have enough commands queued up to justify rev'ing
			 * the send spec.
			 */
			if (type == BTRFS_FILE_EXTENT_PREALLOC) {
				ret = 0;
				goto out;
			}

			/* Have a hole, just skip it. */
			if (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {
				ret = 0;
				goto out;
			}
		}
	}

	ret = find_extent_clone(sctx, path, key->objectid, key->offset,
			sctx->cur_inode_size, &found_clone);
	if (ret != -ENOENT && ret < 0)
		goto out;

	ret = send_write_or_clone(sctx, path, key, found_clone);
	if (ret)
		goto out;
out_hole:
	ret = maybe_send_hole(sctx, path, key);
out:
	return ret;
}

static int process_all_extents(struct send_ctx *sctx)
{
	int ret;
	struct btrfs_root *root;
	struct btrfs_path *path;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct extent_buffer *eb;
	int slot;

	root = sctx->send_root;
	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	key.objectid = sctx->cmp_key->objectid;
	key.type = BTRFS_EXTENT_DATA_KEY;
	key.offset = 0;
	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
	if (ret < 0)
		goto out;

	while (1) {
		eb = path->nodes[0];
		slot = path->slots[0];

		if (slot >= btrfs_header_nritems(eb)) {
			ret = btrfs_next_leaf(root, path);
			if (ret < 0) {
				goto out;
			} else if (ret > 0) {
				ret = 0;
				break;
			}
			continue;
		}

		btrfs_item_key_to_cpu(eb, &found_key, slot);

		if (found_key.objectid != key.objectid ||
		    found_key.type != key.type) {
			ret = 0;
			goto out;
		}

		ret = process_extent(sctx, path, &found_key);
		if (ret < 0)
			goto out;

		path->slots[0]++;
	}

out:
	btrfs_free_path(path);
	return ret;
}

static int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,
					   int *pending_move,
					   int *refs_processed)
{
	int ret = 0;

	if (sctx->cur_ino == 0)
		goto out;
	if (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&
	    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)
		goto out;
	if (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))
		goto out;

	ret = process_recorded_refs(sctx, pending_move);
	if (ret < 0)
		goto out;

	*refs_processed = 1;
out:
	return ret;
}

static int finish_inode_if_needed(struct send_ctx *sctx, int at_end)
{
	int ret = 0;
	u64 left_mode;
	u64 left_uid;
	u64 left_gid;
	u64 right_mode;
	u64 right_uid;
	u64 right_gid;
	int need_chmod = 0;
	int need_chown = 0;
	int pending_move = 0;
	int refs_processed = 0;

	ret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,
					      &refs_processed);
	if (ret < 0)
		goto out;

	/*
	 * We have processed the refs and thus need to advance send_progress.
	 * Now, calls to get_cur_xxx will take the updated refs of the current
	 * inode into account.
	 *
	 * On the other hand, if our current inode is a directory and couldn't
	 * be moved/renamed because its parent was renamed/moved too and it has
	 * a higher inode number, we can only move/rename our current inode
	 * after we moved/renamed its parent. Therefore in this case operate on
	 * the old path (pre move/rename) of our current inode, and the
	 * move/rename will be performed later.
	 */
	if (refs_processed && !pending_move)
		sctx->send_progress = sctx->cur_ino + 1;

	if (sctx->cur_ino == 0 || sctx->cur_inode_deleted)
		goto out;
	if (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)
		goto out;

	ret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,
			&left_mode, &left_uid, &left_gid, NULL);
	if (ret < 0)
		goto out;

	if (!sctx->parent_root || sctx->cur_inode_new) {
		need_chown = 1;
		if (!S_ISLNK(sctx->cur_inode_mode))
			need_chmod = 1;
	} else {
		ret = get_inode_info(sctx->parent_root, sctx->cur_ino,
				NULL, NULL, &right_mode, &right_uid,
				&right_gid, NULL);
		if (ret < 0)
			goto out;

		if (left_uid != right_uid || left_gid != right_gid)
			need_chown = 1;
		if (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)
			need_chmod = 1;
	}

	if (S_ISREG(sctx->cur_inode_mode)) {
		if (need_send_hole(sctx)) {
			if (sctx->cur_inode_last_extent == (u64)-1 ||
			    sctx->cur_inode_last_extent <
			    sctx->cur_inode_size) {
				ret = get_last_extent(sctx, (u64)-1);
				if (ret)
					goto out;
			}
			if (sctx->cur_inode_last_extent <
			    sctx->cur_inode_size) {
				ret = send_hole(sctx, sctx->cur_inode_size);
				if (ret)
					goto out;
			}
		}
		ret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,
				sctx->cur_inode_size);
		if (ret < 0)
			goto out;
	}

	if (need_chown) {
		ret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,
				left_uid, left_gid);
		if (ret < 0)
			goto out;
	}
	if (need_chmod) {
		ret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,
				left_mode);
		if (ret < 0)
			goto out;
	}

	/*
	 * If other directory inodes depended on our current directory
	 * inode's move/rename, now do their move/rename operations.
	 */
	if (!is_waiting_for_move(sctx, sctx->cur_ino)) {
		ret = apply_children_dir_moves(sctx);
		if (ret)
			goto out;
		/*
		 * Need to send that every time, no matter if it actually
		 * changed between the two trees as we have done changes to
		 * the inode before. If our inode is a directory and it's
		 * waiting to be moved/renamed, we will send its utimes when
		 * it's moved/renamed, therefore we don't need to do it here.
		 */
		sctx->send_progress = sctx->cur_ino + 1;
		ret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);
		if (ret < 0)
			goto out;
	}

out:
	return ret;
}

static int changed_inode(struct send_ctx *sctx,
			 enum btrfs_compare_tree_result result)
{
	int ret = 0;
	struct btrfs_key *key = sctx->cmp_key;
	struct btrfs_inode_item *left_ii = NULL;
	struct btrfs_inode_item *right_ii = NULL;
	u64 left_gen = 0;
	u64 right_gen = 0;

	sctx->cur_ino = key->objectid;
	sctx->cur_inode_new_gen = 0;
	sctx->cur_inode_last_extent = (u64)-1;

	/*
	 * Set send_progress to current inode. This will tell all get_cur_xxx
	 * functions that the current inode's refs are not updated yet. Later,
	 * when process_recorded_refs is finished, it is set to cur_ino + 1.
	 */
	sctx->send_progress = sctx->cur_ino;

	if (result == BTRFS_COMPARE_TREE_NEW ||
	    result == BTRFS_COMPARE_TREE_CHANGED) {
		left_ii = btrfs_item_ptr(sctx->left_path->nodes[0],
				sctx->left_path->slots[0],
				struct btrfs_inode_item);
		left_gen = btrfs_inode_generation(sctx->left_path->nodes[0],
				left_ii);
	} else {
		right_ii = btrfs_item_ptr(sctx->right_path->nodes[0],
				sctx->right_path->slots[0],
				struct btrfs_inode_item);
		right_gen = btrfs_inode_generation(sctx->right_path->nodes[0],
				right_ii);
	}
	if (result == BTRFS_COMPARE_TREE_CHANGED) {
		right_ii = btrfs_item_ptr(sctx->right_path->nodes[0],
				sctx->right_path->slots[0],
				struct btrfs_inode_item);

		right_gen = btrfs_inode_generation(sctx->right_path->nodes[0],
				right_ii);

		/*
		 * The cur_ino = root dir case is special here. We can't treat
		 * the inode as deleted+reused because it would generate a
		 * stream that tries to delete/mkdir the root dir.
		 */
		if (left_gen != right_gen &&
		    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)
			sctx->cur_inode_new_gen = 1;
	}

	if (result == BTRFS_COMPARE_TREE_NEW) {
		sctx->cur_inode_gen = left_gen;
		sctx->cur_inode_new = 1;
		sctx->cur_inode_deleted = 0;
		sctx->cur_inode_size = btrfs_inode_size(
				sctx->left_path->nodes[0], left_ii);
		sctx->cur_inode_mode = btrfs_inode_mode(
				sctx->left_path->nodes[0], left_ii);
		sctx->cur_inode_rdev = btrfs_inode_rdev(
				sctx->left_path->nodes[0], left_ii);
		if (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)
			ret = send_create_inode_if_needed(sctx);
	} else if (result == BTRFS_COMPARE_TREE_DELETED) {
		sctx->cur_inode_gen = right_gen;
		sctx->cur_inode_new = 0;
		sctx->cur_inode_deleted = 1;
		sctx->cur_inode_size = btrfs_inode_size(
				sctx->right_path->nodes[0], right_ii);
		sctx->cur_inode_mode = btrfs_inode_mode(
				sctx->right_path->nodes[0], right_ii);
	} else if (result == BTRFS_COMPARE_TREE_CHANGED) {
		/*
		 * We need to do some special handling in case the inode was
		 * reported as changed with a changed generation number. This
		 * means that the original inode was deleted and new inode
		 * reused the same inum. So we have to treat the old inode as
		 * deleted and the new one as new.
		 */
		if (sctx->cur_inode_new_gen) {
			/*
			 * First, process the inode as if it was deleted.
			 */
			sctx->cur_inode_gen = right_gen;
			sctx->cur_inode_new = 0;
			sctx->cur_inode_deleted = 1;
			sctx->cur_inode_size = btrfs_inode_size(
					sctx->right_path->nodes[0], right_ii);
			sctx->cur_inode_mode = btrfs_inode_mode(
					sctx->right_path->nodes[0], right_ii);
			ret = process_all_refs(sctx,
					BTRFS_COMPARE_TREE_DELETED);
			if (ret < 0)
				goto out;

			/*
			 * Now process the inode as if it was new.
			 */
			sctx->cur_inode_gen = left_gen;
			sctx->cur_inode_new = 1;
			sctx->cur_inode_deleted = 0;
			sctx->cur_inode_size = btrfs_inode_size(
					sctx->left_path->nodes[0], left_ii);
			sctx->cur_inode_mode = btrfs_inode_mode(
					sctx->left_path->nodes[0], left_ii);
			sctx->cur_inode_rdev = btrfs_inode_rdev(
					sctx->left_path->nodes[0], left_ii);
			ret = send_create_inode_if_needed(sctx);
			if (ret < 0)
				goto out;

			ret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);
			if (ret < 0)
				goto out;
			/*
			 * Advance send_progress now as we did not get into
			 * process_recorded_refs_if_needed in the new_gen case.
			 */
			sctx->send_progress = sctx->cur_ino + 1;

			/*
			 * Now process all extents and xattrs of the inode as if
			 * they were all new.
			 */
			ret = process_all_extents(sctx);
			if (ret < 0)
				goto out;
			ret = process_all_new_xattrs(sctx);
			if (ret < 0)
				goto out;
		} else {
			sctx->cur_inode_gen = left_gen;
			sctx->cur_inode_new = 0;
			sctx->cur_inode_new_gen = 0;
			sctx->cur_inode_deleted = 0;
			sctx->cur_inode_size = btrfs_inode_size(
					sctx->left_path->nodes[0], left_ii);
			sctx->cur_inode_mode = btrfs_inode_mode(
					sctx->left_path->nodes[0], left_ii);
		}
	}

out:
	return ret;
}

/*
 * We have to process new refs before deleted refs, but compare_trees gives us
 * the new and deleted refs mixed. To fix this, we record the new/deleted refs
 * first and later process them in process_recorded_refs.
 * For the cur_inode_new_gen case, we skip recording completely because
 * changed_inode did already initiate processing of refs. The reason for this is
 * that in this case, compare_tree actually compares the refs of 2 different
 * inodes. To fix this, process_all_refs is used in changed_inode to handle all
 * refs of the right tree as deleted and all refs of the left tree as new.
 */
static int changed_ref(struct send_ctx *sctx,
		       enum btrfs_compare_tree_result result)
{
	int ret = 0;

	BUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);

	if (!sctx->cur_inode_new_gen &&
	    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {
		if (result == BTRFS_COMPARE_TREE_NEW)
			ret = record_new_ref(sctx);
		else if (result == BTRFS_COMPARE_TREE_DELETED)
			ret = record_deleted_ref(sctx);
		else if (result == BTRFS_COMPARE_TREE_CHANGED)
			ret = record_changed_ref(sctx);
	}

	return ret;
}

/*
 * Process new/deleted/changed xattrs. We skip processing in the
 * cur_inode_new_gen case because changed_inode did already initiate processing
 * of xattrs. The reason is the same as in changed_ref
 */
static int changed_xattr(struct send_ctx *sctx,
			 enum btrfs_compare_tree_result result)
{
	int ret = 0;

	BUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);

	if (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {
		if (result == BTRFS_COMPARE_TREE_NEW)
			ret = process_new_xattr(sctx);
		else if (result == BTRFS_COMPARE_TREE_DELETED)
			ret = process_deleted_xattr(sctx);
		else if (result == BTRFS_COMPARE_TREE_CHANGED)
			ret = process_changed_xattr(sctx);
	}

	return ret;
}

/*
 * Process new/deleted/changed extents. We skip processing in the
 * cur_inode_new_gen case because changed_inode did already initiate processing
 * of extents. The reason is the same as in changed_ref
 */
static int changed_extent(struct send_ctx *sctx,
			  enum btrfs_compare_tree_result result)
{
	int ret = 0;

	BUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);

	if (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {
		if (result != BTRFS_COMPARE_TREE_DELETED)
			ret = process_extent(sctx, sctx->left_path,
					sctx->cmp_key);
	}

	return ret;
}

static int dir_changed(struct send_ctx *sctx, u64 dir)
{
	u64 orig_gen, new_gen;
	int ret;

	ret = get_inode_info(sctx->send_root, dir, NULL, &new_gen, NULL, NULL,
			     NULL, NULL);
	if (ret)
		return ret;

	ret = get_inode_info(sctx->parent_root, dir, NULL, &orig_gen, NULL,
			     NULL, NULL, NULL);
	if (ret)
		return ret;

	return (orig_gen != new_gen) ? 1 : 0;
}

static int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,
			struct btrfs_key *key)
{
	struct btrfs_inode_extref *extref;
	struct extent_buffer *leaf;
	u64 dirid = 0, last_dirid = 0;
	unsigned long ptr;
	u32 item_size;
	u32 cur_offset = 0;
	int ref_name_len;
	int ret = 0;

	/* Easy case, just check this one dirid */
	if (key->type == BTRFS_INODE_REF_KEY) {
		dirid = key->offset;

		ret = dir_changed(sctx, dirid);
		goto out;
	}

	leaf = path->nodes[0];
	item_size = btrfs_item_size_nr(leaf, path->slots[0]);
	ptr = btrfs_item_ptr_offset(leaf, path->slots[0]);
	while (cur_offset < item_size) {
		extref = (struct btrfs_inode_extref *)(ptr +
						       cur_offset);
		dirid = btrfs_inode_extref_parent(leaf, extref);
		ref_name_len = btrfs_inode_extref_name_len(leaf, extref);
		cur_offset += ref_name_len + sizeof(*extref);
		if (dirid == last_dirid)
			continue;
		ret = dir_changed(sctx, dirid);
		if (ret)
			break;
		last_dirid = dirid;
	}
out:
	return ret;
}

/*
 * Updates compare related fields in sctx and simply forwards to the actual
 * changed_xxx functions.
 */
static int changed_cb(struct btrfs_root *left_root,
		      struct btrfs_root *right_root,
		      struct btrfs_path *left_path,
		      struct btrfs_path *right_path,
		      struct btrfs_key *key,
		      enum btrfs_compare_tree_result result,
		      void *ctx)
{
	int ret = 0;
	struct send_ctx *sctx = ctx;

	if (result == BTRFS_COMPARE_TREE_SAME) {
		if (key->type == BTRFS_INODE_REF_KEY ||
		    key->type == BTRFS_INODE_EXTREF_KEY) {
			ret = compare_refs(sctx, left_path, key);
			if (!ret)
				return 0;
			if (ret < 0)
				return ret;
		} else if (key->type == BTRFS_EXTENT_DATA_KEY) {
			return maybe_send_hole(sctx, left_path, key);
		} else {
			return 0;
		}
		result = BTRFS_COMPARE_TREE_CHANGED;
		ret = 0;
	}

	sctx->left_path = left_path;
	sctx->right_path = right_path;
	sctx->cmp_key = key;

	ret = finish_inode_if_needed(sctx, 0);
	if (ret < 0)
		goto out;

	/* Ignore non-FS objects */
	if (key->objectid == BTRFS_FREE_INO_OBJECTID ||
	    key->objectid == BTRFS_FREE_SPACE_OBJECTID)
		goto out;

	if (key->type == BTRFS_INODE_ITEM_KEY)
		ret = changed_inode(sctx, result);
	else if (key->type == BTRFS_INODE_REF_KEY ||
		 key->type == BTRFS_INODE_EXTREF_KEY)
		ret = changed_ref(sctx, result);
	else if (key->type == BTRFS_XATTR_ITEM_KEY)
		ret = changed_xattr(sctx, result);
	else if (key->type == BTRFS_EXTENT_DATA_KEY)
		ret = changed_extent(sctx, result);

out:
	return ret;
}

static int full_send_tree(struct send_ctx *sctx)
{
	int ret;
	struct btrfs_root *send_root = sctx->send_root;
	struct btrfs_key key;
	struct btrfs_key found_key;
	struct btrfs_path *path;
	struct extent_buffer *eb;
	int slot;

	path = alloc_path_for_send();
	if (!path)
		return -ENOMEM;

	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
	key.type = BTRFS_INODE_ITEM_KEY;
	key.offset = 0;

	ret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);
	if (ret < 0)
		goto out;
	if (ret)
		goto out_finish;

	while (1) {
		eb = path->nodes[0];
		slot = path->slots[0];
		btrfs_item_key_to_cpu(eb, &found_key, slot);

		ret = changed_cb(send_root, NULL, path, NULL,
				&found_key, BTRFS_COMPARE_TREE_NEW, sctx);
		if (ret < 0)
			goto out;

		key.objectid = found_key.objectid;
		key.type = found_key.type;
		key.offset = found_key.offset + 1;

		ret = btrfs_next_item(send_root, path);
		if (ret < 0)
			goto out;
		if (ret) {
			ret  = 0;
			break;
		}
	}

out_finish:
	ret = finish_inode_if_needed(sctx, 1);

out:
	btrfs_free_path(path);
	return ret;
}

static int send_subvol(struct send_ctx *sctx)
{
	int ret;

	if (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {
		ret = send_header(sctx);
		if (ret < 0)
			goto out;
	}

	ret = send_subvol_begin(sctx);
	if (ret < 0)
		goto out;

	if (sctx->parent_root) {
		ret = btrfs_compare_trees(sctx->send_root, sctx->parent_root,
				changed_cb, sctx);
		if (ret < 0)
			goto out;
		ret = finish_inode_if_needed(sctx, 1);
		if (ret < 0)
			goto out;
	} else {
		ret = full_send_tree(sctx);
		if (ret < 0)
			goto out;
	}

out:
	free_recorded_refs(sctx);
	return ret;
}

static void btrfs_root_dec_send_in_progress(struct btrfs_root* root)
{
	spin_lock(&root->root_item_lock);
	root->send_in_progress--;
	/*
	 * Not much left to do, we don't know why it's unbalanced and
	 * can't blindly reset it to 0.
	 */
	if (root->send_in_progress < 0)
		btrfs_err(root->fs_info,
			"send_in_progres unbalanced %d root %llu",
			root->send_in_progress, root->root_key.objectid);
	spin_unlock(&root->root_item_lock);
}

long btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)
{
	int ret = 0;
	struct btrfs_root *send_root;
	struct btrfs_root *clone_root;
	struct btrfs_fs_info *fs_info;
	struct btrfs_ioctl_send_args *arg = NULL;
	struct btrfs_key key;
	struct send_ctx *sctx = NULL;
	u32 i;
	u64 *clone_sources_tmp = NULL;
	int clone_sources_to_rollback = 0;
	int sort_clone_roots = 0;
	int index;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	send_root = BTRFS_I(file_inode(mnt_file))->root;
	fs_info = send_root->fs_info;

	/*
	 * The subvolume must remain read-only during send, protect against
	 * making it RW. This also protects against deletion.
	 */
	spin_lock(&send_root->root_item_lock);
	send_root->send_in_progress++;
	spin_unlock(&send_root->root_item_lock);

	/*
	 * This is done when we lookup the root, it should already be complete
	 * by the time we get here.
	 */
	WARN_ON(send_root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE);

	/*
	 * Userspace tools do the checks and warn the user if it's
	 * not RO.
	 */
	if (!btrfs_root_readonly(send_root)) {
		ret = -EPERM;
		goto out;
	}

	arg = memdup_user(arg_, sizeof(*arg));
	if (IS_ERR(arg)) {
		ret = PTR_ERR(arg);
		arg = NULL;
		goto out;
	}

	if (!access_ok(VERIFY_READ, arg->clone_sources,
			sizeof(*arg->clone_sources) *
			arg->clone_sources_count)) {
		ret = -EFAULT;
		goto out;
	}

	if (arg->flags & ~BTRFS_SEND_FLAG_MASK) {
		ret = -EINVAL;
		goto out;
	}

	sctx = kzalloc(sizeof(struct send_ctx), GFP_NOFS);
	if (!sctx) {
		ret = -ENOMEM;
		goto out;
	}

	INIT_LIST_HEAD(&sctx->new_refs);
	INIT_LIST_HEAD(&sctx->deleted_refs);
	INIT_RADIX_TREE(&sctx->name_cache, GFP_NOFS);
	INIT_LIST_HEAD(&sctx->name_cache_list);

	sctx->flags = arg->flags;

	sctx->send_filp = fget(arg->send_fd);
	if (!sctx->send_filp) {
		ret = -EBADF;
		goto out;
	}

	sctx->send_root = send_root;
	/*
	 * Unlikely but possible, if the subvolume is marked for deletion but
	 * is slow to remove the directory entry, send can still be started
	 */
	if (btrfs_root_dead(sctx->send_root)) {
		ret = -EPERM;
		goto out;
	}

	sctx->clone_roots_cnt = arg->clone_sources_count;

	sctx->send_max_size = BTRFS_SEND_BUF_SIZE;
	sctx->send_buf = vmalloc(sctx->send_max_size);
	if (!sctx->send_buf) {
		ret = -ENOMEM;
		goto out;
	}

	sctx->read_buf = vmalloc(BTRFS_SEND_READ_SIZE);
	if (!sctx->read_buf) {
		ret = -ENOMEM;
		goto out;
	}

	sctx->pending_dir_moves = RB_ROOT;
	sctx->waiting_dir_moves = RB_ROOT;
	sctx->orphan_dirs = RB_ROOT;

	sctx->clone_roots = vzalloc(sizeof(struct clone_root) *
			(arg->clone_sources_count + 1));
	if (!sctx->clone_roots) {
		ret = -ENOMEM;
		goto out;
	}

	if (arg->clone_sources_count) {
		clone_sources_tmp = vmalloc(arg->clone_sources_count *
				sizeof(*arg->clone_sources));
		if (!clone_sources_tmp) {
			ret = -ENOMEM;
			goto out;
		}

		ret = copy_from_user(clone_sources_tmp, arg->clone_sources,
				arg->clone_sources_count *
				sizeof(*arg->clone_sources));
		if (ret) {
			ret = -EFAULT;
			goto out;
		}

		for (i = 0; i < arg->clone_sources_count; i++) {
			key.objectid = clone_sources_tmp[i];
			key.type = BTRFS_ROOT_ITEM_KEY;
			key.offset = (u64)-1;

			index = srcu_read_lock(&fs_info->subvol_srcu);

			clone_root = btrfs_read_fs_root_no_name(fs_info, &key);
			if (IS_ERR(clone_root)) {
				srcu_read_unlock(&fs_info->subvol_srcu, index);
				ret = PTR_ERR(clone_root);
				goto out;
			}
			clone_sources_to_rollback = i + 1;
			spin_lock(&clone_root->root_item_lock);
			clone_root->send_in_progress++;
			if (!btrfs_root_readonly(clone_root)) {
				spin_unlock(&clone_root->root_item_lock);
				srcu_read_unlock(&fs_info->subvol_srcu, index);
				ret = -EPERM;
				goto out;
			}
			spin_unlock(&clone_root->root_item_lock);
			srcu_read_unlock(&fs_info->subvol_srcu, index);

			sctx->clone_roots[i].root = clone_root;
		}
		vfree(clone_sources_tmp);
		clone_sources_tmp = NULL;
	}

	if (arg->parent_root) {
		key.objectid = arg->parent_root;
		key.type = BTRFS_ROOT_ITEM_KEY;
		key.offset = (u64)-1;

		index = srcu_read_lock(&fs_info->subvol_srcu);

		sctx->parent_root = btrfs_read_fs_root_no_name(fs_info, &key);
		if (IS_ERR(sctx->parent_root)) {
			srcu_read_unlock(&fs_info->subvol_srcu, index);
			ret = PTR_ERR(sctx->parent_root);
			goto out;
		}

		spin_lock(&sctx->parent_root->root_item_lock);
		sctx->parent_root->send_in_progress++;
		if (!btrfs_root_readonly(sctx->parent_root) ||
				btrfs_root_dead(sctx->parent_root)) {
			spin_unlock(&sctx->parent_root->root_item_lock);
			srcu_read_unlock(&fs_info->subvol_srcu, index);
			ret = -EPERM;
			goto out;
		}
		spin_unlock(&sctx->parent_root->root_item_lock);

		srcu_read_unlock(&fs_info->subvol_srcu, index);
	}

	/*
	 * Clones from send_root are allowed, but only if the clone source
	 * is behind the current send position. This is checked while searching
	 * for possible clone sources.
	 */
	sctx->clone_roots[sctx->clone_roots_cnt++].root = sctx->send_root;

	/* We do a bsearch later */
	sort(sctx->clone_roots, sctx->clone_roots_cnt,
			sizeof(*sctx->clone_roots), __clone_root_cmp_sort,
			NULL);
	sort_clone_roots = 1;

	current->journal_info = BTRFS_SEND_TRANS_STUB;
	ret = send_subvol(sctx);
	current->journal_info = NULL;
	if (ret < 0)
		goto out;

	if (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {
		ret = begin_cmd(sctx, BTRFS_SEND_C_END);
		if (ret < 0)
			goto out;
		ret = send_cmd(sctx);
		if (ret < 0)
			goto out;
	}

out:
	WARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));
	while (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {
		struct rb_node *n;
		struct pending_dir_move *pm;

		n = rb_first(&sctx->pending_dir_moves);
		pm = rb_entry(n, struct pending_dir_move, node);
		while (!list_empty(&pm->list)) {
			struct pending_dir_move *pm2;

			pm2 = list_first_entry(&pm->list,
					       struct pending_dir_move, list);
			free_pending_move(sctx, pm2);
		}
		free_pending_move(sctx, pm);
	}

	WARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));
	while (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {
		struct rb_node *n;
		struct waiting_dir_move *dm;

		n = rb_first(&sctx->waiting_dir_moves);
		dm = rb_entry(n, struct waiting_dir_move, node);
		rb_erase(&dm->node, &sctx->waiting_dir_moves);
		kfree(dm);
	}

	WARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));
	while (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {
		struct rb_node *n;
		struct orphan_dir_info *odi;

		n = rb_first(&sctx->orphan_dirs);
		odi = rb_entry(n, struct orphan_dir_info, node);
		free_orphan_dir_info(sctx, odi);
	}

	if (sort_clone_roots) {
		for (i = 0; i < sctx->clone_roots_cnt; i++)
			btrfs_root_dec_send_in_progress(
					sctx->clone_roots[i].root);
	} else {
		for (i = 0; sctx && i < clone_sources_to_rollback; i++)
			btrfs_root_dec_send_in_progress(
					sctx->clone_roots[i].root);

		btrfs_root_dec_send_in_progress(send_root);
	}
	if (sctx && !IS_ERR_OR_NULL(sctx->parent_root))
		btrfs_root_dec_send_in_progress(sctx->parent_root);

	kfree(arg);
	vfree(clone_sources_tmp);

	if (sctx) {
		if (sctx->send_filp)
			fput(sctx->send_filp);

		vfree(sctx->clone_roots);
		vfree(sctx->send_buf);
		vfree(sctx->read_buf);

		name_cache_free(sctx);

		kfree(sctx);
	}

	return ret;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _LINUX_MMAN_H
#define _LINUX_MMAN_H

#include <linux/mm.h>
#include <linux/percpu_counter.h>

#include <linux/atomic.h>
#include <uapi/linux/mman.h>

extern int sysctl_overcommit_memory;
extern int sysctl_overcommit_ratio;
extern unsigned long sysctl_overcommit_kbytes;
extern struct percpu_counter vm_committed_as;

#ifdef CONFIG_SMP
extern s32 vm_committed_as_batch;
#else
#define vm_committed_as_batch 0
#endif

unsigned long vm_memory_committed(void);

static inline void vm_acct_memory(long pages)
{
	__percpu_counter_add(&vm_committed_as, pages, vm_committed_as_batch);
}

static inline void vm_unacct_memory(long pages)
{
	vm_acct_memory(-pages);
}

/*
 * Allow architectures to handle additional protection bits
 */

#ifndef arch_calc_vm_prot_bits
#define arch_calc_vm_prot_bits(prot) 0
#endif

#ifndef arch_vm_get_page_prot
#define arch_vm_get_page_prot(vm_flags) __pgprot(0)
#endif

#ifndef arch_validate_prot
/*
 * This is called from mprotect().  PROT_GROWSDOWN and PROT_GROWSUP have
 * already been masked out.
 *
 * Returns true if the prot flags are valid
 */
static inline int arch_validate_prot(unsigned long prot)
{
	return (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM)) == 0;
}
#define arch_validate_prot arch_validate_prot
#endif

/*
 * Optimisation macro.  It is equivalent to:
 *      (x & bit1) ? bit2 : 0
 * but this version is faster.
 * ("bit1" and "bit2" must be single bits)
 */
#define _calc_vm_trans(x, bit1, bit2) \
  ((!(bit1) || !(bit2)) ? 0 : \
  ((bit1) <= (bit2) ? ((x) & (bit1)) * ((bit2) / (bit1)) \
   : ((x) & (bit1)) / ((bit1) / (bit2))))

/*
 * Combine the mmap "prot" argument into "vm_flags" used internally.
 */
static inline unsigned long
calc_vm_prot_bits(unsigned long prot)
{
	return _calc_vm_trans(prot, PROT_READ,  VM_READ ) |
	       _calc_vm_trans(prot, PROT_WRITE, VM_WRITE) |
	       _calc_vm_trans(prot, PROT_EXEC,  VM_EXEC) |
	       arch_calc_vm_prot_bits(prot);
}

/*
 * Combine the mmap "flags" argument into "vm_flags" used internally.
 */
static inline unsigned long
calc_vm_flag_bits(unsigned long flags)
{
	return _calc_vm_trans(flags, MAP_GROWSDOWN,  VM_GROWSDOWN ) |
	       _calc_vm_trans(flags, MAP_DENYWRITE,  VM_DENYWRITE ) |
	       _calc_vm_trans(flags, MAP_LOCKED,     VM_LOCKED    );
}

unsigned long vm_commit_limit(void);
#endif /* _LINUX_MMAN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef _SCSI_SCSI_DEVICE_H
#define _SCSI_SCSI_DEVICE_H

#include <linux/list.h>
#include <linux/spinlock.h>
#include <linux/workqueue.h>
#include <linux/blkdev.h>
#include <scsi/scsi.h>
#include <linux/atomic.h>

struct device;
struct request_queue;
struct scsi_cmnd;
struct scsi_lun;
struct scsi_sense_hdr;

struct scsi_mode_data {
	__u32	length;
	__u16	block_descriptor_length;
	__u8	medium_type;
	__u8	device_specific;
	__u8	header_length;
	__u8	longlba:1;
};

/*
 * sdev state: If you alter this, you also need to alter scsi_sysfs.c
 * (for the ascii descriptions) and the state model enforcer:
 * scsi_lib:scsi_device_set_state().
 */
enum scsi_device_state {
	SDEV_CREATED = 1,	/* device created but not added to sysfs
				 * Only internal commands allowed (for inq) */
	SDEV_RUNNING,		/* device properly configured
				 * All commands allowed */
	SDEV_CANCEL,		/* beginning to delete device
				 * Only error handler commands allowed */
	SDEV_DEL,		/* device deleted 
				 * no commands allowed */
	SDEV_QUIESCE,		/* Device quiescent.  No block commands
				 * will be accepted, only specials (which
				 * originate in the mid-layer) */
	SDEV_OFFLINE,		/* Device offlined (by error handling or
				 * user request */
	SDEV_TRANSPORT_OFFLINE,	/* Offlined by transport class error handler */
	SDEV_BLOCK,		/* Device blocked by scsi lld.  No
				 * scsi commands from user or midlayer
				 * should be issued to the scsi
				 * lld. */
	SDEV_CREATED_BLOCK,	/* same as above but for created devices */
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE	= 1,	/* media has changed */
	SDEV_EVT_INQUIRY_CHANGE_REPORTED,		/* 3F 03  UA reported */
	SDEV_EVT_CAPACITY_CHANGE_REPORTED,		/* 2A 09  UA reported */
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED,	/* 38 07  UA reported */
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED,	/* 2A 01  UA reported */
	SDEV_EVT_LUN_CHANGE_REPORTED,			/* 3F 0E  UA reported */

	SDEV_EVT_FIRST		= SDEV_EVT_MEDIA_CHANGE,
	SDEV_EVT_LAST		= SDEV_EVT_LUN_CHANGE_REPORTED,

	SDEV_EVT_MAXBITS	= SDEV_EVT_LAST + 1
};

struct scsi_event {
	enum scsi_device_event	evt_type;
	struct list_head	node;

	/* put union of data structures, for non-simple event types,
	 * here
	 */
};

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;

	/* the next two are protected by the host->host_lock */
	struct list_head    siblings;   /* list of all devices on this host */
	struct list_head    same_target_siblings; /* just the devices sharing same target id */

	atomic_t device_busy;		/* commands actually active on LLDD */
	atomic_t device_blocked;	/* Device returned QUEUE_FULL. */

	spinlock_t list_lock;
	struct list_head cmd_list;	/* queue of in use SCSI Command structures */
	struct list_head starved_entry;
	struct scsi_cmnd *current_cmnd;	/* currently active command */
	unsigned short queue_depth;	/* How deep of a queue we want */
	unsigned short max_queue_depth;	/* max queue depth */
	unsigned short last_queue_full_depth; /* These two are used by */
	unsigned short last_queue_full_count; /* scsi_track_queue_full() */
	unsigned long last_queue_full_time;	/* last queue full time */
	unsigned long queue_ramp_up_period;	/* ramp up period in jiffies */
#define SCSI_DEFAULT_RAMP_UP_PERIOD	(120 * HZ)

	unsigned long last_queue_ramp_up;	/* last queue ramp up time */

	unsigned int id, channel;
	u64 lun;
	unsigned int manufacturer;	/* Manufacturer of device, for using 
					 * vendor-specific cmd's */
	unsigned sector_size;	/* size in bytes */

	void *hostdata;		/* available to low-level driver */
	char type;
	char scsi_level;
	char inq_periph_qual;	/* PQ from INQUIRY data */	
	unsigned char inquiry_len;	/* valid bytes in 'inquiry' */
	unsigned char * inquiry;	/* INQUIRY response data */
	const char * vendor;		/* [back_compat] point into 'inquiry' ... */
	const char * model;		/* ... after scan; point to static string */
	const char * rev;		/* ... "nullnullnullnull" before scan */

#define SCSI_VPD_PG_LEN                255
	int vpd_pg83_len;
	unsigned char *vpd_pg83;
	int vpd_pg80_len;
	unsigned char *vpd_pg80;
	unsigned char current_tag;	/* current tag */
	struct scsi_target      *sdev_target;   /* used only for single_lun */

	unsigned int	sdev_bflags; /* black/white flags as also found in
				 * scsi_devinfo.[hc]. For now used only to
				 * pass settings from slave_alloc to scsi
				 * core. */
	unsigned int eh_timeout; /* Error handling timeout */
	unsigned removable:1;
	unsigned changed:1;	/* Data invalid due to media change */
	unsigned busy:1;	/* Used to prevent races */
	unsigned lockable:1;	/* Able to prevent media removal */
	unsigned locked:1;      /* Media removal disabled */
	unsigned borken:1;	/* Tell the Seagate driver to be 
				 * painfully slow on this device */
	unsigned disconnect:1;	/* can disconnect */
	unsigned soft_reset:1;	/* Uses soft reset option */
	unsigned sdtr:1;	/* Device supports SDTR messages */
	unsigned wdtr:1;	/* Device supports WDTR messages */
	unsigned ppr:1;		/* Device supports PPR messages */
	unsigned tagged_supported:1;	/* Supports SCSI-II tagged queuing */
	unsigned simple_tags:1;	/* simple queue tag messages are enabled */
	unsigned ordered_tags:1;/* ordered queue tag messages are enabled */
	unsigned was_reset:1;	/* There was a bus reset on the bus for 
				 * this device */
	unsigned expecting_cc_ua:1; /* Expecting a CHECK_CONDITION/UNIT_ATTN
				     * because we did a bus reset. */
	unsigned use_10_for_rw:1; /* first try 10-byte read / write */
	unsigned use_10_for_ms:1; /* first try 10-byte mode sense/select */
	unsigned no_report_opcodes:1;	/* no REPORT SUPPORTED OPERATION CODES */
	unsigned no_write_same:1;	/* no WRITE SAME command */
	unsigned use_16_for_rw:1; /* Use read/write(16) over read/write(10) */
	unsigned skip_ms_page_8:1;	/* do not use MODE SENSE page 0x08 */
	unsigned skip_ms_page_3f:1;	/* do not use MODE SENSE page 0x3f */
	unsigned skip_vpd_pages:1;	/* do not read VPD pages */
	unsigned try_vpd_pages:1;	/* attempt to read VPD pages */
	unsigned use_192_bytes_for_3f:1; /* ask for 192 bytes from page 0x3f */
	unsigned no_start_on_add:1;	/* do not issue start on add */
	unsigned allow_restart:1; /* issue START_UNIT in error handler */
	unsigned manage_start_stop:1;	/* Let HLD (sd) manage start/stop */
	unsigned start_stop_pwr_cond:1;	/* Set power cond. in START_STOP_UNIT */
	unsigned no_uld_attach:1; /* disable connecting to upper level drivers */
	unsigned select_no_atn:1;
	unsigned fix_capacity:1;	/* READ_CAPACITY is too high by 1 */
	unsigned guess_capacity:1;	/* READ_CAPACITY might be too high by 1 */
	unsigned retry_hwerror:1;	/* Retry HARDWARE_ERROR */
	unsigned last_sector_bug:1;	/* do not use multisector accesses on
					   SD_LAST_BUGGY_SECTORS */
	unsigned no_read_disc_info:1;	/* Avoid READ_DISC_INFO cmds */
	unsigned no_read_capacity_16:1; /* Avoid READ_CAPACITY_16 cmds */
	unsigned try_rc_10_first:1;	/* Try READ_CAPACACITY_10 first */
	unsigned is_visible:1;	/* is the device visible in sysfs */
	unsigned wce_default_on:1;	/* Cache is ON by default */
	unsigned no_dif:1;	/* T10 PI (DIF) should be disabled */
	unsigned broken_fua:1;		/* Don't set FUA bit */
	unsigned lun_in_cdb:1;		/* Store LUN bits in CDB[1] */

	atomic_t disk_events_disable_depth; /* disable depth for disk events */

	DECLARE_BITMAP(supported_events, SDEV_EVT_MAXBITS); /* supported events */
	DECLARE_BITMAP(pending_events, SDEV_EVT_MAXBITS); /* pending events */
	struct list_head event_list;	/* asserted events */
	struct work_struct event_work;

	unsigned int max_device_blocked; /* what device_blocked counts down from  */
#define SCSI_DEFAULT_DEVICE_BLOCKED	3

	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;

	struct device		sdev_gendev,
				sdev_dev;

	struct execute_work	ew; /* used to get process context on put */
	struct work_struct	requeue_work;

	struct scsi_dh_data	*scsi_dh_data;
	enum scsi_device_state sdev_state;
	unsigned long		sdev_data[0];
} __attribute__((aligned(sizeof(unsigned long))));

struct scsi_dh_devlist {
	char *vendor;
	char *model;
};

typedef void (*activate_complete)(void *, int);
struct scsi_device_handler {
	/* Used by the infrastructure */
	struct list_head list; /* list of scsi_device_handlers */

	/* Filled by the hardware handler */
	struct module *module;
	const char *name;
	const struct scsi_dh_devlist *devlist;
	int (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	int (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	bool (*match)(struct scsi_device *);
};

struct scsi_dh_data {
	struct scsi_device_handler *scsi_dh;
	struct scsi_device *sdev;
	struct kref kref;
	char buf[0];
};

#define	to_scsi_device(d)	\
	container_of(d, struct scsi_device, sdev_gendev)
#define	class_to_sdev(d)	\
	container_of(d, struct scsi_device, sdev_dev)
#define transport_class_to_sdev(class_dev) \
	to_scsi_device(class_dev->parent)

#define sdev_printk(prefix, sdev, fmt, a...)	\
	dev_printk(prefix, &(sdev)->sdev_gendev, fmt, ##a)

#define sdev_dbg(sdev, fmt, a...) \
	dev_dbg(&(sdev)->sdev_gendev, fmt, ##a)

#define scmd_printk(prefix, scmd, fmt, a...)				\
        (scmd)->request->rq_disk ?					\
	sdev_printk(prefix, (scmd)->device, "[%s] " fmt,		\
		    (scmd)->request->rq_disk->disk_name, ##a) :		\
	sdev_printk(prefix, (scmd)->device, fmt, ##a)

#define scmd_dbg(scmd, fmt, a...)					   \
	do {								   \
		if ((scmd)->request->rq_disk)				   \
			sdev_dbg((scmd)->device, "[%s] " fmt,		   \
				 (scmd)->request->rq_disk->disk_name, ##a);\
		else							   \
			sdev_dbg((scmd)->device, fmt, ##a);		   \
	} while (0)

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING,
	STARGET_DEL,
};

/*
 * scsi_target: representation of a scsi target, for now, this is only
 * used for single_lun devices. If no one has active IO to the target,
 * starget_sdev_user is NULL, else it points to the active sdev.
 */
struct scsi_target {
	struct scsi_device	*starget_sdev_user;
	struct list_head	siblings;
	struct list_head	devices;
	struct device		dev;
	struct kref		reap_ref; /* last put renders target invisible */
	unsigned int		channel;
	unsigned int		id; /* target id ... replace
				     * scsi_device.id eventually */
	unsigned int		create:1; /* signal that it needs to be added */
	unsigned int		single_lun:1;	/* Indicates we should only
						 * allow I/O to one of the luns
						 * for the device at a time. */
	unsigned int		pdt_1f_for_no_lun:1;	/* PDT = 0x1f
						 * means no lun present. */
	unsigned int		no_report_luns:1;	/* Don't use
						 * REPORT LUNS for scanning. */
	unsigned int		expecting_lun_change:1;	/* A device has reported
						 * a 3F/0E UA, other devices on
						 * the same target will also. */
	/* commands actually active on LLD. */
	atomic_t		target_busy;
	atomic_t		target_blocked;

	/*
	 * LLDs should set this in the slave_alloc host template callout.
	 * If set to zero then there is not limit.
	 */
	unsigned int		can_queue;
	unsigned int		max_target_blocked;
#define SCSI_DEFAULT_TARGET_BLOCKED	3

	char			scsi_level;
	enum scsi_target_state	state;
	void 			*hostdata; /* available to low-level driver */
	unsigned long		starget_data[0]; /* for the transport */
	/* starget_data must be the last element!!!! */
} __attribute__((aligned(sizeof(unsigned long))));

#define to_scsi_target(d)	container_of(d, struct scsi_target, dev)
static inline struct scsi_target *scsi_target(struct scsi_device *sdev)
{
	return to_scsi_target(sdev->sdev_gendev.parent);
}
#define transport_class_to_starget(class_dev) \
	to_scsi_target(class_dev->parent)

#define starget_printk(prefix, starget, fmt, a...)	\
	dev_printk(prefix, &(starget)->dev, fmt, ##a)

extern struct scsi_device *__scsi_add_device(struct Scsi_Host *,
		uint, uint, u64, void *hostdata);
extern int scsi_add_device(struct Scsi_Host *host, uint channel,
			   uint target, u64 lun);
extern int scsi_register_device_handler(struct scsi_device_handler *scsi_dh);
extern void scsi_remove_device(struct scsi_device *);
extern int scsi_unregister_device_handler(struct scsi_device_handler *scsi_dh);
void scsi_attach_vpd(struct scsi_device *sdev);

extern int scsi_device_get(struct scsi_device *);
extern void scsi_device_put(struct scsi_device *);
extern struct scsi_device *scsi_device_lookup(struct Scsi_Host *,
					      uint, uint, u64);
extern struct scsi_device *__scsi_device_lookup(struct Scsi_Host *,
						uint, uint, u64);
extern struct scsi_device *scsi_device_lookup_by_target(struct scsi_target *,
							u64);
extern struct scsi_device *__scsi_device_lookup_by_target(struct scsi_target *,
							  u64);
extern void starget_for_each_device(struct scsi_target *, void *,
		     void (*fn)(struct scsi_device *, void *));
extern void __starget_for_each_device(struct scsi_target *, void *,
				      void (*fn)(struct scsi_device *,
						 void *));

/* only exposed to implement shost_for_each_device */
extern struct scsi_device *__scsi_iterate_devices(struct Scsi_Host *,
						  struct scsi_device *);

/**
 * shost_for_each_device - iterate over all devices of a host
 * @sdev: the &struct scsi_device to use as a cursor
 * @shost: the &struct scsi_host to iterate over
 *
 * Iterator that returns each device attached to @shost.  This loop
 * takes a reference on each device and releases it at the end.  If
 * you break out of the loop, you must call scsi_device_put(sdev).
 */
#define shost_for_each_device(sdev, shost) \
	for ((sdev) = __scsi_iterate_devices((shost), NULL); \
	     (sdev); \
	     (sdev) = __scsi_iterate_devices((shost), (sdev)))

/**
 * __shost_for_each_device - iterate over all devices of a host (UNLOCKED)
 * @sdev: the &struct scsi_device to use as a cursor
 * @shost: the &struct scsi_host to iterate over
 *
 * Iterator that returns each device attached to @shost.  It does _not_
 * take a reference on the scsi_device, so the whole loop must be
 * protected by shost->host_lock.
 *
 * Note: The only reason to use this is because you need to access the
 * device list in interrupt context.  Otherwise you really want to use
 * shost_for_each_device instead.
 */
#define __shost_for_each_device(sdev, shost) \
	list_for_each_entry((sdev), &((shost)->__devices), siblings)

extern void scsi_adjust_queue_depth(struct scsi_device *, int, int);
extern int scsi_track_queue_full(struct scsi_device *, int);

extern int scsi_set_medium_removal(struct scsi_device *, char);

extern int scsi_mode_sense(struct scsi_device *sdev, int dbd, int modepage,
			   unsigned char *buffer, int len, int timeout,
			   int retries, struct scsi_mode_data *data,
			   struct scsi_sense_hdr *);
extern int scsi_mode_select(struct scsi_device *sdev, int pf, int sp,
			    int modepage, unsigned char *buffer, int len,
			    int timeout, int retries,
			    struct scsi_mode_data *data,
			    struct scsi_sense_hdr *);
extern int scsi_test_unit_ready(struct scsi_device *sdev, int timeout,
				int retries, struct scsi_sense_hdr *sshdr);
extern int scsi_get_vpd_page(struct scsi_device *, u8 page, unsigned char *buf,
			     int buf_len);
extern int scsi_report_opcode(struct scsi_device *sdev, unsigned char *buffer,
			      unsigned int len, unsigned char opcode);
extern int scsi_device_set_state(struct scsi_device *sdev,
				 enum scsi_device_state state);
extern struct scsi_event *sdev_evt_alloc(enum scsi_device_event evt_type,
					  gfp_t gfpflags);
extern void sdev_evt_send(struct scsi_device *sdev, struct scsi_event *evt);
extern void sdev_evt_send_simple(struct scsi_device *sdev,
			  enum scsi_device_event evt_type, gfp_t gfpflags);
extern int scsi_device_quiesce(struct scsi_device *sdev);
extern void scsi_device_resume(struct scsi_device *sdev);
extern void scsi_target_quiesce(struct scsi_target *);
extern void scsi_target_resume(struct scsi_target *);
extern void scsi_scan_target(struct device *parent, unsigned int channel,
			     unsigned int id, u64 lun, int rescan);
extern void scsi_target_reap(struct scsi_target *);
extern void scsi_target_block(struct device *);
extern void scsi_target_unblock(struct device *, enum scsi_device_state);
extern void scsi_remove_target(struct device *);
extern void int_to_scsilun(u64, struct scsi_lun *);
extern u64 scsilun_to_int(struct scsi_lun *);
extern const char *scsi_device_state_name(enum scsi_device_state);
extern int scsi_is_sdev_device(const struct device *);
extern int scsi_is_target_device(const struct device *);
extern int scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
			int data_direction, void *buffer, unsigned bufflen,
			unsigned char *sense, int timeout, int retries,
			u64 flags, int *resid);
extern int scsi_execute_req_flags(struct scsi_device *sdev,
	const unsigned char *cmd, int data_direction, void *buffer,
	unsigned bufflen, struct scsi_sense_hdr *sshdr, int timeout,
	int retries, int *resid, u64 flags);
static inline int scsi_execute_req(struct scsi_device *sdev,
	const unsigned char *cmd, int data_direction, void *buffer,
	unsigned bufflen, struct scsi_sense_hdr *sshdr, int timeout,
	int retries, int *resid)
{
	return scsi_execute_req_flags(sdev, cmd, data_direction, buffer,
		bufflen, sshdr, timeout, retries, resid, 0);
}
extern void sdev_disable_disk_events(struct scsi_device *sdev);
extern void sdev_enable_disk_events(struct scsi_device *sdev);

#ifdef CONFIG_PM_RUNTIME
extern int scsi_autopm_get_device(struct scsi_device *);
extern void scsi_autopm_put_device(struct scsi_device *);
#else
static inline int scsi_autopm_get_device(struct scsi_device *d) { return 0; }
static inline void scsi_autopm_put_device(struct scsi_device *d) {}
#endif /* CONFIG_PM_RUNTIME */

static inline int __must_check scsi_device_reprobe(struct scsi_device *sdev)
{
	return device_reprobe(&sdev->sdev_gendev);
}

static inline unsigned int sdev_channel(struct scsi_device *sdev)
{
	return sdev->channel;
}

static inline unsigned int sdev_id(struct scsi_device *sdev)
{
	return sdev->id;
}

#define scmd_id(scmd) sdev_id((scmd)->device)
#define scmd_channel(scmd) sdev_channel((scmd)->device)

/*
 * checks for positions of the SCSI state machine
 */
static inline int scsi_device_online(struct scsi_device *sdev)
{
	return (sdev->sdev_state != SDEV_OFFLINE &&
		sdev->sdev_state != SDEV_TRANSPORT_OFFLINE &&
		sdev->sdev_state != SDEV_DEL);
}
static inline int scsi_device_blocked(struct scsi_device *sdev)
{
	return sdev->sdev_state == SDEV_BLOCK ||
		sdev->sdev_state == SDEV_CREATED_BLOCK;
}
static inline int scsi_device_created(struct scsi_device *sdev)
{
	return sdev->sdev_state == SDEV_CREATED ||
		sdev->sdev_state == SDEV_CREATED_BLOCK;
}

/* accessor functions for the SCSI parameters */
static inline int scsi_device_sync(struct scsi_device *sdev)
{
	return sdev->sdtr;
}
static inline int scsi_device_wide(struct scsi_device *sdev)
{
	return sdev->wdtr;
}
static inline int scsi_device_dt(struct scsi_device *sdev)
{
	return sdev->ppr;
}
static inline int scsi_device_dt_only(struct scsi_device *sdev)
{
	if (sdev->inquiry_len < 57)
		return 0;
	return (sdev->inquiry[56] & 0x0c) == 0x04;
}
static inline int scsi_device_ius(struct scsi_device *sdev)
{
	if (sdev->inquiry_len < 57)
		return 0;
	return sdev->inquiry[56] & 0x01;
}
static inline int scsi_device_qas(struct scsi_device *sdev)
{
	if (sdev->inquiry_len < 57)
		return 0;
	return sdev->inquiry[56] & 0x02;
}
static inline int scsi_device_enclosure(struct scsi_device *sdev)
{
	return sdev->inquiry ? (sdev->inquiry[6] & (1<<6)) : 1;
}

static inline int scsi_device_protection(struct scsi_device *sdev)
{
	if (sdev->no_dif)
		return 0;

	return sdev->scsi_level > SCSI_2 && sdev->inquiry[5] & (1<<0);
}

static inline int scsi_device_tpgs(struct scsi_device *sdev)
{
	return sdev->inquiry ? (sdev->inquiry[5] >> 4) & 0x3 : 0;
}

#define MODULE_ALIAS_SCSI_DEVICE(type) \
	MODULE_ALIAS("scsi:t-" __stringify(type) "*")
#define SCSI_DEVICE_MODALIAS_FMT "scsi:t-0x%02x"

#endif /* _SCSI_SCSI_DEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                              /*
  Red Black Trees
  (C) 1999  Andrea Arcangeli <andrea@suse.de>
  (C) 2002  David Woodhouse <dwmw2@infradead.org>
  (C) 2012  Michel Lespinasse <walken@google.com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  linux/lib/rbtree.c
*/

#include <linux/rbtree_augmented.h>
#include <linux/export.h>

/*
 * red-black trees properties:  http://en.wikipedia.org/wiki/Rbtree
 *
 *  1) A node is either red or black
 *  2) The root is black
 *  3) All leaves (NULL) are black
 *  4) Both children of every red node are black
 *  5) Every simple path from root to leaves contains the same number
 *     of black nodes.
 *
 *  4 and 5 give the O(log n) guarantee, since 4 implies you cannot have two
 *  consecutive red nodes in a path and every red node is therefore followed by
 *  a black. So if B is the number of black nodes on every simple path (as per
 *  5), then the longest possible path due to 4 is 2B.
 *
 *  We shall indicate color with case, where black nodes are uppercase and red
 *  nodes will be lowercase. Unknown color nodes shall be drawn as red within
 *  parentheses and have some accompanying text comment.
 */

static inline void rb_set_black(struct rb_node *rb)
{
	rb->__rb_parent_color |= RB_BLACK;
}

static inline struct rb_node *rb_red_parent(struct rb_node *red)
{
	return (struct rb_node *)red->__rb_parent_color;
}

/*
 * Helper function for rotations:
 * - old's parent and color get assigned to new
 * - old gets assigned new as a parent and 'color' as a color.
 */
static inline void
__rb_rotate_set_parents(struct rb_node *old, struct rb_node *new,
			struct rb_root *root, int color)
{
	struct rb_node *parent = rb_parent(old);
	new->__rb_parent_color = old->__rb_parent_color;
	rb_set_parent_color(old, new, color);
	__rb_change_child(old, new, parent, root);
}

static __always_inline void
__rb_insert(struct rb_node *node, struct rb_root *root,
	    void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
	struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;

	while (true) {
		/*
		 * Loop invariant: node is red
		 *
		 * If there is a black parent, we are done.
		 * Otherwise, take some corrective action as we don't
		 * want a red root or two consecutive red nodes.
		 */
		if (!parent) {
			rb_set_parent_color(node, NULL, RB_BLACK);
			break;
		} else if (rb_is_black(parent))
			break;

		gparent = rb_red_parent(parent);

		tmp = gparent->rb_right;
		if (parent != tmp) {	/* parent == gparent->rb_left */
			if (tmp && rb_is_red(tmp)) {
				/*
				 * Case 1 - color flips
				 *
				 *       G            g
				 *      / \          / \
				 *     p   u  -->   P   U
				 *    /            /
				 *   n            n
				 *
				 * However, since g's parent might be red, and
				 * 4) does not allow this, we need to recurse
				 * at g.
				 */
				rb_set_parent_color(tmp, gparent, RB_BLACK);
				rb_set_parent_color(parent, gparent, RB_BLACK);
				node = gparent;
				parent = rb_parent(node);
				rb_set_parent_color(node, parent, RB_RED);
				continue;
			}

			tmp = parent->rb_right;
			if (node == tmp) {
				/*
				 * Case 2 - left rotate at parent
				 *
				 *      G             G
				 *     / \           / \
				 *    p   U  -->    n   U
				 *     \           /
				 *      n         p
				 *
				 * This still leaves us in violation of 4), the
				 * continuation into Case 3 will fix that.
				 */
				parent->rb_right = tmp = node->rb_left;
				node->rb_left = parent;
				if (tmp)
					rb_set_parent_color(tmp, parent,
							    RB_BLACK);
				rb_set_parent_color(parent, node, RB_RED);
				augment_rotate(parent, node);
				parent = node;
				tmp = node->rb_right;
			}

			/*
			 * Case 3 - right rotate at gparent
			 *
			 *        G           P
			 *       / \         / \
			 *      p   U  -->  n   g
			 *     /                 \
			 *    n                   U
			 */
			gparent->rb_left = tmp;  /* == parent->rb_right */
			parent->rb_right = gparent;
			if (tmp)
				rb_set_parent_color(tmp, gparent, RB_BLACK);
			__rb_rotate_set_parents(gparent, parent, root, RB_RED);
			augment_rotate(gparent, parent);
			break;
		} else {
			tmp = gparent->rb_left;
			if (tmp && rb_is_red(tmp)) {
				/* Case 1 - color flips */
				rb_set_parent_color(tmp, gparent, RB_BLACK);
				rb_set_parent_color(parent, gparent, RB_BLACK);
				node = gparent;
				parent = rb_parent(node);
				rb_set_parent_color(node, parent, RB_RED);
				continue;
			}

			tmp = parent->rb_left;
			if (node == tmp) {
				/* Case 2 - right rotate at parent */
				parent->rb_left = tmp = node->rb_right;
				node->rb_right = parent;
				if (tmp)
					rb_set_parent_color(tmp, parent,
							    RB_BLACK);
				rb_set_parent_color(parent, node, RB_RED);
				augment_rotate(parent, node);
				parent = node;
				tmp = node->rb_left;
			}

			/* Case 3 - left rotate at gparent */
			gparent->rb_right = tmp;  /* == parent->rb_left */
			parent->rb_left = gparent;
			if (tmp)
				rb_set_parent_color(tmp, gparent, RB_BLACK);
			__rb_rotate_set_parents(gparent, parent, root, RB_RED);
			augment_rotate(gparent, parent);
			break;
		}
	}
}

/*
 * Inline version for rb_erase() use - we want to be able to inline
 * and eliminate the dummy_rotate callback there
 */
static __always_inline void
____rb_erase_color(struct rb_node *parent, struct rb_root *root,
	void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
	struct rb_node *node = NULL, *sibling, *tmp1, *tmp2;

	while (true) {
		/*
		 * Loop invariants:
		 * - node is black (or NULL on first iteration)
		 * - node is not the root (parent is not NULL)
		 * - All leaf paths going through parent and node have a
		 *   black node count that is 1 lower than other leaf paths.
		 */
		sibling = parent->rb_right;
		if (node != sibling) {	/* node == parent->rb_left */
			if (rb_is_red(sibling)) {
				/*
				 * Case 1 - left rotate at parent
				 *
				 *     P               S
				 *    / \             / \
				 *   N   s    -->    p   Sr
				 *      / \         / \
				 *     Sl  Sr      N   Sl
				 */
				parent->rb_right = tmp1 = sibling->rb_left;
				sibling->rb_left = parent;
				rb_set_parent_color(tmp1, parent, RB_BLACK);
				__rb_rotate_set_parents(parent, sibling, root,
							RB_RED);
				augment_rotate(parent, sibling);
				sibling = tmp1;
			}
			tmp1 = sibling->rb_right;
			if (!tmp1 || rb_is_black(tmp1)) {
				tmp2 = sibling->rb_left;
				if (!tmp2 || rb_is_black(tmp2)) {
					/*
					 * Case 2 - sibling color flip
					 * (p could be either color here)
					 *
					 *    (p)           (p)
					 *    / \           / \
					 *   N   S    -->  N   s
					 *      / \           / \
					 *     Sl  Sr        Sl  Sr
					 *
					 * This leaves us violating 5) which
					 * can be fixed by flipping p to black
					 * if it was red, or by recursing at p.
					 * p is red when coming from Case 1.
					 */
					rb_set_parent_color(sibling, parent,
							    RB_RED);
					if (rb_is_red(parent))
						rb_set_black(parent);
					else {
						node = parent;
						parent = rb_parent(node);
						if (parent)
							continue;
					}
					break;
				}
				/*
				 * Case 3 - right rotate at sibling
				 * (p could be either color here)
				 *
				 *   (p)           (p)
				 *   / \           / \
				 *  N   S    -->  N   Sl
				 *     / \             \
				 *    sl  Sr            s
				 *                       \
				 *                        Sr
				 */
				sibling->rb_left = tmp1 = tmp2->rb_right;
				tmp2->rb_right = sibling;
				parent->rb_right = tmp2;
				if (tmp1)
					rb_set_parent_color(tmp1, sibling,
							    RB_BLACK);
				augment_rotate(sibling, tmp2);
				tmp1 = sibling;
				sibling = tmp2;
			}
			/*
			 * Case 4 - left rotate at parent + color flips
			 * (p and sl could be either color here.
			 *  After rotation, p becomes black, s acquires
			 *  p's color, and sl keeps its color)
			 *
			 *      (p)             (s)
			 *      / \             / \
			 *     N   S     -->   P   Sr
			 *        / \         / \
			 *      (sl) sr      N  (sl)
			 */
			parent->rb_right = tmp2 = sibling->rb_left;
			sibling->rb_left = parent;
			rb_set_parent_color(tmp1, sibling, RB_BLACK);
			if (tmp2)
				rb_set_parent(tmp2, parent);
			__rb_rotate_set_parents(parent, sibling, root,
						RB_BLACK);
			augment_rotate(parent, sibling);
			break;
		} else {
			sibling = parent->rb_left;
			if (rb_is_red(sibling)) {
				/* Case 1 - right rotate at parent */
				parent->rb_left = tmp1 = sibling->rb_right;
				sibling->rb_right = parent;
				rb_set_parent_color(tmp1, parent, RB_BLACK);
				__rb_rotate_set_parents(parent, sibling, root,
							RB_RED);
				augment_rotate(parent, sibling);
				sibling = tmp1;
			}
			tmp1 = sibling->rb_left;
			if (!tmp1 || rb_is_black(tmp1)) {
				tmp2 = sibling->rb_right;
				if (!tmp2 || rb_is_black(tmp2)) {
					/* Case 2 - sibling color flip */
					rb_set_parent_color(sibling, parent,
							    RB_RED);
					if (rb_is_red(parent))
						rb_set_black(parent);
					else {
						node = parent;
						parent = rb_parent(node);
						if (parent)
							continue;
					}
					break;
				}
				/* Case 3 - right rotate at sibling */
				sibling->rb_right = tmp1 = tmp2->rb_left;
				tmp2->rb_left = sibling;
				parent->rb_left = tmp2;
				if (tmp1)
					rb_set_parent_color(tmp1, sibling,
							    RB_BLACK);
				augment_rotate(sibling, tmp2);
				tmp1 = sibling;
				sibling = tmp2;
			}
			/* Case 4 - left rotate at parent + color flips */
			parent->rb_left = tmp2 = sibling->rb_right;
			sibling->rb_right = parent;
			rb_set_parent_color(tmp1, sibling, RB_BLACK);
			if (tmp2)
				rb_set_parent(tmp2, parent);
			__rb_rotate_set_parents(parent, sibling, root,
						RB_BLACK);
			augment_rotate(parent, sibling);
			break;
		}
	}
}

/* Non-inline version for rb_erase_augmented() use */
void __rb_erase_color(struct rb_node *parent, struct rb_root *root,
	void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
	____rb_erase_color(parent, root, augment_rotate);
}
EXPORT_SYMBOL(__rb_erase_color);

/*
 * Non-augmented rbtree manipulation functions.
 *
 * We use dummy augmented callbacks here, and have the compiler optimize them
 * out of the rb_insert_color() and rb_erase() function definitions.
 */

static inline void dummy_propagate(struct rb_node *node, struct rb_node *stop) {}
static inline void dummy_copy(struct rb_node *old, struct rb_node *new) {}
static inline void dummy_rotate(struct rb_node *old, struct rb_node *new) {}

static const struct rb_augment_callbacks dummy_callbacks = {
	dummy_propagate, dummy_copy, dummy_rotate
};

void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
	__rb_insert(node, root, dummy_rotate);
}
EXPORT_SYMBOL(rb_insert_color);

void rb_erase(struct rb_node *node, struct rb_root *root)
{
	struct rb_node *rebalance;
	rebalance = __rb_erase_augmented(node, root, &dummy_callbacks);
	if (rebalance)
		____rb_erase_color(rebalance, root, dummy_rotate);
}
EXPORT_SYMBOL(rb_erase);

/*
 * Augmented rbtree manipulation functions.
 *
 * This instantiates the same __always_inline functions as in the non-augmented
 * case, but this time with user-defined callbacks.
 */

void __rb_insert_augmented(struct rb_node *node, struct rb_root *root,
	void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
	__rb_insert(node, root, augment_rotate);
}
EXPORT_SYMBOL(__rb_insert_augmented);

/*
 * This function returns the first node (in sort order) of the tree.
 */
struct rb_node *rb_first(const struct rb_root *root)
{
	struct rb_node	*n;

	n = root->rb_node;
	if (!n)
		return NULL;
	while (n->rb_left)
		n = n->rb_left;
	return n;
}
EXPORT_SYMBOL(rb_first);

struct rb_node *rb_last(const struct rb_root *root)
{
	struct rb_node	*n;

	n = root->rb_node;
	if (!n)
		return NULL;
	while (n->rb_right)
		n = n->rb_right;
	return n;
}
EXPORT_SYMBOL(rb_last);

struct rb_node *rb_next(const struct rb_node *node)
{
	struct rb_node *parent;

	if (RB_EMPTY_NODE(node))
		return NULL;

	/*
	 * If we have a right-hand child, go down and then left as far
	 * as we can.
	 */
	if (node->rb_right) {
		node = node->rb_right; 
		while (node->rb_left)
			node=node->rb_left;
		return (struct rb_node *)node;
	}

	/*
	 * No right-hand children. Everything down and left is smaller than us,
	 * so any 'next' node must be in the general direction of our parent.
	 * Go up the tree; any time the ancestor is a right-hand child of its
	 * parent, keep going up. First time it's a left-hand child of its
	 * parent, said parent is our 'next' node.
	 */
	while ((parent = rb_parent(node)) && node == parent->rb_right)
		node = parent;

	return parent;
}
EXPORT_SYMBOL(rb_next);

struct rb_node *rb_prev(const struct rb_node *node)
{
	struct rb_node *parent;

	if (RB_EMPTY_NODE(node))
		return NULL;

	/*
	 * If we have a left-hand child, go down and then right as far
	 * as we can.
	 */
	if (node->rb_left) {
		node = node->rb_left; 
		while (node->rb_right)
			node=node->rb_right;
		return (struct rb_node *)node;
	}

	/*
	 * No left-hand children. Go up till we find an ancestor which
	 * is a right-hand child of its parent.
	 */
	while ((parent = rb_parent(node)) && node == parent->rb_left)
		node = parent;

	return parent;
}
EXPORT_SYMBOL(rb_prev);

void rb_replace_node(struct rb_node *victim, struct rb_node *new,
		     struct rb_root *root)
{
	struct rb_node *parent = rb_parent(victim);

	/* Set the surrounding nodes to point to the replacement */
	__rb_change_child(victim, new, parent, root);
	if (victim->rb_left)
		rb_set_parent(victim->rb_left, new);
	if (victim->rb_right)
		rb_set_parent(victim->rb_right, new);

	/* Copy the pointers/colour from the victim to the replacement */
	*new = *victim;
}
EXPORT_SYMBOL(rb_replace_node);

static struct rb_node *rb_left_deepest_node(const struct rb_node *node)
{
	for (;;) {
		if (node->rb_left)
			node = node->rb_left;
		else if (node->rb_right)
			node = node->rb_right;
		else
			return (struct rb_node *)node;
	}
}

struct rb_node *rb_next_postorder(const struct rb_node *node)
{
	const struct rb_node *parent;
	if (!node)
		return NULL;
	parent = rb_parent(node);

	/* If we're sitting on node, we've already seen our children */
	if (parent && node == parent->rb_left && parent->rb_right) {
		/* If we are the parent's left node, go to the parent's right
		 * node then all the way down to the left */
		return rb_left_deepest_node(parent->rb_right);
	} else
		/* Otherwise we are the parent's right node, and the parent
		 * should be next */
		return (struct rb_node *)parent;
}
EXPORT_SYMBOL(rb_next_postorder);

struct rb_node *rb_first_postorder(const struct rb_root *root)
{
	if (!root->rb_node)
		return NULL;

	return rb_left_deepest_node(root->rb_node);
}
EXPORT_SYMBOL(rb_first_postorder);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef AU88X0_EQ_H
#define AU88X0_EQ_H

/***************************************************************************
 *            au88x0_eq.h
 *
 *  Definitions and constant data for the Aureal Hardware EQ.
 *
 *  Sun Jun  8 18:23:38 2003
 *  Author: Manuel Jander (mjander@users.sourceforge.net)
 ****************************************************************************/

typedef struct {
	u16 LeftCoefs[50];	//0x4
	u16 RightCoefs[50];	// 0x68
	u16 LeftGains[10];	//0xd0
	u16 RightGains[10];	//0xe4
} auxxEqCoeffSet_t;

typedef struct {
	s32 this04;		/* How many filters for each side (default = 10) */
	s32 this08;		/* inited to cero. Stereo flag? */
} eqhw_t;

typedef struct {
	eqhw_t this04;		/* CHwEq */
	u16 this08;		/* Bad codec flag ? SetBypassGain: bypass gain */
	u16 this0a;
	u16 this0c;		/* SetBypassGain: bypass gain when this28 is not set. */
	u16 this0e;

	s32 this10;		/* How many gains are used for each side (right or left). */
	u16 this14_array[10];	/* SetLeftGainsTarget: Left (and right?) EQ gains  */
	s32 this28;		/* flag related to EQ enabled or not. Gang flag ? */
	s32 this54;		/* SetBypass */
	s32 this58;
	s32 this5c;
	/*0x60 */ auxxEqCoeffSet_t coefset;
	/* 50 u16 word each channel. */
	u16 this130[20];	/* Left and Right gains */
} eqlzr_t;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * raumfeld_audio.c  --  SoC audio for Raumfeld audio devices
 *
 * Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
 *
 * based on code from:
 *
 *    Wolfson Microelectronics PLC.
 *    Openedhand Ltd.
 *    Liam Girdwood <lrg@slimlogic.co.uk>
 *    Richard Purdie <richard@openedhand.com>
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/gpio.h>
#include <sound/pcm.h>
#include <sound/soc.h>

#include <asm/mach-types.h>

#include "pxa-ssp.h"

#define GPIO_SPDIF_RESET	(38)
#define GPIO_MCLK_RESET		(111)
#define GPIO_CODEC_RESET	(120)

static struct i2c_client *max9486_client;
static struct i2c_board_info max9486_hwmon_info = {
	I2C_BOARD_INFO("max9485", 0x63),
};

#define MAX9485_MCLK_FREQ_112896 0x22
#define MAX9485_MCLK_FREQ_122880 0x23
#define MAX9485_MCLK_FREQ_225792 0x32
#define MAX9485_MCLK_FREQ_245760 0x33

static void set_max9485_clk(char clk)
{
	i2c_master_send(max9486_client, &clk, 1);
}

static void raumfeld_enable_audio(bool en)
{
	if (en) {
		gpio_set_value(GPIO_MCLK_RESET, 1);

		/* wait some time to let the clocks become stable */
		msleep(100);

		gpio_set_value(GPIO_SPDIF_RESET, 1);
		gpio_set_value(GPIO_CODEC_RESET, 1);
	} else {
		gpio_set_value(GPIO_MCLK_RESET, 0);
		gpio_set_value(GPIO_SPDIF_RESET, 0);
		gpio_set_value(GPIO_CODEC_RESET, 0);
	}
}

/* CS4270 */
static int raumfeld_cs4270_startup(struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;

	/* set freq to 0 to enable all possible codec sample rates */
	return snd_soc_dai_set_sysclk(codec_dai, 0, 0, 0);
}

static void raumfeld_cs4270_shutdown(struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;

	/* set freq to 0 to enable all possible codec sample rates */
	snd_soc_dai_set_sysclk(codec_dai, 0, 0, 0);
}

static int raumfeld_cs4270_hw_params(struct snd_pcm_substream *substream,
				     struct snd_pcm_hw_params *params)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;
	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
	unsigned int fmt, clk = 0;
	int ret = 0;

	switch (params_rate(params)) {
	case 44100:
		set_max9485_clk(MAX9485_MCLK_FREQ_112896);
		clk = 11289600;
		break;
	case 48000:
		set_max9485_clk(MAX9485_MCLK_FREQ_122880);
		clk = 12288000;
		break;
	case 88200:
		set_max9485_clk(MAX9485_MCLK_FREQ_225792);
		clk = 22579200;
		break;
	case 96000:
		set_max9485_clk(MAX9485_MCLK_FREQ_245760);
		clk = 24576000;
		break;
	default:
		return -EINVAL;
	}

	fmt = SND_SOC_DAIFMT_I2S |
	      SND_SOC_DAIFMT_NB_NF |
	      SND_SOC_DAIFMT_CBS_CFS;

	/* setup the CODEC DAI */
	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_sysclk(codec_dai, 0, clk, 0);
	if (ret < 0)
		return ret;

	/* setup the CPU DAI */
	ret = snd_soc_dai_set_pll(cpu_dai, 0, 0, 0, clk);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_clkdiv(cpu_dai, PXA_SSP_DIV_SCR, 4);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_sysclk(cpu_dai, PXA_SSP_CLK_EXT, clk, 1);
	if (ret < 0)
		return ret;

	return 0;
}

static struct snd_soc_ops raumfeld_cs4270_ops = {
	.startup = raumfeld_cs4270_startup,
	.shutdown = raumfeld_cs4270_shutdown,
	.hw_params = raumfeld_cs4270_hw_params,
};

static int raumfeld_analog_suspend(struct snd_soc_card *card)
{
	raumfeld_enable_audio(false);
	return 0;
}

static int raumfeld_analog_resume(struct snd_soc_card *card)
{
	raumfeld_enable_audio(true);
	return 0;
}

/* AK4104 */

static int raumfeld_ak4104_hw_params(struct snd_pcm_substream *substream,
				     struct snd_pcm_hw_params *params)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;
	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
	int fmt, ret = 0, clk = 0;

	switch (params_rate(params)) {
	case 44100:
		set_max9485_clk(MAX9485_MCLK_FREQ_112896);
		clk = 11289600;
		break;
	case 48000:
		set_max9485_clk(MAX9485_MCLK_FREQ_122880);
		clk = 12288000;
		break;
	case 88200:
		set_max9485_clk(MAX9485_MCLK_FREQ_225792);
		clk = 22579200;
		break;
	case 96000:
		set_max9485_clk(MAX9485_MCLK_FREQ_245760);
		clk = 24576000;
		break;
	default:
		return -EINVAL;
	}

	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF;

	/* setup the CODEC DAI */
	ret = snd_soc_dai_set_fmt(codec_dai, fmt | SND_SOC_DAIFMT_CBS_CFS);
	if (ret < 0)
		return ret;

	/* setup the CPU DAI */
	ret = snd_soc_dai_set_pll(cpu_dai, 0, 0, 0, clk);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_fmt(cpu_dai, fmt | SND_SOC_DAIFMT_CBS_CFS);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_clkdiv(cpu_dai, PXA_SSP_DIV_SCR, 4);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_sysclk(cpu_dai, PXA_SSP_CLK_EXT, clk, 1);
	if (ret < 0)
		return ret;

	return 0;
}

static struct snd_soc_ops raumfeld_ak4104_ops = {
	.hw_params = raumfeld_ak4104_hw_params,
};

#define DAI_LINK_CS4270		\
{							\
	.name		= "CS4270",			\
	.stream_name	= "CS4270",			\
	.cpu_dai_name	= "pxa-ssp-dai.0",		\
	.platform_name	= "pxa-pcm-audio",		\
	.codec_dai_name	= "cs4270-hifi",		\
	.codec_name	= "cs4270.0-0048",	\
	.ops		= &raumfeld_cs4270_ops,		\
}

#define DAI_LINK_AK4104		\
{							\
	.name		= "ak4104",			\
	.stream_name	= "Playback",			\
	.cpu_dai_name	= "pxa-ssp-dai.1",		\
	.codec_dai_name	= "ak4104-hifi",		\
	.platform_name	= "pxa-pcm-audio",		\
	.ops		= &raumfeld_ak4104_ops,		\
	.codec_name	= "spi0.0",			\
}

static struct snd_soc_dai_link snd_soc_raumfeld_connector_dai[] =
{
	DAI_LINK_CS4270,
	DAI_LINK_AK4104,
};

static struct snd_soc_dai_link snd_soc_raumfeld_speaker_dai[] =
{
	DAI_LINK_CS4270,
};

static struct snd_soc_card snd_soc_raumfeld_connector = {
	.name		= "Raumfeld Connector",
	.owner		= THIS_MODULE,
	.dai_link	= snd_soc_raumfeld_connector_dai,
	.num_links	= ARRAY_SIZE(snd_soc_raumfeld_connector_dai),
	.suspend_post	= raumfeld_analog_suspend,
	.resume_pre	= raumfeld_analog_resume,
};

static struct snd_soc_card snd_soc_raumfeld_speaker = {
	.name		= "Raumfeld Speaker",
	.owner		= THIS_MODULE,
	.dai_link	= snd_soc_raumfeld_speaker_dai,
	.num_links	= ARRAY_SIZE(snd_soc_raumfeld_speaker_dai),
	.suspend_post	= raumfeld_analog_suspend,
	.resume_pre	= raumfeld_analog_resume,
};

static struct platform_device *raumfeld_audio_device;

static int __init raumfeld_audio_init(void)
{
	int ret;

	if (!machine_is_raumfeld_speaker() &&
	    !machine_is_raumfeld_connector())
		return 0;

	max9486_client = i2c_new_device(i2c_get_adapter(0),
					&max9486_hwmon_info);

	if (!max9486_client)
		return -ENOMEM;

	set_max9485_clk(MAX9485_MCLK_FREQ_122880);

	/* Register analog device */
	raumfeld_audio_device = platform_device_alloc("soc-audio", 0);
	if (!raumfeld_audio_device)
		return -ENOMEM;

	if (machine_is_raumfeld_speaker())
		platform_set_drvdata(raumfeld_audio_device,
				     &snd_soc_raumfeld_speaker);

	if (machine_is_raumfeld_connector())
		platform_set_drvdata(raumfeld_audio_device,
				     &snd_soc_raumfeld_connector);

	ret = platform_device_add(raumfeld_audio_device);
	if (ret < 0) {
		platform_device_put(raumfeld_audio_device);
		return ret;
	}

	raumfeld_enable_audio(true);
	return 0;
}

static void __exit raumfeld_audio_exit(void)
{
	raumfeld_enable_audio(false);

	platform_device_unregister(raumfeld_audio_device);

	i2c_unregister_device(max9486_client);

	gpio_free(GPIO_MCLK_RESET);
	gpio_free(GPIO_CODEC_RESET);
	gpio_free(GPIO_SPDIF_RESET);
}

module_init(raumfeld_audio_init);
module_exit(raumfeld_audio_exit);

/* Module information */
MODULE_AUTHOR("Daniel Mack <daniel@caiaq.de>");
MODULE_DESCRIPTION("Raumfeld audio SoC");
MODULE_LICENSE("GPL");
                                                                                                      /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/* PF_KEY user interface, this is defined by rfc2367 so
 * do not make arbitrary modifications or else this header
 * file will not be compliant.
 */

#ifndef _LINUX_PFKEY2_H
#define _LINUX_PFKEY2_H

#include <linux/types.h>

#define PF_KEY_V2		2
#define PFKEYV2_REVISION	199806L

struct sadb_msg {
	__u8		sadb_msg_version;
	__u8		sadb_msg_type;
	__u8		sadb_msg_errno;
	__u8		sadb_msg_satype;
	__u16	sadb_msg_len;
	__u16	sadb_msg_reserved;
	__u32	sadb_msg_seq;
	__u32	sadb_msg_pid;
} __attribute__((packed));
/* sizeof(struct sadb_msg) == 16 */

struct sadb_ext {
	__u16	sadb_ext_len;
	__u16	sadb_ext_type;
} __attribute__((packed));
/* sizeof(struct sadb_ext) == 4 */

struct sadb_sa {
	__u16	sadb_sa_len;
	__u16	sadb_sa_exttype;
	__be32		sadb_sa_spi;
	__u8		sadb_sa_replay;
	__u8		sadb_sa_state;
	__u8		sadb_sa_auth;
	__u8		sadb_sa_encrypt;
	__u32	sadb_sa_flags;
} __attribute__((packed));
/* sizeof(struct sadb_sa) == 16 */

struct sadb_lifetime {
	__u16	sadb_lifetime_len;
	__u16	sadb_lifetime_exttype;
	__u32	sadb_lifetime_allocations;
	__u64	sadb_lifetime_bytes;
	__u64	sadb_lifetime_addtime;
	__u64	sadb_lifetime_usetime;
} __attribute__((packed));
/* sizeof(struct sadb_lifetime) == 32 */

struct sadb_address {
	__u16	sadb_address_len;
	__u16	sadb_address_exttype;
	__u8		sadb_address_proto;
	__u8		sadb_address_prefixlen;
	__u16	sadb_address_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_address) == 8 */

struct sadb_key {
	__u16	sadb_key_len;
	__u16	sadb_key_exttype;
	__u16	sadb_key_bits;
	__u16	sadb_key_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_key) == 8 */

struct sadb_ident {
	__u16	sadb_ident_len;
	__u16	sadb_ident_exttype;
	__u16	sadb_ident_type;
	__u16	sadb_ident_reserved;
	__u64	sadb_ident_id;
} __attribute__((packed));
/* sizeof(struct sadb_ident) == 16 */

struct sadb_sens {
	__u16	sadb_sens_len;
	__u16	sadb_sens_exttype;
	__u32	sadb_sens_dpd;
	__u8		sadb_sens_sens_level;
	__u8		sadb_sens_sens_len;
	__u8		sadb_sens_integ_level;
	__u8		sadb_sens_integ_len;
	__u32	sadb_sens_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_sens) == 16 */

/* followed by:
	__u64	sadb_sens_bitmap[sens_len];
	__u64	sadb_integ_bitmap[integ_len];  */

struct sadb_prop {
	__u16	sadb_prop_len;
	__u16	sadb_prop_exttype;
	__u8		sadb_prop_replay;
	__u8		sadb_prop_reserved[3];
} __attribute__((packed));
/* sizeof(struct sadb_prop) == 8 */

/* followed by:
	struct sadb_comb sadb_combs[(sadb_prop_len +
		sizeof(__u64) - sizeof(struct sadb_prop)) /
		sizeof(struct sadb_comb)]; */

struct sadb_comb {
	__u8		sadb_comb_auth;
	__u8		sadb_comb_encrypt;
	__u16	sadb_comb_flags;
	__u16	sadb_comb_auth_minbits;
	__u16	sadb_comb_auth_maxbits;
	__u16	sadb_comb_encrypt_minbits;
	__u16	sadb_comb_encrypt_maxbits;
	__u32	sadb_comb_reserved;
	__u32	sadb_comb_soft_allocations;
	__u32	sadb_comb_hard_allocations;
	__u64	sadb_comb_soft_bytes;
	__u64	sadb_comb_hard_bytes;
	__u64	sadb_comb_soft_addtime;
	__u64	sadb_comb_hard_addtime;
	__u64	sadb_comb_soft_usetime;
	__u64	sadb_comb_hard_usetime;
} __attribute__((packed));
/* sizeof(struct sadb_comb) == 72 */

struct sadb_supported {
	__u16	sadb_supported_len;
	__u16	sadb_supported_exttype;
	__u32	sadb_supported_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_supported) == 8 */

/* followed by:
	struct sadb_alg sadb_algs[(sadb_supported_len +
		sizeof(__u64) - sizeof(struct sadb_supported)) /
		sizeof(struct sadb_alg)]; */

struct sadb_alg {
	__u8		sadb_alg_id;
	__u8		sadb_alg_ivlen;
	__u16	sadb_alg_minbits;
	__u16	sadb_alg_maxbits;
	__u16	sadb_alg_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_alg) == 8 */

struct sadb_spirange {
	__u16	sadb_spirange_len;
	__u16	sadb_spirange_exttype;
	__u32	sadb_spirange_min;
	__u32	sadb_spirange_max;
	__u32	sadb_spirange_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_spirange) == 16 */

struct sadb_x_kmprivate {
	__u16	sadb_x_kmprivate_len;
	__u16	sadb_x_kmprivate_exttype;
	__u32	sadb_x_kmprivate_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_x_kmprivate) == 8 */

struct sadb_x_sa2 {
	__u16	sadb_x_sa2_len;
	__u16	sadb_x_sa2_exttype;
	__u8		sadb_x_sa2_mode;
	__u8		sadb_x_sa2_reserved1;
	__u16	sadb_x_sa2_reserved2;
	__u32	sadb_x_sa2_sequence;
	__u32	sadb_x_sa2_reqid;
} __attribute__((packed));
/* sizeof(struct sadb_x_sa2) == 16 */

struct sadb_x_policy {
	__u16	sadb_x_policy_len;
	__u16	sadb_x_policy_exttype;
	__u16	sadb_x_policy_type;
	__u8		sadb_x_policy_dir;
	__u8		sadb_x_policy_reserved;
	__u32	sadb_x_policy_id;
	__u32	sadb_x_policy_priority;
} __attribute__((packed));
/* sizeof(struct sadb_x_policy) == 16 */

struct sadb_x_ipsecrequest {
	__u16	sadb_x_ipsecrequest_len;
	__u16	sadb_x_ipsecrequest_proto;
	__u8		sadb_x_ipsecrequest_mode;
	__u8		sadb_x_ipsecrequest_level;
	__u16	sadb_x_ipsecrequest_reserved1;
	__u32	sadb_x_ipsecrequest_reqid;
	__u32	sadb_x_ipsecrequest_reserved2;
} __attribute__((packed));
/* sizeof(struct sadb_x_ipsecrequest) == 16 */

/* This defines the TYPE of Nat Traversal in use.  Currently only one
 * type of NAT-T is supported, draft-ietf-ipsec-udp-encaps-06
 */
struct sadb_x_nat_t_type {
	__u16	sadb_x_nat_t_type_len;
	__u16	sadb_x_nat_t_type_exttype;
	__u8		sadb_x_nat_t_type_type;
	__u8		sadb_x_nat_t_type_reserved[3];
} __attribute__((packed));
/* sizeof(struct sadb_x_nat_t_type) == 8 */

/* Pass a NAT Traversal port (Source or Dest port) */
struct sadb_x_nat_t_port {
	__u16	sadb_x_nat_t_port_len;
	__u16	sadb_x_nat_t_port_exttype;
	__be16		sadb_x_nat_t_port_port;
	__u16	sadb_x_nat_t_port_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_x_nat_t_port) == 8 */

/* Generic LSM security context */
struct sadb_x_sec_ctx {
	__u16	sadb_x_sec_len;
	__u16	sadb_x_sec_exttype;
	__u8		sadb_x_ctx_alg;  /* LSMs: e.g., selinux == 1 */
	__u8		sadb_x_ctx_doi;
	__u16	sadb_x_ctx_len;
} __attribute__((packed));
/* sizeof(struct sadb_sec_ctx) = 8 */

/* Used by MIGRATE to pass addresses IKE will use to perform
 * negotiation with the peer */
struct sadb_x_kmaddress {
	__u16	sadb_x_kmaddress_len;
	__u16	sadb_x_kmaddress_exttype;
	__u32	sadb_x_kmaddress_reserved;
} __attribute__((packed));
/* sizeof(struct sadb_x_kmaddress) == 8 */

/* To specify the SA dump filter */
struct sadb_x_filter {
	__u16	sadb_x_filter_len;
	__u16	sadb_x_filter_exttype;
	__u32	sadb_x_filter_saddr[4];
	__u32	sadb_x_filter_daddr[4];
	__u16	sadb_x_filter_family;
	__u8	sadb_x_filter_splen;
	__u8	sadb_x_filter_dplen;
} __attribute__((packed));
/* sizeof(struct sadb_x_filter) == 40 */

/* Message types */
#define SADB_RESERVED		0
#define SADB_GETSPI		1
#define SADB_UPDATE		2
#define SADB_ADD		3
#define SADB_DELETE		4
#define SADB_GET		5
#define SADB_ACQUIRE		6
#define SADB_REGISTER		7
#define SADB_EXPIRE		8
#define SADB_FLUSH		9
#define SADB_DUMP		10
#define SADB_X_PROMISC		11
#define SADB_X_PCHANGE		12
#define SADB_X_SPDUPDATE	13
#define SADB_X_SPDADD		14
#define SADB_X_SPDDELETE	15
#define SADB_X_SPDGET		16
#define SADB_X_SPDACQUIRE	17
#define SADB_X_SPDDUMP		18
#define SADB_X_SPDFLUSH		19
#define SADB_X_SPDSETIDX	20
#define SADB_X_SPDEXPIRE	21
#define SADB_X_SPDDELETE2	22
#define SADB_X_NAT_T_NEW_MAPPING	23
#define SADB_X_MIGRATE		24
#define SADB_MAX		24

/* Security Association flags */
#define SADB_SAFLAGS_PFS	1
#define SADB_SAFLAGS_NOPMTUDISC	0x20000000
#define SADB_SAFLAGS_DECAP_DSCP	0x40000000
#define SADB_SAFLAGS_NOECN	0x80000000

/* Security Association states */
#define SADB_SASTATE_LARVAL	0
#define SADB_SASTATE_MATURE	1
#define SADB_SASTATE_DYING	2
#define SADB_SASTATE_DEAD	3
#define SADB_SASTATE_MAX	3

/* Security Association types */
#define SADB_SATYPE_UNSPEC	0
#define SADB_SATYPE_AH		2
#define SADB_SATYPE_ESP		3
#define SADB_SATYPE_RSVP	5
#define SADB_SATYPE_OSPFV2	6
#define SADB_SATYPE_RIPV2	7
#define SADB_SATYPE_MIP		8
#define SADB_X_SATYPE_IPCOMP	9
#define SADB_SATYPE_MAX		9

/* Authentication algorithms */
#define SADB_AALG_NONE			0
#define SADB_AALG_MD5HMAC		2
#define SADB_AALG_SHA1HMAC		3
#define SADB_X_AALG_SHA2_256HMAC	5
#define SADB_X_AALG_SHA2_384HMAC	6
#define SADB_X_AALG_SHA2_512HMAC	7
#define SADB_X_AALG_RIPEMD160HMAC	8
#define SADB_X_AALG_AES_XCBC_MAC	9
#define SADB_X_AALG_NULL		251	/* kame */
#define SADB_AALG_MAX			251

/* Encryption algorithms */
#define SADB_EALG_NONE			0
#define SADB_EALG_DESCBC		2
#define SADB_EALG_3DESCBC		3
#define SADB_X_EALG_CASTCBC		6
#define SADB_X_EALG_BLOWFISHCBC		7
#define SADB_EALG_NULL			11
#define SADB_X_EALG_AESCBC		12
#define SADB_X_EALG_AESCTR		13
#define SADB_X_EALG_AES_CCM_ICV8	14
#define SADB_X_EALG_AES_CCM_ICV12	15
#define SADB_X_EALG_AES_CCM_ICV16	16
#define SADB_X_EALG_AES_GCM_ICV8	18
#define SADB_X_EALG_AES_GCM_ICV12	19
#define SADB_X_EALG_AES_GCM_ICV16	20
#define SADB_X_EALG_CAMELLIACBC		22
#define SADB_X_EALG_NULL_AES_GMAC	23
#define SADB_EALG_MAX                   253 /* last EALG */
/* private allocations should use 249-255 (RFC2407) */
#define SADB_X_EALG_SERPENTCBC  252     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
#define SADB_X_EALG_TWOFISHCBC  253     /* draft-ietf-ipsec-ciph-aes-cbc-00 */

/* Compression algorithms */
#define SADB_X_CALG_NONE		0
#define SADB_X_CALG_OUI			1
#define SADB_X_CALG_DEFLATE		2
#define SADB_X_CALG_LZS			3
#define SADB_X_CALG_LZJH		4
#define SADB_X_CALG_MAX			4

/* Extension Header values */
#define SADB_EXT_RESERVED		0
#define SADB_EXT_SA			1
#define SADB_EXT_LIFETIME_CURRENT	2
#define SADB_EXT_LIFETIME_HARD		3
#define SADB_EXT_LIFETIME_SOFT		4
#define SADB_EXT_ADDRESS_SRC		5
#define SADB_EXT_ADDRESS_DST		6
#define SADB_EXT_ADDRESS_PROXY		7
#define SADB_EXT_KEY_AUTH		8
#define SADB_EXT_KEY_ENCRYPT		9
#define SADB_EXT_IDENTITY_SRC		10
#define SADB_EXT_IDENTITY_DST		11
#define SADB_EXT_SENSITIVITY		12
#define SADB_EXT_PROPOSAL		13
#define SADB_EXT_SUPPORTED_AUTH		14
#define SADB_EXT_SUPPORTED_ENCRYPT	15
#define SADB_EXT_SPIRANGE		16
#define SADB_X_EXT_KMPRIVATE		17
#define SADB_X_EXT_POLICY		18
#define SADB_X_EXT_SA2			19
/* The next four entries are for setting up NAT Traversal */
#define SADB_X_EXT_NAT_T_TYPE		20
#define SADB_X_EXT_NAT_T_SPORT		21
#define SADB_X_EXT_NAT_T_DPORT		22
#define SADB_X_EXT_NAT_T_OA		23
#define SADB_X_EXT_SEC_CTX		24
/* Used with MIGRATE to pass @ to IKE for negotiation */
#define SADB_X_EXT_KMADDRESS		25
#define SADB_X_EXT_FILTER		26
#define SADB_EXT_MAX			26

/* Identity Extension values */
#define SADB_IDENTTYPE_RESERVED	0
#define SADB_IDENTTYPE_PREFIX	1
#define SADB_IDENTTYPE_FQDN	2
#define SADB_IDENTTYPE_USERFQDN	3
#define SADB_IDENTTYPE_MAX	3

#endif /* !(_LINUX_PFKEY2_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* Header file for middle end gimplification.
   Copyright (C) 2013-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

#ifndef GCC_GIMPLIFY_ME_H
#define GCC_GIMPLIFY_ME_H

/* Validation of GIMPLE expressions.  Note that these predicates only check
 *    the basic form of the expression, they don't recurse to make sure that
 *       underlying nodes are also of the right form.  */
typedef bool (*gimple_predicate)(tree);

extern tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);
extern tree force_gimple_operand (tree, gimple_seq *, bool, tree);
extern tree force_gimple_operand_gsi_1 (gimple_stmt_iterator *, tree,
					gimple_predicate, tree,
					bool, enum gsi_iterator_update);
extern tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,
				      bool, enum gsi_iterator_update);
extern void gimple_regimplify_operands (gimple *, gimple_stmt_iterator *);

#endif /* GCC_GIMPLIFY_ME_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  INDX( 	                 (                                     ` P     z    *YM 3qH9qH9PvH9                        i s o 8 8 5 9               ` P     z    *YM 3/g2M 3PvH9                        i s o 8 8 5 9               ` P     z    *YM 3/g2M 3PvH9                        i s o 8 8 5 9               z    L 3 h2L 3L 3                         u t f 8 . h                 z    L 3 h2L 3 L 3                         u t f 8 . h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF                              ?          @     @    <   !  <H!xb  !hbx?  q  _                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      !"#$%&'()*+,-./0123456789:                                                                                                                                                                                                                                                                                                                                                                                                                "  $  &  (  *  ,  .      2  4  6  8  :  <  >  @  B  D  F  H  J  L  N  P  R  T  V  X  Z  \  ^  `  b  d  f  h  j  l  n                    y  {    ~                                                                                                                                                                                                                                                                                                                                                                                        @  B  D  F  H  J  L  N  P  R  T  V  X  Z  \  ^      b  d  f  h  j  l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ,,,,,,,,,	,
,,,,,,,,,,,,,,,,,,,,,, ,!,",#,$,%,&,',(,),*,+,,,-,.,    `,      :>  g,  i,  k,            r,    u,                    ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        $$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                                                                                                                        2!                                                                  `!a!b!c!d!e!f!g!h!i!j!k!l!m!n!o!        !                                                                                                                                                                                                                                                      	
                                    ()*+,-./                89:;<=>?                HIJKLM                      Y  [  ]  _                hijklmno                                                                                                                                                                                                                             
                         "  $  &  (  *  ,  .  0  2  4  6  8  :  <  >  @  B  D  F  H  J  L  N  P  R  T  V  X  Z  \  ^  `  b  d  f  h  j  l  n  p  r  t  v  x  z  |  ~                                                                                                                                                                                                                                                                                                                                                                                            }      c,                                                                                                                                                                                                                                                                                 
                         "                                                                                                                          123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUV                                                                                                                                                                                                                                                                                                                                                   !"#$%&'()*+,-./ 	
  `  b  d  f  h  j  l  n  p  r  t  v  x  z  |  ~                                                                                                                                                                                                                                                                                                                                                                          p  r      v                                                                                                                                                                                     
                          "  $  &  (  *  ,  .  0  2                ;          A        F  H  J  L  No,m,                              b,        n,                  d,                DE                                                                                                                                                                                                                                                 
                         "  $  &  (  *  ,  .      2  4  6    9  ;  =  ?  A  C  E  G    J  L  N  P  R  T  V  X  Z  \  ^  `  b  d  f  h  j  l  n  p  r  t  v    y  {  }  C                                    =                                                                                                                                                                                                                                                                                                                               A B C D E F G H I J K L M N O P Q R S T U V W X Y Z                                                                                                                                                                                                                                           x<                           ,                                       int         u16 W       4                        ^      	      
                             	4      
                   ;                     s   3  	>  S  -    C      $S  	            GS  	            jS  	            S  	            S  	            S  	            S  	            S  	            <S  	            _S  	            S  	            S  	            S  	            S  	            S  	            1S  	        	    -      >        T  	            3          ,       in 3      idx I   tbl       out 3  Q  %  $ >  $ >   :;I   I   :;I   'I   '  	I  
!   4 :;I?<  & I  ! I/  4 :;I  4 :;I  .?:;'I@B   :;I  4 :;I  4 :;I  4 :;I           (        P                                Q(       ,        Q                ,                     ,                                    ../fs/cifs ../include/linux ../include/asm-generic  winucase.c   types.h   init.h   nls.h   int-ll64.h     	        	 K'O initcall_debug ../fs/cifs/winucase.c __con_initcall_start t2_a6 t2_a7 bool boot_command_line initcall_t t2_ff saved_command_line t2_1d /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out t2_1f t2_00 unsigned char t2_02 t2_03 t2_04 t2_05 long unsigned int t2_21 short unsigned int t2_24 __security_initcall_end reset_devices wchar_t late_time_init unsigned int cifs_toupper long long unsigned int toplevel GNU C89 7.3.1 20180522 -mlittle-endian -mgeneral-regs-only -mpc-relative-literal-loads -mabi=lp64 -g -Os -std=gnu90 -fno-strict-aliasing -fno-common -fstack-usage -fno-delete-null-pointer-checks -fno-PIE -fno-store-merging -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -fno-strict-overflow -fstack-check=no -fconserve-stack --param allow-store-data-races=0 long long int char t2_2c t2_2d t2_1e short int __security_initcall_start long int t2_01 signed char _Bool __con_initcall_end  GCC: (Linaro GCC 7.3-2018.05~dev) 7.3.1 20180522            x                ,                                                                                                                                                                                                                 &             !      $             '      "             -                    3                   9                   ?                   E                   K                   Q                   W                   ]                   c                   i                   o      
             u                                              	                      
                                                                                                                                                     {             ,        winucase.c $x $d toplevel t2_00 t2_01 t2_02 t2_03 t2_04 t2_05 t2_1d t2_1e t2_1f t2_21 t2_24 t2_2c t2_2d t2_a6 t2_a7 t2_ff cifs_toupper                                                       &                   $                   "                                              (                                                                                                                 `                  h                  0                  8            
                                                                                                                        )                    0                  7            d      >            ~      E                  L                   S            {      Z            (      h            V      o                                                F                                     ]                   %                                                       A                  K                  n                  Y                 o      )                   4           g      Y                  e            &      n                 z            $                                    "                                                                                         
                                                                       u                                                                       "      %                  .           ;      ;                  D           i      Q                  Z           o      g                  p           :       }                             @                   
                 h                                                                                                                    ,           #                                                                                                             .symtab .strtab .shstrtab .rela.text .data .bss .rela.rodata .rela.debug_info .debug_abbrev .debug_loc .rela.debug_aranges .rela.debug_line .debug_str .comment .note.GNU-stack .rela.debug_frame                                                                                            @       ,                                    @               5      0                           &                     l                                      ,                     l                                      6                     p        (                             1      @               6                                C                      p(      @                             >      @               7      H                          O                      +                                    ]                      ,      Y                              m                      -      0                              h      @               =      0                                                 7-                                    |      @               >                                       0               -                                        0               1      2                                                   1                                                           1      (                                    @                >      0                                                 2      H         "                 	                      X5                                                          P>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            INDX( 	                 (             .                     ?    p `     8    B33%C3B3                     . b u i l t - i n . o . c m d               p `     8    B33%C3B3                     . b u i l t - i n . o . c m d               8     A3p34VB3 A30      /               m t _ b o o t _ r e a s o n . s u                   p34VB3 A30      /               m t _ b o o t _ r e a s o n  s u                   x d     8     A3p34VB3 A30      /               m t _ b o o t _ r e a s o n . s u                   8     A3p34VB3 A30      /               m t _ b o o t _ r e a s o n . s u                    A3p34VB3 A30      /               m t _ b o o t _ r e a s o n . s u                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            cmd_drivers/net/wireless/bcmdhd/hnd_pktq.o := /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/aarch64-linux-gnu-gcc -Wp,-MD,drivers/net/wireless/bcmdhd/.hnd_pktq.o.d  -nostdinc -isystem /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/../lib/gcc/aarch64-linux-gnu/7.3.1/include -I../arch/arm64/include -Iarch/arm64/include/generated  -I../include -Iinclude -I../arch/arm64/include/uapi -Iarch/arm64/include/generated/uapi -I../include/uapi -Iinclude/generated/uapi -include ../include/linux/kconfig.h   -I../drivers/net/wireless/bcmdhd -Idrivers/net/wireless/bcmdhd -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -mgeneral-regs-only -fno-pic -fstack-usage -mpc-relative-literal-loads -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -fno-PIE -Os -Wno-maybe-uninitialized -fno-store-merging -Wno-misleading-indentation -Wno-duplicate-decl-specifier -Wno-logical-not-parentheses --param=allow-store-data-races=0 -Werror=frame-larger-than=1 -Wframe-larger-than=1400 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -DCC_HAVE_ASM_GOTO   -I/include   -I/home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out  -I../../drivers/misc/mediatek/include/ -I../drivers/misc/mediatek/include/ -Wall -w -Wstrict-prototypes -Dlinux -DLINUX -DBCMDRIVER -DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DBCMFILEIMAGE -DDHDTHREAD -DSHOW_EVENTS -DBCMDBG -DWLP2P -DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT -DKEEP_ALIVE -DCSCAN -DPKT_FILTER_SUPPORT -DEMBEDDED_PLATFORM -DPNO_SUPPORT -DSHOW_LOGTRACE -DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT -DCUSTOMER_HW2 -DGET_CUSTOM_MAC_ENABLE -DWL_CFG80211 -DBCMASSERT_LOG -DCUSTOM_KEEP_ALIVE_SETTING=28000 -DVSDB -DWL_SCB_TIMEOUT=10 -DWLTDLS -DWLTDLS_AUTO_ENABLE -DCUSTOM_TDLS_IDLE_MODE_SETTING=40000 -DCUSTOM_TDLS_RSSI_THRESHOLD_HIGH=-60 -DCUSTOM_TDLS_RSSI_THRESHOLD_LOW=-70 -DROAM_AP_ENV_DETECTION -DROAM_ENABLE -DROAM_API -DENABLE_FW_ROAM_SUSPEND -DCUSTOM_ROAM_TRIGGER_SETTING=-75 -DCUSTOM_ROAM_DELTA_SETTING=10 -DSUPPORT_PM2_ONLY -DCUSTOM_PNO_EVENT_LOCK_xTIME=10 -DMIRACAST_AMPDU_SIZE=8 -DGSCAN_SUPPORT -DWL_VENDOR_EXT_SUPPORT -DLINKSTAT_SUPPORT -DDHD_USE_EARLYSUSPEND -DESCAN_RESULT_PATCH -DWL_SCHED_SCAN -DDHD_OF_SUPPORT -DIOCTL_RESP_TIMEOUT=5000 -DWAIT_DEQUEUE -DCONFIG_CONTROL_PM -DDHD_USE_IDLECOUNT -DDHDENABLE_TAILPAD -DCUSTOM_SUSPEND_BCN_LI_DTIM=2 -DMAX_DTIM_ALLOWED_INTERVAL=600 -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST -DWL_CFG80211_STA_EVENT -DWL_IFACE_COMB_NUM_CHANNELS -DWL_ENABLE_P2P_IF -DWL_CFG80211_ACL -DDISABLE_11H_SOFTAP -DSET_RANDOM_MAC_SOFTAP -DCUSTOM_FORCE_NODFS_FLAG -DCUSTOM_SET_SHORT_DWELL_TIME -DUSE_WL_TXBF -DUSE_WL_FRAMEBURST -DCUSTOM_DPC_CPUCORE=0 -DMAX_AP_CLIENT_CNT=10 -DMAX_GO_CLIENT_CNT=5 -DCONFIG_DTS -DWL11U -DMFP -DDHD_ENABLE_LPC -DCUSTOM_COUNTRY_CODE -DDHD_WAKE_STATUS -DDHD_WAKE_RX_STATUS -DDHD_WAKE_EVENT_STATUS -DRTT_SUPPORT -DRTT_DEBUG -DBDC -DOOB_INTR_ONLY -DHW_OOB -DDHD_BCMEVENTS -DMMC_SDIO_ABORT -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR -DCUSTOM_AMPDU_MPDU=16 -DCUSTOM_AMPDU_BA_WSIZE=64 -DCUSTOM_GLOM_SETTING=8 -DCUSTOM_RXCHAIN=1 -DUSE_DYNAMIC_F2_BLKSIZE -DDYNAMIC_F2_BLKSIZE_FOR_NONLEGACY=256 -DBCMSDIOH_TXGLOM -DCUSTOM_TXGLOM=1 -DBCMSDIOH_TXGLOM_HIGHSPEED -DDHDTCPACK_SUPPRESS -DRXFRAME_THREAD -DREPEAT_READFRAME -DCUSTOM_MAX_TXGLOM_SIZE=64 -DMAX_HDR_READ=128 -DDHD_FIRSTREAD=128 -DCUSTOM_SDIO_F2_BLKSIZE=256 -DDHD_TXBOUND=64 -DDHD_RXBOUND=64 -DCUSTOM_BCN_TIMEOUT_SETTING=5 -DWLFC_STATE_PREALLOC -DDHD_8021X_DUMP -DEAPOL_PKT_PRIO -DENABLE_INSMOD_NO_FW_LOAD -DUSE_LATE_INITCALL_SYNC -DDHD_DEBUG -DSRCBASE=\"drivers/net/wireless/bcmdhd\"  -I../drivers/net/wireless/bcmdhd/include/ -Idrivers/net/wireless/bcmdhd/include/  -I../drivers/net/wireless/bcmdhd/ -Idrivers/net/wireless/bcmdhd/    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(hnd_pktq)"  -D"KBUILD_MODNAME=KBUILD_STR(bcmdhd)" -c -o drivers/net/wireless/bcmdhd/hnd_pktq.o ../drivers/net/wireless/bcmdhd/hnd_pktq.c

source_drivers/net/wireless/bcmdhd/hnd_pktq.o := ../drivers/net/wireless/bcmdhd/hnd_pktq.c

deps_drivers/net/wireless/bcmdhd/hnd_pktq.o := \
  ../drivers/net/wireless/bcmdhd/include/typedefs.h \
  include/generated/uapi/linux/version.h \
  ../include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
    $(wildcard include/config/64bit.h) \
  ../include/uapi/linux/types.h \
  arch/arm64/include/generated/asm/types.h \
  ../include/uapi/asm-generic/types.h \
  ../include/asm-generic/int-ll64.h \
  ../include/uapi/asm-generic/int-ll64.h \
  ../arch/arm64/include/uapi/asm/bitsperlong.h \
  ../include/asm-generic/bitsperlong.h \
  ../include/uapi/asm-generic/bitsperlong.h \
  ../include/uapi/linux/posix_types.h \
  ../include/linux/stddef.h \
  ../include/uapi/linux/stddef.h \
  ../include/linux/compiler.h \
    $(wildcard include/config/sparse/rcu/pointer.h) \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
    $(wildcard include/config/kprobes.h) \
  ../include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
    $(wildcard include/config/gcov/kernel.h) \
    $(wildcard include/config/arch/use/builtin/bswap.h) \
  ../arch/arm64/include/uapi/asm/posix_types.h \
  ../include/uapi/asm-generic/posix_types.h \
  ../drivers/net/wireless/bcmdhd/include/bcmdefs.h \
  ../drivers/net/wireless/bcmdhd/include/osl.h \
  ../drivers/net/wireless/bcmdhd/include/osl_decl.h \
  ../drivers/net/wireless/bcmdhd/include/linux_osl.h \
    $(wildcard include/config/mmc/msm7x00a.h) \
    $(wildcard include/config/dhd/use/static/buf.h) \
    $(wildcard include/config/nf/conntrack/mark.h) \
  ../drivers/net/wireless/bcmdhd/include/bcmsdh.h \
  ../drivers/net/wireless/bcmdhd/include/linuxver.h \
    $(wildcard include/config/net/radio.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/rfkill.h) \
  ../include/linux/module.h \
    $(wildcard include/config/sysfs.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/unused/symbols.h) \
    $(wildcard include/config/module/sig.h) \
    $(wildcard include/config/generic/bug.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/debug/set/module/ronx.h) \
  ../include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  ../include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  ../include/uapi/linux/const.h \
  ../include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/atomic/sleep.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/panic/timeout.h) \
    $(wildcard include/config/ring/buffer.h) \
  /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/lib/gcc/aarch64-linux-gnu/7.3.1/include/stdarg.h \
  ../include/linux/linkage.h \
  ../include/linux/stringify.h \
  ../include/linux/export.h \
    $(wildcard include/config/have/underscore/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
  ../arch/arm64/include/asm/linkage.h \
  ../include/linux/bitops.h \
  ../arch/arm64/include/asm/bitops.h \
  ../arch/arm64/include/asm/barrier.h \
  ../include/asm-generic/bitops/builtin-__ffs.h \
  ../include/asm-generic/bitops/builtin-ffs.h \
  ../include/asm-generic/bitops/builtin-__fls.h \
  ../include/asm-generic/bitops/builtin-fls.h \
  ../include/asm-generic/bitops/ffz.h \
  ../include/asm-generic/bitops/fls64.h \
  ../include/asm-generic/bitops/find.h \
    $(wildcard include/config/generic/find/first/bit.h) \
  ../include/asm-generic/bitops/sched.h \
  ../include/asm-generic/bitops/hweight.h \
  ../include/asm-generic/bitops/arch_hweight.h \
  ../include/asm-generic/bitops/const_hweight.h \
  ../include/asm-generic/bitops/lock.h \
  ../include/asm-generic/bitops/non-atomic.h \
  ../include/asm-generic/bitops/le.h \
  ../arch/arm64/include/uapi/asm/byteorder.h \
  ../include/linux/byteorder/little_endian.h \
  ../include/uapi/linux/byteorder/little_endian.h \
  ../include/linux/swab.h \
  ../include/uapi/linux/swab.h \
  arch/arm64/include/generated/asm/swab.h \
  ../include/uapi/asm-generic/swab.h \
  ../include/linux/byteorder/generic.h \
  ../include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  ../include/linux/typecheck.h \
  ../include/linux/printk.h \
    $(wildcard include/config/mt/printk/uart/console.h) \
    $(wildcard include/config/mtk/aee/feature.h) \
    $(wildcard include/config/printk/mt/prefix.h) \
    $(wildcard include/config/mt/eng/build.h) \
    $(wildcard include/config/log/too/much/warning.h) \
    $(wildcard include/config/message/loglevel/default.h) \
    $(wildcard include/config/early/printk.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
  ../include/linux/init.h \
    $(wildcard include/config/broken/rodata.h) \
    $(wildcard include/config/lto.h) \
  ../include/linux/kern_levels.h \
  ../include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  ../include/uapi/linux/kernel.h \
  ../include/uapi/linux/sysinfo.h \
  ../arch/arm64/include/asm/cache.h \
  ../arch/arm64/include/asm/cachetype.h \
  ../arch/arm64/include/asm/cputype.h \
  ../include/linux/dynamic_debug.h \
  ../include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  ../include/uapi/linux/string.h \
  ../arch/arm64/include/asm/string.h \
  ../include/linux/errno.h \
  ../include/uapi/linux/errno.h \
  arch/arm64/include/generated/asm/errno.h \
  ../include/uapi/asm-generic/errno.h \
  ../include/uapi/asm-generic/errno-base.h \
  ../include/linux/stat.h \
  ../arch/arm64/include/asm/stat.h \
    $(wildcard include/config/compat.h) \
  ../arch/arm64/include/uapi/asm/stat.h \
  ../include/uapi/asm-generic/stat.h \
  ../arch/arm64/include/asm/compat.h \
  ../include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/prove/rcu.h) \
    $(wildcard include/config/no/hz/common.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/preempt/count.h) \
    $(wildcard include/config/sched/autogroup.h) \
    $(wildcard include/config/virt/cpu/accounting/native.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/fanotify.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/mtk/sched/cmp/tgs.h) \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/disable/cpu/sched/domain/balance.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/mtk/sched/cmp.h) \
    $(wildcard include/config/sched/hmp.h) \
    $(wildcard include/config/sched/hmp/prio/filter.h) \
    $(wildcard include/config/hmp/tracer.h) \
    $(wildcard include/config/mtprof/cputime.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/mt/rt/throttle/mon.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/mt/sched/trace.h) \
    $(wildcard include/config/mt/sched/debug.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/preempt/notifiers.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/preempt/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/tasks/rcu.h) \
    $(wildcard include/config/compat/brk.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/virt/cpu/accounting/gen.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/debug/mutexes.h) \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/numa/balancing.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/memcg.h) \
    $(wildcard include/config/uprobes.h) \
    $(wildcard include/config/bcache.h) \
    $(wildcard include/config/preempt/monitor.h) \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/irq/time/accounting.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/no/hz/full.h) \
    $(wildcard include/config/proc/fs.h) \
    $(wildcard include/config/stack/growsup.h) \
    $(wildcard include/config/debug/stack/usage.h) \
    $(wildcard include/config/preempt.h) \
  ../include/uapi/linux/sched.h \
  ../include/linux/sched/prio.h \
  ../arch/arm64/include/uapi/asm/param.h \
  ../include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  ../include/uapi/asm-generic/param.h \
  ../include/linux/capability.h \
  ../include/uapi/linux/capability.h \
  ../include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  ../include/linux/timex.h \
  ../include/uapi/linux/timex.h \
  ../include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  ../include/linux/seqlock.h \
    $(wildcard include/config/debug/lock/alloc.h) \
  ../include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
  ../include/linux/preempt.h \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/context/tracking.h) \
  arch/arm64/include/generated/asm/preempt.h \
  ../include/asm-generic/preempt.h \
  ../include/linux/thread_info.h \
  ../include/linux/bug.h \
  arch/arm64/include/generated/asm/bug.h \
  ../include/asm-generic/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  ../arch/arm64/include/asm/memory.h \
    $(wildcard include/config/arm64/va/bits.h) \
  arch/arm64/include/generated/asm/sizes.h \
  ../include/asm-generic/sizes.h \
  ../include/linux/sizes.h \
  ../include/asm-generic/memory_model.h \
    $(wildcard include/config/flatmem.h) \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  ../arch/arm64/include/asm/thread_info.h \
    $(wildcard include/config/arm64/64k/pages.h) \
  ../include/linux/irqflags.h \
    $(wildcard include/config/mtprof.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  ../arch/arm64/include/asm/irqflags.h \
  ../arch/arm64/include/asm/ptrace.h \
    $(wildcard include/config/cpu/big/endian.h) \
  ../arch/arm64/include/uapi/asm/ptrace.h \
  ../arch/arm64/include/asm/hwcap.h \
  ../arch/arm64/include/uapi/asm/hwcap.h \
  ../include/linux/bottom_half.h \
  ../include/linux/preempt_mask.h \
  ../include/linux/spinlock_types.h \
  ../arch/arm64/include/asm/spinlock_types.h \
  ../include/linux/lockdep.h \
    $(wildcard include/config/lock/stat.h) \
  ../include/linux/rwlock_types.h \
  ../arch/arm64/include/asm/spinlock.h \
  ../arch/arm64/include/asm/processor.h \
  ../arch/arm64/include/asm/fpsimd.h \
  ../arch/arm64/include/asm/hw_breakpoint.h \
    $(wildcard include/config/have/hw/breakpoint.h) \
  ../include/linux/rwlock.h \
  ../include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/uninline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  ../include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  ../include/linux/atomic.h \
    $(wildcard include/config/arch/has/atomic/or.h) \
    $(wildcard include/config/generic/atomic64.h) \
  ../arch/arm64/include/asm/atomic.h \
  ../arch/arm64/include/asm/cmpxchg.h \
  ../include/asm-generic/atomic-long.h \
  ../include/linux/math64.h \
    $(wildcard include/config/arch/supports/int128.h) \
  arch/arm64/include/generated/asm/div64.h \
  ../include/asm-generic/div64.h \
  ../include/linux/time64.h \
  ../include/uapi/linux/time.h \
  ../include/uapi/linux/param.h \
  ../arch/arm64/include/asm/timex.h \
  ../arch/arm64/include/asm/arch_timer.h \
  ../include/clocksource/arm_arch_timer.h \
    $(wildcard include/config/arm/arch/timer.h) \
  ../include/linux/clocksource.h \
    $(wildcard include/config/arch/clocksource/data.h) \
    $(wildcard include/config/clocksource/watchdog.h) \
    $(wildcard include/config/clksrc/of.h) \
  ../include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  ../include/linux/ktime.h \
  ../include/linux/jiffies.h \
  ../include/linux/timekeeping.h \
  ../include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  ../arch/arm64/include/asm/io.h \
  ../include/linux/blk_types.h \
    $(wildcard include/config/blk/cgroup.h) \
    $(wildcard include/config/blk/dev/integrity.h) \
  ../arch/arm64/include/asm/pgtable.h \
    $(wildcard include/config/transparent/hugepage.h) \
    $(wildcard include/config/have/rcu/table/free.h) \
    $(wildcard include/config/arm64/pgtable/levels.h) \
  ../arch/arm64/include/asm/proc-fns.h \
  ../arch/arm64/include/asm/page.h \
    $(wildcard include/config/have/arch/pfn/valid.h) \
  ../arch/arm64/include/asm/pgtable-types.h \
  ../include/asm-generic/pgtable-nopud.h \
  ../include/asm-generic/getorder.h \
  ../arch/arm64/include/asm/pgtable-hwdef.h \
  ../include/asm-generic/pgtable.h \
    $(wildcard include/config/have/arch/soft/dirty.h) \
  ../include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
    $(wildcard include/config/have/cmpxchg/double.h) \
    $(wildcard include/config/have/aligned/struct/page.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
    $(wildcard include/config/compaction.h) \
  ../include/linux/auxvec.h \
  ../include/uapi/linux/auxvec.h \
  ../arch/arm64/include/uapi/asm/auxvec.h \
  ../include/linux/rbtree.h \
  ../include/linux/rwsem.h \
    $(wildcard include/config/rwsem/spin/on/owner.h) \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  ../include/linux/osq_lock.h \
  arch/arm64/include/generated/asm/rwsem.h \
  ../include/asm-generic/rwsem.h \
  ../include/linux/completion.h \
  ../include/linux/wait.h \
  arch/arm64/include/generated/asm/current.h \
  ../include/asm-generic/current.h \
  ../include/uapi/linux/wait.h \
  ../include/linux/cpumask.h \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  ../include/linux/bitmap.h \
  ../include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/guard.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  ../include/linux/uprobes.h \
  ../include/linux/page-flags-layout.h \
  ../include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  include/generated/bounds.h \
  ../arch/arm64/include/asm/sparsemem.h \
  ../arch/arm64/include/asm/mmu.h \
  arch/arm64/include/generated/asm/early_ioremap.h \
  ../include/asm-generic/early_ioremap.h \
    $(wildcard include/config/generic/early/ioremap.h) \
  ../arch/arm64/include/asm/alternative.h \
  ../arch/arm64/include/asm/cpufeature.h \
  ../include/xen/xen.h \
    $(wildcard include/config/xen.h) \
    $(wildcard include/config/xen/dom0.h) \
    $(wildcard include/config/xen/pvh.h) \
  ../include/asm-generic/iomap.h \
    $(wildcard include/config/has/ioport/map.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/generic/iomap.h) \
  ../include/asm-generic/pci_iomap.h \
    $(wildcard include/config/no/generic/pci/ioport/map.h) \
    $(wildcard include/config/generic/pci/iomap.h) \
  ../include/asm-generic/timex.h \
  ../include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  ../include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/movable/node.h) \
  ../include/linux/cputime.h \
  arch/arm64/include/generated/asm/cputime.h \
  ../include/asm-generic/cputime.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  ../include/asm-generic/cputime_jiffies.h \
  ../include/linux/smp.h \
    $(wildcard include/config/profile/cpu.h) \
    $(wildcard include/config/mtk/cpu/hotplug/debug/3.h) \
    $(wildcard include/config/mtk/ram/console.h) \
  ../include/linux/llist.h \
    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
  ../arch/arm64/include/asm/smp.h \
  ../include/linux/sem.h \
  ../include/linux/rcupdate.h \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/rcu/trace.h) \
    $(wildcard include/config/rcu/stall/common.h) \
    $(wildcard include/config/rcu/user/qs.h) \
    $(wildcard include/config/rcu/nocb/cpu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
    $(wildcard include/config/rcu/boost.h) \
    $(wildcard include/config/rcu/nocb/cpu/all.h) \
    $(wildcard include/config/no/hz/full/sysidle.h) \
  ../include/linux/rcutree.h \
  ../include/uapi/linux/sem.h \
  ../include/linux/ipc.h \
  ../include/linux/uidgid.h \
    $(wildcard include/config/user/ns.h) \
  ../include/linux/highuid.h \
  ../include/uapi/linux/ipc.h \
  arch/arm64/include/generated/asm/ipcbuf.h \
  ../include/uapi/asm-generic/ipcbuf.h \
  arch/arm64/include/generated/asm/sembuf.h \
  ../include/uapi/asm-generic/sembuf.h \
  ../include/linux/shm.h \
  ../include/uapi/linux/shm.h \
  arch/arm64/include/generated/asm/shmbuf.h \
  ../include/uapi/asm-generic/shmbuf.h \
  ../arch/arm64/include/asm/shmparam.h \
  ../include/uapi/asm-generic/shmparam.h \
  ../include/linux/signal.h \
    $(wildcard include/config/old/sigaction.h) \
  ../include/uapi/linux/signal.h \
  ../arch/arm64/include/uapi/asm/signal.h \
  ../include/asm-generic/signal.h \
  ../include/uapi/asm-generic/signal.h \
  ../include/uapi/asm-generic/signal-defs.h \
  ../arch/arm64/include/uapi/asm/sigcontext.h \
  ../arch/arm64/include/uapi/asm/siginfo.h \
  ../include/asm-generic/siginfo.h \
  ../include/uapi/asm-generic/siginfo.h \
  ../include/linux/pid.h \
  ../include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  ../include/linux/mmdebug.h \
    $(wildcard include/config/debug/vm.h) \
    $(wildcard include/config/debug/virtual.h) \
  ../include/linux/pfn.h \
  ../arch/arm64/include/asm/percpu.h \
  ../include/asm-generic/percpu.h \
  ../include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  ../include/linux/topology.h \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
  ../include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/cma.h) \
    $(wildcard include/config/memory/isolation.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/have/memblock/node/map.h) \
    $(wildcard include/config/mtk/memcfg.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/page/extension.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  ../include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  ../include/linux/memory_hotplug.h \
    $(wildcard include/config/memory/hotremove.h) \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/have/bootmem/info/node.h) \
  ../include/linux/notifier.h \
  ../include/linux/mutex.h \
    $(wildcard include/config/mutex/spin/on/owner.h) \
  ../include/linux/srcu.h \
  ../include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  ../arch/arm64/include/asm/topology.h \
    $(wildcard include/config/arm/cpu/topology.h) \
    $(wildcard include/config/mtk/cpu/topology.h) \
  ../include/asm-generic/topology.h \
  ../include/linux/proportions.h \
  ../include/linux/percpu_counter.h \
  ../include/linux/gfp.h \
    $(wildcard include/config/dmauser/pages.h) \
    $(wildcard include/config/zone/movable/cma.h) \
    $(wildcard include/config/pm/sleep.h) \
  ../include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
    $(wildcard include/config/have/arch/seccomp/filter.h) \
    $(wildcard include/config/seccomp/filter.h) \
  ../include/uapi/linux/seccomp.h \
  ../arch/arm64/include/asm/seccomp.h \
  ../arch/arm64/include/asm/unistd.h \
  ../arch/arm64/include/uapi/asm/unistd.h \
  ../include/asm-generic/unistd.h \
  ../include/uapi/asm-generic/unistd.h \
  ../include/asm-generic/seccomp.h \
  ../include/uapi/linux/unistd.h \
  ../include/linux/rculist.h \
  ../include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  ../include/linux/resource.h \
  ../include/uapi/linux/resource.h \
  arch/arm64/include/generated/asm/resource.h \
  ../include/asm-generic/resource.h \
  ../include/uapi/asm-generic/resource.h \
  ../include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
    $(wildcard include/config/timerfd.h) \
  ../include/linux/timerqueue.h \
  ../include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  ../include/linux/latencytop.h \
  ../include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
    $(wildcard include/config/security.h) \
  ../include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  ../include/linux/sysctl.h \
  ../include/uapi/linux/sysctl.h \
  ../include/linux/assoc_array.h \
    $(wildcard include/config/associative/array.h) \
  ../include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  ../include/uapi/linux/magic.h \
  ../include/linux/ptrace.h \
  ../include/linux/err.h \
  ../include/linux/pid_namespace.h \
    $(wildcard include/config/pid/ns.h) \
  ../include/linux/mm.h \
    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
    $(wildcard include/config/mem/soft/dirty.h) \
    $(wildcard include/config/x86.h) \
    $(wildcard include/config/ppc.h) \
    $(wildcard include/config/parisc.h) \
    $(wildcard include/config/metag.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/shmem.h) \
    $(wildcard include/config/debug/vm/rb.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/hugetlbfs.h) \
  ../include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  ../include/linux/range.h \
  ../include/linux/bit_spinlock.h \
  ../include/linux/shrinker.h \
  ../include/linux/page_ext.h \
    $(wildcard include/config/page/owner.h) \
  ../include/linux/stacktrace.h \
    $(wildcard include/config/stacktrace.h) \
    $(wildcard include/config/user/stacktrace/support.h) \
  ../include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/memory/failure.h) \
    $(wildcard include/config/toi/incremental.h) \
  ../include/linux/huge_mm.h \
  ../include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
    $(wildcard include/config/debug/tlbflush.h) \
    $(wildcard include/config/debug/vm/vmacache.h) \
  ../include/linux/vm_event_item.h \
    $(wildcard include/config/migration.h) \
    $(wildcard include/config/memory/balloon.h) \
    $(wildcard include/config/balloon/compaction.h) \
  ../include/linux/nsproxy.h \
  ../include/linux/kref.h \
  ../include/uapi/linux/ptrace.h \
  ../include/uapi/linux/stat.h \
  ../include/linux/kmod.h \
  ../include/linux/elf.h \
  ../arch/arm64/include/asm/elf.h \
  arch/arm64/include/generated/asm/user.h \
  ../include/asm-generic/user.h \
  ../include/uapi/linux/elf.h \
  ../include/uapi/linux/elf-em.h \
  ../include/linux/kobject.h \
    $(wildcard include/config/uevent/helper.h) \
    $(wildcard include/config/debug/kobject/release.h) \
  ../include/linux/sysfs.h \
  ../include/linux/kernfs.h \
    $(wildcard include/config/kernfs.h) \
  ../include/linux/idr.h \
  ../include/linux/kobject_ns.h \
  ../include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ppc64.h) \
  ../include/linux/jump_label.h \
    $(wildcard include/config/jump/label.h) \
  ../arch/arm64/include/asm/module.h \
  ../include/asm-generic/module.h \
    $(wildcard include/config/have/mod/arch/specific.h) \
    $(wildcard include/config/modules/use/elf/rel.h) \
    $(wildcard include/config/modules/use/elf/rela.h) \
  ../include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/memcg/kmem.h) \
    $(wildcard include/config/slab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
  ../include/linux/kmemleak.h \
    $(wildcard include/config/debug/kmemleak.h) \
  ../include/linux/pci.h \
    $(wildcard include/config/pci/iov.h) \
    $(wildcard include/config/pcieaspm.h) \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/pci/ats.h) \
    $(wildcard include/config/pci/domains/generic.h) \
    $(wildcard include/config/pcieportbus.h) \
    $(wildcard include/config/pcieaer.h) \
    $(wildcard include/config/pcie/ecrc.h) \
    $(wildcard include/config/ht/irq.h) \
    $(wildcard include/config/pci/domains.h) \
    $(wildcard include/config/pci/quirks.h) \
    $(wildcard include/config/hibernate/callbacks.h) \
    $(wildcard include/config/pci/mmconfig.h) \
    $(wildcard include/config/hotplug/pci.h) \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/eeh.h) \
  ../include/linux/mod_devicetable.h \
  ../include/linux/uuid.h \
  ../include/uapi/linux/uuid.h \
  ../include/linux/ioport.h \
  ../include/linux/device.h \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/acpi.h) \
    $(wildcard include/config/pinctrl.h) \
    $(wildcard include/config/dma/cma.h) \
    $(wildcard include/config/devtmpfs.h) \
    $(wildcard include/config/sysfs/deprecated.h) \
  ../include/linux/klist.h \
  ../include/linux/pinctrl/devinfo.h \
    $(wildcard include/config/pm.h) \
  ../include/linux/pinctrl/consumer.h \
  ../include/linux/seq_file.h \
  ../include/linux/pinctrl/pinctrl-state.h \
  ../include/linux/pm.h \
    $(wildcard include/config/vt/console/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/clk.h) \
    $(wildcard include/config/pm/generic/domains.h) \
  ../include/linux/ratelimit.h \
  ../arch/arm64/include/asm/device.h \
    $(wildcard include/config/iommu/api.h) \
  ../include/linux/pm_wakeup.h \
  ../include/linux/io.h \
  ../include/uapi/linux/pci.h \
  ../include/uapi/linux/pci_regs.h \
  ../include/linux/pci_ids.h \
  ../arch/arm64/include/asm/pci.h \
  ../include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/arch/has/dma/set/coherent/mask.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  ../include/linux/dma-attrs.h \
  ../include/linux/dma-direction.h \
  ../include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
    $(wildcard include/config/arch/has/sg/chain.h) \
  arch/arm64/include/generated/asm/scatterlist.h \
  ../include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  ../arch/arm64/include/asm/dma-mapping.h \
  ../include/linux/vmalloc.h \
  ../include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  ../arch/arm64/include/asm/xen/hypervisor.h \
  ../arch/arm64/include/../../arm/include/asm/xen/hypervisor.h \
  ../include/asm-generic/dma-mapping-common.h \
  ../include/linux/kmemcheck.h \
  ../include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  ../include/asm-generic/pci-bridge.h \
  ../include/asm-generic/pci-dma-compat.h \
  ../include/linux/interrupt.h \
    $(wildcard include/config/irq/forced/threading.h) \
    $(wildcard include/config/generic/irq/probe.h) \
  ../include/linux/irqreturn.h \
  ../include/linux/irqnr.h \
  ../include/uapi/linux/irqnr.h \
  ../include/linux/hardirq.h \
  ../include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  ../include/linux/vtime.h \
  ../include/linux/context_tracking_state.h \
  ../include/linux/static_key.h \
  ../arch/arm64/include/asm/hardirq.h \
  ../arch/arm64/include/asm/irq.h \
  ../include/asm-generic/irq.h \
  ../include/linux/irq_cpustat.h \
  ../include/linux/kthread.h \
  ../include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/xps.h) \
    $(wildcard include/config/bql.h) \
    $(wildcard include/config/rfs/accel.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/net/rx/busy/poll.h) \
    $(wildcard include/config/libfcoe.h) \
    $(wildcard include/config/vlan/8021q.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/tipc.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/cgroup/net/prio.h) \
    $(wildcard include/config/net/flow/limit.h) \
  ../include/linux/pm_qos.h \
  ../include/linux/miscdevice.h \
  ../include/uapi/linux/major.h \
  ../include/linux/delay.h \
  arch/arm64/include/generated/asm/delay.h \
  ../include/asm-generic/delay.h \
  ../include/linux/prefetch.h \
  ../include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/enable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/rapidio/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  ../include/linux/uio.h \
  ../include/uapi/linux/uio.h \
  ../include/linux/dynamic_queue_limits.h \
  ../include/linux/ethtool.h \
  ../include/linux/compat.h \
    $(wildcard include/config/compat/old/sigaction.h) \
    $(wildcard include/config/odd/rt/sigaction.h) \
  ../include/linux/socket.h \
  arch/arm64/include/generated/asm/socket.h \
  ../include/uapi/asm-generic/socket.h \
  arch/arm64/include/generated/asm/sockios.h \
  ../include/uapi/asm-generic/sockios.h \
  ../include/uapi/linux/sockios.h \
  ../include/uapi/linux/socket.h \
  ../include/uapi/linux/if.h \
  ../include/uapi/linux/hdlc/ioctl.h \
  ../include/linux/fs.h \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/ima.h) \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/fs/xip.h) \
  ../include/linux/kdev_t.h \
  ../include/uapi/linux/kdev_t.h \
  ../include/linux/dcache.h \
  ../include/linux/rculist_bl.h \
  ../include/linux/list_bl.h \
  ../include/linux/lockref.h \
    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
  ../include/linux/path.h \
  ../include/linux/list_lru.h \
  ../include/linux/radix-tree.h \
  ../include/linux/semaphore.h \
  ../include/uapi/linux/fiemap.h \
  ../include/linux/migrate_mode.h \
  ../include/linux/percpu-rwsem.h \
  ../include/uapi/linux/fs.h \
  ../include/uapi/linux/limits.h \
  ../include/uapi/linux/ioctl.h \
  arch/arm64/include/generated/asm/ioctl.h \
  ../include/asm-generic/ioctl.h \
  ../include/uapi/asm-generic/ioctl.h \
  ../include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  ../include/uapi/linux/dqblk_xfs.h \
  ../include/linux/dqblk_v1.h \
  ../include/linux/dqblk_v2.h \
  ../include/linux/dqblk_qtree.h \
  ../include/linux/projid.h \
  ../include/uapi/linux/quota.h \
  ../include/linux/nfs_fs_i.h \
  ../include/linux/fcntl.h \
  ../include/uapi/linux/fcntl.h \
  ../arch/arm64/include/uapi/asm/fcntl.h \
  ../include/uapi/asm-generic/fcntl.h \
  ../include/uapi/linux/aio_abi.h \
  ../include/uapi/linux/ethtool.h \
  ../include/linux/if_ether.h \
  ../include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
    $(wildcard include/config/netfilter/xt/target/trace.h) \
    $(wildcard include/config/nf/tables.h) \
    $(wildcard include/config/ip/vs.h) \
  ../include/linux/net.h \
  ../include/linux/random.h \
    $(wildcard include/config/arch/random.h) \
  ../include/uapi/linux/random.h \
  ../include/uapi/linux/net.h \
  ../include/linux/textsearch.h \
  ../include/net/checksum.h \
  ../arch/arm64/include/asm/uaccess.h \
  ../arch/arm64/include/asm/sysreg.h \
  ../arch/arm64/include/asm/compiler.h \
  arch/arm64/include/generated/asm/checksum.h \
  ../include/asm-generic/checksum.h \
  ../include/linux/netdev_features.h \
  ../include/net/flow_keys.h \
  ../include/uapi/linux/if_ether.h \
  ../include/net/net_namespace.h \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/ieee802154/6lowpan.h) \
    $(wildcard include/config/ip/sctp.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/nf/defrag/ipv6.h) \
    $(wildcard include/config/wext/core.h) \
  ../include/net/flow.h \
  ../include/linux/in6.h \
  ../include/uapi/linux/in6.h \
  ../include/uapi/linux/libc-compat.h \
  ../include/net/netns/core.h \
  ../include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  ../include/net/snmp.h \
  ../include/uapi/linux/snmp.h \
  ../include/linux/u64_stats_sync.h \
  ../include/net/netns/unix.h \
  ../include/net/netns/packet.h \
  ../include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/ip/route/classid.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  ../include/net/inet_frag.h \
  ../include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  ../include/net/dst_ops.h \
  ../include/net/netns/ieee802154_6lowpan.h \
  ../include/net/netns/sctp.h \
  ../include/net/netns/dccp.h \
  ../include/net/netns/netfilter.h \
  ../include/linux/proc_fs.h \
  ../include/linux/netfilter.h \
    $(wildcard include/config/nf/nat/needed.h) \
  ../include/linux/in.h \
  ../include/uapi/linux/in.h \
  ../include/uapi/linux/netfilter.h \
  ../include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  ../include/net/netns/conntrack.h \
    $(wildcard include/config/nf/conntrack/proc/compat.h) \
    $(wildcard include/config/nf/conntrack/events.h) \
    $(wildcard include/config/nf/conntrack/labels.h) \
  ../include/linux/list_nulls.h \
  ../include/linux/netfilter/nf_conntrack_tcp.h \
  ../include/uapi/linux/netfilter/nf_conntrack_tcp.h \
  ../include/net/netns/nftables.h \
  ../include/net/netns/xfrm.h \
  ../include/uapi/linux/xfrm.h \
  ../include/net/flowcache.h \
  ../include/linux/seq_file_net.h \
  ../include/net/dsa.h \
  ../include/linux/of.h \
    $(wildcard include/config/sparc.h) \
    $(wildcard include/config/of/dynamic.h) \
    $(wildcard include/config/attach/node.h) \
    $(wildcard include/config/detach/node.h) \
    $(wildcard include/config/add/property.h) \
    $(wildcard include/config/remove/property.h) \
    $(wildcard include/config/update/property.h) \
    $(wildcard include/config/of/resolve.h) \
  ../include/linux/property.h \
  ../include/linux/phy.h \
  ../include/linux/mii.h \
  ../include/uapi/linux/mii.h \
  ../include/linux/phy_fixed.h \
    $(wildcard include/config/fixed/phy.h) \
  ../include/net/netprio_cgroup.h \
  ../include/linux/cgroup.h \
  ../include/uapi/linux/cgroupstats.h \
  ../include/uapi/linux/taskstats.h \
  ../include/linux/percpu-refcount.h \
  ../include/linux/cgroup_subsys.h \
    $(wildcard include/config/cgroup/cpuacct.h) \
    $(wildcard include/config/cgroup/device.h) \
    $(wildcard include/config/cgroup/freezer.h) \
    $(wildcard include/config/cgroup/net/classid.h) \
    $(wildcard include/config/cgroup/bfqio.h) \
    $(wildcard include/config/cgroup/perf.h) \
    $(wildcard include/config/cgroup/hugetlb.h) \
    $(wildcard include/config/cgroup/debug.h) \
  ../include/uapi/linux/neighbour.h \
  ../include/linux/netlink.h \
  ../include/net/scm.h \
    $(wildcard include/config/security/network.h) \
  ../include/linux/security.h \
    $(wildcard include/config/fw/loader/user/helper.h) \
    $(wildcard include/config/security/path.h) \
    $(wildcard include/config/security/network/xfrm.h) \
    $(wildcard include/config/securityfs.h) \
    $(wildcard include/config/security/yama.h) \
    $(wildcard include/config/mtk/root/trace.h) \
  ../include/uapi/linux/netlink.h \
  ../include/uapi/linux/netdevice.h \
  ../include/uapi/linux/if_packet.h \
  ../include/linux/if_link.h \
  ../include/uapi/linux/if_link.h \
  ../include/linux/sched/rt.h \
  ../include/net/lib80211.h \
  ../include/linux/ieee80211.h \
    $(wildcard include/config/timeout.h) \
  ../drivers/net/wireless/bcmdhd/include/bcmutils.h \
  ../drivers/net/wireless/bcmdhd/include/hnd_pktq.h \
  ../drivers/net/wireless/bcmdhd/include/hnd_pktpool.h \
  ../drivers/net/wireless/bcmdhd/include/packed_section_start.h \
  ../drivers/net/wireless/bcmdhd/include/packed_section_end.h \

drivers/net/wireless/bcmdhd/hnd_pktq.o: $(deps_drivers/net/wireless/bcmdhd/hnd_pktq.o)

$(deps_drivers/net/wireless/bcmdhd/hnd_pktq.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                cmd_sound/pci/built-in.o :=  /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/aarch64-linux-gnu-ld -EL    -r -o sound/pci/built-in.o sound/pci/ac97/built-in.o sound/pci/ali5451/built-in.o sound/pci/asihpi/built-in.o sound/pci/au88x0/built-in.o sound/pci/aw2/built-in.o sound/pci/ctxfi/built-in.o sound/pci/ca0106/built-in.o sound/pci/cs46xx/built-in.o sound/pci/cs5535audio/built-in.o sound/pci/lola/built-in.o sound/pci/lx6464es/built-in.o sound/pci/echoaudio/built-in.o sound/pci/emu10k1/built-in.o sound/pci/hda/built-in.o sound/pci/ice1712/built-in.o sound/pci/korg1212/built-in.o sound/pci/mixart/built-in.o sound/pci/nm256/built-in.o sound/pci/oxygen/built-in.o sound/pci/pcxhr/built-in.o sound/pci/riptide/built-in.o sound/pci/rme9652/built-in.o sound/pci/trident/built-in.o sound/pci/ymfpci/built-in.o sound/pci/vx222/built-in.o 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF                                        @     @    QRCZ_  q! K *!# ?  qb B  B|`B  B #! q@|@!P`` X_                           X           int         ;                           G                  u8 U   u32 G   u64        ;                  lj       o|             -      	
                                  
;   B       7             G                     (4   
B            
                   -   
-          _      -       -       -             6          	     ,  -        	7        	-       	-       	-       	-       	-       	-       	-       	       G   	                            	      	      	      	3       
-  m 
    sh1 
   sh2 
                  X         d        R   m    l -                                             -       -              -       -                      fls -   x -     %  $ >  $ >  & I   :;I   :;I   I   'I  	 '  
I  !   4 :;I?<   <  4 :;I?<  'I   I  >I:;  (   :;   :;I8  .?:;'I@B   :;I  4 :;I    4 :;I  U  1RUXY   1  .:;'I    :;I                   P                ,                     X                                                                           $       <       @                       @       D       H       L                       X   '        ../lib ../include/asm-generic/bitops ../include/uapi/asm-generic ../include/asm-generic ../include/linux ../arch/arm64/include/asm  reciprocal_div.c   builtin-fls.h   int-ll64.h   int-ll64.h   types.h   init.h   cachetype.h   printk.h   kernel.h   reciprocal_div.h     	        O%$=&"!""/ uint64_t hex_asc_upper linux_banner panic_on_unrecovered_nmi long long unsigned int SYSTEM_RESTART panic_blink SYSTEM_HALT __rem GNU C89 7.3.1 20180522 -mlittle-endian -mgeneral-regs-only -mpc-relative-literal-loads -mabi=lp64 -g -Os -std=gnu90 -fno-strict-aliasing -fno-common -fstack-usage -fno-delete-null-pointer-checks -fno-PIE -fno-store-merging -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -fno-strict-overflow -fstack-check=no -fconserve-stack --param allow-store-data-races=0 long long int signed char __security_initcall_end saved_command_line SYSTEM_BOOTING long int kptr_restrict ../lib/reciprocal_div.c linux_proc_banner initcall_t file_operations printk_disable_uart unsigned int root_mountflags long unsigned int __u32 atomic_notifier_head console_printk SYSTEM_RUNNING short unsigned int reciprocal_value bool dmesg_restrict __con_initcall_end __base _max1 _max2 sysctl_panic_on_stackoverflow reset_devices system_state panic_timeout __security_initcall_start /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out panic_notifier_list kmsg_fops _Bool unsigned char system_states initcall_debug short int uint32_t SYSTEM_POWER_OFF _min1 _min2 __u64 oops_in_progress char panic_on_oops boot_command_line printk_delay_msec early_boot_irqs_disabled panic_on_io_nmi mach_panic_string mt_need_uart_console __icache_flags hex_asc __con_initcall_start late_time_init  GCC: (Linaro GCC 7.3-2018.05~dev) 7.3.1 20180522          x                X                                                                                                                                                                                                                                        
                                                                                                                                            X        reciprocal_div.c $x reciprocal_value                                                                        
                          )                    7                   >                  J                  Q            -      X                  _                  f            K      k                  x                  }                              =                   s                  o                                                                                                                  "                 -           9      C           
      N           Q      Y                 d                 o                 z           ~                                                                     i                 -                                  t                 |                                  u                                  a      -           c       >                 J                 V                 b           $       n           G      z                                             .                                  d                 <                 o                                   T                                                    	                  W                 ^      .           ^      8                   W                   w           0                                   {               
   0                                                 
   `                                                                   
                                                   4                                                            .symtab .strtab .shstrtab .text .data .bss .rela.debug_info .debug_abbrev .debug_loc .rela.debug_aranges .debug_ranges .rela.debug_line .debug_str .comment .note.GNU-stack .rela.debug_frame                                                                                       @       X                              !                                                           '                                                           1                                                          ,      @               8      h                          =                            v                             K                      !      #                              [                      D      0                              V      @                     0                           j                      t                                    }                            \                             x      @                                                      0               `                                        0                     2                                                   K                                                           P      (                                    @                     0                                                 x                                	                            &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                x|{|>CRn!ZrVti-Qn=%JiCRDA'3U sQS[:66y:&	
y>x~pis[GT>k2v_|8|fbIt~\	3t&1F<F%!!ADA n?	``AE!xM 8|H^zxqO`?'$n8i?=JER-K!}};GHZ->}	/l:;Z,7")uV`1n3{GmGEO>pp_{G_R }?pi)dG6KgOZ#/A_Wf2r"2%_&_vGjx~.?6:T]NXSmi+sIsBlMm[\0k[lmL\gk{;%ru6,#wlrZjk:Z]i-bkT&"6X:\TbEcdySgd8Llv/@ZUrkjpv%2W'tKW6,n A}Z.6l3 d$].)dG3yriU8'D7gfnx>[cTgWgo:s[qKa$}?3bVG@/=c1<	7!e@K:kZ)@`7MDi5&5	L'	6'#	I	MWla<|#1NwOc}QG1Ly8&Q1v8&g0v8j0JYbGw{Iw[-}S{~OqHqdPm,B|X,;#_kFfQzrOMT__*;%%Oqa)z>M:z>)L+mLkLM3%g!/4pn"%/)?{H~KU52gVY* 3\9K`t3G/3(5*Kg2sj<O]-jT7ap-*S5BhV(	B}Mmqm}-:-!ef.<C_>qoYUA
s"r>2,<*
slP^XMTw$-3i2Ea~6`pL72s03#*{euPDyju*DSBTa^5hBMh U5g!A#Xd. -l(eSlIf6rc d[b
zWJ><.=R!wYdV.3{L0<,|[ek#_&#=,|CT*9
\]t8B?$QKJ|WWWiuo11AQ{G}XD`#xj*X-"BSn2\bC<[ <J%t_>Ei\VTTzqEdTib~Gjk-7-t{_"N#|k)'n|J>y5l&T.W'\O_2~}*"f~66ED:
sd(|n/|R%^jdW.!S7T"v"4S	p	u&.Z6Z'z`zrL{!9RvJqBy&		2N['Nk'69Ve}0P4*oAMUquV5|P[U9#>[2I]`?,4]q3G8 xCXCFE"QyPMVUIBPNd(f(BBVb|;gQz/7:!`dyo<88?|*hU#F.=R`Cz!eC"m8Q!Z_4>L,-,xi=FVFVa1fifg<[7q?{#?-'MuYdxFO?N55WC3h3?2Q.;e(}86}qRv3v^eBXAXZGb}S{e{XEM]c7g2S]IzW(C|[5wq~0m2#S|HQs{XaSc1;ftE/gbquz{BnO2ThaA<~V3"B1f/
S27s,Y
P*ydW(7
Grp(:J>BTj5p#`}~i696:4KQfl,zoF0/Y$X2,"xUNxI,:fDBhC/wAU6//+L\OAoQSgo=YHD>Q2x4h~6n,>f^m=!Q+BZWU^6pn3:mV!7Ucgxsv$a@^g.fA]PE|O]Trr4j?tOkxk|VQfR'`3|5cKmf_/`=/ij'WU$*]]yBQ^eY{
jnUApcTE(n-}y>`s`ZBj)a)U5yU/8&8_x{y8Sm{JQ:1cnV=OuZ^d;.
jD9P5acPg{!\ 3O:a:7kw98WoN+
~I%VpPD$2VYyvj^/ie\8FzTiX&bD{xe5:q!FVcSvoDbCi|a;V
	]}yq9aL8GXV+dM#kt$Yjn(s{Dnho0_d.j2	v6Y(-cFG-6fF+FL~f>fTeh'cP+y~(n8|y;\Io1O0c\3$9#l}a6gJ&S^-xS\)6VXta.suKQm
pX,1*{5gJyyam9y2+3d|g*wu>	{Yk?Mb>7iaE,ymRduov=,kHQ6tA>9/<IEH(9%ib7ax#j?E4Gkg8/=)yt3'GXX<5RJBiO_j=J(^#_Iun+N^A9:W01@BHy?P+Uc'QU$HK59) %%07QC7&YmtN01eZL;48]y%coQJggdc /-?78<VG9\=7PMRA>{xO}".Yx0'"L3_Y.\e9QdV?tAY&ia$T2=v	',
X?N*XOevlC?<e%6,+[u~t8{{<\=`&}eKK]aurDf3PS<o7+~\Q&0Uy8rcnFt=fnat]{xjnq'F3$Pd^NOKhu#F^%scnN!,Bnl6fMj 78 z1cK<UJQ+q3eM/h9uu` Zf|;4{1~3x~"Q/k{u&@1WsN}ZI=bUr3O"?;_>]N3:qmFk^3Km@xV])C[neBj+Fs >L!0>Pt}nth_87t$u&mn|K6t7Kv^>r<.atH&GhX'FD&.fM2hz$rqMDP"JFfZ)5Wq`sCAN=:S ci/E\y&eG$/$=4LP7>{ru#&@
cCwhn$U5N{i$Yj?vnh*z*]{sOs2zWf^n.KnkH$F?8p|kZ; '?lrQEp@+Lp?c~s|P @Xt[^-` <=gn`+swrz'21*F#YOWksxr.Z(o+>	9-8l~QHK~@t,J;Sx} ilHR:jd#5Qh\ps]#R#gr\:[m/8#InwbD Lbbwrn__xL[?~"1rH\!T0|;J2Kz8A; F,lL@eyfvY D8(?+0:M^e9SG!$sj}TO;T5,5P0N;3*94zo5MXh:mqV*TaoobG	; W)vU7H-w-?-`O
Jj=k4X;Swj}cAM= 
=h{=6tWcODSpR6{-Rd!s"T*HiC<|N8] ? i'1Kk=t>KoW(;V7hB)5Yz\nRnO\MLK3?60j7F}7G9|$;WeoQ+i
i",K+)+ZRIHX)<IGT1Yz'yy#|iFWwsi-/jsCw^SyNiX)39	o7V#4:=)X>s-uj_d;PO-+f18}lV{oiFelyur(Xo5M^xn~@#ub{D#]Sn =oVQ*oLAgKT&.zh+^jMXAq$YTR#O/@kh%5H`*bjCxm3wo%{}NOPl|^6miEo6=^f9qjvWcrl|[MfiZ5n)3W!AsMU	=IBh `?urWDv{	_js#~`/T	)nnp	9++7I547uW@{5+5!X'5
<
pBPG{Y&$M=W?wx.d8bC`<gVhi<7
m8	83?:kw?g,VR,]~oW^?^~ p[3Zqn6f>X[s~2p~$v|h|r$;c	e[l+{mg/3{n?^f 3+;;F}Q5;N(;199#.>Z.v)cina)Q_I}
]
}S+W(tB_T/BWh\YEQqw+Q>N(tB
7.PBW(]m
mURZH?T-
]P+Z)F
5+^9

-WTNQ$NTx*TRVhBG)4GY
PhBu
(TT([[gs 35@l`@y@>p 8`"0	(iL`0p_n  u|`X14V`	`
7< O ^`,xxM? gOccY=?#yg$'Jan j
o@$8+pV>U/g	Ts(vU Og|_=|7}	s?Mrvu8?(_Q_@_Eo==\8 ]?P=77u(wpm/#]8n<a{#q=IN~(Sq}7}nF%N|'gkwP<zTA.
Qk@7^!?4I	?|~ }@$0_pe++k;^wT^!<Td#, [K \+LIoMW.M*f.|bSUrGmmw,rLDYRSWY5`K-M;%s|nl P&Tw3NiDV5\SuZEC|p\&*I))
6+:+Pna;hoR&_CK&."5wt3J|TRRKy[U-Jk+!mNrX)w)W}WJ]xT?_oiZ|;J&/4WW^vd.J/jWCsWd	?x)yqLu:}3r[G%/n_n*]/-S~-lQL5j2Sk{n;Z*A{
Q^;9FM4}EuWKi.iBtktu.:+;[m0rL,Mm6jr8/@mV]BOu6a :.hamNr0gs3gsNc99g2,sE/`2*g.81t\3ksf9hd9$!RrCb\
U@r\* 7rYA+uNg:Yg1lf(F<Z
VhBZjV+Z
VhBZjV+Z
VhMV>:26q?{5s
-u>mXKjjk}3FX:wV\(D<:(.bl@, ~Sg8'ZQ;J\2#@:)]#X'q+@W>U~"1g>ulp(5<08"CR%Umu	??/*gWLL8:mm'N,t4tvis$Ao>%
8}i-Kq8S~8|TtcS5ZN4.Gp#\.B]M&qS9+u]NX)6V}iH0\yek,.jwZNVJ]"^i@*J5 *2;mD](8XdlZRqv(4-omdO,/.ay+I_Sg;6A}elHf@qMrv3P3H!C("$tS~=! U $GcO'o46%'$!U>O</GzM _rX&;o%$HBI E9+O$W\G O?rMeGI9	OkSu<C[(~{{zN>Iv" 6	#-)_r@NHN!"!=$GW |'O2S|&M}7KzoTx:xKeCr-+N(R??+ORI]Dy/&FyClK>o&#tOT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      B                                          I                                          P                                        X                                           ]                                        f            	                               F     
                 
                  k         	                                   s         
                                                                                   7                                           ;                                          B                                          I                                          P                                        X                                           ]                                        f            	                               F     
                 
                  k         	                                   s         
                                   [                                                                                                                                                                                                                                                                                                                                             1       b                    1                           2       b                    2                           3                                                                                                                                                                                 )                 6     	            <     
            H                 S                 \                 d                 v                 }                                                      1       7                    2                                                           1       7                    2                            3                                                           1       7                    2                            3                            4                           5                           6                           7                           8                           9                           0                            a                                       0                                                                                             0                                             J                                                                                            0                                             J                                            g                                                                                                 
                                           	                                                    	                                                                                                          s                                          x                                        {     
              
                          
                                          
                                                                                                                                                    1       b                    1                           2       b                    2                            3                           4                           5                                       (                        ,            0            4            8             Z     ?       {                                                                                                        9     
                                       C     
                                      L     
                                      V     
                                      _                                            j     
                                     s     
                                     }                                                                                              	                                                                                                                                                                                                                 ?                                                   R     
                                                                                                          	                      b                    	                                         	                     b                   	                                                                     ^                                                  
                                                                              !                      
                 -                                       8                      4                                                                             f     
                                                                                  u                                                                                                                                                                                                                                                                                                                    V                                          `     
                                  k                                            |                                                                                                                                                                                                                                                                                                                                                   
                                                                                                                                   x                                                                                                
                                                                                                                                        
                                                                                                                                          -            ;     U     k            x                                                                       &     <            I     x     
                                      e                                                                                                                                             
                                                                                  u                                                                                                                                                                           (                                                                                                                                      
                                                                                                                     2                                                   $                    	                                                                           
                                                                                      R                       V            [           s                                                                                       		          

     '          ?          T          m                                                                                                               	           
      1           ?           L            d                                                                                            
                                                                                                                                                                                       	                     A                                                                                        \            *     \            O     \            g     ,     '            ,                 ,                 $                                                   |            9                 S     |            S          (       l                      t                                                                                \       
             &       1                    ^                    x                              $          0     R     R          R     R     G     G     G     G     G          RJ             B   C                      
)  D   E       =            M            A            E            *                 :            :            2            3                                                                    00     00     00     00     1     1     1     1     4     5     X6     8     <9     :     ;     <     <     =     4@     A     C            Nn            ]n            qn            n             n                            L             
                                        p             8      	              o    F                                                             
       K      o                  8             B                           `                    !                                                                                 o           o    0      o           o                                                                                                           H                                    (     P                                  F             XU     `     E                        X     x                  \                    l               l                                   t     |          \          |     $          ,                         P     h     p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     E     .E                             F                     v       F                     c       F                     h                                       %S                    A       ,S                    D       3S                    C       9S                    I       @S                    R       HS                    L       MS                    S       XS                    F       ^S                    Z       cS                    N       mS                    X       zS                    E       G                    P       S                    s       S                    d       S                    s       S                    d       S                    p       S                    i       S                    j       I                    t       G                    m       S                     n       S                    o       F                     v       K                     w       S                     x       S                     f       S                     V       F                    h       S                     0       I                    M       S                    c       H                    g       T                     4       
T                     6                                                       .E     P             	     Y             Y                                   G                             G     DH                     H                                                                  Y             &Z                                   0I                             <I     I                     I                                                                   Y             ^Z                                   I                             I     J                     ,J             `                                                     Y             Z                                   J     J                     J     K                     L     M                                                          Y             Z                                  HM     TM                     `M     \N                     N     M                                                          Y             S]                                   O                             O     P                     P     P                                                          Y             ]                     (               Q                              Q     4S                     @U             P                                                     Y             ]                    H       @       U                             U     X                     @U             p                                                     Y             ]                    H       @       U                             U     X     <Z             @U             p                                                     Y             ]     ]             (                       \Z                                                                                                                             Y             ]     ]            H       @               \Z                                                                                                                             Y             ]     ]           H       @               hZ                                                                                                                             Y             ]                                                                                                                                                                             Y             ^                                   [                             [     [                     \     \     p                                                     Y             _                    @       @       ]                             ]     ]                     ,^     0^     `                                                     Y             _               
     @       @       ]                             ^     _                     ,^     0^     `                                                     Y             c                    0       (       tf                             f     f                     '                                                                   Y             d                     (               g                             (g     g                     th                                                                  Y             d                                   li                             xi     i                     i     <j                                                          Y             d                                 li                             pj     j                     8k     <j                                                          Y             d                                  k                             k     l                     l     l     @                                                     Y             $f                     P       P       l     m                     m     m                     ,m             `                                                     Y             f                                   @n                             Ln     \n                     ln             P                                                     Y             f                                  n     n                     n     o                     Lo             P                                                     Y             f                                  o     n                     (p     p                      q             P                                                     Y             f                                  <q     n                     xq     q                     xr             P                                                     Y             g                                    ds                             ps     t                     v     v     @                                                    Y             +i                                 y                             y     @z                     I                                                                   Y             qi                    @       @       z     z     z      {     P{     {             `                                                                             Y             qi                                  z     {     {      {     L|     |             `                                                                             Y             qi                                  |     |     |     ~     ~     ~                                                                                          Y             l                                                                    <                     d          `                                                     Y             l               
                                                     <                     d                                                               Y             m                   (                                                  `                     '                                                                  Y             m              
     (                                                                      '                                                                  Y             !n                                  x                                   T                     d                                                               Y             !n                                                                                                   p                                                     Y             Tq                                  <                             H                                       `                                                     Y             Tq                                   <                             8     x                                                                                        Y             Tq              
                     <                                  T                                                                                        Y             q                                                                                                                                                                             Y             q                                                                                                                                                Y             q                                                                                         l          p                                             Y             }s                                 4                             @     l                               `                                             Y             u                                                                                          D                                                       Y             w                                                                                          '                                                          Y             0w                                                                                                                                                     Y             ex                                   h     t                                                                                                      Y             ex               
                    h     t                                                                                                      Y             ex                                  h     t                                                                                                      Y             ex              
                    h     t                                                                                                      Y             y                                                                                          x                                                          Y             y                                                                                                                                                   Y             y                    P       P                                                           0     0     P                                             Y             y                                                              d                       |     0                                                   Y             y              
                                                     <                  |     0                                                   Y             y                                                                                          0                                                   Y             y              
                                                     $                       0                                                   Y             y                                                              @     `                  |     0                                                  Y             y              
                                                                       |     0                                                  Y             y     y                                                                                              @                                             Y             y     y                                                                                l             @                                             Y             y     y                                                                                l             @                                             Y             y                                                                                                       @                                             Y             }                                                                                                                                                    Y             }                                   X     d                                                                                                        Y             ~                                   |                                                                                                              Y                                                                                                       l          	                                             Y                                                \                             h                                       @
                                             Y                                  @       0                                  $                               P     
                                            Y                                8       0                                                                4     P                                            Y                           
     8       0            x                                                    4     P                                            Y             >^                     (               $                             0     \                                  0                                             Y                                                                                                                                                             Y                                H       H                                                              T                                                       Y                           
     H       H                                    \     4                                                                            Y             0                                                                                                                                                      Y             O                     (                                        8     ,                     4                                                          Y                                                                                                       (             P                                             Y             E^                                   l                             x                                                                                    Y             E^                                  l                             $                                                                                    Y             	                                                                                                                                                  Y             	               
                                                                             0                                                       Y             	                   0       0       <                             H     \                     l                                                       Y             	              
     0       0       <                             |                                                                                 Y                                  (               h                             t                                       0                                             Y                                 0       0       H	                             T	     	                     	                                                          Y             I                    (       (       
                             
     0                               P                                             Y             I               
     (       (                                         X                               p                                             Y             I                                                                                         \          `                                             Y                                  H       H       D                             P     x                                                                             Y                                                                             h                                        @                                             Y             G                    8      8                                        |                          #     0                                             Y             G               
     8      8                                   $     %                          #     0                                             Y                                                (                             )     )                     T)             @                                             Y             7                                   )                             )     d*                     *                                                          Y                                  H       8       +             +             <0     3                          4                                                     Y                                                L9     X9                     9     9                     9     l:                                                  Y                                              L9     :                     :     :                     9     l:     !                                             Y                           
                   L9     :                     ;     ;                     9     l:     !                                             Y             y                                   =                             =     >                     ,>             `$                                             Y             M                     (      (      X?     d?     |?             F     hG             P%                                                                     Y             7                                    <M             HM     O     O     P             '                                                                     Y             7                                  <M             P     O     Q     Q             '                                                                     Y             7                                  Q             Q     O     0S     xS              (                                                                     Y             7                    0       0       S             S     O     W     W             (                                                                     Y                                                                                                                                                                                 Y                                               \                             \     0]                     H]              *                                             Y                                               ]                             ]     ]                     4^             *                                             Y                                               ^                             ^     ^                     \_             +                                             Y             v                                   _                                                                                                                                     Y                                                _                             _     $`                     4`     a     +                                             Y                                                b     b                     b     hd                     (f     (j     ,                                             Y                                               b     b                     b     hd                     (f     (j     ,                                             Y             =                                   lj     xj     j             Hm     o             .                                                                     Y                                                u                             u     Pv                     v             /                                             Y                                                 w     ,w                     Lw     Dy                     `{          /                                             Y                                                                                 x                                   2                                             Y                                                                                                      0             `2                                             Y             R                                                                                                     2                                             Y             A                                        xj                          8                                   3                                             Y             z                    @       8       \                             h     D                          (     4                                                     Y             {                                  t                                                                 x5                                                     Y                                                                                 x                               86                                                     Y             !                                                               ,                          d             (7                                                     Y                                               ,     8                     D                          H             89                                                     Y                                                                                                                                                                                         Y                                                    8                     (                          (             9                                                     Y             Y                                       8                                                            (:                                                     Y             }                                       D                     P                          P             :                                                     Y                                                                                                           (     <                                                     Y             {                                                                                         |          <                                                     Y                                                                                                      h          =                                                     Y             0                    8       8                                                            <             X>                                                     Y                                                                                                                    H?                                             Y             *                                       t                                               \             ?                                             Y                                                                         H                          x             B                                             Y             A                                                                    H                               B                                             Y                                                                                                                                                                                  GCC: (GNU) 4.9 20150123 (prerelease) Android clang version 3.8.256229  (based on LLVM 3.8.256229)     	      GNU gold 1.11    .shstrtab .interp .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .gnu.version .gnu.version_r .rela.dyn .rela.plt .text .rodata .eh_frame .eh_frame_hdr .preinit_array .init_array .fini_array .data.rel.ro .dynamic .got .got.plt .data .bss .comment .note.gnu.gold-version                                                                                  8      8                                                 P      P                                    '             h      h                                     :                         (                          B                         K                             J   o                     0                             T   o       0      0                                  a   o                     P                            p             p      p      8                           z      B                    
                                                                                                        8q                                         D     D     P                                          0A     0A     0f                                          `     `                                                                                                                                                                                                                  0     0     xi                                          H     8     0                                        J     :                                               L     <     x                                           P      @     ,k                                          0     ,     Tc                                  0               ,     c                             	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* $Id: isdnl3.h,v 2.6.6.2 2001/09/23 22:24:49 kai Exp $
 *
 * This software may be used and distributed according to the terms
 * of the GNU General Public License, incorporated herein by reference.
 *
 */

#define SBIT(state) (1 << state)
#define ALL_STATES  0x03ffffff

#define PROTO_DIS_EURO	0x08

#define L3_DEB_WARN	0x01
#define L3_DEB_PROTERR	0x02
#define L3_DEB_STATE	0x04
#define L3_DEB_CHARGE	0x08
#define L3_DEB_CHECK	0x10
#define L3_DEB_SI	0x20

struct stateentry {
	int state;
	int primitive;
	void (*rout) (struct l3_process *, u8, void *);
};

#define l3_debug(st, fmt, args...) HiSax_putstatus(st->l1.hardware, "l3 ", fmt, ## args)

struct PStack;

void newl3state(struct l3_process *pc, int state);
void L3InitTimer(struct l3_process *pc, struct L3Timer *t);
void L3DelTimer(struct L3Timer *t);
int L3AddTimer(struct L3Timer *t, int millisec, int event);
void StopAllL3Timer(struct l3_process *pc);
struct sk_buff *l3_alloc_skb(int len);
struct l3_process *new_l3_process(struct PStack *st, int cr);
void release_l3_process(struct l3_process *p);
struct l3_process *getl3proc(struct PStack *st, int cr);
void l3_msg(struct PStack *st, int pr, void *arg);
void setstack_dss1(struct PStack *st);
void setstack_ni1(struct PStack *st);
void setstack_1tr6(struct PStack *st);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * zr36057.h - zr36057 register offsets
 *
 * Copyright (C) 1998 Dave Perks <dperks@ibm.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef _ZR36057_H_
#define _ZR36057_H_


/* Zoran ZR36057 registers */

#define ZR36057_VFEHCR          0x000	/* Video Front End, Horizontal Configuration Register */
#define ZR36057_VFEHCR_HSPol            (1<<30)
#define ZR36057_VFEHCR_HStart           10
#define ZR36057_VFEHCR_HEnd		0
#define ZR36057_VFEHCR_Hmask		0x3ff

#define ZR36057_VFEVCR          0x004	/* Video Front End, Vertical Configuration Register */
#define ZR36057_VFEVCR_VSPol            (1<<30)
#define ZR36057_VFEVCR_VStart           10
#define ZR36057_VFEVCR_VEnd		0
#define ZR36057_VFEVCR_Vmask		0x3ff

#define ZR36057_VFESPFR         0x008	/* Video Front End, Scaler and Pixel Format Register */
#define ZR36057_VFESPFR_ExtFl           (1<<26)
#define ZR36057_VFESPFR_TopField        (1<<25)
#define ZR36057_VFESPFR_VCLKPol         (1<<24)
#define ZR36057_VFESPFR_HFilter         21
#define ZR36057_VFESPFR_HorDcm          14
#define ZR36057_VFESPFR_VerDcm          8
#define ZR36057_VFESPFR_DispMode        6
#define ZR36057_VFESPFR_YUV422          (0<<3)
#define ZR36057_VFESPFR_RGB888          (1<<3)
#define ZR36057_VFESPFR_RGB565          (2<<3)
#define ZR36057_VFESPFR_RGB555          (3<<3)
#define ZR36057_VFESPFR_ErrDif          (1<<2)
#define ZR36057_VFESPFR_Pack24          (1<<1)
#define ZR36057_VFESPFR_LittleEndian    (1<<0)

#define ZR36057_VDTR            0x00c	/* Video Display "Top" Register */

#define ZR36057_VDBR            0x010	/* Video Display "Bottom" Register */

#define ZR36057_VSSFGR          0x014	/* Video Stride, Status, and Frame Grab Register */
#define ZR36057_VSSFGR_DispStride       16
#define ZR36057_VSSFGR_VidOvf           (1<<8)
#define ZR36057_VSSFGR_SnapShot         (1<<1)
#define ZR36057_VSSFGR_FrameGrab        (1<<0)

#define ZR36057_VDCR            0x018	/* Video Display Configuration Register */
#define ZR36057_VDCR_VidEn              (1<<31)
#define ZR36057_VDCR_MinPix             24
#define ZR36057_VDCR_Triton             (1<<24)
#define ZR36057_VDCR_VidWinHt           12
#define ZR36057_VDCR_VidWinWid          0

#define ZR36057_MMTR            0x01c	/* Masking Map "Top" Register */

#define ZR36057_MMBR            0x020	/* Masking Map "Bottom" Register */

#define ZR36057_OCR             0x024	/* Overlay Control Register */
#define ZR36057_OCR_OvlEnable           (1 << 15)
#define ZR36057_OCR_MaskStride          0

#define ZR36057_SPGPPCR         0x028	/* System, PCI, and General Purpose Pins Control Register */
#define ZR36057_SPGPPCR_SoftReset	(1<<24)

#define ZR36057_GPPGCR1         0x02c	/* General Purpose Pins and GuestBus Control Register (1) */

#define ZR36057_MCSAR           0x030	/* MPEG Code Source Address Register */

#define ZR36057_MCTCR           0x034	/* MPEG Code Transfer Control Register */
#define ZR36057_MCTCR_CodTime           (1 << 30)
#define ZR36057_MCTCR_CEmpty            (1 << 29)
#define ZR36057_MCTCR_CFlush            (1 << 28)
#define ZR36057_MCTCR_CodGuestID	20
#define ZR36057_MCTCR_CodGuestReg	16

#define ZR36057_MCMPR           0x038	/* MPEG Code Memory Pointer Register */

#define ZR36057_ISR             0x03c	/* Interrupt Status Register */
#define ZR36057_ISR_GIRQ1               (1<<30)
#define ZR36057_ISR_GIRQ0               (1<<29)
#define ZR36057_ISR_CodRepIRQ           (1<<28)
#define ZR36057_ISR_JPEGRepIRQ          (1<<27)

#define ZR36057_ICR             0x040	/* Interrupt Control Register */
#define ZR36057_ICR_GIRQ1               (1<<30)
#define ZR36057_ICR_GIRQ0               (1<<29)
#define ZR36057_ICR_CodRepIRQ           (1<<28)
#define ZR36057_ICR_JPEGRepIRQ          (1<<27)
#define ZR36057_ICR_IntPinEn            (1<<24)

#define ZR36057_I2CBR           0x044	/* I2C Bus Register */
#define ZR36057_I2CBR_SDA       	(1<<1)
#define ZR36057_I2CBR_SCL       	(1<<0)

#define ZR36057_JMC             0x100	/* JPEG Mode and Control */
#define ZR36057_JMC_JPG                 (1 << 31)
#define ZR36057_JMC_JPGExpMode          (0 << 29)
#define ZR36057_JMC_JPGCmpMode          (1 << 29)
#define ZR36057_JMC_MJPGExpMode         (2 << 29)
#define ZR36057_JMC_MJPGCmpMode         (3 << 29)
#define ZR36057_JMC_RTBUSY_FB           (1 << 6)
#define ZR36057_JMC_Go_en               (1 << 5)
#define ZR36057_JMC_SyncMstr            (1 << 4)
#define ZR36057_JMC_Fld_per_buff        (1 << 3)
#define ZR36057_JMC_VFIFO_FB            (1 << 2)
#define ZR36057_JMC_CFIFO_FB            (1 << 1)
#define ZR36057_JMC_Stll_LitEndian      (1 << 0)

#define ZR36057_JPC             0x104	/* JPEG Process Control */
#define ZR36057_JPC_P_Reset             (1 << 7)
#define ZR36057_JPC_CodTrnsEn           (1 << 5)
#define ZR36057_JPC_Active              (1 << 0)

#define ZR36057_VSP             0x108	/* Vertical Sync Parameters */
#define ZR36057_VSP_VsyncSize           16
#define ZR36057_VSP_FrmTot              0

#define ZR36057_HSP             0x10c	/* Horizontal Sync Parameters */
#define ZR36057_HSP_HsyncStart          16
#define ZR36057_HSP_LineTot             0

#define ZR36057_FHAP            0x110	/* Field Horizontal Active Portion */
#define ZR36057_FHAP_NAX                16
#define ZR36057_FHAP_PAX                0

#define ZR36057_FVAP            0x114	/* Field Vertical Active Portion */
#define ZR36057_FVAP_NAY                16
#define ZR36057_FVAP_PAY                0

#define ZR36057_FPP             0x118	/* Field Process Parameters */
#define ZR36057_FPP_Odd_Even            (1 << 0)

#define ZR36057_JCBA            0x11c	/* JPEG Code Base Address */

#define ZR36057_JCFT            0x120	/* JPEG Code FIFO Threshold */

#define ZR36057_JCGI            0x124	/* JPEG Codec Guest ID */
#define ZR36057_JCGI_JPEGuestID         4
#define ZR36057_JCGI_JPEGuestReg        0

#define ZR36057_GCR2            0x12c	/* GuestBus Control Register (2) */

#define ZR36057_POR             0x200	/* Post Office Register */
#define ZR36057_POR_POPen               (1<<25)
#define ZR36057_POR_POTime              (1<<24)
#define ZR36057_POR_PODir               (1<<23)

#define ZR36057_STR             0x300	/* "Still" Transfer Register */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * TI Palmas MFD Driver
 *
 * Copyright 2011-2012 Texas Instruments Inc.
 *
 * Author: Graeme Gregory <gg@slimlogic.co.uk>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under  the terms of the GNU General  Public License as published by the
 *  Free Software Foundation;  either version 2 of the License, or (at your
 *  option) any later version.
 *
 */

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/interrupt.h>
#include <linux/irq.h>
#include <linux/regmap.h>
#include <linux/err.h>
#include <linux/mfd/core.h>
#include <linux/mfd/palmas.h>
#include <linux/of_device.h>

static const struct regmap_config palmas_regmap_config[PALMAS_NUM_CLIENTS] = {
	{
		.reg_bits = 8,
		.val_bits = 8,
		.max_register = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,
					PALMAS_PRIMARY_SECONDARY_PAD3),
	},
	{
		.reg_bits = 8,
		.val_bits = 8,
		.max_register = PALMAS_BASE_TO_REG(PALMAS_GPADC_BASE,
					PALMAS_GPADC_SMPS_VSEL_MONITORING),
	},
	{
		.reg_bits = 8,
		.val_bits = 8,
		.max_register = PALMAS_BASE_TO_REG(PALMAS_TRIM_GPADC_BASE,
					PALMAS_GPADC_TRIM16),
	},
};

static const struct regmap_irq tps65917_irqs[] = {
	/* INT1 IRQs */
	[TPS65917_RESERVED1] = {
		.mask = TPS65917_RESERVED,
	},
	[TPS65917_PWRON_IRQ] = {
		.mask = TPS65917_INT1_STATUS_PWRON,
	},
	[TPS65917_LONG_PRESS_KEY_IRQ] = {
		.mask = TPS65917_INT1_STATUS_LONG_PRESS_KEY,
	},
	[TPS65917_RESERVED2] = {
		.mask = TPS65917_RESERVED,
	},
	[TPS65917_PWRDOWN_IRQ] = {
		.mask = TPS65917_INT1_STATUS_PWRDOWN,
	},
	[TPS65917_HOTDIE_IRQ] = {
		.mask = TPS65917_INT1_STATUS_HOTDIE,
	},
	[TPS65917_VSYS_MON_IRQ] = {
		.mask = TPS65917_INT1_STATUS_VSYS_MON,
	},
	[TPS65917_RESERVED3] = {
		.mask = TPS65917_RESERVED,
	},
	/* INT2 IRQs*/
	[TPS65917_RESERVED4] = {
		.mask = TPS65917_RESERVED,
		.reg_offset = 1,
	},
	[TPS65917_OTP_ERROR_IRQ] = {
		.mask = TPS65917_INT2_STATUS_OTP_ERROR,
		.reg_offset = 1,
	},
	[TPS65917_WDT_IRQ] = {
		.mask = TPS65917_INT2_STATUS_WDT,
		.reg_offset = 1,
	},
	[TPS65917_RESERVED5] = {
		.mask = TPS65917_RESERVED,
		.reg_offset = 1,
	},
	[TPS65917_RESET_IN_IRQ] = {
		.mask = TPS65917_INT2_STATUS_RESET_IN,
		.reg_offset = 1,
	},
	[TPS65917_FSD_IRQ] = {
		.mask = TPS65917_INT2_STATUS_FSD,
		.reg_offset = 1,
	},
	[TPS65917_SHORT_IRQ] = {
		.mask = TPS65917_INT2_STATUS_SHORT,
		.reg_offset = 1,
	},
	[TPS65917_RESERVED6] = {
		.mask = TPS65917_RESERVED,
		.reg_offset = 1,
	},
	/* INT3 IRQs */
	[TPS65917_GPADC_AUTO_0_IRQ] = {
		.mask = TPS65917_INT3_STATUS_GPADC_AUTO_0,
		.reg_offset = 2,
	},
	[TPS65917_GPADC_AUTO_1_IRQ] = {
		.mask = TPS65917_INT3_STATUS_GPADC_AUTO_1,
		.reg_offset = 2,
	},
	[TPS65917_GPADC_EOC_SW_IRQ] = {
		.mask = TPS65917_INT3_STATUS_GPADC_EOC_SW,
		.reg_offset = 2,
	},
	[TPS65917_RESREVED6] = {
		.mask = TPS65917_RESERVED6,
		.reg_offset = 2,
	},
	[TPS65917_RESERVED7] = {
		.mask = TPS65917_RESERVED,
		.reg_offset = 2,
	},
	[TPS65917_RESERVED8] = {
		.mask = TPS65917_RESERVED,
		.reg_offset = 2,
	},
	[TPS65917_RESERVED9] = {
		.mask = TPS65917_RESERVED,
		.reg_offset = 2,
	},
	[TPS65917_VBUS_IRQ] = {
		.mask = TPS65917_INT3_STATUS_VBUS,
		.reg_offset = 2,
	},
	/* INT4 IRQs */
	[TPS65917_GPIO_0_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_0,
		.reg_offset = 3,
	},
	[TPS65917_GPIO_1_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_1,
		.reg_offset = 3,
	},
	[TPS65917_GPIO_2_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_2,
		.reg_offset = 3,
	},
	[TPS65917_GPIO_3_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_3,
		.reg_offset = 3,
	},
	[TPS65917_GPIO_4_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_4,
		.reg_offset = 3,
	},
	[TPS65917_GPIO_5_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_5,
		.reg_offset = 3,
	},
	[TPS65917_GPIO_6_IRQ] = {
		.mask = TPS65917_INT4_STATUS_GPIO_6,
		.reg_offset = 3,
	},
	[TPS65917_RESERVED10] = {
		.mask = TPS65917_RESERVED10,
		.reg_offset = 3,
	},
};

static const struct regmap_irq palmas_irqs[] = {
	/* INT1 IRQs */
	[PALMAS_CHARG_DET_N_VBUS_OVV_IRQ] = {
		.mask = PALMAS_INT1_STATUS_CHARG_DET_N_VBUS_OVV,
	},
	[PALMAS_PWRON_IRQ] = {
		.mask = PALMAS_INT1_STATUS_PWRON,
	},
	[PALMAS_LONG_PRESS_KEY_IRQ] = {
		.mask = PALMAS_INT1_STATUS_LONG_PRESS_KEY,
	},
	[PALMAS_RPWRON_IRQ] = {
		.mask = PALMAS_INT1_STATUS_RPWRON,
	},
	[PALMAS_PWRDOWN_IRQ] = {
		.mask = PALMAS_INT1_STATUS_PWRDOWN,
	},
	[PALMAS_HOTDIE_IRQ] = {
		.mask = PALMAS_INT1_STATUS_HOTDIE,
	},
	[PALMAS_VSYS_MON_IRQ] = {
		.mask = PALMAS_INT1_STATUS_VSYS_MON,
	},
	[PALMAS_VBAT_MON_IRQ] = {
		.mask = PALMAS_INT1_STATUS_VBAT_MON,
	},
	/* INT2 IRQs*/
	[PALMAS_RTC_ALARM_IRQ] = {
		.mask = PALMAS_INT2_STATUS_RTC_ALARM,
		.reg_offset = 1,
	},
	[PALMAS_RTC_TIMER_IRQ] = {
		.mask = PALMAS_INT2_STATUS_RTC_TIMER,
		.reg_offset = 1,
	},
	[PALMAS_WDT_IRQ] = {
		.mask = PALMAS_INT2_STATUS_WDT,
		.reg_offset = 1,
	},
	[PALMAS_BATREMOVAL_IRQ] = {
		.mask = PALMAS_INT2_STATUS_BATREMOVAL,
		.reg_offset = 1,
	},
	[PALMAS_RESET_IN_IRQ] = {
		.mask = PALMAS_INT2_STATUS_RESET_IN,
		.reg_offset = 1,
	},
	[PALMAS_FBI_BB_IRQ] = {
		.mask = PALMAS_INT2_STATUS_FBI_BB,
		.reg_offset = 1,
	},
	[PALMAS_SHORT_IRQ] = {
		.mask = PALMAS_INT2_STATUS_SHORT,
		.reg_offset = 1,
	},
	[PALMAS_VAC_ACOK_IRQ] = {
		.mask = PALMAS_INT2_STATUS_VAC_ACOK,
		.reg_offset = 1,
	},
	/* INT3 IRQs */
	[PALMAS_GPADC_AUTO_0_IRQ] = {
		.mask = PALMAS_INT3_STATUS_GPADC_AUTO_0,
		.reg_offset = 2,
	},
	[PALMAS_GPADC_AUTO_1_IRQ] = {
		.mask = PALMAS_INT3_STATUS_GPADC_AUTO_1,
		.reg_offset = 2,
	},
	[PALMAS_GPADC_EOC_SW_IRQ] = {
		.mask = PALMAS_INT3_STATUS_GPADC_EOC_SW,
		.reg_offset = 2,
	},
	[PALMAS_GPADC_EOC_RT_IRQ] = {
		.mask = PALMAS_INT3_STATUS_GPADC_EOC_RT,
		.reg_offset = 2,
	},
	[PALMAS_ID_OTG_IRQ] = {
		.mask = PALMAS_INT3_STATUS_ID_OTG,
		.reg_offset = 2,
	},
	[PALMAS_ID_IRQ] = {
		.mask = PALMAS_INT3_STATUS_ID,
		.reg_offset = 2,
	},
	[PALMAS_VBUS_OTG_IRQ] = {
		.mask = PALMAS_INT3_STATUS_VBUS_OTG,
		.reg_offset = 2,
	},
	[PALMAS_VBUS_IRQ] = {
		.mask = PALMAS_INT3_STATUS_VBUS,
		.reg_offset = 2,
	},
	/* INT4 IRQs */
	[PALMAS_GPIO_0_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_0,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_1_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_1,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_2_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_2,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_3_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_3,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_4_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_4,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_5_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_5,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_6_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_6,
		.reg_offset = 3,
	},
	[PALMAS_GPIO_7_IRQ] = {
		.mask = PALMAS_INT4_STATUS_GPIO_7,
		.reg_offset = 3,
	},
};

static struct regmap_irq_chip palmas_irq_chip = {
	.name = "palmas",
	.irqs = palmas_irqs,
	.num_irqs = ARRAY_SIZE(palmas_irqs),

	.num_regs = 4,
	.irq_reg_stride = 5,
	.status_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,
			PALMAS_INT1_STATUS),
	.mask_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,
			PALMAS_INT1_MASK),
};

static struct regmap_irq_chip tps65917_irq_chip = {
	.name = "tps65917",
	.irqs = tps65917_irqs,
	.num_irqs = ARRAY_SIZE(tps65917_irqs),

	.num_regs = 4,
	.irq_reg_stride = 5,
	.status_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,
			PALMAS_INT1_STATUS),
	.mask_base = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE,
			PALMAS_INT1_MASK),
};

int palmas_ext_control_req_config(struct palmas *palmas,
	enum palmas_external_requestor_id id,  int ext_ctrl, bool enable)
{
	struct palmas_pmic_driver_data *pmic_ddata = palmas->pmic_ddata;
	int preq_mask_bit = 0;
	int reg_add = 0;
	int bit_pos, ret;

	if (!(ext_ctrl & PALMAS_EXT_REQ))
		return 0;

	if (id >= PALMAS_EXTERNAL_REQSTR_ID_MAX)
		return 0;

	if (ext_ctrl & PALMAS_EXT_CONTROL_NSLEEP) {
		reg_add = PALMAS_NSLEEP_RES_ASSIGN;
		preq_mask_bit = 0;
	} else if (ext_ctrl & PALMAS_EXT_CONTROL_ENABLE1) {
		reg_add = PALMAS_ENABLE1_RES_ASSIGN;
		preq_mask_bit = 1;
	} else if (ext_ctrl & PALMAS_EXT_CONTROL_ENABLE2) {
		reg_add = PALMAS_ENABLE2_RES_ASSIGN;
		preq_mask_bit = 2;
	}

	bit_pos = pmic_ddata->sleep_req_info[id].bit_pos;
	reg_add += pmic_ddata->sleep_req_info[id].reg_offset;
	if (enable)
		ret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,
				reg_add, BIT(bit_pos), BIT(bit_pos));
	else
		ret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,
				reg_add, BIT(bit_pos), 0);
	if (ret < 0) {
		dev_err(palmas->dev, "Resource reg 0x%02x update failed %d\n",
			reg_add, ret);
		return ret;
	}

	/* Unmask the PREQ */
	ret = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,
			PALMAS_POWER_CTRL, BIT(preq_mask_bit), 0);
	if (ret < 0) {
		dev_err(palmas->dev, "POWER_CTRL register update failed %d\n",
			ret);
		return ret;
	}
	return ret;
}
EXPORT_SYMBOL_GPL(palmas_ext_control_req_config);

static int palmas_set_pdata_irq_flag(struct i2c_client *i2c,
		struct palmas_platform_data *pdata)
{
	struct irq_data *irq_data = irq_get_irq_data(i2c->irq);
	if (!irq_data) {
		dev_err(&i2c->dev, "Invalid IRQ: %d\n", i2c->irq);
		return -EINVAL;
	}

	pdata->irq_flags = irqd_get_trigger_type(irq_data);
	dev_info(&i2c->dev, "Irq flag is 0x%08x\n", pdata->irq_flags);
	return 0;
}

static void palmas_dt_to_pdata(struct i2c_client *i2c,
		struct palmas_platform_data *pdata)
{
	struct device_node *node = i2c->dev.of_node;
	int ret;
	u32 prop;

	ret = of_property_read_u32(node, "ti,mux-pad1", &prop);
	if (!ret) {
		pdata->mux_from_pdata = 1;
		pdata->pad1 = prop;
	}

	ret = of_property_read_u32(node, "ti,mux-pad2", &prop);
	if (!ret) {
		pdata->mux_from_pdata = 1;
		pdata->pad2 = prop;
	}

	/* The default for this register is all masked */
	ret = of_property_read_u32(node, "ti,power-ctrl", &prop);
	if (!ret)
		pdata->power_ctrl = prop;
	else
		pdata->power_ctrl = PALMAS_POWER_CTRL_NSLEEP_MASK |
					PALMAS_POWER_CTRL_ENABLE1_MASK |
					PALMAS_POWER_CTRL_ENABLE2_MASK;
	if (i2c->irq)
		palmas_set_pdata_irq_flag(i2c, pdata);

	pdata->pm_off = of_property_read_bool(node,
			"ti,system-power-controller");
}

static struct palmas *palmas_dev;
static void palmas_power_off(void)
{
	unsigned int addr;
	int ret, slave;
	struct device_node *np = palmas_dev->dev->of_node;

	if (of_property_read_bool(np, "ti,palmas-override-powerhold")) {
		addr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,
					  PALMAS_PRIMARY_SECONDARY_PAD2);
		slave = PALMAS_BASE_TO_SLAVE(PALMAS_PU_PD_OD_BASE);

		ret = regmap_update_bits(palmas_dev->regmap[slave], addr,
				PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_7_MASK, 0);
		if (ret)
			dev_err(palmas_dev->dev,
				"Unable to write PRIMARY_SECONDARY_PAD2 %d\n",
				ret);
	}

	if (!palmas_dev)
		return;

	slave = PALMAS_BASE_TO_SLAVE(PALMAS_PMU_CONTROL_BASE);
	addr = PALMAS_BASE_TO_REG(PALMAS_PMU_CONTROL_BASE, PALMAS_DEV_CTRL);

	ret = regmap_update_bits(
			palmas_dev->regmap[slave],
			addr,
			PALMAS_DEV_CTRL_DEV_ON,
			0);

	if (ret)
		pr_err("%s: Unable to write to DEV_CTRL_DEV_ON: %d\n",
				__func__, ret);
}

static unsigned int palmas_features = PALMAS_PMIC_FEATURE_SMPS10_BOOST;
static unsigned int tps659038_features;

struct palmas_driver_data {
	unsigned int *features;
	struct regmap_irq_chip *irq_chip;
};

static struct palmas_driver_data palmas_data = {
	.features = &palmas_features,
	.irq_chip = &palmas_irq_chip,
};

static struct palmas_driver_data tps659038_data = {
	.features = &tps659038_features,
	.irq_chip = &palmas_irq_chip,
};

static struct palmas_driver_data tps65917_data = {
	.features = &tps659038_features,
	.irq_chip = &tps65917_irq_chip,
};

static const struct of_device_id of_palmas_match_tbl[] = {
	{
		.compatible = "ti,palmas",
		.data = &palmas_data,
	},
	{
		.compatible = "ti,tps659038",
		.data = &tps659038_data,
	},
	{
		.compatible = "ti,tps65917",
		.data = &tps65917_data,
	},
	{ },
};
MODULE_DEVICE_TABLE(of, of_palmas_match_tbl);

static int palmas_i2c_probe(struct i2c_client *i2c,
			    const struct i2c_device_id *id)
{
	struct palmas *palmas;
	struct palmas_platform_data *pdata;
	struct palmas_driver_data *driver_data;
	struct device_node *node = i2c->dev.of_node;
	int ret = 0, i;
	unsigned int reg, addr;
	int slave;
	const struct of_device_id *match;

	pdata = dev_get_platdata(&i2c->dev);

	if (node && !pdata) {
		pdata = devm_kzalloc(&i2c->dev, sizeof(*pdata), GFP_KERNEL);

		if (!pdata)
			return -ENOMEM;

		palmas_dt_to_pdata(i2c, pdata);
	}

	if (!pdata)
		return -EINVAL;

	palmas = devm_kzalloc(&i2c->dev, sizeof(struct palmas), GFP_KERNEL);
	if (palmas == NULL)
		return -ENOMEM;

	i2c_set_clientdata(i2c, palmas);
	palmas->dev = &i2c->dev;
	palmas->irq = i2c->irq;

	match = of_match_device(of_palmas_match_tbl, &i2c->dev);

	if (!match)
		return -ENODATA;

	driver_data = (struct palmas_driver_data *)match->data;
	palmas->features = *driver_data->features;

	for (i = 0; i < PALMAS_NUM_CLIENTS; i++) {
		if (i == 0)
			palmas->i2c_clients[i] = i2c;
		else {
			palmas->i2c_clients[i] =
					i2c_new_dummy(i2c->adapter,
							i2c->addr + i);
			if (!palmas->i2c_clients[i]) {
				dev_err(palmas->dev,
					"can't attach client %d\n", i);
				ret = -ENOMEM;
				goto err_i2c;
			}
			palmas->i2c_clients[i]->dev.of_node = of_node_get(node);
		}
		palmas->regmap[i] = devm_regmap_init_i2c(palmas->i2c_clients[i],
				&palmas_regmap_config[i]);
		if (IS_ERR(palmas->regmap[i])) {
			ret = PTR_ERR(palmas->regmap[i]);
			dev_err(palmas->dev,
				"Failed to allocate regmap %d, err: %d\n",
				i, ret);
			goto err_i2c;
		}
	}

	if (!palmas->irq) {
		dev_warn(palmas->dev, "IRQ missing: skipping irq request\n");
		goto no_irq;
	}

	/* Change interrupt line output polarity */
	if (pdata->irq_flags & IRQ_TYPE_LEVEL_HIGH)
		reg = PALMAS_POLARITY_CTRL_INT_POLARITY;
	else
		reg = 0;
	ret = palmas_update_bits(palmas, PALMAS_PU_PD_OD_BASE,
			PALMAS_POLARITY_CTRL, PALMAS_POLARITY_CTRL_INT_POLARITY,
			reg);
	if (ret < 0) {
		dev_err(palmas->dev, "POLARITY_CTRL updat failed: %d\n", ret);
		goto err_i2c;
	}

	/* Change IRQ into clear on read mode for efficiency */
	slave = PALMAS_BASE_TO_SLAVE(PALMAS_INTERRUPT_BASE);
	addr = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE, PALMAS_INT_CTRL);
	reg = PALMAS_INT_CTRL_INT_CLEAR;

	regmap_write(palmas->regmap[slave], addr, reg);

	ret = regmap_add_irq_chip(palmas->regmap[slave], palmas->irq,
				  IRQF_ONESHOT | pdata->irq_flags, 0,
				  driver_data->irq_chip, &palmas->irq_data);
	if (ret < 0)
		goto err_i2c;

no_irq:
	slave = PALMAS_BASE_TO_SLAVE(PALMAS_PU_PD_OD_BASE);
	addr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,
			PALMAS_PRIMARY_SECONDARY_PAD1);

	if (pdata->mux_from_pdata) {
		reg = pdata->pad1;
		ret = regmap_write(palmas->regmap[slave], addr, reg);
		if (ret)
			goto err_irq;
	} else {
		ret = regmap_read(palmas->regmap[slave], addr, &reg);
		if (ret)
			goto err_irq;
	}

	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_0))
		palmas->gpio_muxed |= PALMAS_GPIO_0_MUXED;
	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK))
		palmas->gpio_muxed |= PALMAS_GPIO_1_MUXED;
	else if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK) ==
			(2 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_SHIFT))
		palmas->led_muxed |= PALMAS_LED1_MUXED;
	else if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK) ==
			(3 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_SHIFT))
		palmas->pwm_muxed |= PALMAS_PWM1_MUXED;
	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK))
		palmas->gpio_muxed |= PALMAS_GPIO_2_MUXED;
	else if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK) ==
			(2 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_SHIFT))
		palmas->led_muxed |= PALMAS_LED2_MUXED;
	else if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK) ==
			(3 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_SHIFT))
		palmas->pwm_muxed |= PALMAS_PWM2_MUXED;
	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_3))
		palmas->gpio_muxed |= PALMAS_GPIO_3_MUXED;

	addr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,
			PALMAS_PRIMARY_SECONDARY_PAD2);

	if (pdata->mux_from_pdata) {
		reg = pdata->pad2;
		ret = regmap_write(palmas->regmap[slave], addr, reg);
		if (ret)
			goto err_irq;
	} else {
		ret = regmap_read(palmas->regmap[slave], addr, &reg);
		if (ret)
			goto err_irq;
	}

	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_4))
		palmas->gpio_muxed |= PALMAS_GPIO_4_MUXED;
	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_5_MASK))
		palmas->gpio_muxed |= PALMAS_GPIO_5_MUXED;
	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_6))
		palmas->gpio_muxed |= PALMAS_GPIO_6_MUXED;
	if (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_7_MASK))
		palmas->gpio_muxed |= PALMAS_GPIO_7_MUXED;

	dev_info(palmas->dev, "Muxing GPIO %x, PWM %x, LED %x\n",
			palmas->gpio_muxed, palmas->pwm_muxed,
			palmas->led_muxed);

	reg = pdata->power_ctrl;

	slave = PALMAS_BASE_TO_SLAVE(PALMAS_PMU_CONTROL_BASE);
	addr = PALMAS_BASE_TO_REG(PALMAS_PMU_CONTROL_BASE, PALMAS_POWER_CTRL);

	ret = regmap_write(palmas->regmap[slave], addr, reg);
	if (ret)
		goto err_irq;

	/*
	 * If we are probing with DT do this the DT way and return here
	 * otherwise continue and add devices using mfd helpers.
	 */
	if (node) {
		ret = of_platform_populate(node, NULL, NULL, &i2c->dev);
		if (ret < 0) {
			goto err_irq;
		} else if (pdata->pm_off && !pm_power_off) {
			palmas_dev = palmas;
			pm_power_off = palmas_power_off;
		}
	}

	return ret;

err_irq:
	regmap_del_irq_chip(palmas->irq, palmas->irq_data);
err_i2c:
	for (i = 1; i < PALMAS_NUM_CLIENTS; i++) {
		if (palmas->i2c_clients[i])
			i2c_unregister_device(palmas->i2c_clients[i]);
	}
	return ret;
}

static int palmas_i2c_remove(struct i2c_client *i2c)
{
	struct palmas *palmas = i2c_get_clientdata(i2c);
	int i;

	regmap_del_irq_chip(palmas->irq, palmas->irq_data);

	for (i = 1; i < PALMAS_NUM_CLIENTS; i++) {
		if (palmas->i2c_clients[i])
			i2c_unregister_device(palmas->i2c_clients[i]);
	}

	if (palmas == palmas_dev) {
		pm_power_off = NULL;
		palmas_dev = NULL;
	}

	return 0;
}

static const struct i2c_device_id palmas_i2c_id[] = {
	{ "palmas", },
	{ "twl6035", },
	{ "twl6037", },
	{ "tps65913", },
	{ /* end */ }
};
MODULE_DEVICE_TABLE(i2c, palmas_i2c_id);

static struct i2c_driver palmas_i2c_driver = {
	.driver = {
		   .name = "palmas",
		   .of_match_table = of_palmas_match_tbl,
		   .owner = THIS_MODULE,
	},
	.probe = palmas_i2c_probe,
	.remove = palmas_i2c_remove,
	.id_table = palmas_i2c_id,
};

static int __init palmas_i2c_init(void)
{
	return i2c_add_driver(&palmas_i2c_driver);
}
/* init early so consumer devices can complete system boot */
subsys_initcall(palmas_i2c_init);

static void __exit palmas_i2c_exit(void)
{
	i2c_del_driver(&palmas_i2c_driver);
}
module_exit(palmas_i2c_exit);

MODULE_AUTHOR("Graeme Gregory <gg@slimlogic.co.uk>");
MODULE_DESCRIPTION("Palmas chip family multi-function driver");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Copyright (C) 2015 MediaTek Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#ifndef __LASTPC_H__
#define __LASTPC_H__

#include <linux/platform_device.h>
#include <linux/pm.h>
#include <linux/compiler.h>

struct lastbus_plt;

struct lastbus_plt_operations {
	/* if platform needs special settings before */
	int (*start)(struct lastbus_plt *plt);
	/* dump anything we get */
	int (*dump)(struct lastbus_plt *plt, char *buf, int len);
	/* enable the lastbus functionality */
	int (*enable)(struct lastbus_plt *plt);
	/* if you want to add unit test by sysfs interface, implement this */
	int (*test)(struct lastbus_plt *plt, int test_case);
	/* if you want to show unit test by sysfs interface, implement this */
	int (*test_show)(char *buf);
	/* if you want to do anything more than lastbus.c:lastbus_probe() */
	int (*probe)(struct lastbus_plt *plt, struct platform_device *pdev);
	/* if you want to do anything more than lastbus.c:lastbus_remove() */
	int (*remove)(struct lastbus_plt *plt, struct platform_device *pdev);
	/* if you want to do anything more than lastbus.c:lastbus_suspend() */
	int (*suspend)(struct lastbus_plt *plt, struct platform_device *pdev, pm_message_t state);
	/* if you want to do anything more than lastbus.c:lastbus_resume() */
	int (*resume)(struct lastbus_plt *plt, struct platform_device *pdev);
};

struct lastbus_plt {
	unsigned int min_buf_len;
	struct lastbus_plt_operations *ops;
	struct lastbus *common;
};

struct lastbus {
	struct platform_driver plt_drv;
	void __iomem *mcu_base;
	void __iomem *peri_base;
	struct lastbus_plt *cur_plt;
};

/* for platform register their specific lastbus behaviors
   (chip or various versions of lastbus)
*/
int lastbus_register(struct lastbus_plt *plt);

#endif /* end of __LASTPC_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *
 * (C) COPYRIGHT 2012-2015 ARM Limited. All rights reserved.
 *
 * This program is free software and is provided to you under the terms of the
 * GNU General Public License version 2 as published by the Free Software
 * Foundation, and any use by you of this program is subject to the terms
 * of such GNU licence.
 *
 * A copy of the licence is included with the program, and can also be obtained
 * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 */





#ifndef _KBASE_DEBUG_H
#define _KBASE_DEBUG_H

#include <linux/bug.h>

/** @brief If equals to 0, a trace containing the file, line, and function will be displayed before each message. */
#define KBASE_DEBUG_SKIP_TRACE 0

/** @brief If different from 0, the trace will only contain the file and line. */
#define KBASE_DEBUG_SKIP_FUNCTION_NAME 0

/** @brief Disable the asserts tests if set to 1. Default is to disable the asserts in release. */
#ifndef KBASE_DEBUG_DISABLE_ASSERTS
#ifdef CONFIG_MALI_DEBUG
#define KBASE_DEBUG_DISABLE_ASSERTS 0
#else
#define KBASE_DEBUG_DISABLE_ASSERTS 1
#endif
#endif				/* KBASE_DEBUG_DISABLE_ASSERTS */

/** Function type that is called on an KBASE_DEBUG_ASSERT() or KBASE_DEBUG_ASSERT_MSG() */
typedef void (kbase_debug_assert_hook) (void *);

struct kbasep_debug_assert_cb {
	kbase_debug_assert_hook *func;
	void *param;
};

/**
 * @def KBASEP_DEBUG_PRINT_TRACE
 * @brief Private macro containing the format of the trace to display before every message
 * @sa KBASE_DEBUG_SKIP_TRACE, KBASE_DEBUG_SKIP_FUNCTION_NAME
 */
#if !KBASE_DEBUG_SKIP_TRACE
#define KBASEP_DEBUG_PRINT_TRACE \
		"In file: " __FILE__ " line: " CSTD_STR2(__LINE__)
#if !KBASE_DEBUG_SKIP_FUNCTION_NAME
#define KBASEP_DEBUG_PRINT_FUNCTION __func__
#else
#define KBASEP_DEBUG_PRINT_FUNCTION ""
#endif
#else
#define KBASEP_DEBUG_PRINT_TRACE ""
#endif

/**
 * @def KBASEP_DEBUG_ASSERT_OUT(trace, function, ...)
 * @brief (Private) system printing function associated to the @see KBASE_DEBUG_ASSERT_MSG event.
 * @param trace location in the code from where the message is printed
 * @param function function from where the message is printed
 * @param ... Format string followed by format arguments.
 * @note function parameter cannot be concatenated with other strings
 */
/* Select the correct system output function*/
#ifdef CONFIG_MALI_DEBUG
#define KBASEP_DEBUG_ASSERT_OUT(trace, function, ...)\
		do { \
			pr_err("Mali<ASSERT>: %s function:%s ", trace, function);\
			pr_err(__VA_ARGS__);\
			pr_err("\n");\
		} while (false)
#else
#define KBASEP_DEBUG_ASSERT_OUT(trace, function, ...) CSTD_NOP()
#endif

#ifdef CONFIG_MALI_DEBUG
#define KBASE_CALL_ASSERT_HOOK() kbasep_debug_assert_call_hook()
#else
#define KBASE_CALL_ASSERT_HOOK() CSTD_NOP()
#endif

/**
 * @def KBASE_DEBUG_ASSERT(expr)
 * @brief Calls @see KBASE_PRINT_ASSERT and prints the expression @a expr if @a expr is false
 *
 * @note This macro does nothing if the flag @see KBASE_DEBUG_DISABLE_ASSERTS is set to 1
 *
 * @param expr Boolean expression
 */
#define KBASE_DEBUG_ASSERT(expr) \
	KBASE_DEBUG_ASSERT_MSG(expr, #expr)

#if KBASE_DEBUG_DISABLE_ASSERTS
#define KBASE_DEBUG_ASSERT_MSG(expr, ...) CSTD_NOP()
#else
	/**
	 * @def KBASE_DEBUG_ASSERT_MSG(expr, ...)
	 * @brief Calls @see KBASEP_DEBUG_ASSERT_OUT and prints the given message if @a expr is false
	 *
	 * @note This macro does nothing if the flag @see KBASE_DEBUG_DISABLE_ASSERTS is set to 1
	 *
	 * @param expr Boolean expression
	 * @param ...  Message to display when @a expr is false, as a format string followed by format arguments.
	 */
#define KBASE_DEBUG_ASSERT_MSG(expr, ...) \
		do { \
			if (!(expr)) { \
				KBASEP_DEBUG_ASSERT_OUT(KBASEP_DEBUG_PRINT_TRACE, KBASEP_DEBUG_PRINT_FUNCTION, __VA_ARGS__);\
				KBASE_CALL_ASSERT_HOOK();\
				BUG();\
			} \
		} while (false)
#endif				/* KBASE_DEBUG_DISABLE_ASSERTS */

/**
 * @def KBASE_DEBUG_CODE( X )
 * @brief Executes the code inside the macro only in debug mode
 *
 * @param X Code to compile only in debug mode.
 */
#ifdef CONFIG_MALI_DEBUG
#define KBASE_DEBUG_CODE(X) X
#else
#define KBASE_DEBUG_CODE(X) CSTD_NOP()
#endif				/* CONFIG_MALI_DEBUG */

/** @} */

/**
 * @brief Register a function to call on ASSERT
 *
 * Such functions will \b only be called during Debug mode, and for debugging
 * features \b only. Do not rely on them to be called in general use.
 *
 * To disable the hook, supply NULL to \a func.
 *
 * @note This function is not thread-safe, and should only be used to
 * register/deregister once in the module's lifetime.
 *
 * @param[in] func the function to call when an assert is triggered.
 * @param[in] param the parameter to pass to \a func when calling it
 */
void kbase_debug_assert_register_hook(kbase_debug_assert_hook *func, void *param);

/**
 * @brief Call a debug assert hook previously registered with kbase_debug_assert_register_hook()
 *
 * @note This function is not thread-safe with respect to multiple threads
 * registering functions and parameters with
 * kbase_debug_assert_register_hook(). Otherwise, thread safety is the
 * responsibility of the registered hook.
 */
void kbasep_debug_assert_call_hook(void);

#endif				/* _KBASE_DEBUG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #
# Copyright (C) 2015 MediaTek Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#

# In case the platform does NOT support this type of sensors
ccflags-y += -I$(srctree)/drivers/misc/mediatek/hwmon/include

obj-y += gravity.o

ifeq ($(CONFIG_MTK_SCP_SENSORHUB_V1),y)
obj-$(CONFIG_MTK_GRAVITYHUB)		+=	gravityhub/
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #include <linux/types.h>
#include <linux/delay.h>
#include <linux/mutex.h>
#include <linux/freezer.h>
#include <linux/semaphore.h>

#include "nt_smc_call.h"
#include "global_function.h"
#include "sched_status.h"

#define SCHED_CALL      0x04

extern int add_work_entry(int work_type, unsigned long buff);

static void secondary_nt_sched_t(void *info)
{
	nt_sched_t();
}


void nt_sched_t_call(void)
{
	int cpu_id = 0;
#if 0
	get_online_cpus();
	cpu_id = get_current_cpuid();
	smp_call_function_single(cpu_id, secondary_nt_sched_t, NULL, 1);
	put_online_cpus();
#else
	int retVal = 0;

	retVal = add_work_entry(SCHED_CALL, NULL);
	if (retVal != 0)
		pr_err("[%s][%d] add_work_entry function failed!\n", __func__, __LINE__);

#endif

	return;
}


int global_fn(void)
{
	int retVal = 0;

	while (1) {
		set_freezable();
		set_current_state(TASK_INTERRUPTIBLE);
#if 1
		if (teei_config_flag == 1) {
			retVal = wait_for_completion_interruptible(&global_down_lock);
			if (retVal == -ERESTARTSYS) {
				pr_err("[%s][%d]*********down &global_down_lock failed *****************\n", __func__, __LINE__);
				continue;
			}
		}
#endif
		retVal = down_interruptible(&smc_lock);
		if (retVal != 0) {
			pr_err("[%s][%d]*********down &smc_lock failed *****************\n", __func__, __LINE__);
			complete(&global_down_lock);
			continue;
		}

		if (forward_call_flag == GLSCH_FOR_SOTER) {
			forward_call_flag = GLSCH_NONE;
			msleep(10);
			nt_sched_t_call();
		} else if (irq_call_flag == GLSCH_HIGH) {
			/* pr_debug("[%s][%d]**************************\n", __func__, __LINE__ ); */
			irq_call_flag = GLSCH_NONE;
			nt_sched_t_call();
			/*msleep_interruptible(10);*/
		} else if (fp_call_flag == GLSCH_HIGH) {
			/* pr_debug("[%s][%d]**************************\n", __func__, __LINE__ ); */
			if (teei_vfs_flag == 0) {
				nt_sched_t_call();
			} else {
				up(&smc_lock);
				msleep_interruptible(1);
			}
		} else if (forward_call_flag == GLSCH_LOW) {
			/* pr_debug("[%s][%d]**************************\n", __func__, __LINE__ ); */
			if (teei_vfs_flag == 0)	{
				nt_sched_t_call();
			} else {
				up(&smc_lock);
				msleep_interruptible(1);
			}
		} else {
			/* pr_debug("[%s][%d]**************************\n", __func__, __LINE__ ); */
			up(&smc_lock);
			msleep_interruptible(1);
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /* bnx2x_dump.h: Broadcom Everest network driver.
 *
 * Copyright (c) 2012-2013 Broadcom Corporation
 *
 * Unless you and Broadcom execute a separate written software license
 * agreement governing use of this software, this software is licensed to you
 * under the terms of the GNU General Public License version 2, available
 * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").
 *
 * Notwithstanding the above, under no circumstances may you combine this
 * software in any way with any other Broadcom software provided under a
 * license other than the GPL, without Broadcom's express prior written
 * consent.
 */

#ifndef BNX2X_DUMP_H
#define BNX2X_DUMP_H

/* WaitP Definitions */
#define DRV_DUMP_XSTORM_WAITP_ADDRESS    0x2b8a80
#define DRV_DUMP_TSTORM_WAITP_ADDRESS    0x1b8a80
#define DRV_DUMP_USTORM_WAITP_ADDRESS    0x338a80
#define DRV_DUMP_CSTORM_WAITP_ADDRESS    0x238a80

/* Possible Chips */
#define DUMP_CHIP_E1 1
#define DUMP_CHIP_E1H 2
#define DUMP_CHIP_E2 4
#define DUMP_CHIP_E3A0 8
#define DUMP_CHIP_E3B0 16
#define DUMP_PATH_0 512
#define DUMP_PATH_1 1024
#define NUM_PRESETS 13
#define NUM_CHIPS 5

struct	dump_header {
	u32 header_size; /* Size in DWORDs excluding this field */
	u32 version;
	u32 preset;
	u32 dump_meta_data; /* OR of CHIP and PATH. */
};

#define  BNX2X_DUMP_VERSION 0x61111111
struct reg_addr {
	u32 addr;
	u32 size;
	u32 chips;
	u32 presets;
};

struct wreg_addr {
	u32 addr;
	u32 size;
	u32 read_regs_count;
	const u32 *read_regs;
	u32 chips;
	u32 presets;
};

#define PAGE_MODE_VALUES_E2 2
#define PAGE_READ_REGS_E2 1
#define PAGE_WRITE_REGS_E2 1
static const u32 page_vals_e2[] = {0, 128};
static const u32 page_write_regs_e2[] = {328476};
static const struct reg_addr page_read_regs_e2[] = {
	{0x58000, 4608, DUMP_CHIP_E2, 0x30}
};

#define PAGE_MODE_VALUES_E3 2
#define PAGE_READ_REGS_E3 1
#define PAGE_WRITE_REGS_E3 1
static const u32 page_vals_e3[] = {0, 128};
static const u32 page_write_regs_e3[] = {328476};
static const struct reg_addr page_read_regs_e3[] = {
	{0x58000, 4608, DUMP_CHIP_E3A0 | DUMP_CHIP_E3B0, 0x30}
};

static const struct reg_addr reg_addrs[] = {
	{ 0x2000, 1, 0x1f, 0xfff},
	{ 0x2004, 1, 0x1f, 0x1fff},
	{ 0x2008, 25, 0x1f, 0xfff},
	{ 0x206c, 1, 0x1f, 0x1fff},
	{ 0x2070, 313, 0x1f, 0xfff},
	{ 0x2800, 103, 0x1f, 0xfff},
	{ 0x3000, 287, 0x1f, 0xfff},
	{ 0x3800, 331, 0x1f, 0xfff},
	{ 0x8800, 6, 0x1f, 0x924},
	{ 0x8818, 1, 0x1e, 0x924},
	{ 0x9000, 4, 0x1c, 0x924},
	{ 0x9010, 7, 0x1c, 0xfff},
	{ 0x902c, 1, 0x1c, 0x924},
	{ 0x9030, 1, 0x1c, 0xfff},
	{ 0x9034, 13, 0x1c, 0x924},
	{ 0x9068, 16, 0x1c, 0xfff},
	{ 0x90a8, 98, 0x1c, 0x924},
	{ 0x9230, 2, 0x1c, 0xfff},
	{ 0x9238, 3, 0x1c, 0x924},
	{ 0x9244, 1, 0x1c, 0xfff},
	{ 0x9248, 1, 0x1c, 0x924},
	{ 0x924c, 1, 0x4, 0x924},
	{ 0x9250, 16, 0x1c, 0x924},
	{ 0x92a8, 2, 0x1c, 0x1fff},
	{ 0x92b4, 1, 0x1c, 0x1fff},
	{ 0x9400, 33, 0x1c, 0x924},
	{ 0x9484, 5, 0x18, 0x924},
	{ 0xa000, 27, 0x1f, 0x924},
	{ 0xa06c, 1, 0x3, 0x924},
	{ 0xa070, 2, 0x1f, 0x924},
	{ 0xa078, 1, 0x1f, 0x1fff},
	{ 0xa07c, 31, 0x1f, 0x924},
	{ 0xa0f8, 1, 0x1f, 0x1fff},
	{ 0xa0fc, 3, 0x1f, 0x924},
	{ 0xa108, 1, 0x1f, 0x1fff},
	{ 0xa10c, 3, 0x1f, 0x924},
	{ 0xa118, 1, 0x1f, 0x1fff},
	{ 0xa11c, 28, 0x1f, 0x924},
	{ 0xa18c, 4, 0x3, 0x924},
	{ 0xa19c, 3, 0x1f, 0x924},
	{ 0xa1a8, 1, 0x1f, 0x1fff},
	{ 0xa1ac, 3, 0x1f, 0x924},
	{ 0xa1b8, 1, 0x1f, 0x1fff},
	{ 0xa1bc, 54, 0x1f, 0x924},
	{ 0xa294, 2, 0x3, 0x924},
	{ 0xa29c, 2, 0x1f, 0x924},
	{ 0xa2a4, 2, 0x7, 0x924},
	{ 0xa2ac, 2, 0x1f, 0x924},
	{ 0xa2b4, 1, 0x1f, 0x1fff},
	{ 0xa2b8, 49, 0x1f, 0x924},
	{ 0xa38c, 2, 0x1f, 0x1fff},
	{ 0xa398, 1, 0x1f, 0x1fff},
	{ 0xa39c, 7, 0x1e, 0x924},
	{ 0xa3b8, 2, 0x18, 0x924},
	{ 0xa3c0, 1, 0x1e, 0x924},
	{ 0xa3c4, 1, 0x1e, 0xfff},
	{ 0xa3c8, 1, 0x1e, 0x924},
	{ 0xa3d0, 1, 0x1e, 0x924},
	{ 0xa3d8, 1, 0x1e, 0x924},
	{ 0xa3e0, 1, 0x1e, 0x924},
	{ 0xa3e8, 1, 0x1e, 0x924},
	{ 0xa3f0, 1, 0x1e, 0x924},
	{ 0xa3f8, 1, 0x1e, 0x924},
	{ 0xa400, 1, 0x1f, 0x924},
	{ 0xa404, 1, 0x1f, 0xfff},
	{ 0xa408, 2, 0x1f, 0x1fff},
	{ 0xa410, 7, 0x1f, 0x924},
	{ 0xa42c, 12, 0x1f, 0xfff},
	{ 0xa45c, 1, 0x1f, 0x924},
	{ 0xa460, 1, 0x1f, 0x1924},
	{ 0xa464, 15, 0x1f, 0x924},
	{ 0xa4a0, 1, 0x7, 0x924},
	{ 0xa4a4, 2, 0x1f, 0x924},
	{ 0xa4ac, 2, 0x3, 0x924},
	{ 0xa4b4, 1, 0x7, 0x924},
	{ 0xa4b8, 2, 0x3, 0x924},
	{ 0xa4c0, 3, 0x1f, 0x924},
	{ 0xa4cc, 5, 0x3, 0x924},
	{ 0xa4e0, 3, 0x1f, 0x924},
	{ 0xa4fc, 2, 0x1f, 0x924},
	{ 0xa504, 1, 0x3, 0x924},
	{ 0xa508, 3, 0x1f, 0x924},
	{ 0xa518, 1, 0x1f, 0x924},
	{ 0xa520, 1, 0x1f, 0x924},
	{ 0xa528, 1, 0x1f, 0x924},
	{ 0xa530, 1, 0x1f, 0x924},
	{ 0xa538, 1, 0x1f, 0x924},
	{ 0xa540, 1, 0x1f, 0x924},
	{ 0xa548, 1, 0x3, 0x924},
	{ 0xa550, 1, 0x3, 0x924},
	{ 0xa558, 1, 0x3, 0x924},
	{ 0xa560, 1, 0x3, 0x924},
	{ 0xa568, 1, 0x3, 0x924},
	{ 0xa570, 1, 0x1f, 0x924},
	{ 0xa580, 1, 0x1f, 0x1fff},
	{ 0xa590, 1, 0x1f, 0x1fff},
	{ 0xa5a0, 1, 0x7, 0x924},
	{ 0xa5c0, 1, 0x1f, 0x924},
	{ 0xa5e0, 1, 0x1e, 0x924},
	{ 0xa5e8, 1, 0x1e, 0x924},
	{ 0xa5f0, 1, 0x1e, 0x924},
	{ 0xa5f8, 1, 0x6, 0x924},
	{ 0xa5fc, 1, 0x1e, 0x924},
	{ 0xa600, 5, 0x1e, 0xfff},
	{ 0xa614, 1, 0x1e, 0x924},
	{ 0xa618, 1, 0x1e, 0xfff},
	{ 0xa61c, 1, 0x1e, 0x924},
	{ 0xa620, 6, 0x1c, 0x924},
	{ 0xa638, 20, 0x4, 0x924},
	{ 0xa688, 35, 0x1c, 0x924},
	{ 0xa714, 1, 0x1c, 0xfff},
	{ 0xa718, 2, 0x1c, 0x924},
	{ 0xa720, 1, 0x1c, 0xfff},
	{ 0xa724, 3, 0x1c, 0x924},
	{ 0xa730, 1, 0x4, 0x924},
	{ 0xa734, 2, 0x1c, 0x924},
	{ 0xa73c, 4, 0x4, 0x924},
	{ 0xa74c, 1, 0x1c, 0x924},
	{ 0xa750, 1, 0x1c, 0xfff},
	{ 0xa754, 3, 0x1c, 0x924},
	{ 0xa760, 5, 0x4, 0x924},
	{ 0xa774, 7, 0x1c, 0x924},
	{ 0xa790, 15, 0x4, 0x924},
	{ 0xa7cc, 4, 0x1c, 0x924},
	{ 0xa7e0, 6, 0x18, 0x924},
	{ 0xa800, 18, 0x4, 0x924},
	{ 0xa848, 33, 0x1c, 0x924},
	{ 0xa8cc, 2, 0x18, 0x924},
	{ 0xa8d4, 4, 0x1c, 0x924},
	{ 0xa8e4, 1, 0x18, 0x924},
	{ 0xa8e8, 1, 0x1c, 0x924},
	{ 0xa8f0, 1, 0x1c, 0x924},
	{ 0xa8f8, 30, 0x18, 0x924},
	{ 0xa974, 73, 0x18, 0x924},
	{ 0xac30, 1, 0x18, 0x924},
	{ 0xac40, 1, 0x18, 0x924},
	{ 0xac50, 1, 0x18, 0x924},
	{ 0xac60, 1, 0x10, 0x924},
	{ 0x10000, 9, 0x1f, 0x924},
	{ 0x10024, 1, 0x7, 0x924},
	{ 0x10028, 5, 0x1f, 0x924},
	{ 0x1003c, 6, 0x7, 0x924},
	{ 0x10054, 20, 0x1f, 0x924},
	{ 0x100a4, 4, 0x7, 0x924},
	{ 0x100b4, 11, 0x1f, 0x924},
	{ 0x100e0, 4, 0x7, 0x924},
	{ 0x100f0, 8, 0x1f, 0x924},
	{ 0x10110, 6, 0x7, 0x924},
	{ 0x10128, 110, 0x1f, 0x924},
	{ 0x102e0, 4, 0x7, 0x924},
	{ 0x102f0, 18, 0x1f, 0x924},
	{ 0x10338, 20, 0x7, 0x924},
	{ 0x10388, 10, 0x1f, 0x924},
	{ 0x103d0, 2, 0x3, 0x1fff},
	{ 0x103dc, 1, 0x3, 0x1fff},
	{ 0x10400, 6, 0x7, 0x924},
	{ 0x10418, 1, 0x1f, 0xfff},
	{ 0x1041c, 1, 0x1f, 0x924},
	{ 0x10420, 1, 0x1f, 0xfff},
	{ 0x10424, 1, 0x1f, 0x924},
	{ 0x10428, 1, 0x1f, 0xfff},
	{ 0x1042c, 1, 0x1f, 0x924},
	{ 0x10430, 10, 0x7, 0x924},
	{ 0x10458, 2, 0x1f, 0x924},
	{ 0x10460, 1, 0x1f, 0xfff},
	{ 0x10464, 4, 0x1f, 0x924},
	{ 0x10474, 1, 0x1f, 0xfff},
	{ 0x10478, 14, 0x1f, 0x924},
	{ 0x104b0, 12, 0x7, 0x924},
	{ 0x104e0, 1, 0x1f, 0xfff},
	{ 0x104e8, 1, 0x1f, 0x924},
	{ 0x104ec, 1, 0x1f, 0xfff},
	{ 0x104f4, 1, 0x1f, 0x924},
	{ 0x104f8, 1, 0x1f, 0xfff},
	{ 0x10500, 2, 0x1f, 0x924},
	{ 0x10508, 1, 0x1f, 0xfff},
	{ 0x1050c, 9, 0x1f, 0x924},
	{ 0x10530, 1, 0x1f, 0xfff},
	{ 0x10534, 1, 0x1f, 0x924},
	{ 0x10538, 1, 0x1f, 0xfff},
	{ 0x1053c, 3, 0x1f, 0x924},
	{ 0x10548, 1, 0x1f, 0xfff},
	{ 0x1054c, 3, 0x1f, 0x924},
	{ 0x10558, 1, 0x1f, 0xfff},
	{ 0x1055c, 123, 0x1f, 0x924},
	{ 0x10750, 2, 0x7, 0x924},
	{ 0x10760, 2, 0x7, 0x924},
	{ 0x10770, 2, 0x7, 0x924},
	{ 0x10780, 2, 0x7, 0x924},
	{ 0x10790, 2, 0x1f, 0x924},
	{ 0x107a0, 2, 0x7, 0x924},
	{ 0x107b0, 2, 0x7, 0x924},
	{ 0x107c0, 2, 0x7, 0x924},
	{ 0x107d0, 2, 0x7, 0x924},
	{ 0x107e0, 2, 0x1f, 0x924},
	{ 0x10880, 2, 0x1f, 0x924},
	{ 0x10900, 2, 0x1f, 0x924},
	{ 0x16000, 1, 0x6, 0x924},
	{ 0x16004, 25, 0x1e, 0x924},
	{ 0x16070, 8, 0x1e, 0x924},
	{ 0x16090, 4, 0xe, 0x924},
	{ 0x160a0, 6, 0x1e, 0x924},
	{ 0x160c0, 7, 0x1e, 0x924},
	{ 0x160dc, 2, 0x6, 0x924},
	{ 0x160e4, 6, 0x1e, 0x924},
	{ 0x160fc, 4, 0x1e, 0x1fff},
	{ 0x1610c, 2, 0x6, 0x924},
	{ 0x16114, 6, 0x1e, 0x924},
	{ 0x16140, 48, 0x1e, 0x1fff},
	{ 0x16204, 5, 0x1e, 0x924},
	{ 0x18000, 1, 0x1e, 0x924},
	{ 0x18008, 1, 0x1e, 0x924},
	{ 0x18010, 35, 0x1c, 0x924},
	{ 0x180a4, 2, 0x1c, 0x924},
	{ 0x180c0, 9, 0x1c, 0x924},
	{ 0x180e4, 1, 0xc, 0x924},
	{ 0x180e8, 2, 0x1c, 0x924},
	{ 0x180f0, 1, 0xc, 0x924},
	{ 0x180f4, 79, 0x1c, 0x924},
	{ 0x18230, 1, 0xc, 0x924},
	{ 0x18234, 2, 0x1c, 0x924},
	{ 0x1823c, 1, 0xc, 0x924},
	{ 0x18240, 13, 0x1c, 0x924},
	{ 0x18274, 1, 0x4, 0x924},
	{ 0x18278, 12, 0x1c, 0x924},
	{ 0x182a8, 1, 0x1c, 0xfff},
	{ 0x182ac, 3, 0x1c, 0x924},
	{ 0x182b8, 1, 0x1c, 0xfff},
	{ 0x182bc, 19, 0x1c, 0x924},
	{ 0x18308, 1, 0x1c, 0xfff},
	{ 0x1830c, 3, 0x1c, 0x924},
	{ 0x18318, 1, 0x1c, 0xfff},
	{ 0x1831c, 7, 0x1c, 0x924},
	{ 0x18338, 1, 0x1c, 0xfff},
	{ 0x1833c, 3, 0x1c, 0x924},
	{ 0x18348, 1, 0x1c, 0xfff},
	{ 0x1834c, 28, 0x1c, 0x924},
	{ 0x183bc, 2, 0x1c, 0x1fff},
	{ 0x183c8, 3, 0x1c, 0x1fff},
	{ 0x183d8, 1, 0x1c, 0x1fff},
	{ 0x18440, 48, 0x1c, 0x1fff},
	{ 0x18500, 15, 0x1c, 0x924},
	{ 0x18570, 1, 0x18, 0xfff},
	{ 0x18574, 1, 0x18, 0x924},
	{ 0x18578, 1, 0x18, 0xfff},
	{ 0x1857c, 4, 0x18, 0x924},
	{ 0x1858c, 1, 0x18, 0xfff},
	{ 0x18590, 1, 0x18, 0x924},
	{ 0x18594, 1, 0x18, 0xfff},
	{ 0x18598, 32, 0x18, 0x924},
	{ 0x18618, 5, 0x10, 0x924},
	{ 0x1862c, 4, 0x10, 0xfff},
	{ 0x1863c, 16, 0x10, 0x924},
	{ 0x18680, 44, 0x10, 0x924},
	{ 0x18748, 12, 0x10, 0x924},
	{ 0x18788, 1, 0x10, 0x924},
	{ 0x1879c, 6, 0x10, 0x924},
	{ 0x187c4, 51, 0x10, 0x924},
	{ 0x18a00, 48, 0x10, 0x924},
	{ 0x20000, 24, 0x1f, 0x924},
	{ 0x20060, 8, 0x1f, 0x9e4},
	{ 0x20080, 94, 0x1f, 0x924},
	{ 0x201f8, 1, 0x3, 0x924},
	{ 0x201fc, 1, 0x1f, 0x924},
	{ 0x20200, 1, 0x3, 0x924},
	{ 0x20204, 1, 0x1f, 0x924},
	{ 0x20208, 1, 0x3, 0x924},
	{ 0x2020c, 4, 0x1f, 0x924},
	{ 0x2021c, 11, 0x1f, 0xfff},
	{ 0x20248, 24, 0x1f, 0x924},
	{ 0x202b8, 2, 0x1f, 0x1fff},
	{ 0x202c4, 1, 0x1f, 0x1fff},
	{ 0x202c8, 1, 0x1c, 0x924},
	{ 0x202d8, 4, 0x1c, 0x924},
	{ 0x202f0, 1, 0x10, 0x924},
	{ 0x20400, 1, 0x1f, 0x924},
	{ 0x20404, 1, 0x1f, 0xfff},
	{ 0x2040c, 2, 0x1f, 0xfff},
	{ 0x20414, 2, 0x1f, 0x924},
	{ 0x2041c, 2, 0x1f, 0xfff},
	{ 0x20424, 2, 0x1f, 0x924},
	{ 0x2042c, 18, 0x1e, 0x924},
	{ 0x20480, 1, 0x1f, 0x924},
	{ 0x20500, 1, 0x1f, 0x924},
	{ 0x20600, 1, 0x1f, 0x924},
	{ 0x28000, 1, 0x1f, 0x9e4},
	{ 0x28004, 255, 0x1f, 0x180},
	{ 0x28400, 1, 0x1f, 0x1c0},
	{ 0x28404, 255, 0x1f, 0x180},
	{ 0x28800, 1, 0x1f, 0x1c0},
	{ 0x28804, 255, 0x1f, 0x180},
	{ 0x28c00, 1, 0x1f, 0x1c0},
	{ 0x28c04, 255, 0x1f, 0x180},
	{ 0x29000, 1, 0x1f, 0x1c0},
	{ 0x29004, 255, 0x1f, 0x180},
	{ 0x29400, 1, 0x1f, 0x1c0},
	{ 0x29404, 255, 0x1f, 0x180},
	{ 0x29800, 1, 0x1f, 0x1c0},
	{ 0x29804, 255, 0x1f, 0x180},
	{ 0x29c00, 1, 0x1f, 0x1c0},
	{ 0x29c04, 255, 0x1f, 0x180},
	{ 0x2a000, 1, 0x1f, 0x1c0},
	{ 0x2a004, 255, 0x1f, 0x180},
	{ 0x2a400, 1, 0x1f, 0x1c0},
	{ 0x2a404, 255, 0x1f, 0x180},
	{ 0x2a800, 1, 0x1f, 0x1c0},
	{ 0x2a804, 255, 0x1f, 0x180},
	{ 0x2ac00, 1, 0x1f, 0x1c0},
	{ 0x2ac04, 255, 0x1f, 0x180},
	{ 0x2b000, 1, 0x1f, 0x1c0},
	{ 0x2b004, 255, 0x1f, 0x180},
	{ 0x2b400, 1, 0x1f, 0x1c0},
	{ 0x2b404, 255, 0x1f, 0x180},
	{ 0x2b800, 1, 0x1f, 0x1c0},
	{ 0x2b804, 255, 0x1f, 0x180},
	{ 0x2bc00, 1, 0x1f, 0x1c0},
	{ 0x2bc04, 255, 0x1f, 0x180},
	{ 0x2c000, 1, 0x1f, 0x1c0},
	{ 0x2c004, 255, 0x1f, 0x180},
	{ 0x2c400, 1, 0x1f, 0x1c0},
	{ 0x2c404, 255, 0x1f, 0x180},
	{ 0x2c800, 1, 0x1f, 0x1c0},
	{ 0x2c804, 255, 0x1f, 0x180},
	{ 0x2cc00, 1, 0x1f, 0x1c0},
	{ 0x2cc04, 255, 0x1f, 0x180},
	{ 0x2d000, 1, 0x1f, 0x1c0},
	{ 0x2d004, 255, 0x1f, 0x180},
	{ 0x2d400, 1, 0x1f, 0x1c0},
	{ 0x2d404, 255, 0x1f, 0x180},
	{ 0x2d800, 1, 0x1f, 0x1c0},
	{ 0x2d804, 255, 0x1f, 0x180},
	{ 0x2dc00, 1, 0x1f, 0x1c0},
	{ 0x2dc04, 255, 0x1f, 0x180},
	{ 0x2e000, 1, 0x1f, 0x1c0},
	{ 0x2e004, 255, 0x1f, 0x180},
	{ 0x2e400, 1, 0x1f, 0x1c0},
	{ 0x2e404, 255, 0x1f, 0x180},
	{ 0x2e800, 1, 0x1f, 0x1c0},
	{ 0x2e804, 255, 0x1f, 0x180},
	{ 0x2ec00, 1, 0x1f, 0x1c0},
	{ 0x2ec04, 255, 0x1f, 0x180},
	{ 0x2f000, 1, 0x1f, 0x1c0},
	{ 0x2f004, 255, 0x1f, 0x180},
	{ 0x2f400, 1, 0x1f, 0x1c0},
	{ 0x2f404, 255, 0x1f, 0x180},
	{ 0x2f800, 1, 0x1f, 0x1c0},
	{ 0x2f804, 255, 0x1f, 0x180},
	{ 0x2fc00, 1, 0x1f, 0x1c0},
	{ 0x2fc04, 255, 0x1f, 0x180},
	{ 0x30000, 1, 0x1f, 0x9e4},
	{ 0x30004, 255, 0x1f, 0x180},
	{ 0x30400, 1, 0x1f, 0x1c0},
	{ 0x30404, 255, 0x1f, 0x180},
	{ 0x30800, 1, 0x1f, 0x1c0},
	{ 0x30804, 255, 0x1f, 0x180},
	{ 0x30c00, 1, 0x1f, 0x1c0},
	{ 0x30c04, 255, 0x1f, 0x180},
	{ 0x31000, 1, 0x1f, 0x1c0},
	{ 0x31004, 255, 0x1f, 0x180},
	{ 0x31400, 1, 0x1f, 0x1c0},
	{ 0x31404, 255, 0x1f, 0x180},
	{ 0x31800, 1, 0x1f, 0x1c0},
	{ 0x31804, 255, 0x1f, 0x180},
	{ 0x31c00, 1, 0x1f, 0x1c0},
	{ 0x31c04, 255, 0x1f, 0x180},
	{ 0x32000, 1, 0x1f, 0x1c0},
	{ 0x32004, 255, 0x1f, 0x180},
	{ 0x32400, 1, 0x1f, 0x1c0},
	{ 0x32404, 255, 0x1f, 0x180},
	{ 0x32800, 1, 0x1f, 0x1c0},
	{ 0x32804, 255, 0x1f, 0x180},
	{ 0x32c00, 1, 0x1f, 0x1c0},
	{ 0x32c04, 255, 0x1f, 0x180},
	{ 0x33000, 1, 0x1f, 0x1c0},
	{ 0x33004, 255, 0x1f, 0x180},
	{ 0x33400, 1, 0x1f, 0x1c0},
	{ 0x33404, 255, 0x1f, 0x180},
	{ 0x33800, 1, 0x1f, 0x1c0},
	{ 0x33804, 255, 0x1f, 0x180},
	{ 0x33c00, 1, 0x1f, 0x1c0},
	{ 0x33c04, 255, 0x1f, 0x180},
	{ 0x34000, 1, 0x1f, 0x1c0},
	{ 0x34004, 255, 0x1f, 0x180},
	{ 0x34400, 1, 0x1f, 0x1c0},
	{ 0x34404, 255, 0x1f, 0x180},
	{ 0x34800, 1, 0x1f, 0x1c0},
	{ 0x34804, 255, 0x1f, 0x180},
	{ 0x34c00, 1, 0x1f, 0x1c0},
	{ 0x34c04, 255, 0x1f, 0x180},
	{ 0x35000, 1, 0x1f, 0x1c0},
	{ 0x35004, 255, 0x1f, 0x180},
	{ 0x35400, 1, 0x1f, 0x1c0},
	{ 0x35404, 255, 0x1f, 0x180},
	{ 0x35800, 1, 0x1f, 0x1c0},
	{ 0x35804, 255, 0x1f, 0x180},
	{ 0x35c00, 1, 0x1f, 0x1c0},
	{ 0x35c04, 255, 0x1f, 0x180},
	{ 0x36000, 1, 0x1f, 0x1c0},
	{ 0x36004, 255, 0x1f, 0x180},
	{ 0x36400, 1, 0x1f, 0x1c0},
	{ 0x36404, 255, 0x1f, 0x180},
	{ 0x36800, 1, 0x1f, 0x1c0},
	{ 0x36804, 255, 0x1f, 0x180},
	{ 0x36c00, 1, 0x1f, 0x1c0},
	{ 0x36c04, 255, 0x1f, 0x180},
	{ 0x37000, 1, 0x1f, 0x1c0},
	{ 0x37004, 255, 0x1f, 0x180},
	{ 0x37400, 1, 0x1f, 0x1c0},
	{ 0x37404, 255, 0x1f, 0x180},
	{ 0x37800, 1, 0x1f, 0x1c0},
	{ 0x37804, 255, 0x1f, 0x180},
	{ 0x37c00, 1, 0x1f, 0x1c0},
	{ 0x37c04, 255, 0x1f, 0x180},
	{ 0x38000, 1, 0x1f, 0x1c0},
	{ 0x38004, 255, 0x1f, 0x180},
	{ 0x38400, 1, 0x1f, 0x1c0},
	{ 0x38404, 255, 0x1f, 0x180},
	{ 0x38800, 1, 0x1f, 0x1c0},
	{ 0x38804, 255, 0x1f, 0x180},
	{ 0x38c00, 1, 0x1f, 0x1c0},
	{ 0x38c04, 255, 0x1f, 0x180},
	{ 0x39000, 1, 0x1f, 0x1c0},
	{ 0x39004, 255, 0x1f, 0x180},
	{ 0x39400, 1, 0x1f, 0x1c0},
	{ 0x39404, 255, 0x1f, 0x180},
	{ 0x39800, 1, 0x1f, 0x1c0},
	{ 0x39804, 255, 0x1f, 0x180},
	{ 0x39c00, 1, 0x1f, 0x1c0},
	{ 0x39c04, 255, 0x1f, 0x180},
	{ 0x3a000, 1, 0x1f, 0x1c0},
	{ 0x3a004, 255, 0x1f, 0x180},
	{ 0x3a400, 1, 0x1f, 0x1c0},
	{ 0x3a404, 255, 0x1f, 0x180},
	{ 0x3a800, 1, 0x1f, 0x1c0},
	{ 0x3a804, 255, 0x1f, 0x180},
	{ 0x3ac00, 1, 0x1f, 0x1c0},
	{ 0x3ac04, 255, 0x1f, 0x180},
	{ 0x3b000, 1, 0x1f, 0x1c0},
	{ 0x3b004, 255, 0x1f, 0x180},
	{ 0x3b400, 1, 0x1f, 0x1c0},
	{ 0x3b404, 255, 0x1f, 0x180},
	{ 0x3b800, 1, 0x1f, 0x1c0},
	{ 0x3b804, 255, 0x1f, 0x180},
	{ 0x3bc00, 1, 0x1f, 0x1c0},
	{ 0x3bc04, 255, 0x1f, 0x180},
	{ 0x3c000, 1, 0x1f, 0x1c0},
	{ 0x3c004, 255, 0x1f, 0x180},
	{ 0x3c400, 1, 0x1f, 0x1c0},
	{ 0x3c404, 255, 0x1f, 0x180},
	{ 0x3c800, 1, 0x1f, 0x1c0},
	{ 0x3c804, 255, 0x1f, 0x180},
	{ 0x3cc00, 1, 0x1f, 0x1c0},
	{ 0x3cc04, 255, 0x1f, 0x180},
	{ 0x3d000, 1, 0x1f, 0x1c0},
	{ 0x3d004, 255, 0x1f, 0x180},
	{ 0x3d400, 1, 0x1f, 0x1c0},
	{ 0x3d404, 255, 0x1f, 0x180},
	{ 0x3d800, 1, 0x1f, 0x1c0},
	{ 0x3d804, 255, 0x1f, 0x180},
	{ 0x3dc00, 1, 0x1f, 0x1c0},
	{ 0x3dc04, 255, 0x1f, 0x180},
	{ 0x3e000, 1, 0x1f, 0x1c0},
	{ 0x3e004, 255, 0x1f, 0x180},
	{ 0x3e400, 1, 0x1f, 0x1c0},
	{ 0x3e404, 255, 0x1f, 0x180},
	{ 0x3e800, 1, 0x1f, 0x1c0},
	{ 0x3e804, 255, 0x1f, 0x180},
	{ 0x3ec00, 1, 0x1f, 0x1c0},
	{ 0x3ec04, 255, 0x1f, 0x180},
	{ 0x3f000, 1, 0x1f, 0x1c0},
	{ 0x3f004, 255, 0x1f, 0x180},
	{ 0x3f400, 1, 0x1f, 0x1c0},
	{ 0x3f404, 255, 0x1f, 0x180},
	{ 0x3f800, 1, 0x1f, 0x1c0},
	{ 0x3f804, 255, 0x1f, 0x180},
	{ 0x3fc00, 1, 0x1f, 0x1c0},
	{ 0x3fc04, 255, 0x1f, 0x180},
	{ 0x40000, 85, 0x1f, 0x924},
	{ 0x40154, 13, 0x1f, 0xfff},
	{ 0x40198, 2, 0x1f, 0x1fff},
	{ 0x401a4, 1, 0x1f, 0x1fff},
	{ 0x401a8, 8, 0x1e, 0x924},
	{ 0x401c8, 1, 0x2, 0x924},
	{ 0x401cc, 2, 0x1e, 0x924},
	{ 0x401d4, 2, 0x1c, 0x924},
	{ 0x40200, 4, 0x1f, 0x924},
	{ 0x40220, 6, 0x1c, 0x924},
	{ 0x40238, 8, 0xc, 0x924},
	{ 0x40258, 4, 0x1c, 0x924},
	{ 0x40268, 2, 0x18, 0x924},
	{ 0x40270, 17, 0x10, 0x924},
	{ 0x40400, 43, 0x1f, 0x924},
	{ 0x404bc, 2, 0x1f, 0x1fff},
	{ 0x404c8, 1, 0x1f, 0x1fff},
	{ 0x404cc, 3, 0x1e, 0x924},
	{ 0x404e0, 1, 0x1c, 0x924},
	{ 0x40500, 2, 0x1f, 0x924},
	{ 0x40510, 2, 0x1f, 0x924},
	{ 0x40520, 2, 0x1f, 0x924},
	{ 0x40530, 2, 0x1f, 0x924},
	{ 0x40540, 2, 0x1f, 0x924},
	{ 0x40550, 10, 0x1c, 0x924},
	{ 0x40610, 2, 0x1c, 0x924},
	{ 0x42000, 164, 0x1f, 0x924},
	{ 0x422b0, 2, 0x1f, 0x1fff},
	{ 0x422bc, 1, 0x1f, 0x1fff},
	{ 0x422c0, 4, 0x1c, 0x924},
	{ 0x422d4, 5, 0x1e, 0x924},
	{ 0x422e8, 1, 0x1c, 0x924},
	{ 0x42400, 49, 0x1f, 0x924},
	{ 0x424c8, 32, 0x1f, 0x924},
	{ 0x42548, 1, 0x1f, 0xfff},
	{ 0x4254c, 1, 0x1f, 0x924},
	{ 0x42550, 1, 0x1f, 0xfff},
	{ 0x42554, 1, 0x1f, 0x924},
	{ 0x42558, 1, 0x1f, 0xfff},
	{ 0x4255c, 1, 0x1f, 0x924},
	{ 0x42568, 2, 0x1f, 0x924},
	{ 0x42640, 5, 0x1c, 0x924},
	{ 0x42800, 1, 0x1f, 0x924},
	{ 0x50000, 1, 0x1f, 0x1fff},
	{ 0x50004, 19, 0x1f, 0x924},
	{ 0x50050, 8, 0x1f, 0x93c},
	{ 0x50070, 60, 0x1f, 0x924},
	{ 0x50160, 8, 0x1f, 0xfff},
	{ 0x50180, 20, 0x1f, 0x924},
	{ 0x501e0, 2, 0x1f, 0x1fff},
	{ 0x501ec, 1, 0x1f, 0x1fff},
	{ 0x501f0, 4, 0x1e, 0x924},
	{ 0x50200, 1, 0x1f, 0x924},
	{ 0x50204, 1, 0x1f, 0xfff},
	{ 0x5020c, 2, 0x1f, 0xfff},
	{ 0x50214, 2, 0x1f, 0x924},
	{ 0x5021c, 1, 0x1f, 0xfff},
	{ 0x50220, 2, 0x1f, 0x924},
	{ 0x50228, 6, 0x1e, 0x924},
	{ 0x50240, 1, 0x1f, 0x924},
	{ 0x50280, 1, 0x1f, 0x924},
	{ 0x50300, 1, 0x1c, 0x924},
	{ 0x5030c, 1, 0x1c, 0x924},
	{ 0x50318, 1, 0x1c, 0x934},
	{ 0x5031c, 1, 0x1c, 0x924},
	{ 0x50320, 2, 0x1c, 0x934},
	{ 0x50330, 1, 0x10, 0x924},
	{ 0x52000, 1, 0x1f, 0x924},
	{ 0x54000, 1, 0x1f, 0x93c},
	{ 0x54004, 255, 0x1f, 0x30},
	{ 0x54400, 1, 0x1f, 0x38},
	{ 0x54404, 255, 0x1f, 0x30},
	{ 0x54800, 1, 0x1f, 0x38},
	{ 0x54804, 255, 0x1f, 0x30},
	{ 0x54c00, 1, 0x1f, 0x38},
	{ 0x54c04, 255, 0x1f, 0x30},
	{ 0x55000, 1, 0x1f, 0x38},
	{ 0x55004, 255, 0x1f, 0x30},
	{ 0x55400, 1, 0x1f, 0x38},
	{ 0x55404, 255, 0x1f, 0x30},
	{ 0x55800, 1, 0x1f, 0x38},
	{ 0x55804, 255, 0x1f, 0x30},
	{ 0x55c00, 1, 0x1f, 0x38},
	{ 0x55c04, 255, 0x1f, 0x30},
	{ 0x56000, 1, 0x1f, 0x38},
	{ 0x56004, 255, 0x1f, 0x30},
	{ 0x56400, 1, 0x1f, 0x38},
	{ 0x56404, 255, 0x1f, 0x30},
	{ 0x56800, 1, 0x1f, 0x38},
	{ 0x56804, 255, 0x1f, 0x30},
	{ 0x56c00, 1, 0x1f, 0x38},
	{ 0x56c04, 255, 0x1f, 0x30},
	{ 0x57000, 1, 0x1f, 0x38},
	{ 0x57004, 255, 0x1f, 0x30},
	{ 0x58000, 1, 0x1f, 0x934},
	{ 0x58004, 8191, 0x3, 0x30},
	{ 0x60000, 26, 0x1f, 0x924},
	{ 0x60068, 8, 0x3, 0x924},
	{ 0x60088, 2, 0x1f, 0x924},
	{ 0x60090, 1, 0x1f, 0xfff},
	{ 0x60094, 9, 0x1f, 0x924},
	{ 0x600b8, 9, 0x3, 0x924},
	{ 0x600dc, 1, 0x1f, 0x924},
	{ 0x600e0, 5, 0x3, 0x924},
	{ 0x600f4, 1, 0x7, 0x924},
	{ 0x600f8, 1, 0x3, 0x924},
	{ 0x600fc, 8, 0x1f, 0x924},
	{ 0x6012c, 2, 0x1f, 0x1fff},
	{ 0x60138, 1, 0x1f, 0x1fff},
	{ 0x6013c, 24, 0x2, 0x924},
	{ 0x6019c, 2, 0x1c, 0x924},
	{ 0x601ac, 18, 0x1c, 0x924},
	{ 0x60200, 1, 0x1f, 0xb6d},
	{ 0x60204, 2, 0x1f, 0x249},
	{ 0x60210, 13, 0x1c, 0x924},
	{ 0x60244, 16, 0x10, 0x924},
	{ 0x61000, 1, 0x1f, 0xb6d},
	{ 0x61004, 511, 0x1f, 0x249},
	{ 0x61800, 512, 0x18, 0x249},
	{ 0x70000, 8, 0x1f, 0xb6d},
	{ 0x70020, 8184, 0x1f, 0x249},
	{ 0x78000, 8192, 0x18, 0x249},
	{ 0x85000, 3, 0x1f, 0x1000},
	{ 0x8501c, 7, 0x1f, 0x1000},
	{ 0x85048, 1, 0x1f, 0x1000},
	{ 0x85200, 32, 0x1f, 0x1000},
	{ 0xa0000, 16384, 0x3, 0x1000},
	{ 0xb0000, 16384, 0x2, 0x1000},
	{ 0xc1000, 7, 0x1f, 0x924},
	{ 0xc102c, 2, 0x1f, 0x1fff},
	{ 0xc1038, 1, 0x1f, 0x1fff},
	{ 0xc103c, 2, 0x1c, 0x924},
	{ 0xc1800, 2, 0x1f, 0x924},
	{ 0xc2000, 164, 0x1f, 0x924},
	{ 0xc22b0, 2, 0x1f, 0x1fff},
	{ 0xc22bc, 1, 0x1f, 0x1fff},
	{ 0xc22c0, 5, 0x1c, 0x924},
	{ 0xc22d8, 4, 0x1c, 0x924},
	{ 0xc2400, 49, 0x1f, 0x924},
	{ 0xc24c8, 32, 0x1f, 0x924},
	{ 0xc2548, 1, 0x1f, 0xfff},
	{ 0xc254c, 1, 0x1f, 0x924},
	{ 0xc2550, 1, 0x1f, 0xfff},
	{ 0xc2554, 1, 0x1f, 0x924},
	{ 0xc2558, 1, 0x1f, 0xfff},
	{ 0xc255c, 1, 0x1f, 0x924},
	{ 0xc2568, 2, 0x1f, 0x924},
	{ 0xc2600, 1, 0x1f, 0x924},
	{ 0xc4000, 165, 0x1f, 0x924},
	{ 0xc42b4, 2, 0x1f, 0x1fff},
	{ 0xc42c0, 1, 0x1f, 0x1fff},
	{ 0xc42d8, 2, 0x1c, 0x924},
	{ 0xc42e0, 7, 0x1e, 0x924},
	{ 0xc42fc, 1, 0x1c, 0x924},
	{ 0xc4400, 51, 0x1f, 0x924},
	{ 0xc44d0, 32, 0x1f, 0x924},
	{ 0xc4550, 1, 0x1f, 0xfff},
	{ 0xc4554, 1, 0x1f, 0x924},
	{ 0xc4558, 1, 0x1f, 0xfff},
	{ 0xc455c, 1, 0x1f, 0x924},
	{ 0xc4560, 1, 0x1f, 0xfff},
	{ 0xc4564, 1, 0x1f, 0x924},
	{ 0xc4570, 2, 0x1f, 0x924},
	{ 0xc4578, 5, 0x1c, 0x924},
	{ 0xc4600, 1, 0x1f, 0x924},
	{ 0xd0000, 19, 0x1f, 0x924},
	{ 0xd004c, 8, 0x1f, 0x1927},
	{ 0xd006c, 64, 0x1f, 0x924},
	{ 0xd016c, 8, 0x1f, 0xfff},
	{ 0xd018c, 19, 0x1f, 0x924},
	{ 0xd01e8, 2, 0x1f, 0x1fff},
	{ 0xd01f4, 1, 0x1f, 0x1fff},
	{ 0xd01fc, 1, 0x1c, 0x924},
	{ 0xd0200, 1, 0x1f, 0x924},
	{ 0xd0204, 1, 0x1f, 0xfff},
	{ 0xd020c, 3, 0x1f, 0xfff},
	{ 0xd0218, 4, 0x1f, 0x924},
	{ 0xd0228, 18, 0x1e, 0x924},
	{ 0xd0280, 1, 0x1f, 0x924},
	{ 0xd0300, 1, 0x1f, 0x924},
	{ 0xd0400, 1, 0x1f, 0x924},
	{ 0xd0818, 1, 0x10, 0x924},
	{ 0xd4000, 1, 0x1f, 0x1927},
	{ 0xd4004, 255, 0x1f, 0x6},
	{ 0xd4400, 1, 0x1f, 0x1007},
	{ 0xd4404, 255, 0x1f, 0x6},
	{ 0xd4800, 1, 0x1f, 0x1007},
	{ 0xd4804, 255, 0x1f, 0x6},
	{ 0xd4c00, 1, 0x1f, 0x1007},
	{ 0xd4c04, 255, 0x1f, 0x6},
	{ 0xd5000, 1, 0x1f, 0x1007},
	{ 0xd5004, 255, 0x1f, 0x6},
	{ 0xd5400, 1, 0x1f, 0x1007},
	{ 0xd5404, 255, 0x1f, 0x6},
	{ 0xd5800, 1, 0x1f, 0x1007},
	{ 0xd5804, 255, 0x1f, 0x6},
	{ 0xd5c00, 1, 0x1f, 0x1007},
	{ 0xd5c04, 255, 0x1f, 0x6},
	{ 0xd6000, 1, 0x1f, 0x1007},
	{ 0xd6004, 255, 0x1f, 0x6},
	{ 0xd6400, 1, 0x1f, 0x1007},
	{ 0xd6404, 255, 0x1f, 0x6},
	{ 0xd8000, 1, 0x1f, 0x1927},
	{ 0xd8004, 255, 0x1f, 0x6},
	{ 0xd8400, 1, 0x1f, 0x1007},
	{ 0xd8404, 255, 0x1f, 0x6},
	{ 0xd8800, 1, 0x1f, 0x1007},
	{ 0xd8804, 255, 0x1f, 0x6},
	{ 0xd8c00, 1, 0x1f, 0x1007},
	{ 0xd8c04, 255, 0x1f, 0x6},
	{ 0xd9000, 1, 0x1f, 0x1007},
	{ 0xd9004, 255, 0x1f, 0x6},
	{ 0xd9400, 1, 0x1f, 0x1007},
	{ 0xd9404, 255, 0x1f, 0x6},
	{ 0xd9800, 1, 0x1f, 0x1007},
	{ 0xd9804, 255, 0x1f, 0x6},
	{ 0xd9c00, 1, 0x1f, 0x1007},
	{ 0xd9c04, 255, 0x1f, 0x6},
	{ 0xda000, 1, 0x1f, 0x1007},
	{ 0xda004, 255, 0x1f, 0x6},
	{ 0xda400, 1, 0x1f, 0x1007},
	{ 0xda404, 255, 0x1f, 0x6},
	{ 0xda800, 1, 0x1f, 0x1007},
	{ 0xda804, 255, 0x1f, 0x6},
	{ 0xdac00, 1, 0x1f, 0x1007},
	{ 0xdac04, 255, 0x1f, 0x6},
	{ 0xdb000, 1, 0x1f, 0x1007},
	{ 0xdb004, 255, 0x1f, 0x6},
	{ 0xdb400, 1, 0x1f, 0x1007},
	{ 0xdb404, 255, 0x1f, 0x6},
	{ 0xdb800, 1, 0x1f, 0x1007},
	{ 0xdb804, 255, 0x1f, 0x6},
	{ 0xdbc00, 1, 0x1f, 0x1007},
	{ 0xdbc04, 255, 0x1f, 0x6},
	{ 0xdc000, 1, 0x1f, 0x1007},
	{ 0xdc004, 255, 0x1f, 0x6},
	{ 0xdc400, 1, 0x1f, 0x1007},
	{ 0xdc404, 255, 0x1f, 0x6},
	{ 0xdc800, 1, 0x1f, 0x1007},
	{ 0xdc804, 255, 0x1f, 0x6},
	{ 0xdcc00, 1, 0x1f, 0x1007},
	{ 0xdcc04, 255, 0x1f, 0x6},
	{ 0xdd000, 1, 0x1f, 0x1007},
	{ 0xdd004, 255, 0x1f, 0x6},
	{ 0xdd400, 1, 0x1f, 0x1007},
	{ 0xdd404, 255, 0x1f, 0x6},
	{ 0xdd800, 1, 0x1f, 0x1007},
	{ 0xdd804, 255, 0x1f, 0x6},
	{ 0xddc00, 1, 0x1f, 0x1007},
	{ 0xddc04, 255, 0x1f, 0x6},
	{ 0xde000, 1, 0x1f, 0x1007},
	{ 0xde004, 255, 0x1f, 0x6},
	{ 0xde400, 1, 0x1f, 0x1007},
	{ 0xde404, 255, 0x1f, 0x6},
	{ 0xde800, 1, 0x1f, 0x1007},
	{ 0xde804, 255, 0x1f, 0x6},
	{ 0xdec00, 1, 0x1f, 0x1007},
	{ 0xdec04, 255, 0x1f, 0x6},
	{ 0xdf000, 1, 0x1f, 0x1007},
	{ 0xdf004, 255, 0x1f, 0x6},
	{ 0xdf400, 1, 0x1f, 0x1007},
	{ 0xdf404, 255, 0x1f, 0x6},
	{ 0xdf800, 1, 0x1f, 0x1007},
	{ 0xdf804, 255, 0x1f, 0x6},
	{ 0xdfc00, 1, 0x1f, 0x1007},
	{ 0xdfc04, 255, 0x1f, 0x6},
	{ 0xe0000, 21, 0x1f, 0x924},
	{ 0xe0054, 8, 0x1f, 0xf24},
	{ 0xe0074, 49, 0x1f, 0x924},
	{ 0xe0138, 1, 0x3, 0x924},
	{ 0xe013c, 6, 0x1f, 0x924},
	{ 0xe0154, 8, 0x1f, 0xfff},
	{ 0xe0174, 21, 0x1f, 0x924},
	{ 0xe01d8, 2, 0x1f, 0x1fff},
	{ 0xe01e4, 1, 0x1f, 0x1fff},
	{ 0xe01f4, 1, 0x4, 0x924},
	{ 0xe01f8, 1, 0x1c, 0x924},
	{ 0xe0200, 1, 0x1f, 0x924},
	{ 0xe0204, 1, 0x1f, 0xfff},
	{ 0xe020c, 2, 0x1f, 0xfff},
	{ 0xe0214, 2, 0x1f, 0x924},
	{ 0xe021c, 2, 0x1f, 0xfff},
	{ 0xe0224, 2, 0x1f, 0x924},
	{ 0xe022c, 18, 0x1e, 0x924},
	{ 0xe0280, 1, 0x1f, 0x924},
	{ 0xe0300, 1, 0x1f, 0x924},
	{ 0xe0400, 1, 0x10, 0x924},
	{ 0xe1000, 1, 0x1f, 0x924},
	{ 0xe2000, 1, 0x1f, 0xf24},
	{ 0xe2004, 255, 0x1f, 0xc00},
	{ 0xe2400, 1, 0x1f, 0xe00},
	{ 0xe2404, 255, 0x1f, 0xc00},
	{ 0xe2800, 1, 0x1f, 0xe00},
	{ 0xe2804, 255, 0x1f, 0xc00},
	{ 0xe2c00, 1, 0x1f, 0xe00},
	{ 0xe2c04, 255, 0x1f, 0xc00},
	{ 0xe3000, 1, 0x1f, 0xe00},
	{ 0xe3004, 255, 0x1f, 0xc00},
	{ 0xe3400, 1, 0x1f, 0xe00},
	{ 0xe3404, 255, 0x1f, 0xc00},
	{ 0xe3800, 1, 0x1f, 0xe00},
	{ 0xe3804, 255, 0x1f, 0xc00},
	{ 0xe3c00, 1, 0x1f, 0xe00},
	{ 0xe3c04, 255, 0x1f, 0xc00},
	{ 0xf0000, 1, 0x1f, 0xf24},
	{ 0xf0004, 255, 0x1f, 0xc00},
	{ 0xf0400, 1, 0x1f, 0xe00},
	{ 0xf0404, 255, 0x1f, 0xc00},
	{ 0xf0800, 1, 0x1f, 0xe00},
	{ 0xf0804, 255, 0x1f, 0xc00},
	{ 0xf0c00, 1, 0x1f, 0xe00},
	{ 0xf0c04, 255, 0x1f, 0xc00},
	{ 0xf1000, 1, 0x1f, 0xe00},
	{ 0xf1004, 255, 0x1f, 0xc00},
	{ 0xf1400, 1, 0x1f, 0xe00},
	{ 0xf1404, 255, 0x1f, 0xc00},
	{ 0xf1800, 1, 0x1f, 0xe00},
	{ 0xf1804, 255, 0x1f, 0xc00},
	{ 0xf1c00, 1, 0x1f, 0xe00},
	{ 0xf1c04, 255, 0x1f, 0xc00},
	{ 0xf2000, 1, 0x1f, 0xe00},
	{ 0xf2004, 255, 0x1f, 0xc00},
	{ 0xf2400, 1, 0x1f, 0xe00},
	{ 0xf2404, 255, 0x1f, 0xc00},
	{ 0xf2800, 1, 0x1f, 0xe00},
	{ 0xf2804, 255, 0x1f, 0xc00},
	{ 0xf2c00, 1, 0x1f, 0xe00},
	{ 0xf2c04, 255, 0x1f, 0xc00},
	{ 0xf3000, 1, 0x1f, 0xe00},
	{ 0xf3004, 255, 0x1f, 0xc00},
	{ 0xf3400, 1, 0x1f, 0xe00},
	{ 0xf3404, 255, 0x1f, 0xc00},
	{ 0xf3800, 1, 0x1f, 0xe00},
	{ 0xf3804, 255, 0x1f, 0xc00},
	{ 0xf3c00, 1, 0x1f, 0xe00},
	{ 0xf3c04, 255, 0x1f, 0xc00},
	{ 0xf4000, 1, 0x1f, 0xe00},
	{ 0xf4004, 255, 0x1f, 0xc00},
	{ 0xf4400, 1, 0x1f, 0xe00},
	{ 0xf4404, 255, 0x1f, 0xc00},
	{ 0xf4800, 1, 0x1f, 0xe00},
	{ 0xf4804, 255, 0x1f, 0xc00},
	{ 0xf4c00, 1, 0x1f, 0xe00},
	{ 0xf4c04, 255, 0x1f, 0xc00},
	{ 0xf5000, 1, 0x1f, 0xe00},
	{ 0xf5004, 255, 0x1f, 0xc00},
	{ 0xf5400, 1, 0x1f, 0xe00},
	{ 0xf5404, 255, 0x1f, 0xc00},
	{ 0xf5800, 1, 0x1f, 0xe00},
	{ 0xf5804, 255, 0x1f, 0xc00},
	{ 0xf5c00, 1, 0x1f, 0xe00},
	{ 0xf5c04, 255, 0x1f, 0xc00},
	{ 0xf6000, 1, 0x1f, 0xe00},
	{ 0xf6004, 255, 0x1f, 0xc00},
	{ 0xf6400, 1, 0x1f, 0xe00},
	{ 0xf6404, 255, 0x1f, 0xc00},
	{ 0xf6800, 1, 0x1f, 0xe00},
	{ 0xf6804, 255, 0x1f, 0xc00},
	{ 0xf6c00, 1, 0x1f, 0xe00},
	{ 0xf6c04, 255, 0x1f, 0xc00},
	{ 0xf7000, 1, 0x1f, 0xe00},
	{ 0xf7004, 255, 0x1f, 0xc00},
	{ 0xf7400, 1, 0x1f, 0xe00},
	{ 0xf7404, 255, 0x1f, 0xc00},
	{ 0xf7800, 1, 0x1f, 0xe00},
	{ 0xf7804, 255, 0x1f, 0xc00},
	{ 0xf7c00, 1, 0x1f, 0xe00},
	{ 0xf7c04, 255, 0x1f, 0xc00},
	{ 0xf8000, 1, 0x1f, 0xe00},
	{ 0xf8004, 255, 0x1f, 0xc00},
	{ 0xf8400, 1, 0x1f, 0xe00},
	{ 0xf8404, 255, 0x1f, 0xc00},
	{ 0xf8800, 1, 0x1f, 0xe00},
	{ 0xf8804, 255, 0x1f, 0xc00},
	{ 0xf8c00, 1, 0x1f, 0xe00},
	{ 0xf8c04, 255, 0x1f, 0xc00},
	{ 0xf9000, 1, 0x1f, 0xe00},
	{ 0xf9004, 255, 0x1f, 0xc00},
	{ 0xf9400, 1, 0x1f, 0xe00},
	{ 0xf9404, 255, 0x1f, 0xc00},
	{ 0xf9800, 1, 0x1f, 0xe00},
	{ 0xf9804, 255, 0x1f, 0xc00},
	{ 0xf9c00, 1, 0x1f, 0xe00},
	{ 0xf9c04, 255, 0x1f, 0xc00},
	{ 0xfa000, 1, 0x1f, 0xe00},
	{ 0xfa004, 255, 0x1f, 0xc00},
	{ 0xfa400, 1, 0x1f, 0xe00},
	{ 0xfa404, 255, 0x1f, 0xc00},
	{ 0xfa800, 1, 0x1f, 0xe00},
	{ 0xfa804, 255, 0x1f, 0xc00},
	{ 0xfac00, 1, 0x1f, 0xe00},
	{ 0xfac04, 255, 0x1f, 0xc00},
	{ 0xfb000, 1, 0x1f, 0xe00},
	{ 0xfb004, 255, 0x1f, 0xc00},
	{ 0xfb400, 1, 0x1f, 0xe00},
	{ 0xfb404, 255, 0x1f, 0xc00},
	{ 0xfb800, 1, 0x1f, 0xe00},
	{ 0xfb804, 255, 0x1f, 0xc00},
	{ 0xfbc00, 1, 0x1f, 0xe00},
	{ 0xfbc04, 255, 0x1f, 0xc00},
	{ 0xfc000, 1, 0x1f, 0xe00},
	{ 0xfc004, 255, 0x1f, 0xc00},
	{ 0xfc400, 1, 0x1f, 0xe00},
	{ 0xfc404, 255, 0x1f, 0xc00},
	{ 0xfc800, 1, 0x1f, 0xe00},
	{ 0xfc804, 255, 0x1f, 0xc00},
	{ 0xfcc00, 1, 0x1f, 0xe00},
	{ 0xfcc04, 255, 0x1f, 0xc00},
	{ 0xfd000, 1, 0x1f, 0xe00},
	{ 0xfd004, 255, 0x1f, 0xc00},
	{ 0xfd400, 1, 0x1f, 0xe00},
	{ 0xfd404, 255, 0x1f, 0xc00},
	{ 0xfd800, 1, 0x1f, 0xe00},
	{ 0xfd804, 255, 0x1f, 0xc00},
	{ 0xfdc00, 1, 0x1f, 0xe00},
	{ 0xfdc04, 255, 0x1f, 0xc00},
	{ 0xfe000, 1, 0x1f, 0xe00},
	{ 0xfe004, 255, 0x1f, 0xc00},
	{ 0xfe400, 1, 0x1f, 0xe00},
	{ 0xfe404, 255, 0x1f, 0xc00},
	{ 0xfe800, 1, 0x1f, 0xe00},
	{ 0xfe804, 255, 0x1f, 0xc00},
	{ 0xfec00, 1, 0x1f, 0xe00},
	{ 0xfec04, 255, 0x1f, 0xc00},
	{ 0xff000, 1, 0x1f, 0xe00},
	{ 0xff004, 255, 0x1f, 0xc00},
	{ 0xff400, 1, 0x1f, 0xe00},
	{ 0xff404, 255, 0x1f, 0xc00},
	{ 0xff800, 1, 0x1f, 0xe00},
	{ 0xff804, 255, 0x1f, 0xc00},
	{ 0xffc00, 1, 0x1f, 0xe00},
	{ 0xffc04, 255, 0x1f, 0xc00},
	{ 0x101000, 5, 0x1f, 0x924},
	{ 0x101014, 1, 0x1f, 0xfff},
	{ 0x101018, 6, 0x1f, 0x924},
	{ 0x101040, 2, 0x1f, 0x1fff},
	{ 0x10104c, 1, 0x1f, 0x1fff},
	{ 0x101050, 1, 0x1e, 0x924},
	{ 0x101054, 3, 0x1c, 0x924},
	{ 0x101100, 1, 0x1f, 0x924},
	{ 0x101800, 8, 0x1f, 0x924},
	{ 0x102000, 18, 0x1f, 0x924},
	{ 0x102058, 2, 0x1f, 0x1fff},
	{ 0x102064, 1, 0x1f, 0x1fff},
	{ 0x102068, 6, 0x1c, 0x924},
	{ 0x102080, 16, 0x1f, 0xfff},
	{ 0x1020c0, 1, 0x1f, 0x924},
	{ 0x1020c8, 8, 0x2, 0x924},
	{ 0x1020e8, 9, 0x1c, 0x924},
	{ 0x102400, 1, 0x1f, 0x924},
	{ 0x103000, 1, 0x1f, 0x924},
	{ 0x103004, 2, 0x1f, 0xfff},
	{ 0x10300c, 23, 0x1f, 0x924},
	{ 0x103088, 2, 0x1f, 0x1fff},
	{ 0x103094, 1, 0x1f, 0x1fff},
	{ 0x103098, 1, 0x1e, 0x924},
	{ 0x10309c, 2, 0x1e, 0xfff},
	{ 0x1030a4, 2, 0x1e, 0x924},
	{ 0x1030ac, 2, 0x1c, 0x924},
	{ 0x1030b4, 1, 0x4, 0x924},
	{ 0x1030b8, 2, 0x1c, 0xfff},
	{ 0x1030c0, 3, 0x1c, 0x924},
	{ 0x1030cc, 1, 0x1c, 0xfff},
	{ 0x1030d0, 1, 0x1c, 0x924},
	{ 0x1030d8, 2, 0x1c, 0x924},
	{ 0x1030e0, 1, 0x1c, 0xfff},
	{ 0x1030e4, 5, 0x1c, 0x924},
	{ 0x103400, 136, 0x1c, 0x1fff},
	{ 0x103800, 8, 0x1f, 0x924},
	{ 0x104000, 1, 0x1f, 0x924},
	{ 0x104004, 1, 0x1f, 0xfff},
	{ 0x104008, 4, 0x1f, 0x924},
	{ 0x104018, 1, 0x1f, 0xfff},
	{ 0x10401c, 1, 0x1f, 0x924},
	{ 0x104020, 1, 0x1f, 0xfff},
	{ 0x104024, 6, 0x1f, 0x924},
	{ 0x10403c, 1, 0x1f, 0xfff},
	{ 0x104040, 47, 0x1f, 0x924},
	{ 0x10410c, 2, 0x1f, 0x1fff},
	{ 0x104118, 1, 0x1f, 0x1fff},
	{ 0x10411c, 16, 0x1c, 0x924},
	{ 0x104200, 17, 0x1f, 0x924},
	{ 0x104400, 1, 0x1f, 0x1fff},
	{ 0x104404, 63, 0x1f, 0xfff},
	{ 0x104500, 192, 0x1f, 0xdb6},
	{ 0x104800, 1, 0x1f, 0x1fff},
	{ 0x104804, 63, 0x1f, 0xfff},
	{ 0x104900, 192, 0x1f, 0xdb6},
	{ 0x105000, 4, 0x1f, 0x1fff},
	{ 0x105010, 252, 0x1f, 0xfff},
	{ 0x105400, 768, 0x1f, 0xdb6},
	{ 0x107000, 7, 0x1c, 0x924},
	{ 0x10701c, 1, 0x18, 0x924},
	{ 0x108000, 33, 0x3, 0x924},
	{ 0x1080ac, 5, 0x2, 0x924},
	{ 0x108100, 5, 0x3, 0x924},
	{ 0x108120, 5, 0x3, 0x924},
	{ 0x108200, 74, 0x3, 0x924},
	{ 0x108400, 74, 0x3, 0x924},
	{ 0x108800, 152, 0x3, 0x924},
	{ 0x110000, 111, 0x1c, 0x924},
	{ 0x1101cc, 2, 0x1c, 0x1fff},
	{ 0x1101d8, 1, 0x1c, 0x1fff},
	{ 0x1101dc, 1, 0x18, 0x924},
	{ 0x110200, 4, 0x1c, 0x924},
	{ 0x120000, 92, 0x1f, 0x924},
	{ 0x120170, 2, 0x3, 0x924},
	{ 0x120178, 14, 0x1f, 0x924},
	{ 0x1201b0, 2, 0x1f, 0xfff},
	{ 0x1201b8, 93, 0x1f, 0x924},
	{ 0x12032c, 1, 0x1f, 0xfff},
	{ 0x120330, 15, 0x1f, 0x924},
	{ 0x12036c, 3, 0x1f, 0xfff},
	{ 0x120378, 36, 0x1f, 0x924},
	{ 0x120408, 2, 0x1f, 0xfff},
	{ 0x120410, 1, 0x1f, 0x924},
	{ 0x120414, 15, 0x1f, 0xfff},
	{ 0x120450, 10, 0x1f, 0x924},
	{ 0x120478, 2, 0x1f, 0xfff},
	{ 0x120480, 43, 0x1f, 0x924},
	{ 0x12052c, 1, 0x1f, 0xfff},
	{ 0x120530, 5, 0x1f, 0x924},
	{ 0x120544, 4, 0x3, 0x924},
	{ 0x120554, 4, 0x1f, 0x924},
	{ 0x120564, 2, 0x1f, 0xfff},
	{ 0x12057c, 2, 0x1f, 0x1fff},
	{ 0x120588, 3, 0x1f, 0x1fff},
	{ 0x120598, 1, 0x1f, 0x1fff},
	{ 0x12059c, 22, 0x1e, 0x924},
	{ 0x1205f4, 1, 0x6, 0x924},
	{ 0x1205f8, 4, 0x1c, 0x924},
	{ 0x120618, 1, 0x1c, 0x924},
	{ 0x12061c, 31, 0x1e, 0x924},
	{ 0x120698, 3, 0x1c, 0x924},
	{ 0x1206a4, 1, 0x4, 0x924},
	{ 0x1206a8, 1, 0x1c, 0x924},
	{ 0x1206b0, 38, 0x1c, 0x924},
	{ 0x120748, 1, 0x1c, 0xfff},
	{ 0x12074c, 11, 0x1c, 0x924},
	{ 0x120778, 2, 0x1c, 0xfff},
	{ 0x120780, 23, 0x1c, 0x924},
	{ 0x1207dc, 1, 0x4, 0x924},
	{ 0x1207fc, 1, 0x1c, 0x924},
	{ 0x12080c, 2, 0x1f, 0xfff},
	{ 0x120814, 1, 0x1f, 0x924},
	{ 0x120818, 1, 0x1f, 0xfff},
	{ 0x12081c, 1, 0x1f, 0x924},
	{ 0x120820, 1, 0x1f, 0xfff},
	{ 0x120824, 1, 0x1f, 0x924},
	{ 0x120828, 1, 0x1f, 0xfff},
	{ 0x12082c, 1, 0x1f, 0x924},
	{ 0x120830, 1, 0x1f, 0xfff},
	{ 0x120834, 1, 0x1f, 0x924},
	{ 0x120838, 1, 0x1f, 0xfff},
	{ 0x12083c, 1, 0x1f, 0x924},
	{ 0x120840, 1, 0x1f, 0xfff},
	{ 0x120844, 1, 0x1f, 0x924},
	{ 0x120848, 1, 0x1f, 0xfff},
	{ 0x12084c, 1, 0x1f, 0x924},
	{ 0x120850, 1, 0x1f, 0xfff},
	{ 0x120854, 1, 0x1f, 0x924},
	{ 0x120858, 1, 0x1f, 0xfff},
	{ 0x12085c, 1, 0x1f, 0x924},
	{ 0x120860, 1, 0x1f, 0xfff},
	{ 0x120864, 1, 0x1f, 0x924},
	{ 0x120868, 1, 0x1f, 0xfff},
	{ 0x12086c, 1, 0x1f, 0x924},
	{ 0x120870, 1, 0x1f, 0xfff},
	{ 0x120874, 1, 0x1f, 0x924},
	{ 0x120878, 1, 0x1f, 0xfff},
	{ 0x12087c, 1, 0x1f, 0x924},
	{ 0x120880, 1, 0x1f, 0xfff},
	{ 0x120884, 1, 0x1f, 0x924},
	{ 0x120888, 1, 0x1f, 0xfff},
	{ 0x12088c, 1, 0x1f, 0x924},
	{ 0x120890, 1, 0x1f, 0xfff},
	{ 0x120894, 1, 0x1f, 0x924},
	{ 0x120898, 1, 0x1f, 0xfff},
	{ 0x12089c, 1, 0x1f, 0x924},
	{ 0x1208a0, 1, 0x1f, 0xfff},
	{ 0x1208a4, 1, 0x1f, 0x924},
	{ 0x1208a8, 1, 0x1f, 0xfff},
	{ 0x1208ac, 1, 0x1f, 0x924},
	{ 0x1208b0, 1, 0x1f, 0xfff},
	{ 0x1208b4, 1, 0x1f, 0x924},
	{ 0x1208b8, 1, 0x1f, 0xfff},
	{ 0x1208bc, 1, 0x1f, 0x924},
	{ 0x1208c0, 1, 0x1f, 0xfff},
	{ 0x1208c4, 1, 0x1f, 0x924},
	{ 0x1208c8, 1, 0x1f, 0xfff},
	{ 0x1208cc, 1, 0x1f, 0x924},
	{ 0x1208d0, 1, 0x1f, 0xfff},
	{ 0x1208d4, 1, 0x1f, 0x924},
	{ 0x1208d8, 1, 0x1f, 0xfff},
	{ 0x1208dc, 1, 0x1f, 0x924},
	{ 0x1208e0, 1, 0x1f, 0xfff},
	{ 0x1208e4, 1, 0x1f, 0x924},
	{ 0x1208e8, 1, 0x1f, 0xfff},
	{ 0x1208ec, 1, 0x1f, 0x924},
	{ 0x1208f0, 1, 0x1f, 0xfff},
	{ 0x1208f4, 1, 0x1f, 0x924},
	{ 0x1208f8, 1, 0x1f, 0xfff},
	{ 0x1208fc, 1, 0x1f, 0x924},
	{ 0x120900, 1, 0x1f, 0xfff},
	{ 0x120904, 1, 0x1f, 0x924},
	{ 0x120908, 1, 0x1f, 0xfff},
	{ 0x12090c, 1, 0x1f, 0x924},
	{ 0x120910, 7, 0x1c, 0x924},
	{ 0x120930, 9, 0x1c, 0x924},
	{ 0x12095c, 37, 0x18, 0x924},
	{ 0x120a00, 2, 0x7, 0x924},
	{ 0x120b00, 1, 0x18, 0x924},
	{ 0x122000, 2, 0x1f, 0x924},
	{ 0x122008, 2046, 0x1, 0x924},
	{ 0x128000, 6144, 0x1e, 0x924},
	{ 0x130000, 1, 0x1c, 0x1fff},
	{ 0x130004, 11, 0x1c, 0x924},
	{ 0x130030, 1, 0x1c, 0xfff},
	{ 0x130034, 6, 0x1c, 0x924},
	{ 0x13004c, 3, 0x1c, 0xfff},
	{ 0x130058, 3, 0x1c, 0x924},
	{ 0x130064, 2, 0x1c, 0xfff},
	{ 0x13006c, 8, 0x1c, 0x924},
	{ 0x13009c, 2, 0x1c, 0x1fff},
	{ 0x1300a8, 1, 0x1c, 0x1fff},
	{ 0x130100, 12, 0x1c, 0x924},
	{ 0x130130, 1, 0x1c, 0xfff},
	{ 0x130134, 14, 0x1c, 0x924},
	{ 0x13016c, 1, 0x1c, 0xfff},
	{ 0x130170, 1, 0x1c, 0x924},
	{ 0x130180, 1, 0x1c, 0x924},
	{ 0x130200, 1, 0x1c, 0x924},
	{ 0x130280, 1, 0x1c, 0x924},
	{ 0x130300, 1, 0x1c, 0xfff},
	{ 0x130304, 4, 0x1c, 0x924},
	{ 0x130380, 1, 0x1c, 0x924},
	{ 0x130400, 1, 0x1c, 0x924},
	{ 0x130480, 1, 0x1c, 0xfff},
	{ 0x130484, 4, 0x1c, 0x924},
	{ 0x130800, 72, 0x1c, 0x924},
	{ 0x131000, 136, 0x1c, 0x924},
	{ 0x132000, 148, 0x1c, 0x924},
	{ 0x134000, 544, 0x1c, 0x924},
	{ 0x140000, 1, 0x1f, 0x924},
	{ 0x140004, 9, 0xf, 0x924},
	{ 0x140028, 8, 0x1f, 0x924},
	{ 0x140048, 5, 0xf, 0x924},
	{ 0x14005c, 2, 0xf, 0xfff},
	{ 0x140064, 3, 0xf, 0x924},
	{ 0x140070, 1, 0x1f, 0x924},
	{ 0x140074, 10, 0xf, 0x924},
	{ 0x14009c, 1, 0x1f, 0x924},
	{ 0x1400a0, 5, 0xf, 0x924},
	{ 0x1400b4, 7, 0x1f, 0x924},
	{ 0x1400d0, 2, 0xf, 0xfff},
	{ 0x1400d8, 2, 0xf, 0x924},
	{ 0x1400e0, 1, 0xf, 0xfff},
	{ 0x1400e4, 5, 0xf, 0x924},
	{ 0x1400f8, 2, 0x1f, 0x924},
	{ 0x140100, 5, 0x3, 0x924},
	{ 0x140114, 5, 0xf, 0x924},
	{ 0x140128, 7, 0x1f, 0x924},
	{ 0x140144, 9, 0xf, 0x924},
	{ 0x140168, 8, 0x1f, 0x924},
	{ 0x140188, 3, 0xf, 0x924},
	{ 0x140194, 13, 0x1f, 0x924},
	{ 0x1401d8, 2, 0x1f, 0x1fff},
	{ 0x1401e4, 1, 0x1f, 0x1fff},
	{ 0x140200, 6, 0xf, 0xfff},
	{ 0x1402e0, 2, 0xc, 0x924},
	{ 0x1402e8, 2, 0x1c, 0x924},
	{ 0x1402f0, 9, 0xc, 0x924},
	{ 0x140314, 9, 0x10, 0x924},
	{ 0x140338, 7, 0x10, 0xfff},
	{ 0x140354, 7, 0x10, 0x924},
	{ 0x140370, 7, 0x10, 0xfff},
	{ 0x14038c, 14, 0x10, 0x924},
	{ 0x1404b0, 14, 0x10, 0x924},
	{ 0x15c000, 2, 0x1e, 0x924},
	{ 0x15c008, 5, 0x2, 0x924},
	{ 0x15c020, 8, 0x1c, 0x924},
	{ 0x15c040, 1, 0xc, 0x924},
	{ 0x15c044, 2, 0x1c, 0x924},
	{ 0x15c04c, 8, 0xc, 0x924},
	{ 0x15c06c, 8, 0x1c, 0x924},
	{ 0x15c090, 13, 0x1c, 0x924},
	{ 0x15c0c8, 24, 0x1c, 0x924},
	{ 0x15c128, 2, 0xc, 0x924},
	{ 0x15c130, 1, 0x1c, 0x924},
	{ 0x15c138, 6, 0x1c, 0x924},
	{ 0x15c150, 2, 0x18, 0x924},
	{ 0x15c158, 2, 0x8, 0x924},
	{ 0x15c160, 23, 0x10, 0x924},
	{ 0x15c1bc, 6, 0x10, 0xfff},
	{ 0x15c1d4, 23, 0x10, 0x924},
	{ 0x15c230, 7, 0x10, 0xfff},
	{ 0x15c24c, 90, 0x10, 0x924},
	{ 0x160004, 6, 0x18, 0x924},
	{ 0x16003c, 1, 0x10, 0x924},
	{ 0x160040, 6, 0x18, 0x924},
	{ 0x16005c, 6, 0x18, 0x924},
	{ 0x160074, 1, 0x10, 0x924},
	{ 0x160078, 2, 0x18, 0x924},
	{ 0x160300, 8, 0x18, 0x924},
	{ 0x160330, 6, 0x18, 0x924},
	{ 0x160404, 6, 0x18, 0x924},
	{ 0x16043c, 1, 0x10, 0x924},
	{ 0x160440, 6, 0x18, 0x924},
	{ 0x16045c, 6, 0x18, 0x924},
	{ 0x160474, 1, 0x10, 0x924},
	{ 0x160478, 2, 0x18, 0x924},
	{ 0x160700, 8, 0x18, 0x924},
	{ 0x160730, 6, 0x18, 0x924},
	{ 0x161000, 7, 0x1f, 0x924},
	{ 0x16102c, 2, 0x1f, 0x1fff},
	{ 0x161038, 1, 0x1f, 0x1fff},
	{ 0x16103c, 2, 0x1c, 0x924},
	{ 0x161800, 2, 0x1f, 0x924},
	{ 0x162000, 54, 0x18, 0x924},
	{ 0x162200, 60, 0x18, 0x924},
	{ 0x162400, 54, 0x18, 0x924},
	{ 0x162600, 60, 0x18, 0x924},
	{ 0x162800, 54, 0x18, 0x924},
	{ 0x162a00, 60, 0x18, 0x924},
	{ 0x162c00, 54, 0x18, 0x924},
	{ 0x162e00, 60, 0x18, 0x924},
	{ 0x163000, 1, 0x18, 0x924},
	{ 0x163008, 1, 0x18, 0x924},
	{ 0x163010, 1, 0x18, 0x924},
	{ 0x163018, 1, 0x18, 0x924},
	{ 0x163020, 5, 0x18, 0x924},
	{ 0x163038, 3, 0x18, 0x924},
	{ 0x163048, 3, 0x18, 0x924},
	{ 0x163058, 1, 0x18, 0x924},
	{ 0x163060, 1, 0x18, 0x924},
	{ 0x163068, 1, 0x18, 0x924},
	{ 0x163070, 3, 0x18, 0x924},
	{ 0x163080, 1, 0x18, 0x924},
	{ 0x163088, 3, 0x18, 0x924},
	{ 0x163098, 1, 0x18, 0x924},
	{ 0x1630a0, 1, 0x18, 0x924},
	{ 0x1630a8, 1, 0x18, 0x924},
	{ 0x1630b0, 2, 0x10, 0x924},
	{ 0x1630c0, 1, 0x18, 0x924},
	{ 0x1630c8, 1, 0x18, 0x924},
	{ 0x1630d0, 1, 0x18, 0x924},
	{ 0x1630d8, 1, 0x18, 0x924},
	{ 0x1630e0, 2, 0x18, 0x924},
	{ 0x163110, 1, 0x18, 0x924},
	{ 0x163120, 2, 0x18, 0x924},
	{ 0x163420, 4, 0x18, 0x924},
	{ 0x163438, 2, 0x18, 0x924},
	{ 0x163488, 2, 0x18, 0x924},
	{ 0x163520, 2, 0x18, 0x924},
	{ 0x163800, 1, 0x18, 0x924},
	{ 0x163808, 1, 0x18, 0x924},
	{ 0x163810, 1, 0x18, 0x924},
	{ 0x163818, 1, 0x18, 0x924},
	{ 0x163820, 5, 0x18, 0x924},
	{ 0x163838, 3, 0x18, 0x924},
	{ 0x163848, 3, 0x18, 0x924},
	{ 0x163858, 1, 0x18, 0x924},
	{ 0x163860, 1, 0x18, 0x924},
	{ 0x163868, 1, 0x18, 0x924},
	{ 0x163870, 3, 0x18, 0x924},
	{ 0x163880, 1, 0x18, 0x924},
	{ 0x163888, 3, 0x18, 0x924},
	{ 0x163898, 1, 0x18, 0x924},
	{ 0x1638a0, 1, 0x18, 0x924},
	{ 0x1638a8, 1, 0x18, 0x924},
	{ 0x1638b0, 2, 0x10, 0x924},
	{ 0x1638c0, 1, 0x18, 0x924},
	{ 0x1638c8, 1, 0x18, 0x924},
	{ 0x1638d0, 1, 0x18, 0x924},
	{ 0x1638d8, 1, 0x18, 0x924},
	{ 0x1638e0, 2, 0x18, 0x924},
	{ 0x163910, 1, 0x18, 0x924},
	{ 0x163920, 2, 0x18, 0x924},
	{ 0x163c20, 4, 0x18, 0x924},
	{ 0x163c38, 2, 0x18, 0x924},
	{ 0x163c88, 2, 0x18, 0x924},
	{ 0x163d20, 2, 0x18, 0x924},
	{ 0x164000, 5, 0x1f, 0x924},
	{ 0x164014, 2, 0x1f, 0xfff},
	{ 0x16401c, 53, 0x1f, 0x924},
	{ 0x164100, 2, 0x1f, 0x1fff},
	{ 0x16410c, 1, 0x1f, 0x1fff},
	{ 0x164110, 2, 0x1e, 0x924},
	{ 0x164118, 15, 0x1c, 0x924},
	{ 0x164200, 1, 0x1f, 0x924},
	{ 0x164208, 1, 0x1f, 0x924},
	{ 0x164210, 1, 0x1f, 0x924},
	{ 0x164218, 1, 0x1f, 0x924},
	{ 0x164220, 1, 0x1f, 0x924},
	{ 0x164228, 1, 0x1f, 0x924},
	{ 0x164230, 1, 0x1f, 0x924},
	{ 0x164238, 1, 0x1f, 0x924},
	{ 0x164240, 1, 0x1f, 0x924},
	{ 0x164248, 1, 0x1f, 0x924},
	{ 0x164250, 1, 0x1f, 0x924},
	{ 0x164258, 1, 0x1f, 0x924},
	{ 0x164260, 1, 0x1f, 0x924},
	{ 0x164270, 2, 0x1f, 0x924},
	{ 0x164280, 2, 0x1f, 0x924},
	{ 0x164800, 2, 0x1f, 0x924},
	{ 0x165000, 2, 0x1f, 0x924},
	{ 0x166000, 164, 0x1f, 0x924},
	{ 0x1662b0, 2, 0x1f, 0x1fff},
	{ 0x1662bc, 1, 0x1f, 0x1fff},
	{ 0x1662cc, 7, 0x1c, 0x924},
	{ 0x166400, 49, 0x1f, 0x924},
	{ 0x1664c8, 32, 0x1f, 0x924},
	{ 0x166548, 1, 0x1f, 0xfff},
	{ 0x16654c, 1, 0x1f, 0x924},
	{ 0x166550, 1, 0x1f, 0xfff},
	{ 0x166554, 1, 0x1f, 0x924},
	{ 0x166558, 1, 0x1f, 0xfff},
	{ 0x16655c, 1, 0x1f, 0x924},
	{ 0x166568, 2, 0x1f, 0x924},
	{ 0x166570, 5, 0x1c, 0x924},
	{ 0x166800, 1, 0x1f, 0x924},
	{ 0x168000, 1, 0x1f, 0xfff},
	{ 0x168004, 1, 0x1f, 0x924},
	{ 0x168008, 1, 0x1f, 0xfff},
	{ 0x16800c, 1, 0x1f, 0x924},
	{ 0x168010, 1, 0x1f, 0xfff},
	{ 0x168014, 1, 0x1f, 0x924},
	{ 0x168018, 1, 0x1f, 0xfff},
	{ 0x16801c, 3, 0x1f, 0x924},
	{ 0x168028, 2, 0x1f, 0xfff},
	{ 0x168030, 10, 0x1f, 0x924},
	{ 0x168058, 9, 0x1f, 0xfff},
	{ 0x16807c, 106, 0x1f, 0x924},
	{ 0x168224, 2, 0x3, 0x924},
	{ 0x16822c, 3, 0x1f, 0x924},
	{ 0x168238, 1, 0x1f, 0xfff},
	{ 0x16823c, 25, 0x1f, 0x924},
	{ 0x1682a0, 12, 0x3, 0x924},
	{ 0x1682d0, 7, 0x1f, 0xfff},
	{ 0x1682ec, 5, 0x1f, 0x924},
	{ 0x168300, 2, 0x3, 0xfff},
	{ 0x168308, 65, 0x1f, 0xfff},
	{ 0x16840c, 1, 0x1f, 0x924},
	{ 0x168410, 2, 0x1f, 0xfff},
	{ 0x168418, 2, 0x3, 0x924},
	{ 0x168420, 6, 0x1f, 0x924},
	{ 0x168448, 2, 0x1f, 0x1fff},
	{ 0x168454, 1, 0x1f, 0x1fff},
	{ 0x168800, 19, 0x1f, 0x924},
	{ 0x168900, 1, 0x1f, 0x924},
	{ 0x168a00, 128, 0x1f, 0xfff},
	{ 0x16a000, 1536, 0x1f, 0x924},
	{ 0x16c000, 1536, 0x1f, 0x924},
	{ 0x16e000, 16, 0x2, 0x924},
	{ 0x16e040, 8, 0x1c, 0x924},
	{ 0x16e100, 1, 0x2, 0x924},
	{ 0x16e200, 2, 0x2, 0xfff},
	{ 0x16e400, 1, 0x2, 0x924},
	{ 0x16e404, 2, 0x2, 0xfff},
	{ 0x16e40c, 94, 0x2, 0x924},
	{ 0x16e584, 64, 0x2, 0xfff},
	{ 0x16e684, 2, 0x1e, 0xfff},
	{ 0x16e68c, 4, 0x2, 0xfff},
	{ 0x16e69c, 8, 0x2, 0x924},
	{ 0x16e6bc, 4, 0x1e, 0x924},
	{ 0x16e6cc, 4, 0x2, 0x924},
	{ 0x16e6e0, 2, 0x1c, 0x924},
	{ 0x16e6e8, 5, 0xc, 0x924},
	{ 0x16e6fc, 4, 0x1c, 0xfff},
	{ 0x16e70c, 1, 0x1c, 0x924},
	{ 0x16e768, 17, 0x1c, 0x924},
	{ 0x16e7ac, 12, 0x10, 0xfff},
	{ 0x170000, 24, 0x1f, 0x924},
	{ 0x170060, 4, 0x3, 0x924},
	{ 0x170070, 13, 0x1f, 0x924},
	{ 0x1700a4, 1, 0x1f, 0xfff},
	{ 0x1700a8, 1, 0x1f, 0x924},
	{ 0x1700ac, 2, 0x1f, 0xfff},
	{ 0x1700b4, 3, 0x1f, 0x924},
	{ 0x1700c0, 1, 0x1f, 0xfff},
	{ 0x1700c4, 44, 0x1f, 0x924},
	{ 0x170184, 2, 0x1f, 0x1fff},
	{ 0x170190, 1, 0x1f, 0x1fff},
	{ 0x170194, 11, 0x1c, 0x924},
	{ 0x1701c4, 1, 0x1c, 0x924},
	{ 0x1701cc, 7, 0x1c, 0x924},
	{ 0x1701e8, 1, 0x18, 0x924},
	{ 0x1701ec, 1, 0x1c, 0x924},
	{ 0x1701f4, 1, 0x1c, 0x924},
	{ 0x170200, 4, 0x1f, 0x924},
	{ 0x170214, 1, 0x1f, 0x924},
	{ 0x170218, 77, 0x1c, 0x924},
	{ 0x170400, 64, 0x1c, 0x924},
	{ 0x178000, 1, 0x1f, 0x924},
	{ 0x180000, 61, 0x1f, 0x924},
	{ 0x180114, 2, 0x1f, 0x1fff},
	{ 0x180120, 3, 0x1f, 0x1fff},
	{ 0x180130, 1, 0x1f, 0x1fff},
	{ 0x18013c, 2, 0x1e, 0x924},
	{ 0x180200, 27, 0x1f, 0x924},
	{ 0x18026c, 1, 0x1f, 0xfff},
	{ 0x180270, 12, 0x1f, 0x924},
	{ 0x1802a0, 1, 0x1f, 0xfff},
	{ 0x1802a4, 17, 0x1f, 0x924},
	{ 0x180340, 4, 0x1f, 0x924},
	{ 0x180380, 1, 0x1c, 0x924},
	{ 0x180388, 1, 0x1c, 0x924},
	{ 0x180390, 1, 0x1c, 0x924},
	{ 0x180398, 1, 0x1c, 0x924},
	{ 0x1803a0, 5, 0x1c, 0x924},
	{ 0x1803b4, 2, 0x18, 0x924},
	{ 0x181000, 4, 0x1f, 0x93c},
	{ 0x181010, 1020, 0x1f, 0x38},
	{ 0x182000, 4, 0x18, 0x924},
	{ 0x1a0000, 1, 0x1f, 0x92c},
	{ 0x1a0004, 5631, 0x1f, 0x8},
	{ 0x1a5800, 2560, 0x1e, 0x8},
	{ 0x1a8000, 1, 0x1f, 0x92c},
	{ 0x1a8004, 8191, 0x1e, 0x8},
	{ 0x1b0000, 1, 0x1f, 0x92c},
	{ 0x1b0004, 15, 0x2, 0x8},
	{ 0x1b0040, 1, 0x1e, 0x92c},
	{ 0x1b0044, 239, 0x2, 0x8},
	{ 0x1b0400, 1, 0x1f, 0x92c},
	{ 0x1b0404, 255, 0x2, 0x8},
	{ 0x1b0800, 1, 0x1f, 0x924},
	{ 0x1b0840, 1, 0x1e, 0x924},
	{ 0x1b0c00, 1, 0x1f, 0x1fff},
	{ 0x1b1000, 1, 0x1f, 0x1fff},
	{ 0x1b1040, 1, 0x1e, 0x1fff},
	{ 0x1b1400, 1, 0x1f, 0x924},
	{ 0x1b1440, 1, 0x1e, 0x924},
	{ 0x1b1480, 1, 0x1e, 0x924},
	{ 0x1b14c0, 1, 0x1e, 0x924},
	{ 0x1b1800, 128, 0x1f, 0x10},
	{ 0x1b1c00, 128, 0x1f, 0x10},
	{ 0x1b2000, 1, 0x1f, 0xdb6},
	{ 0x1b2400, 1, 0x1e, 0x92c},
	{ 0x1b2404, 5631, 0x1c, 0x8},
	{ 0x1b8000, 1, 0x1f, 0xfff},
	{ 0x1b8040, 1, 0x1f, 0xfff},
	{ 0x1b8080, 1, 0x1f, 0xfff},
	{ 0x1b80c0, 1, 0x1f, 0xfff},
	{ 0x1b8100, 1, 0x1f, 0x924},
	{ 0x1b8140, 1, 0x1f, 0x924},
	{ 0x1b8180, 1, 0x1f, 0x924},
	{ 0x1b81c0, 1, 0x1f, 0x924},
	{ 0x1b8200, 1, 0x1f, 0x924},
	{ 0x1b8240, 1, 0x1f, 0x924},
	{ 0x1b8280, 1, 0x1f, 0x924},
	{ 0x1b82c0, 1, 0x1f, 0x924},
	{ 0x1b8300, 1, 0x1f, 0x924},
	{ 0x1b8340, 1, 0x1f, 0x924},
	{ 0x1b8380, 1, 0x1f, 0x924},
	{ 0x1b83c0, 1, 0x1f, 0x924},
	{ 0x1b8400, 1, 0x1f, 0x924},
	{ 0x1b8440, 1, 0x1f, 0x924},
	{ 0x1b8480, 1, 0x1f, 0x924},
	{ 0x1b84c0, 1, 0x1f, 0x924},
	{ 0x1b8500, 1, 0x1f, 0x924},
	{ 0x1b8540, 1, 0x1f, 0x924},
	{ 0x1b8580, 1, 0x1f, 0x924},
	{ 0x1b85c0, 19, 0x1c, 0x924},
	{ 0x1b8800, 1, 0x1f, 0x924},
	{ 0x1b8840, 1, 0x1f, 0x924},
	{ 0x1b8880, 1, 0x1f, 0x924},
	{ 0x1b88c0, 1, 0x1f, 0x924},
	{ 0x1b8900, 1, 0x1f, 0x924},
	{ 0x1b8940, 1, 0x1f, 0x924},
	{ 0x1b8980, 1, 0x1f, 0x924},
	{ 0x1b89c0, 1, 0x1f, 0x924},
	{ 0x1b8a00, 1, 0x1f, 0x934},
	{ 0x1b8a40, 1, 0x1f, 0x924},
	{ 0x1b8a80, 1, 0x1f, 0x492},
	{ 0x1b8ac0, 1, 0x1f, 0x924},
	{ 0x1b8b00, 1, 0x1f, 0x924},
	{ 0x1b8b40, 1, 0x1f, 0x924},
	{ 0x1b8b80, 1, 0x1f, 0x924},
	{ 0x1b8bc0, 1, 0x1f, 0x924},
	{ 0x1b8c00, 1, 0x1f, 0x924},
	{ 0x1b8c40, 1, 0x1f, 0x924},
	{ 0x1b8c80, 1, 0x1f, 0x924},
	{ 0x1b8cc0, 1, 0x1f, 0x924},
	{ 0x1b8cc4, 1, 0x1c, 0x924},
	{ 0x1b8d00, 1, 0x1f, 0x924},
	{ 0x1b8d40, 1, 0x1f, 0x924},
	{ 0x1b8d80, 1, 0x1f, 0x924},
	{ 0x1b8dc0, 1, 0x1f, 0x924},
	{ 0x1b8e00, 1, 0x1f, 0x924},
	{ 0x1b8e40, 1, 0x1f, 0x924},
	{ 0x1b8e80, 1, 0x1f, 0x924},
	{ 0x1b8e84, 1, 0x1c, 0x924},
	{ 0x1b8ec0, 1, 0x1e, 0x924},
	{ 0x1b8f00, 1, 0x1e, 0x924},
	{ 0x1b8f40, 1, 0x1e, 0x924},
	{ 0x1b8f80, 1, 0x1e, 0x924},
	{ 0x1b8fc0, 1, 0x1e, 0x924},
	{ 0x1b8fd4, 5, 0x1c, 0x924},
	{ 0x1b8fe8, 2, 0x18, 0x924},
	{ 0x1b9000, 1, 0x1c, 0x924},
	{ 0x1b9040, 3, 0x1c, 0x924},
	{ 0x1b905c, 1, 0x18, 0x924},
	{ 0x1b9064, 1, 0x10, 0x924},
	{ 0x1b9080, 10, 0x10, 0x924},
	{ 0x1c0000, 2, 0x1f, 0x924},
	{ 0x200000, 65, 0x1f, 0x924},
	{ 0x200124, 2, 0x1f, 0x1fff},
	{ 0x200130, 3, 0x1f, 0x1fff},
	{ 0x200140, 1, 0x1f, 0x1fff},
	{ 0x20014c, 2, 0x1e, 0x924},
	{ 0x200200, 27, 0x1f, 0x924},
	{ 0x20026c, 1, 0x1f, 0xfff},
	{ 0x200270, 12, 0x1f, 0x924},
	{ 0x2002a0, 1, 0x1f, 0xfff},
	{ 0x2002a4, 17, 0x1f, 0x924},
	{ 0x200340, 4, 0x1f, 0x924},
	{ 0x200380, 1, 0x1c, 0x924},
	{ 0x200388, 1, 0x1c, 0x924},
	{ 0x200390, 1, 0x1c, 0x924},
	{ 0x200398, 1, 0x1c, 0x924},
	{ 0x2003a0, 1, 0x1c, 0x924},
	{ 0x2003a8, 2, 0x1c, 0x924},
	{ 0x202000, 4, 0x1f, 0x1927},
	{ 0x202010, 2044, 0x1f, 0x1007},
	{ 0x204000, 4, 0x18, 0x924},
	{ 0x220000, 1, 0x1f, 0x925},
	{ 0x220004, 5631, 0x1f, 0x1},
	{ 0x225800, 2560, 0x1e, 0x1},
	{ 0x228000, 1, 0x1f, 0x925},
	{ 0x228004, 8191, 0x1e, 0x1},
	{ 0x230000, 1, 0x1f, 0x925},
	{ 0x230004, 15, 0x2, 0x1},
	{ 0x230040, 1, 0x1e, 0x925},
	{ 0x230044, 239, 0x2, 0x1},
	{ 0x230400, 1, 0x1f, 0x925},
	{ 0x230404, 255, 0x2, 0x1},
	{ 0x230800, 1, 0x1f, 0x924},
	{ 0x230840, 1, 0x1e, 0x924},
	{ 0x230c00, 1, 0x1f, 0x924},
	{ 0x231000, 1, 0x1f, 0x924},
	{ 0x231040, 1, 0x1e, 0x924},
	{ 0x231400, 1, 0x1f, 0x924},
	{ 0x231440, 1, 0x1e, 0x924},
	{ 0x231480, 1, 0x1e, 0x924},
	{ 0x2314c0, 1, 0x1e, 0x924},
	{ 0x231800, 128, 0x1f, 0x2},
	{ 0x231c00, 128, 0x1f, 0x2},
	{ 0x232000, 1, 0x1f, 0xdb6},
	{ 0x232400, 1, 0x1e, 0x925},
	{ 0x232404, 5631, 0x1c, 0x1},
	{ 0x238000, 1, 0x1f, 0xfff},
	{ 0x238040, 1, 0x1f, 0xfff},
	{ 0x238080, 1, 0x1f, 0xfff},
	{ 0x2380c0, 1, 0x1f, 0xfff},
	{ 0x238100, 1, 0x1f, 0x924},
	{ 0x238140, 1, 0x1f, 0x924},
	{ 0x238180, 1, 0x1f, 0x924},
	{ 0x2381c0, 1, 0x1f, 0x924},
	{ 0x238200, 1, 0x1f, 0x924},
	{ 0x238240, 1, 0x1f, 0x924},
	{ 0x238280, 1, 0x1f, 0x924},
	{ 0x2382c0, 1, 0x1f, 0x924},
	{ 0x238300, 1, 0x1f, 0x924},
	{ 0x238340, 1, 0x1f, 0x924},
	{ 0x238380, 1, 0x1f, 0x924},
	{ 0x2383c0, 1, 0x1f, 0x924},
	{ 0x238400, 1, 0x1f, 0x924},
	{ 0x238440, 1, 0x1f, 0x924},
	{ 0x238480, 1, 0x1f, 0x924},
	{ 0x2384c0, 1, 0x1f, 0x924},
	{ 0x238500, 1, 0x1f, 0x924},
	{ 0x238540, 1, 0x1f, 0x924},
	{ 0x238580, 1, 0x1f, 0x924},
	{ 0x2385c0, 19, 0x1c, 0x924},
	{ 0x238800, 1, 0x1f, 0x924},
	{ 0x238840, 1, 0x1f, 0x924},
	{ 0x238880, 1, 0x1f, 0x924},
	{ 0x2388c0, 1, 0x1f, 0x924},
	{ 0x238900, 1, 0x1f, 0x924},
	{ 0x238940, 1, 0x1f, 0x924},
	{ 0x238980, 1, 0x1f, 0x924},
	{ 0x2389c0, 1, 0x1f, 0x924},
	{ 0x238a00, 1, 0x1f, 0x926},
	{ 0x238a40, 1, 0x1f, 0x924},
	{ 0x238a80, 1, 0x1f, 0x492},
	{ 0x238ac0, 1, 0x1f, 0x924},
	{ 0x238b00, 1, 0x1f, 0x924},
	{ 0x238b40, 1, 0x1f, 0x924},
	{ 0x238b80, 1, 0x1f, 0x924},
	{ 0x238bc0, 1, 0x1f, 0x924},
	{ 0x238c00, 1, 0x1f, 0x924},
	{ 0x238c40, 1, 0x1f, 0x924},
	{ 0x238c80, 1, 0x1f, 0x924},
	{ 0x238cc0, 1, 0x1f, 0x924},
	{ 0x238cc4, 1, 0x1c, 0x924},
	{ 0x238d00, 1, 0x1f, 0x924},
	{ 0x238d40, 1, 0x1f, 0x924},
	{ 0x238d80, 1, 0x1f, 0x924},
	{ 0x238dc0, 1, 0x1f, 0x924},
	{ 0x238e00, 1, 0x1f, 0x924},
	{ 0x238e40, 1, 0x1f, 0x924},
	{ 0x238e80, 1, 0x1f, 0x924},
	{ 0x238e84, 1, 0x1c, 0x924},
	{ 0x238ec0, 1, 0x1e, 0x924},
	{ 0x238f00, 1, 0x1e, 0x924},
	{ 0x238f40, 1, 0x1e, 0x924},
	{ 0x238f80, 1, 0x1e, 0x924},
	{ 0x238fc0, 1, 0x1e, 0x924},
	{ 0x238fd4, 5, 0x1c, 0x924},
	{ 0x238fe8, 2, 0x18, 0x924},
	{ 0x239000, 1, 0x1c, 0x924},
	{ 0x239040, 3, 0x1c, 0x924},
	{ 0x23905c, 1, 0x18, 0x924},
	{ 0x239064, 1, 0x10, 0x924},
	{ 0x239080, 10, 0x10, 0x924},
	{ 0x240000, 2, 0x1f, 0x924},
	{ 0x280000, 65, 0x1f, 0x924},
	{ 0x280124, 2, 0x1f, 0x1fff},
	{ 0x280130, 3, 0x1f, 0x1fff},
	{ 0x280140, 1, 0x1f, 0x1fff},
	{ 0x28014c, 2, 0x1e, 0x924},
	{ 0x280200, 27, 0x1f, 0x924},
	{ 0x28026c, 1, 0x1f, 0xfff},
	{ 0x280270, 12, 0x1f, 0x924},
	{ 0x2802a0, 1, 0x1f, 0xfff},
	{ 0x2802a4, 17, 0x1f, 0x924},
	{ 0x280340, 4, 0x1f, 0x924},
	{ 0x280380, 1, 0x1c, 0x924},
	{ 0x280388, 1, 0x1c, 0x924},
	{ 0x280390, 1, 0x1c, 0x924},
	{ 0x280398, 1, 0x1c, 0x924},
	{ 0x2803a0, 1, 0x1c, 0x924},
	{ 0x2803a8, 2, 0x1c, 0x924},
	{ 0x282000, 4, 0x1f, 0x9e4},
	{ 0x282010, 2044, 0x1f, 0x1c0},
	{ 0x284000, 4, 0x18, 0x924},
	{ 0x2a0000, 1, 0x1f, 0x964},
	{ 0x2a0004, 5631, 0x1f, 0x40},
	{ 0x2a5800, 2560, 0x1e, 0x40},
	{ 0x2a8000, 1, 0x1f, 0x964},
	{ 0x2a8004, 8191, 0x1e, 0x40},
	{ 0x2b0000, 1, 0x1f, 0x964},
	{ 0x2b0004, 15, 0x2, 0x40},
	{ 0x2b0040, 1, 0x1e, 0x964},
	{ 0x2b0044, 239, 0x2, 0x40},
	{ 0x2b0400, 1, 0x1f, 0x964},
	{ 0x2b0404, 255, 0x2, 0x40},
	{ 0x2b0800, 1, 0x1f, 0x924},
	{ 0x2b0840, 1, 0x1e, 0x924},
	{ 0x2b0c00, 1, 0x1f, 0x924},
	{ 0x2b1000, 1, 0x1f, 0x924},
	{ 0x2b1040, 1, 0x1e, 0x924},
	{ 0x2b1400, 1, 0x1f, 0x924},
	{ 0x2b1440, 1, 0x1e, 0x924},
	{ 0x2b1480, 1, 0x1e, 0x924},
	{ 0x2b14c0, 1, 0x1e, 0x924},
	{ 0x2b1800, 128, 0x1f, 0x80},
	{ 0x2b1c00, 128, 0x1f, 0x80},
	{ 0x2b2000, 1, 0x1f, 0xdb6},
	{ 0x2b2400, 1, 0x1e, 0x964},
	{ 0x2b2404, 5631, 0x1c, 0x40},
	{ 0x2b8000, 1, 0x1f, 0xfff},
	{ 0x2b8040, 1, 0x1f, 0xfff},
	{ 0x2b8080, 1, 0x1f, 0xfff},
	{ 0x2b80c0, 1, 0x1f, 0x924},
	{ 0x2b8100, 1, 0x1f, 0x924},
	{ 0x2b8140, 1, 0x1f, 0x924},
	{ 0x2b8180, 1, 0x1f, 0x924},
	{ 0x2b81c0, 1, 0x1f, 0x924},
	{ 0x2b8200, 1, 0x1f, 0x924},
	{ 0x2b8240, 1, 0x1f, 0x924},
	{ 0x2b8280, 1, 0x1f, 0x924},
	{ 0x2b82c0, 1, 0x1f, 0x924},
	{ 0x2b8300, 1, 0x1f, 0x924},
	{ 0x2b8340, 1, 0x1f, 0x924},
	{ 0x2b8380, 1, 0x1f, 0x924},
	{ 0x2b83c0, 1, 0x1f, 0x924},
	{ 0x2b8400, 1, 0x1f, 0x924},
	{ 0x2b8440, 1, 0x1f, 0x924},
	{ 0x2b8480, 1, 0x1f, 0x924},
	{ 0x2b84c0, 1, 0x1f, 0x924},
	{ 0x2b8500, 1, 0x1f, 0x924},
	{ 0x2b8540, 1, 0x1f, 0x924},
	{ 0x2b8580, 1, 0x1f, 0x924},
	{ 0x2b85c0, 19, 0x1c, 0x924},
	{ 0x2b8800, 1, 0x1f, 0x924},
	{ 0x2b8840, 1, 0x1f, 0x924},
	{ 0x2b8880, 1, 0x1f, 0x924},
	{ 0x2b88c0, 1, 0x1f, 0x924},
	{ 0x2b8900, 1, 0x1f, 0x924},
	{ 0x2b8940, 1, 0x1f, 0x924},
	{ 0x2b8980, 1, 0x1f, 0x924},
	{ 0x2b89c0, 1, 0x1f, 0x924},
	{ 0x2b8a00, 1, 0x1f, 0x9a4},
	{ 0x2b8a40, 1, 0x1f, 0x924},
	{ 0x2b8a80, 1, 0x1f, 0x492},
	{ 0x2b8ac0, 1, 0x1f, 0x924},
	{ 0x2b8b00, 1, 0x1f, 0x924},
	{ 0x2b8b40, 1, 0x1f, 0x924},
	{ 0x2b8b80, 1, 0x1f, 0x924},
	{ 0x2b8bc0, 1, 0x1f, 0x924},
	{ 0x2b8c00, 1, 0x1f, 0x924},
	{ 0x2b8c40, 1, 0x1f, 0x924},
	{ 0x2b8c80, 1, 0x1f, 0x924},
	{ 0x2b8cc0, 1, 0x1f, 0x924},
	{ 0x2b8cc4, 1, 0x1c, 0x924},
	{ 0x2b8d00, 1, 0x1f, 0x924},
	{ 0x2b8d40, 1, 0x1f, 0x924},
	{ 0x2b8d80, 1, 0x1f, 0x924},
	{ 0x2b8dc0, 1, 0x1f, 0x924},
	{ 0x2b8e00, 1, 0x1f, 0x924},
	{ 0x2b8e40, 1, 0x1f, 0x924},
	{ 0x2b8e80, 1, 0x1f, 0x924},
	{ 0x2b8e84, 1, 0x1c, 0x924},
	{ 0x2b8ec0, 1, 0x1e, 0x924},
	{ 0x2b8f00, 1, 0x1e, 0x924},
	{ 0x2b8f40, 1, 0x1e, 0x924},
	{ 0x2b8f80, 1, 0x1e, 0x924},
	{ 0x2b8fc0, 1, 0x1e, 0x924},
	{ 0x2b8fd4, 5, 0x1c, 0x924},
	{ 0x2b8fe8, 2, 0x18, 0x924},
	{ 0x2b9000, 1, 0x1c, 0x924},
	{ 0x2b9040, 3, 0x1c, 0x924},
	{ 0x2b905c, 1, 0x18, 0x924},
	{ 0x2b9064, 1, 0x10, 0x924},
	{ 0x2b9080, 10, 0x10, 0x924},
	{ 0x2c0000, 2, 0x1f, 0x1fff},
	{ 0x300000, 65, 0x1f, 0x924},
	{ 0x300124, 2, 0x1f, 0x1fff},
	{ 0x300130, 3, 0x1f, 0x1fff},
	{ 0x300140, 1, 0x1f, 0x1fff},
	{ 0x30014c, 2, 0x1e, 0x924},
	{ 0x300200, 27, 0x1f, 0x924},
	{ 0x30026c, 1, 0x1f, 0xfff},
	{ 0x300270, 12, 0x1f, 0x924},
	{ 0x3002a0, 1, 0x1f, 0xfff},
	{ 0x3002a4, 17, 0x1f, 0x924},
	{ 0x300340, 4, 0x1f, 0x924},
	{ 0x300380, 1, 0x1c, 0x924},
	{ 0x300388, 1, 0x1c, 0x924},
	{ 0x300390, 1, 0x1c, 0x924},
	{ 0x300398, 1, 0x1c, 0x924},
	{ 0x3003a0, 1, 0x1c, 0x924},
	{ 0x3003a8, 2, 0x1c, 0x924},
	{ 0x302000, 4, 0x1f, 0xf24},
	{ 0x302010, 2044, 0x1f, 0xe00},
	{ 0x304000, 4, 0x18, 0x924},
	{ 0x320000, 1, 0x1f, 0xb24},
	{ 0x320004, 5631, 0x1f, 0x200},
	{ 0x325800, 2560, 0x1e, 0x200},
	{ 0x328000, 1, 0x1f, 0xb24},
	{ 0x328004, 8191, 0x1e, 0x200},
	{ 0x330000, 1, 0x1f, 0xb24},
	{ 0x330004, 15, 0x2, 0x200},
	{ 0x330040, 1, 0x1e, 0xb24},
	{ 0x330044, 239, 0x2, 0x200},
	{ 0x330400, 1, 0x1f, 0xb24},
	{ 0x330404, 255, 0x2, 0x200},
	{ 0x330800, 1, 0x1f, 0x924},
	{ 0x330840, 1, 0x1e, 0x924},
	{ 0x330c00, 1, 0x1f, 0x924},
	{ 0x331000, 1, 0x1f, 0x924},
	{ 0x331040, 1, 0x1e, 0x924},
	{ 0x331400, 1, 0x1f, 0x924},
	{ 0x331440, 1, 0x1e, 0x924},
	{ 0x331480, 1, 0x1e, 0x924},
	{ 0x3314c0, 1, 0x1e, 0x924},
	{ 0x331800, 128, 0x1f, 0x400},
	{ 0x331c00, 128, 0x1f, 0x400},
	{ 0x332000, 1, 0x1f, 0xdb6},
	{ 0x332400, 1, 0x1e, 0xb24},
	{ 0x332404, 5631, 0x1c, 0x200},
	{ 0x338000, 1, 0x1f, 0xfff},
	{ 0x338040, 1, 0x1f, 0xfff},
	{ 0x338080, 1, 0x1f, 0xfff},
	{ 0x3380c0, 1, 0x1f, 0xfff},
	{ 0x338100, 1, 0x1f, 0x924},
	{ 0x338140, 1, 0x1f, 0x924},
	{ 0x338180, 1, 0x1f, 0x924},
	{ 0x3381c0, 1, 0x1f, 0x924},
	{ 0x338200, 1, 0x1f, 0x924},
	{ 0x338240, 1, 0x1f, 0x924},
	{ 0x338280, 1, 0x1f, 0x924},
	{ 0x3382c0, 1, 0x1f, 0x924},
	{ 0x338300, 1, 0x1f, 0x924},
	{ 0x338340, 1, 0x1f, 0x924},
	{ 0x338380, 1, 0x1f, 0x924},
	{ 0x3383c0, 1, 0x1f, 0x924},
	{ 0x338400, 1, 0x1f, 0x924},
	{ 0x338440, 1, 0x1f, 0x924},
	{ 0x338480, 1, 0x1f, 0x924},
	{ 0x3384c0, 1, 0x1f, 0x924},
	{ 0x338500, 1, 0x1f, 0x924},
	{ 0x338540, 1, 0x1f, 0x924},
	{ 0x338580, 1, 0x1f, 0x924},
	{ 0x3385c0, 19, 0x1c, 0x924},
	{ 0x338800, 1, 0x1f, 0x924},
	{ 0x338840, 1, 0x1f, 0x924},
	{ 0x338880, 1, 0x1f, 0x924},
	{ 0x3388c0, 1, 0x1f, 0x924},
	{ 0x338900, 1, 0x1f, 0x924},
	{ 0x338940, 1, 0x1f, 0x924},
	{ 0x338980, 1, 0x1f, 0x924},
	{ 0x3389c0, 1, 0x1f, 0x924},
	{ 0x338a00, 1, 0x1f, 0xd24},
	{ 0x338a40, 1, 0x1f, 0x924},
	{ 0x338a80, 1, 0x1f, 0x492},
	{ 0x338ac0, 1, 0x1f, 0x924},
	{ 0x338b00, 1, 0x1f, 0x924},
	{ 0x338b40, 1, 0x1f, 0x924},
	{ 0x338b80, 1, 0x1f, 0x924},
	{ 0x338bc0, 1, 0x1f, 0x924},
	{ 0x338c00, 1, 0x1f, 0x924},
	{ 0x338c40, 1, 0x1f, 0x924},
	{ 0x338c80, 1, 0x1f, 0x924},
	{ 0x338cc0, 1, 0x1f, 0x924},
	{ 0x338cc4, 1, 0x1c, 0x924},
	{ 0x338d00, 1, 0x1f, 0x924},
	{ 0x338d40, 1, 0x1f, 0x924},
	{ 0x338d80, 1, 0x1f, 0x924},
	{ 0x338dc0, 1, 0x1f, 0x924},
	{ 0x338e00, 1, 0x1f, 0x924},
	{ 0x338e40, 1, 0x1f, 0x924},
	{ 0x338e80, 1, 0x1f, 0x924},
	{ 0x338e84, 1, 0x1c, 0x924},
	{ 0x338ec0, 1, 0x1e, 0x924},
	{ 0x338f00, 1, 0x1e, 0x924},
	{ 0x338f40, 1, 0x1e, 0x924},
	{ 0x338f80, 1, 0x1e, 0x924},
	{ 0x338fc0, 1, 0x1e, 0x924},
	{ 0x338fd4, 5, 0x1c, 0x924},
	{ 0x338fe8, 2, 0x18, 0x924},
	{ 0x339000, 1, 0x1c, 0x924},
	{ 0x339040, 3, 0x1c, 0x924},
	{ 0x33905c, 1, 0x18, 0x924},
	{ 0x339064, 1, 0x10, 0x924},
	{ 0x339080, 10, 0x10, 0x924},
	{ 0x340000, 2, 0x1f, 0x924},
	{ 0x3a0000, 40960, 0x1c, 0x1000}
};

#define REGS_COUNT ARRAY_SIZE(reg_addrs)

static const struct reg_addr idle_reg_addrs[] = {
	{ 0x2104, 1, 0x1f, 0xfff},
	{ 0x2110, 2, 0x1f, 0xfff},
	{ 0x211c, 8, 0x1f, 0xfff},
	{ 0x2814, 1, 0x1f, 0xfff},
	{ 0x281c, 2, 0x1f, 0xfff},
	{ 0x2854, 1, 0x1f, 0xfff},
	{ 0x285c, 1, 0x1f, 0xfff},
	{ 0x3040, 1, 0x1f, 0xfff},
	{ 0x9010, 7, 0x1c, 0xfff},
	{ 0x9030, 1, 0x1c, 0xfff},
	{ 0x9068, 16, 0x1c, 0xfff},
	{ 0x9230, 2, 0x1c, 0xfff},
	{ 0x9244, 1, 0x1c, 0xfff},
	{ 0x9298, 1, 0x1c, 0xfff},
	{ 0x92a8, 1, 0x1c, 0x1fff},
	{ 0xa38c, 1, 0x1f, 0x1fff},
	{ 0xa3c4, 1, 0x1e, 0xfff},
	{ 0xa404, 1, 0x1f, 0xfff},
	{ 0xa408, 2, 0x1f, 0x1fff},
	{ 0xa42c, 12, 0x1f, 0xfff},
	{ 0xa580, 1, 0x1f, 0x1fff},
	{ 0xa590, 1, 0x1f, 0x1fff},
	{ 0xa600, 5, 0x1e, 0xfff},
	{ 0xa618, 1, 0x1e, 0xfff},
	{ 0xa714, 1, 0x1c, 0xfff},
	{ 0xa720, 1, 0x1c, 0xfff},
	{ 0xa750, 1, 0x1c, 0xfff},
	{ 0xc09c, 1, 0x3, 0xfff},
	{ 0x103b0, 1, 0x1f, 0xfff},
	{ 0x103c0, 1, 0x1f, 0xfff},
	{ 0x103d0, 1, 0x3, 0x1fff},
	{ 0x10418, 1, 0x1f, 0xfff},
	{ 0x10420, 1, 0x1f, 0xfff},
	{ 0x10428, 1, 0x1f, 0xfff},
	{ 0x10460, 1, 0x1f, 0xfff},
	{ 0x10474, 1, 0x1f, 0xfff},
	{ 0x104e0, 1, 0x1f, 0xfff},
	{ 0x104ec, 1, 0x1f, 0xfff},
	{ 0x104f8, 1, 0x1f, 0xfff},
	{ 0x10508, 1, 0x1f, 0xfff},
	{ 0x10530, 1, 0x1f, 0xfff},
	{ 0x10538, 1, 0x1f, 0xfff},
	{ 0x10548, 1, 0x1f, 0xfff},
	{ 0x10558, 1, 0x1f, 0xfff},
	{ 0x182a8, 1, 0x1c, 0xfff},
	{ 0x182b8, 1, 0x1c, 0xfff},
	{ 0x18308, 1, 0x1c, 0xfff},
	{ 0x18318, 1, 0x1c, 0xfff},
	{ 0x18338, 1, 0x1c, 0xfff},
	{ 0x18348, 1, 0x1c, 0xfff},
	{ 0x183bc, 1, 0x1c, 0x1fff},
	{ 0x183cc, 1, 0x1c, 0x1fff},
	{ 0x18570, 1, 0x18, 0xfff},
	{ 0x18578, 1, 0x18, 0xfff},
	{ 0x1858c, 1, 0x18, 0xfff},
	{ 0x18594, 1, 0x18, 0xfff},
	{ 0x1862c, 4, 0x10, 0xfff},
	{ 0x2021c, 11, 0x1f, 0xfff},
	{ 0x202a8, 1, 0x1f, 0xfff},
	{ 0x202b8, 1, 0x1f, 0x1fff},
	{ 0x20404, 1, 0x1f, 0xfff},
	{ 0x2040c, 2, 0x1f, 0xfff},
	{ 0x2041c, 2, 0x1f, 0xfff},
	{ 0x40154, 14, 0x1f, 0xfff},
	{ 0x40198, 1, 0x1f, 0x1fff},
	{ 0x404ac, 1, 0x1f, 0xfff},
	{ 0x404bc, 1, 0x1f, 0x1fff},
	{ 0x42290, 1, 0x1f, 0xfff},
	{ 0x422a0, 1, 0x1f, 0xfff},
	{ 0x422b0, 1, 0x1f, 0x1fff},
	{ 0x42548, 1, 0x1f, 0xfff},
	{ 0x42550, 1, 0x1f, 0xfff},
	{ 0x42558, 1, 0x1f, 0xfff},
	{ 0x50160, 8, 0x1f, 0xfff},
	{ 0x501d0, 1, 0x1f, 0xfff},
	{ 0x501e0, 1, 0x1f, 0x1fff},
	{ 0x50204, 1, 0x1f, 0xfff},
	{ 0x5020c, 2, 0x1f, 0xfff},
	{ 0x5021c, 1, 0x1f, 0xfff},
	{ 0x60090, 1, 0x1f, 0xfff},
	{ 0x6011c, 1, 0x1f, 0xfff},
	{ 0x6012c, 1, 0x1f, 0x1fff},
	{ 0xc101c, 1, 0x1f, 0xfff},
	{ 0xc102c, 1, 0x1f, 0x1fff},
	{ 0xc2290, 1, 0x1f, 0xfff},
	{ 0xc22a0, 1, 0x1f, 0xfff},
	{ 0xc22b0, 1, 0x1f, 0x1fff},
	{ 0xc2548, 1, 0x1f, 0xfff},
	{ 0xc2550, 1, 0x1f, 0xfff},
	{ 0xc2558, 1, 0x1f, 0xfff},
	{ 0xc4294, 1, 0x1f, 0xfff},
	{ 0xc42a4, 1, 0x1f, 0xfff},
	{ 0xc42b4, 1, 0x1f, 0x1fff},
	{ 0xc4550, 1, 0x1f, 0xfff},
	{ 0xc4558, 1, 0x1f, 0xfff},
	{ 0xc4560, 1, 0x1f, 0xfff},
	{ 0xd016c, 8, 0x1f, 0xfff},
	{ 0xd01d8, 1, 0x1f, 0xfff},
	{ 0xd01e8, 1, 0x1f, 0x1fff},
	{ 0xd0204, 1, 0x1f, 0xfff},
	{ 0xd020c, 3, 0x1f, 0xfff},
	{ 0xe0154, 8, 0x1f, 0xfff},
	{ 0xe01c8, 1, 0x1f, 0xfff},
	{ 0xe01d8, 1, 0x1f, 0x1fff},
	{ 0xe0204, 1, 0x1f, 0xfff},
	{ 0xe020c, 2, 0x1f, 0xfff},
	{ 0xe021c, 2, 0x1f, 0xfff},
	{ 0x101014, 1, 0x1f, 0xfff},
	{ 0x101030, 1, 0x1f, 0xfff},
	{ 0x101040, 1, 0x1f, 0x1fff},
	{ 0x102058, 1, 0x1f, 0x1fff},
	{ 0x102080, 16, 0x1f, 0xfff},
	{ 0x103004, 2, 0x1f, 0xfff},
	{ 0x103068, 1, 0x1f, 0xfff},
	{ 0x103078, 1, 0x1f, 0xfff},
	{ 0x103088, 1, 0x1f, 0x1fff},
	{ 0x10309c, 2, 0x1e, 0xfff},
	{ 0x1030b8, 2, 0x1c, 0xfff},
	{ 0x1030cc, 1, 0x1c, 0xfff},
	{ 0x1030e0, 1, 0x1c, 0xfff},
	{ 0x104004, 1, 0x1f, 0xfff},
	{ 0x104018, 1, 0x1f, 0xfff},
	{ 0x104020, 1, 0x1f, 0xfff},
	{ 0x10403c, 1, 0x1f, 0xfff},
	{ 0x1040fc, 1, 0x1f, 0xfff},
	{ 0x10410c, 1, 0x1f, 0x1fff},
	{ 0x104400, 1, 0x1f, 0x1fff},
	{ 0x104404, 63, 0x1f, 0xfff},
	{ 0x104800, 1, 0x1f, 0x1fff},
	{ 0x104804, 63, 0x1f, 0xfff},
	{ 0x105000, 4, 0x1f, 0x1fff},
	{ 0x105010, 252, 0x1f, 0xfff},
	{ 0x108094, 1, 0x3, 0xfff},
	{ 0x1201b0, 2, 0x1f, 0xfff},
	{ 0x12032c, 1, 0x1f, 0xfff},
	{ 0x12036c, 3, 0x1f, 0xfff},
	{ 0x120408, 2, 0x1f, 0xfff},
	{ 0x120414, 15, 0x1f, 0xfff},
	{ 0x120478, 2, 0x1f, 0xfff},
	{ 0x12052c, 1, 0x1f, 0xfff},
	{ 0x120564, 3, 0x1f, 0xfff},
	{ 0x12057c, 1, 0x1f, 0x1fff},
	{ 0x12058c, 1, 0x1f, 0x1fff},
	{ 0x120608, 1, 0x1e, 0xfff},
	{ 0x120748, 1, 0x1c, 0xfff},
	{ 0x120778, 2, 0x1c, 0xfff},
	{ 0x120808, 3, 0x1f, 0xfff},
	{ 0x120818, 1, 0x1f, 0xfff},
	{ 0x120820, 1, 0x1f, 0xfff},
	{ 0x120828, 1, 0x1f, 0xfff},
	{ 0x120830, 1, 0x1f, 0xfff},
	{ 0x120838, 1, 0x1f, 0xfff},
	{ 0x120840, 1, 0x1f, 0xfff},
	{ 0x120848, 1, 0x1f, 0xfff},
	{ 0x120850, 1, 0x1f, 0xfff},
	{ 0x120858, 1, 0x1f, 0xfff},
	{ 0x120860, 1, 0x1f, 0xfff},
	{ 0x120868, 1, 0x1f, 0xfff},
	{ 0x120870, 1, 0x1f, 0xfff},
	{ 0x120878, 1, 0x1f, 0xfff},
	{ 0x120880, 1, 0x1f, 0xfff},
	{ 0x120888, 1, 0x1f, 0xfff},
	{ 0x120890, 1, 0x1f, 0xfff},
	{ 0x120898, 1, 0x1f, 0xfff},
	{ 0x1208a0, 1, 0x1f, 0xfff},
	{ 0x1208a8, 1, 0x1f, 0xfff},
	{ 0x1208b0, 1, 0x1f, 0xfff},
	{ 0x1208b8, 1, 0x1f, 0xfff},
	{ 0x1208c0, 1, 0x1f, 0xfff},
	{ 0x1208c8, 1, 0x1f, 0xfff},
	{ 0x1208d0, 1, 0x1f, 0xfff},
	{ 0x1208d8, 1, 0x1f, 0xfff},
	{ 0x1208e0, 1, 0x1f, 0xfff},
	{ 0x1208e8, 1, 0x1f, 0xfff},
	{ 0x1208f0, 1, 0x1f, 0xfff},
	{ 0x1208f8, 1, 0x1f, 0xfff},
	{ 0x120900, 1, 0x1f, 0xfff},
	{ 0x120908, 1, 0x1f, 0xfff},
	{ 0x130030, 1, 0x1c, 0xfff},
	{ 0x13004c, 3, 0x1c, 0xfff},
	{ 0x130064, 2, 0x1c, 0xfff},
	{ 0x13009c, 1, 0x1c, 0x1fff},
	{ 0x130130, 1, 0x1c, 0xfff},
	{ 0x13016c, 1, 0x1c, 0xfff},
	{ 0x130300, 1, 0x1c, 0xfff},
	{ 0x130480, 1, 0x1c, 0xfff},
	{ 0x14005c, 2, 0xf, 0xfff},
	{ 0x1400d0, 2, 0xf, 0xfff},
	{ 0x1400e0, 1, 0xf, 0xfff},
	{ 0x1401c8, 1, 0xf, 0xfff},
	{ 0x140200, 6, 0xf, 0xfff},
	{ 0x140338, 7, 0x10, 0xfff},
	{ 0x140370, 7, 0x10, 0xfff},
	{ 0x15c1bc, 6, 0x10, 0xfff},
	{ 0x15c230, 7, 0x10, 0xfff},
	{ 0x16101c, 1, 0x1f, 0xfff},
	{ 0x16102c, 1, 0x1f, 0x1fff},
	{ 0x164014, 2, 0x1f, 0xfff},
	{ 0x1640f0, 1, 0x1f, 0xfff},
	{ 0x166290, 1, 0x1f, 0xfff},
	{ 0x1662a0, 1, 0x1f, 0xfff},
	{ 0x1662b0, 1, 0x1f, 0x1fff},
	{ 0x166548, 1, 0x1f, 0xfff},
	{ 0x166550, 1, 0x1f, 0xfff},
	{ 0x166558, 1, 0x1f, 0xfff},
	{ 0x168000, 1, 0x1f, 0xfff},
	{ 0x168008, 1, 0x1f, 0xfff},
	{ 0x168010, 1, 0x1f, 0xfff},
	{ 0x168018, 1, 0x1f, 0xfff},
	{ 0x168028, 2, 0x1f, 0xfff},
	{ 0x168058, 9, 0x1f, 0xfff},
	{ 0x168238, 1, 0x1f, 0xfff},
	{ 0x1682d0, 7, 0x1f, 0xfff},
	{ 0x168300, 2, 0x3, 0xfff},
	{ 0x168308, 65, 0x1f, 0xfff},
	{ 0x168410, 2, 0x1f, 0xfff},
	{ 0x168438, 1, 0x1f, 0xfff},
	{ 0x168448, 1, 0x1f, 0x1fff},
	{ 0x168a00, 128, 0x1f, 0xfff},
	{ 0x16e200, 128, 0x2, 0xfff},
	{ 0x16e404, 2, 0x2, 0xfff},
	{ 0x16e584, 64, 0x2, 0xfff},
	{ 0x16e684, 2, 0x1e, 0xfff},
	{ 0x16e68c, 4, 0x2, 0xfff},
	{ 0x16e6fc, 4, 0x1c, 0xfff},
	{ 0x16e7ac, 12, 0x10, 0xfff},
	{ 0x1700a4, 1, 0x1f, 0xfff},
	{ 0x1700ac, 2, 0x1f, 0xfff},
	{ 0x1700c0, 1, 0x1f, 0xfff},
	{ 0x170174, 1, 0x1f, 0xfff},
	{ 0x170184, 1, 0x1f, 0x1fff},
	{ 0x1800f4, 1, 0x1f, 0xfff},
	{ 0x180104, 1, 0x1f, 0xfff},
	{ 0x180114, 1, 0x1f, 0x1fff},
	{ 0x180124, 1, 0x1f, 0x1fff},
	{ 0x18026c, 1, 0x1f, 0xfff},
	{ 0x1802a0, 1, 0x1f, 0xfff},
	{ 0x1b8000, 1, 0x1f, 0xfff},
	{ 0x1b8040, 1, 0x1f, 0xfff},
	{ 0x1b8080, 1, 0x1f, 0xfff},
	{ 0x1b80c0, 1, 0x1f, 0xfff},
	{ 0x200104, 1, 0x1f, 0xfff},
	{ 0x200114, 1, 0x1f, 0xfff},
	{ 0x200124, 1, 0x1f, 0x1fff},
	{ 0x200134, 1, 0x1f, 0x1fff},
	{ 0x20026c, 1, 0x1f, 0xfff},
	{ 0x2002a0, 1, 0x1f, 0xfff},
	{ 0x238000, 1, 0x1f, 0xfff},
	{ 0x238040, 1, 0x1f, 0xfff},
	{ 0x238080, 1, 0x1f, 0xfff},
	{ 0x2380c0, 1, 0x1f, 0xfff},
	{ 0x280104, 1, 0x1f, 0xfff},
	{ 0x280114, 1, 0x1f, 0xfff},
	{ 0x280124, 1, 0x1f, 0x1fff},
	{ 0x280134, 1, 0x1f, 0x1fff},
	{ 0x28026c, 1, 0x1f, 0xfff},
	{ 0x2802a0, 1, 0x1f, 0xfff},
	{ 0x2b8000, 1, 0x1f, 0xfff},
	{ 0x2b8040, 1, 0x1f, 0xfff},
	{ 0x2b8080, 1, 0x1f, 0xfff},
	{ 0x300104, 1, 0x1f, 0xfff},
	{ 0x300114, 1, 0x1f, 0xfff},
	{ 0x300124, 1, 0x1f, 0x1fff},
	{ 0x300134, 1, 0x1f, 0x1fff},
	{ 0x30026c, 1, 0x1f, 0xfff},
	{ 0x3002a0, 1, 0x1f, 0xfff},
	{ 0x338000, 1, 0x1f, 0xfff},
	{ 0x338040, 1, 0x1f, 0xfff},
	{ 0x338080, 1, 0x1f, 0xfff},
	{ 0x3380c0, 1, 0x1f, 0xfff}
};

#define IDLE_REGS_COUNT ARRAY_SIZE(idle_reg_addrs)

static const u32 read_reg_e1[] = {
	0x1b1000};

static const struct wreg_addr wreg_addr_e1 = {
	0x1b0c00, 192, 1, read_reg_e1, 0x1f, 0x1fff};

static const u32 read_reg_e1h[] = {
	0x1b1040, 0x1b1000};

static const struct wreg_addr wreg_addr_e1h = {
	0x1b0c00, 256, 2, read_reg_e1h, 0x1f, 0x1fff};

static const u32 read_reg_e2[] = {
	0x1b1040, 0x1b1000};

static const struct wreg_addr wreg_addr_e2 = {
	0x1b0c00, 128, 2, read_reg_e2, 0x1f, 0x1fff};

static const u32 read_reg_e3[] = {
	0x1b1040, 0x1b1000};

static const struct wreg_addr wreg_addr_e3 = {
	0x1b0c00, 128, 2, read_reg_e3, 0x1f, 0x1fff};

static const u32 read_reg_e3b0[] = {
	0x1b1040, 0x1b1000};

static const struct wreg_addr wreg_addr_e3b0 = {
	0x1b0c00, 128, 2, read_reg_e3b0, 0x1f, 0x1fff};

static const unsigned int dump_num_registers[NUM_CHIPS][NUM_PRESETS] = {
	{19758, 17543, 26951, 18705, 17287, 26695, 19812, 31367, 40775, 19788,
	 25223, 34631, 19074},
	{31750, 18273, 32253, 30697, 18017, 31997, 31804, 32097, 46077, 31780,
	 25953, 39933, 35895},
	{36527, 17928, 33697, 35474, 18700, 34466, 36581, 31752, 47521, 36557,
	 25608, 41377, 43903},
	{45239, 17936, 34387, 44186, 18708, 35156, 45293, 31760, 48211, 45269,
	 25616, 42067, 43903},
	{45302, 17999, 34802, 44249, 18771, 35571, 45356, 31823, 48626, 45332,
	 25679, 42482, 43903}
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Initial register settings functions
 *
 * Copyright (c) 2004-2007 Reyk Floeter <reyk@openbsd.org>
 * Copyright (c) 2006-2009 Nick Kossifidis <mickflemm@gmail.com>
 * Copyright (c) 2007-2008 Jiri Slaby <jirislaby@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

#include "ath5k.h"
#include "reg.h"
#include "debug.h"

/**
 * struct ath5k_ini - Mode-independent initial register writes
 * @ini_register: Register address
 * @ini_value: Default value
 * @ini_mode: 0 to write 1 to read (and clear)
 */
struct ath5k_ini {
	u16	ini_register;
	u32	ini_value;

	enum {
		AR5K_INI_WRITE = 0,	/* Default */
		AR5K_INI_READ = 1,
	} ini_mode;
};

/**
 * struct ath5k_ini_mode - Mode specific initial register values
 * @mode_register: Register address
 * @mode_value: Set of values for each enum ath5k_driver_mode
 */
struct ath5k_ini_mode {
	u16	mode_register;
	u32	mode_value[3];
};

/* Initial register settings for AR5210 */
static const struct ath5k_ini ar5210_ini[] = {
	/* PCU and MAC registers */
	{ AR5K_NOQCU_TXDP0,	0 },
	{ AR5K_NOQCU_TXDP1,	0 },
	{ AR5K_RXDP,		0 },
	{ AR5K_CR,		0 },
	{ AR5K_ISR,		0, AR5K_INI_READ },
	{ AR5K_IMR,		0 },
	{ AR5K_IER,		AR5K_IER_DISABLE },
	{ AR5K_BSR,		0, AR5K_INI_READ },
	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
	{ AR5K_CFG,		AR5K_INIT_CFG },
	{ AR5K_TOPS,		8 },
	{ AR5K_RXNOFRM,		8 },
	{ AR5K_RPGTO,		0 },
	{ AR5K_TXNOFRM,		0 },
	{ AR5K_SFR,		0 },
	{ AR5K_MIBC,		0 },
	{ AR5K_MISC,		0 },
	{ AR5K_RX_FILTER_5210,	0 },
	{ AR5K_MCAST_FILTER0_5210, 0 },
	{ AR5K_MCAST_FILTER1_5210, 0 },
	{ AR5K_TX_MASK0,	0 },
	{ AR5K_TX_MASK1,	0 },
	{ AR5K_CLR_TMASK,	0 },
	{ AR5K_TRIG_LVL,	AR5K_TUNE_MIN_TX_FIFO_THRES },
	{ AR5K_DIAG_SW_5210,	0 },
	{ AR5K_RSSI_THR,	AR5K_TUNE_RSSI_THRES },
	{ AR5K_TSF_L32_5210,	0 },
	{ AR5K_TIMER0_5210,	0 },
	{ AR5K_TIMER1_5210,	0xffffffff },
	{ AR5K_TIMER2_5210,	0xffffffff },
	{ AR5K_TIMER3_5210,	1 },
	{ AR5K_CFP_DUR_5210,	0 },
	{ AR5K_CFP_PERIOD_5210,	0 },
	/* PHY registers */
	{ AR5K_PHY(0),	0x00000047 },
	{ AR5K_PHY_AGC,	0x00000000 },
	{ AR5K_PHY(3),	0x09848ea6 },
	{ AR5K_PHY(4),	0x3d32e000 },
	{ AR5K_PHY(5),	0x0000076b },
	{ AR5K_PHY_ACT,	AR5K_PHY_ACT_DISABLE },
	{ AR5K_PHY(8),	0x02020200 },
	{ AR5K_PHY(9),	0x00000e0e },
	{ AR5K_PHY(10),	0x0a020201 },
	{ AR5K_PHY(11),	0x00036ffc },
	{ AR5K_PHY(12),	0x00000000 },
	{ AR5K_PHY(13),	0x00000e0e },
	{ AR5K_PHY(14),	0x00000007 },
	{ AR5K_PHY(15),	0x00020100 },
	{ AR5K_PHY(16),	0x89630000 },
	{ AR5K_PHY(17),	0x1372169c },
	{ AR5K_PHY(18),	0x0018b633 },
	{ AR5K_PHY(19),	0x1284613c },
	{ AR5K_PHY(20),	0x0de8b8e0 },
	{ AR5K_PHY(21),	0x00074859 },
	{ AR5K_PHY(22),	0x7e80beba },
	{ AR5K_PHY(23),	0x313a665e },
	{ AR5K_PHY_AGCCTL, 0x00001d08 },
	{ AR5K_PHY(25),	0x0001ce00 },
	{ AR5K_PHY(26),	0x409a4190 },
	{ AR5K_PHY(28),	0x0000000f },
	{ AR5K_PHY(29),	0x00000080 },
	{ AR5K_PHY(30),	0x00000004 },
	{ AR5K_PHY(31),	0x00000018 },	/* 0x987c */
	{ AR5K_PHY(64),	0x00000000 },	/* 0x9900 */
	{ AR5K_PHY(65),	0x00000000 },
	{ AR5K_PHY(66),	0x00000000 },
	{ AR5K_PHY(67),	0x00800000 },
	{ AR5K_PHY(68),	0x00000003 },
	/* BB gain table (64bytes) */
	{ AR5K_BB_GAIN(0), 0x00000000 },
	{ AR5K_BB_GAIN(1), 0x00000020 },
	{ AR5K_BB_GAIN(2), 0x00000010 },
	{ AR5K_BB_GAIN(3), 0x00000030 },
	{ AR5K_BB_GAIN(4), 0x00000008 },
	{ AR5K_BB_GAIN(5), 0x00000028 },
	{ AR5K_BB_GAIN(6), 0x00000028 },
	{ AR5K_BB_GAIN(7), 0x00000004 },
	{ AR5K_BB_GAIN(8), 0x00000024 },
	{ AR5K_BB_GAIN(9), 0x00000014 },
	{ AR5K_BB_GAIN(10), 0x00000034 },
	{ AR5K_BB_GAIN(11), 0x0000000c },
	{ AR5K_BB_GAIN(12), 0x0000002c },
	{ AR5K_BB_GAIN(13), 0x00000002 },
	{ AR5K_BB_GAIN(14), 0x00000022 },
	{ AR5K_BB_GAIN(15), 0x00000012 },
	{ AR5K_BB_GAIN(16), 0x00000032 },
	{ AR5K_BB_GAIN(17), 0x0000000a },
	{ AR5K_BB_GAIN(18), 0x0000002a },
	{ AR5K_BB_GAIN(19), 0x00000001 },
	{ AR5K_BB_GAIN(20), 0x00000021 },
	{ AR5K_BB_GAIN(21), 0x00000011 },
	{ AR5K_BB_GAIN(22), 0x00000031 },
	{ AR5K_BB_GAIN(23), 0x00000009 },
	{ AR5K_BB_GAIN(24), 0x00000029 },
	{ AR5K_BB_GAIN(25), 0x00000005 },
	{ AR5K_BB_GAIN(26), 0x00000025 },
	{ AR5K_BB_GAIN(27), 0x00000015 },
	{ AR5K_BB_GAIN(28), 0x00000035 },
	{ AR5K_BB_GAIN(29), 0x0000000d },
	{ AR5K_BB_GAIN(30), 0x0000002d },
	{ AR5K_BB_GAIN(31), 0x00000003 },
	{ AR5K_BB_GAIN(32), 0x00000023 },
	{ AR5K_BB_GAIN(33), 0x00000013 },
	{ AR5K_BB_GAIN(34), 0x00000033 },
	{ AR5K_BB_GAIN(35), 0x0000000b },
	{ AR5K_BB_GAIN(36), 0x0000002b },
	{ AR5K_BB_GAIN(37), 0x00000007 },
	{ AR5K_BB_GAIN(38), 0x00000027 },
	{ AR5K_BB_GAIN(39), 0x00000017 },
	{ AR5K_BB_GAIN(40), 0x00000037 },
	{ AR5K_BB_GAIN(41), 0x0000000f },
	{ AR5K_BB_GAIN(42), 0x0000002f },
	{ AR5K_BB_GAIN(43), 0x0000002f },
	{ AR5K_BB_GAIN(44), 0x0000002f },
	{ AR5K_BB_GAIN(45), 0x0000002f },
	{ AR5K_BB_GAIN(46), 0x0000002f },
	{ AR5K_BB_GAIN(47), 0x0000002f },
	{ AR5K_BB_GAIN(48), 0x0000002f },
	{ AR5K_BB_GAIN(49), 0x0000002f },
	{ AR5K_BB_GAIN(50), 0x0000002f },
	{ AR5K_BB_GAIN(51), 0x0000002f },
	{ AR5K_BB_GAIN(52), 0x0000002f },
	{ AR5K_BB_GAIN(53), 0x0000002f },
	{ AR5K_BB_GAIN(54), 0x0000002f },
	{ AR5K_BB_GAIN(55), 0x0000002f },
	{ AR5K_BB_GAIN(56), 0x0000002f },
	{ AR5K_BB_GAIN(57), 0x0000002f },
	{ AR5K_BB_GAIN(58), 0x0000002f },
	{ AR5K_BB_GAIN(59), 0x0000002f },
	{ AR5K_BB_GAIN(60), 0x0000002f },
	{ AR5K_BB_GAIN(61), 0x0000002f },
	{ AR5K_BB_GAIN(62), 0x0000002f },
	{ AR5K_BB_GAIN(63), 0x0000002f },
	/* 5110 RF gain table (64btes) */
	{ AR5K_RF_GAIN(0), 0x0000001d },
	{ AR5K_RF_GAIN(1), 0x0000005d },
	{ AR5K_RF_GAIN(2), 0x0000009d },
	{ AR5K_RF_GAIN(3), 0x000000dd },
	{ AR5K_RF_GAIN(4), 0x0000011d },
	{ AR5K_RF_GAIN(5), 0x00000021 },
	{ AR5K_RF_GAIN(6), 0x00000061 },
	{ AR5K_RF_GAIN(7), 0x000000a1 },
	{ AR5K_RF_GAIN(8), 0x000000e1 },
	{ AR5K_RF_GAIN(9), 0x00000031 },
	{ AR5K_RF_GAIN(10), 0x00000071 },
	{ AR5K_RF_GAIN(11), 0x000000b1 },
	{ AR5K_RF_GAIN(12), 0x0000001c },
	{ AR5K_RF_GAIN(13), 0x0000005c },
	{ AR5K_RF_GAIN(14), 0x00000029 },
	{ AR5K_RF_GAIN(15), 0x00000069 },
	{ AR5K_RF_GAIN(16), 0x000000a9 },
	{ AR5K_RF_GAIN(17), 0x00000020 },
	{ AR5K_RF_GAIN(18), 0x00000019 },
	{ AR5K_RF_GAIN(19), 0x00000059 },
	{ AR5K_RF_GAIN(20), 0x00000099 },
	{ AR5K_RF_GAIN(21), 0x00000030 },
	{ AR5K_RF_GAIN(22), 0x00000005 },
	{ AR5K_RF_GAIN(23), 0x00000025 },
	{ AR5K_RF_GAIN(24), 0x00000065 },
	{ AR5K_RF_GAIN(25), 0x000000a5 },
	{ AR5K_RF_GAIN(26), 0x00000028 },
	{ AR5K_RF_GAIN(27), 0x00000068 },
	{ AR5K_RF_GAIN(28), 0x0000001f },
	{ AR5K_RF_GAIN(29), 0x0000001e },
	{ AR5K_RF_GAIN(30), 0x00000018 },
	{ AR5K_RF_GAIN(31), 0x00000058 },
	{ AR5K_RF_GAIN(32), 0x00000098 },
	{ AR5K_RF_GAIN(33), 0x00000003 },
	{ AR5K_RF_GAIN(34), 0x00000004 },
	{ AR5K_RF_GAIN(35), 0x00000044 },
	{ AR5K_RF_GAIN(36), 0x00000084 },
	{ AR5K_RF_GAIN(37), 0x00000013 },
	{ AR5K_RF_GAIN(38), 0x00000012 },
	{ AR5K_RF_GAIN(39), 0x00000052 },
	{ AR5K_RF_GAIN(40), 0x00000092 },
	{ AR5K_RF_GAIN(41), 0x000000d2 },
	{ AR5K_RF_GAIN(42), 0x0000002b },
	{ AR5K_RF_GAIN(43), 0x0000002a },
	{ AR5K_RF_GAIN(44), 0x0000006a },
	{ AR5K_RF_GAIN(45), 0x000000aa },
	{ AR5K_RF_GAIN(46), 0x0000001b },
	{ AR5K_RF_GAIN(47), 0x0000001a },
	{ AR5K_RF_GAIN(48), 0x0000005a },
	{ AR5K_RF_GAIN(49), 0x0000009a },
	{ AR5K_RF_GAIN(50), 0x000000da },
	{ AR5K_RF_GAIN(51), 0x00000006 },
	{ AR5K_RF_GAIN(52), 0x00000006 },
	{ AR5K_RF_GAIN(53), 0x00000006 },
	{ AR5K_RF_GAIN(54), 0x00000006 },
	{ AR5K_RF_GAIN(55), 0x00000006 },
	{ AR5K_RF_GAIN(56), 0x00000006 },
	{ AR5K_RF_GAIN(57), 0x00000006 },
	{ AR5K_RF_GAIN(58), 0x00000006 },
	{ AR5K_RF_GAIN(59), 0x00000006 },
	{ AR5K_RF_GAIN(60), 0x00000006 },
	{ AR5K_RF_GAIN(61), 0x00000006 },
	{ AR5K_RF_GAIN(62), 0x00000006 },
	{ AR5K_RF_GAIN(63), 0x00000006 },
	/* PHY activation */
	{ AR5K_PHY(53), 0x00000020 },
	{ AR5K_PHY(51), 0x00000004 },
	{ AR5K_PHY(50), 0x00060106 },
	{ AR5K_PHY(39), 0x0000006d },
	{ AR5K_PHY(48), 0x00000000 },
	{ AR5K_PHY(52), 0x00000014 },
	{ AR5K_PHY_ACT, AR5K_PHY_ACT_ENABLE },
};

/* Initial register settings for AR5211 */
static const struct ath5k_ini ar5211_ini[] = {
	{ AR5K_RXDP,		0x00000000 },
	{ AR5K_RTSD0,		0x84849c9c },
	{ AR5K_RTSD1,		0x7c7c7c7c },
	{ AR5K_RXCFG,		0x00000005 },
	{ AR5K_MIBC,		0x00000000 },
	{ AR5K_TOPS,		0x00000008 },
	{ AR5K_RXNOFRM,		0x00000008 },
	{ AR5K_TXNOFRM,		0x00000010 },
	{ AR5K_RPGTO,		0x00000000 },
	{ AR5K_RFCNT,		0x0000001f },
	{ AR5K_QUEUE_TXDP(0),	0x00000000 },
	{ AR5K_QUEUE_TXDP(1),	0x00000000 },
	{ AR5K_QUEUE_TXDP(2),	0x00000000 },
	{ AR5K_QUEUE_TXDP(3),	0x00000000 },
	{ AR5K_QUEUE_TXDP(4),	0x00000000 },
	{ AR5K_QUEUE_TXDP(5),	0x00000000 },
	{ AR5K_QUEUE_TXDP(6),	0x00000000 },
	{ AR5K_QUEUE_TXDP(7),	0x00000000 },
	{ AR5K_QUEUE_TXDP(8),	0x00000000 },
	{ AR5K_QUEUE_TXDP(9),	0x00000000 },
	{ AR5K_DCU_FP,		0x00000000 },
	{ AR5K_STA_ID1,		0x00000000 },
	{ AR5K_BSS_ID0,		0x00000000 },
	{ AR5K_BSS_ID1,		0x00000000 },
	{ AR5K_RSSI_THR,	0x00000000 },
	{ AR5K_CFP_PERIOD_5211,	0x00000000 },
	{ AR5K_TIMER0_5211,	0x00000030 },
	{ AR5K_TIMER1_5211,	0x0007ffff },
	{ AR5K_TIMER2_5211,	0x01ffffff },
	{ AR5K_TIMER3_5211,	0x00000031 },
	{ AR5K_CFP_DUR_5211,	0x00000000 },
	{ AR5K_RX_FILTER_5211,	0x00000000 },
	{ AR5K_MCAST_FILTER0_5211, 0x00000000 },
	{ AR5K_MCAST_FILTER1_5211, 0x00000002 },
	{ AR5K_DIAG_SW_5211,	0x00000000 },
	{ AR5K_ADDAC_TEST,	0x00000000 },
	{ AR5K_DEFAULT_ANTENNA,	0x00000000 },
	/* PHY registers */
	{ AR5K_PHY_AGC,	0x00000000 },
	{ AR5K_PHY(3),	0x2d849093 },
	{ AR5K_PHY(4),	0x7d32e000 },
	{ AR5K_PHY(5),	0x00000f6b },
	{ AR5K_PHY_ACT,	0x00000000 },
	{ AR5K_PHY(11),	0x00026ffe },
	{ AR5K_PHY(12),	0x00000000 },
	{ AR5K_PHY(15),	0x00020100 },
	{ AR5K_PHY(16),	0x206a017a },
	{ AR5K_PHY(19),	0x1284613c },
	{ AR5K_PHY(21),	0x00000859 },
	{ AR5K_PHY(26),	0x409a4190 },	/* 0x9868 */
	{ AR5K_PHY(27),	0x050cb081 },
	{ AR5K_PHY(28),	0x0000000f },
	{ AR5K_PHY(29),	0x00000080 },
	{ AR5K_PHY(30),	0x0000000c },
	{ AR5K_PHY(64),	0x00000000 },
	{ AR5K_PHY(65),	0x00000000 },
	{ AR5K_PHY(66),	0x00000000 },
	{ AR5K_PHY(67),	0x00800000 },
	{ AR5K_PHY(68),	0x00000001 },
	{ AR5K_PHY(71),	0x0000092a },
	{ AR5K_PHY_IQ,	0x00000000 },
	{ AR5K_PHY(73),	0x00058a05 },
	{ AR5K_PHY(74),	0x00000001 },
	{ AR5K_PHY(75),	0x00000000 },
	{ AR5K_PHY_PAPD_PROBE, 0x00000000 },
	{ AR5K_PHY(77),	0x00000000 },	/* 0x9934 */
	{ AR5K_PHY(78),	0x00000000 },	/* 0x9938 */
	{ AR5K_PHY(79),	0x0000003f },	/* 0x993c */
	{ AR5K_PHY(80),	0x00000004 },
	{ AR5K_PHY(82),	0x00000000 },
	{ AR5K_PHY(83),	0x00000000 },
	{ AR5K_PHY(84),	0x00000000 },
	{ AR5K_PHY_RADAR, 0x5d50f14c },
	{ AR5K_PHY(86),	0x00000018 },
	{ AR5K_PHY(87),	0x004b6a8e },
	/* Initial Power table (32bytes)
	 * common on all cards/modes.
	 * Note: Table is rewritten during
	 * txpower setup later using calibration
	 * data etc. so next write is non-common */
	{ AR5K_PHY_PCDAC_TXPOWER(1), 0x06ff05ff },
	{ AR5K_PHY_PCDAC_TXPOWER(2), 0x07ff07ff },
	{ AR5K_PHY_PCDAC_TXPOWER(3), 0x08ff08ff },
	{ AR5K_PHY_PCDAC_TXPOWER(4), 0x09ff09ff },
	{ AR5K_PHY_PCDAC_TXPOWER(5), 0x0aff0aff },
	{ AR5K_PHY_PCDAC_TXPOWER(6), 0x0bff0bff },
	{ AR5K_PHY_PCDAC_TXPOWER(7), 0x0cff0cff },
	{ AR5K_PHY_PCDAC_TXPOWER(8), 0x0dff0dff },
	{ AR5K_PHY_PCDAC_TXPOWER(9), 0x0fff0eff },
	{ AR5K_PHY_PCDAC_TXPOWER(10), 0x12ff12ff },
	{ AR5K_PHY_PCDAC_TXPOWER(11), 0x14ff13ff },
	{ AR5K_PHY_PCDAC_TXPOWER(12), 0x16ff15ff },
	{ AR5K_PHY_PCDAC_TXPOWER(13), 0x19ff17ff },
	{ AR5K_PHY_PCDAC_TXPOWER(14), 0x1bff1aff },
	{ AR5K_PHY_PCDAC_TXPOWER(15), 0x1eff1dff },
	{ AR5K_PHY_PCDAC_TXPOWER(16), 0x23ff20ff },
	{ AR5K_PHY_PCDAC_TXPOWER(17), 0x27ff25ff },
	{ AR5K_PHY_PCDAC_TXPOWER(18), 0x2cff29ff },
	{ AR5K_PHY_PCDAC_TXPOWER(19), 0x31ff2fff },
	{ AR5K_PHY_PCDAC_TXPOWER(20), 0x37ff34ff },
	{ AR5K_PHY_PCDAC_TXPOWER(21), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(22), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(23), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(24), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(25), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(26), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(27), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(28), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(29), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(30), 0x3aff3aff },
	{ AR5K_PHY_PCDAC_TXPOWER(31), 0x3aff3aff },
	{ AR5K_PHY_CCKTXCTL, 0x00000000 },
	{ AR5K_PHY(642), 0x503e4646 },
	{ AR5K_PHY_GAIN_2GHZ, 0x6480416c },
	{ AR5K_PHY(644), 0x0199a003 },
	{ AR5K_PHY(645), 0x044cd610 },
	{ AR5K_PHY(646), 0x13800040 },
	{ AR5K_PHY(647), 0x1be00060 },
	{ AR5K_PHY(648), 0x0c53800a },
	{ AR5K_PHY(649), 0x0014df3b },
	{ AR5K_PHY(650), 0x000001b5 },
	{ AR5K_PHY(651), 0x00000020 },
};

/* Initial mode-specific settings for AR5211
 * 5211 supports OFDM-only g (draft g) but we
 * need to test it ! */
static const struct ath5k_ini_mode ar5211_ini_mode[] = {
	{ AR5K_TXCFG,
	/*	A          B           G       */
	   { 0x00000015, 0x0000001d, 0x00000015 } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(0),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(1),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(2),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(3),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(4),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(5),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(6),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(7),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(8),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(9),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_DCU_GBL_IFS_SLOT,
	   { 0x00000168, 0x000001b8, 0x00000168 } },
	{ AR5K_DCU_GBL_IFS_SIFS,
	   { 0x00000230, 0x000000b0, 0x00000230 } },
	{ AR5K_DCU_GBL_IFS_EIFS,
	   { 0x00000d98, 0x00001f48, 0x00000d98 } },
	{ AR5K_DCU_GBL_IFS_MISC,
	   { 0x0000a0e0, 0x00005880, 0x0000a0e0 } },
	{ AR5K_TIME_OUT,
	   { 0x04000400, 0x20003000, 0x04000400 } },
	{ AR5K_USEC_5211,
	   { 0x0e8d8fa7, 0x01608f95, 0x0e8d8fa7 } },
	{ AR5K_PHY(8),
	   { 0x02020200, 0x02010200, 0x02020200 } },
	{ AR5K_PHY_RF_CTL2,
	   { 0x00000e0e, 0x00000707, 0x00000e0e } },
	{ AR5K_PHY_RF_CTL3,
	   { 0x0a020001, 0x05010000, 0x0a020001 } },
	{ AR5K_PHY_RF_CTL4,
	   { 0x00000e0e, 0x00000e0e, 0x00000e0e } },
	{ AR5K_PHY_PA_CTL,
	   { 0x00000007, 0x0000000b, 0x0000000b } },
	{ AR5K_PHY_SETTLING,
	   { 0x1372169c, 0x137216a8, 0x1372169c } },
	{ AR5K_PHY_GAIN,
	   { 0x0018ba67, 0x0018ba69, 0x0018ba69 } },
	{ AR5K_PHY_DESIRED_SIZE,
	   { 0x0c28b4e0, 0x0c28b4e0, 0x0c28b4e0 } },
	{ AR5K_PHY_SIG,
	   { 0x7e800d2e, 0x7ec00d2e, 0x7e800d2e } },
	{ AR5K_PHY_AGCCOARSE,
	   { 0x31375d5e, 0x313a5d5e, 0x31375d5e } },
	{ AR5K_PHY_AGCCTL,
	   { 0x0000bd10, 0x0000bd38, 0x0000bd10 } },
	{ AR5K_PHY_NF,
	   { 0x0001ce00, 0x0001ce00, 0x0001ce00 } },
	{ AR5K_PHY_RX_DELAY,
	   { 0x00002710, 0x0000157c, 0x00002710 } },
	{ AR5K_PHY(70),
	   { 0x00000190, 0x00000084, 0x00000190 } },
	{ AR5K_PHY_FRAME_CTL_5211,
	   { 0x6fe01020, 0x6fe00920, 0x6fe01020 } },
	{ AR5K_PHY_PCDAC_TXPOWER_BASE,
	   { 0x05ff14ff, 0x05ff14ff, 0x05ff19ff } },
	{ AR5K_RF_BUFFER_CONTROL_4,
	   { 0x00000010, 0x00000010, 0x00000010 } },
};

/* Initial register settings for AR5212 and newer chips */
static const struct ath5k_ini ar5212_ini_common_start[] = {
	{ AR5K_RXDP,		0x00000000 },
	{ AR5K_RXCFG,		0x00000005 },
	{ AR5K_MIBC,		0x00000000 },
	{ AR5K_TOPS,		0x00000008 },
	{ AR5K_RXNOFRM,		0x00000008 },
	{ AR5K_TXNOFRM,		0x00000010 },
	{ AR5K_RPGTO,		0x00000000 },
	{ AR5K_RFCNT,		0x0000001f },
	{ AR5K_QUEUE_TXDP(0),	0x00000000 },
	{ AR5K_QUEUE_TXDP(1),	0x00000000 },
	{ AR5K_QUEUE_TXDP(2),	0x00000000 },
	{ AR5K_QUEUE_TXDP(3),	0x00000000 },
	{ AR5K_QUEUE_TXDP(4),	0x00000000 },
	{ AR5K_QUEUE_TXDP(5),	0x00000000 },
	{ AR5K_QUEUE_TXDP(6),	0x00000000 },
	{ AR5K_QUEUE_TXDP(7),	0x00000000 },
	{ AR5K_QUEUE_TXDP(8),	0x00000000 },
	{ AR5K_QUEUE_TXDP(9),	0x00000000 },
	{ AR5K_DCU_FP,		0x00000000 },
	{ AR5K_DCU_TXP,		0x00000000 },
	/* Tx filter table 0 (32 entries) */
	{ AR5K_DCU_TX_FILTER_0(0),  0x00000000 }, /* DCU 0 */
	{ AR5K_DCU_TX_FILTER_0(1),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(2),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(3),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(4),  0x00000000 }, /* DCU 1 */
	{ AR5K_DCU_TX_FILTER_0(5),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(6),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(7),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(8),  0x00000000 }, /* DCU 2 */
	{ AR5K_DCU_TX_FILTER_0(9),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(10), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(11), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(12), 0x00000000 }, /* DCU 3 */
	{ AR5K_DCU_TX_FILTER_0(13), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(14), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(15), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(16), 0x00000000 }, /* DCU 4 */
	{ AR5K_DCU_TX_FILTER_0(17), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(18), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(19), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(20), 0x00000000 }, /* DCU 5 */
	{ AR5K_DCU_TX_FILTER_0(21), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(22), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(23), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(24), 0x00000000 }, /* DCU 6 */
	{ AR5K_DCU_TX_FILTER_0(25), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(26), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(27), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(28), 0x00000000 }, /* DCU 7 */
	{ AR5K_DCU_TX_FILTER_0(29), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(30), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_0(31), 0x00000000 },
	/* Tx filter table 1 (16 entries) */
	{ AR5K_DCU_TX_FILTER_1(0),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(1),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(2),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(3),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(4),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(5),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(6),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(7),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(8),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(9),  0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(10), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(11), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(12), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(13), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(14), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_1(15), 0x00000000 },
	{ AR5K_DCU_TX_FILTER_CLR, 0x00000000 },
	{ AR5K_DCU_TX_FILTER_SET, 0x00000000 },
	{ AR5K_STA_ID1,		0x00000000 },
	{ AR5K_BSS_ID0,		0x00000000 },
	{ AR5K_BSS_ID1,		0x00000000 },
	{ AR5K_BEACON_5211,	0x00000000 },
	{ AR5K_CFP_PERIOD_5211, 0x00000000 },
	{ AR5K_TIMER0_5211,	0x00000030 },
	{ AR5K_TIMER1_5211,	0x0007ffff },
	{ AR5K_TIMER2_5211,	0x01ffffff },
	{ AR5K_TIMER3_5211,	0x00000031 },
	{ AR5K_CFP_DUR_5211,	0x00000000 },
	{ AR5K_RX_FILTER_5211,	0x00000000 },
	{ AR5K_DIAG_SW_5211,	0x00000000 },
	{ AR5K_ADDAC_TEST,	0x00000000 },
	{ AR5K_DEFAULT_ANTENNA,	0x00000000 },
	{ AR5K_FRAME_CTL_QOSM,	0x000fc78f },
	{ AR5K_XRMODE,		0x2a82301a },
	{ AR5K_XRDELAY,		0x05dc01e0 },
	{ AR5K_XRTIMEOUT,	0x1f402710 },
	{ AR5K_XRCHIRP,		0x01f40000 },
	{ AR5K_XRSTOMP,		0x00001e1c },
	{ AR5K_SLEEP0,		0x0002aaaa },
	{ AR5K_SLEEP1,		0x02005555 },
	{ AR5K_SLEEP2,		0x00000000 },
	{ AR_BSSMSKL,		0xffffffff },
	{ AR_BSSMSKU,		0x0000ffff },
	{ AR5K_TXPC,		0x00000000 },
	{ AR5K_PROFCNT_TX,	0x00000000 },
	{ AR5K_PROFCNT_RX,	0x00000000 },
	{ AR5K_PROFCNT_RXCLR,	0x00000000 },
	{ AR5K_PROFCNT_CYCLE,	0x00000000 },
	{ AR5K_QUIET_CTL1,	0x00000088 },
	/* Initial rate duration table (32 entries )*/
	{ AR5K_RATE_DUR(0),	0x00000000 },
	{ AR5K_RATE_DUR(1),	0x0000008c },
	{ AR5K_RATE_DUR(2),	0x000000e4 },
	{ AR5K_RATE_DUR(3),	0x000002d5 },
	{ AR5K_RATE_DUR(4),	0x00000000 },
	{ AR5K_RATE_DUR(5),	0x00000000 },
	{ AR5K_RATE_DUR(6),	0x000000a0 },
	{ AR5K_RATE_DUR(7),	0x000001c9 },
	{ AR5K_RATE_DUR(8),	0x0000002c },
	{ AR5K_RATE_DUR(9),	0x0000002c },
	{ AR5K_RATE_DUR(10),	0x00000030 },
	{ AR5K_RATE_DUR(11),	0x0000003c },
	{ AR5K_RATE_DUR(12),	0x0000002c },
	{ AR5K_RATE_DUR(13),	0x0000002c },
	{ AR5K_RATE_DUR(14),	0x00000030 },
	{ AR5K_RATE_DUR(15),	0x0000003c },
	{ AR5K_RATE_DUR(16),	0x00000000 },
	{ AR5K_RATE_DUR(17),	0x00000000 },
	{ AR5K_RATE_DUR(18),	0x00000000 },
	{ AR5K_RATE_DUR(19),	0x00000000 },
	{ AR5K_RATE_DUR(20),	0x00000000 },
	{ AR5K_RATE_DUR(21),	0x00000000 },
	{ AR5K_RATE_DUR(22),	0x00000000 },
	{ AR5K_RATE_DUR(23),	0x00000000 },
	{ AR5K_RATE_DUR(24),	0x000000d5 },
	{ AR5K_RATE_DUR(25),	0x000000df },
	{ AR5K_RATE_DUR(26),	0x00000102 },
	{ AR5K_RATE_DUR(27),	0x0000013a },
	{ AR5K_RATE_DUR(28),	0x00000075 },
	{ AR5K_RATE_DUR(29),	0x0000007f },
	{ AR5K_RATE_DUR(30),	0x000000a2 },
	{ AR5K_RATE_DUR(31),	0x00000000 },
	{ AR5K_QUIET_CTL2,	0x00010002 },
	{ AR5K_TSF_PARM,	0x00000001 },
	{ AR5K_QOS_NOACK,	0x000000c0 },
	{ AR5K_PHY_ERR_FIL,	0x00000000 },
	{ AR5K_XRLAT_TX,	0x00000168 },
	{ AR5K_ACKSIFS,		0x00000000 },
	/* Rate -> db table
	 * notice ...03<-02<-01<-00 ! */
	{ AR5K_RATE2DB(0),	0x03020100 },
	{ AR5K_RATE2DB(1),	0x07060504 },
	{ AR5K_RATE2DB(2),	0x0b0a0908 },
	{ AR5K_RATE2DB(3),	0x0f0e0d0c },
	{ AR5K_RATE2DB(4),	0x13121110 },
	{ AR5K_RATE2DB(5),	0x17161514 },
	{ AR5K_RATE2DB(6),	0x1b1a1918 },
	{ AR5K_RATE2DB(7),	0x1f1e1d1c },
	/* Db -> Rate table */
	{ AR5K_DB2RATE(0),	0x03020100 },
	{ AR5K_DB2RATE(1),	0x07060504 },
	{ AR5K_DB2RATE(2),	0x0b0a0908 },
	{ AR5K_DB2RATE(3),	0x0f0e0d0c },
	{ AR5K_DB2RATE(4),	0x13121110 },
	{ AR5K_DB2RATE(5),	0x17161514 },
	{ AR5K_DB2RATE(6),	0x1b1a1918 },
	{ AR5K_DB2RATE(7),	0x1f1e1d1c },
	/* PHY registers (Common settings
	 * for all chips/modes) */
	{ AR5K_PHY(3),		0xad848e19 },
	{ AR5K_PHY(4),		0x7d28e000 },
	{ AR5K_PHY_TIMING_3,	0x9c0a9f6b },
	{ AR5K_PHY_ACT,		0x00000000 },
	{ AR5K_PHY(16),		0x206a017a },
	{ AR5K_PHY(21),		0x00000859 },
	{ AR5K_PHY_BIN_MASK_1,	0x00000000 },
	{ AR5K_PHY_BIN_MASK_2,	0x00000000 },
	{ AR5K_PHY_BIN_MASK_3,	0x00000000 },
	{ AR5K_PHY_BIN_MASK_CTL, 0x00800000 },
	{ AR5K_PHY_ANT_CTL,	0x00000001 },
	/*{ AR5K_PHY(71), 0x0000092a },*/ /* Old value */
	{ AR5K_PHY_MAX_RX_LEN,	0x00000c80 },
	{ AR5K_PHY_IQ,		0x05100000 },
	{ AR5K_PHY_WARM_RESET,	0x00000001 },
	{ AR5K_PHY_CTL,		0x00000004 },
	{ AR5K_PHY_TXPOWER_RATE1, 0x1e1f2022 },
	{ AR5K_PHY_TXPOWER_RATE2, 0x0a0b0c0d },
	{ AR5K_PHY_TXPOWER_RATE_MAX, 0x0000003f },
	{ AR5K_PHY(82),		0x9280b212 },
	{ AR5K_PHY_RADAR,	0x5d50e188 },
	/*{ AR5K_PHY(86), 0x000000ff },*/
	{ AR5K_PHY(87),		0x004b6a8e },
	{ AR5K_PHY_NFTHRES,	0x000003ce },
	{ AR5K_PHY_RESTART,	0x192fb515 },
	{ AR5K_PHY(94),		0x00000001 },
	{ AR5K_PHY_RFBUS_REQ,	0x00000000 },
	/*{ AR5K_PHY(644), 0x0080a333 },*/ /* Old value */
	/*{ AR5K_PHY(645), 0x00206c10 },*/ /* Old value */
	{ AR5K_PHY(644),	0x00806333 },
	{ AR5K_PHY(645),	0x00106c10 },
	{ AR5K_PHY(646),	0x009c4060 },
	/* { AR5K_PHY(647), 0x1483800a }, */
	/* { AR5K_PHY(648), 0x01831061 }, */ /* Old value */
	{ AR5K_PHY(648),	0x018830c6 },
	{ AR5K_PHY(649),	0x00000400 },
	/*{ AR5K_PHY(650), 0x000001b5 },*/
	{ AR5K_PHY(651),	0x00000000 },
	{ AR5K_PHY_TXPOWER_RATE3, 0x20202020 },
	{ AR5K_PHY_TXPOWER_RATE4, 0x20202020 },
	/*{ AR5K_PHY(655), 0x13c889af },*/
	{ AR5K_PHY(656),	0x38490a20 },
	{ AR5K_PHY(657),	0x00007bb6 },
	{ AR5K_PHY(658),	0x0fff3ffc },
};

/* Initial mode-specific settings for AR5212 (Written before ar5212_ini) */
static const struct ath5k_ini_mode ar5212_ini_mode_start[] = {
	{ AR5K_QUEUE_DFS_LOCAL_IFS(0),
	/*	A/XR          B           G       */
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(1),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(2),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(3),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(4),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(5),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(6),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(7),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(8),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_QUEUE_DFS_LOCAL_IFS(9),
	   { 0x002ffc0f, 0x002ffc1f, 0x002ffc0f } },
	{ AR5K_DCU_GBL_IFS_SIFS,
	   { 0x00000230, 0x000000b0, 0x00000160 } },
	{ AR5K_DCU_GBL_IFS_SLOT,
	   { 0x00000168, 0x000001b8, 0x0000018c } },
	{ AR5K_DCU_GBL_IFS_EIFS,
	   { 0x00000e60, 0x00001f1c, 0x00003e38 } },
	{ AR5K_DCU_GBL_IFS_MISC,
	   { 0x0000a0e0, 0x00005880, 0x0000b0e0 } },
	{ AR5K_TIME_OUT,
	   { 0x03e803e8, 0x04200420, 0x08400840 } },
	{ AR5K_PHY(8),
	   { 0x02020200, 0x02010200, 0x02020200 } },
	{ AR5K_PHY_RF_CTL2,
	   { 0x00000e0e, 0x00000707, 0x00000e0e } },
	{ AR5K_PHY_SETTLING,
	   { 0x1372161c, 0x13721722, 0x137216a2 } },
	{ AR5K_PHY_AGCCTL,
	   { 0x00009d10, 0x00009d18, 0x00009d18 } },
	{ AR5K_PHY_NF,
	   { 0x0001ce00, 0x0001ce00, 0x0001ce00 } },
	{ AR5K_PHY_WEAK_OFDM_HIGH_THR,
	   { 0x409a4190, 0x409a4190, 0x409a4190 } },
	{ AR5K_PHY(70),
	   { 0x000001b8, 0x00000084, 0x00000108 } },
	{ AR5K_PHY_OFDM_SELFCORR,
	   { 0x10058a05, 0x10058a05, 0x10058a05 } },
	{ 0xa230,
	   { 0x00000000, 0x00000000, 0x00000108 } },
};

/* Initial mode-specific settings for AR5212 + RF5111
 * (Written after ar5212_ini) */
static const struct ath5k_ini_mode rf5111_ini_mode_end[] = {
	{ AR5K_TXCFG,
	/*	A/XR          B           G       */
	   { 0x00008015, 0x00008015, 0x00008015 } },
	{ AR5K_USEC_5211,
	   { 0x128d8fa7, 0x04e00f95, 0x12e00fab } },
	{ AR5K_PHY_RF_CTL3,
	   { 0x0a020001, 0x05010100, 0x0a020001 } },
	{ AR5K_PHY_RF_CTL4,
	   { 0x00000e0e, 0x00000e0e, 0x00000e0e } },
	{ AR5K_PHY_PA_CTL,
	   { 0x00000007, 0x0000000b, 0x0000000b } },
	{ AR5K_PHY_GAIN,
	   { 0x0018da5a, 0x0018ca69, 0x0018ca69 } },
	{ AR5K_PHY_DESIRED_SIZE,
	   { 0x0de8b4e0, 0x0de8b4e0, 0x0de8b4e0 } },
	{ AR5K_PHY_SIG,
	   { 0x7e800d2e, 0x7ee84d2e, 0x7ee84d2e } },
	{ AR5K_PHY_AGCCOARSE,
	   { 0x3137665e, 0x3137665e, 0x3137665e } },
	{ AR5K_PHY_WEAK_OFDM_LOW_THR,
	   { 0x050cb081, 0x050cb081, 0x050cb080 } },
	{ AR5K_PHY_RX_DELAY,
	   { 0x00002710, 0x0000157c, 0x00002af8 } },
	{ AR5K_PHY_FRAME_CTL_5211,
	   { 0xf7b81020, 0xf7b80d20, 0xf7b81020 } },
	{ AR5K_PHY_GAIN_2GHZ,
	   { 0x642c416a, 0x6440416a, 0x6440416a } },
	{ AR5K_PHY_CCK_RX_CTL_4,
	   { 0x1883800a, 0x1873800a, 0x1883800a } },
};

/* Common for all modes */
static const struct ath5k_ini rf5111_ini_common_end[] = {
	{ AR5K_DCU_FP,		0x00000000 },
	{ AR5K_PHY_AGC,		0x00000000 },
	{ AR5K_PHY_ADC_CTL,	0x00022ffe },
	{ 0x983c,		0x00020100 },
	{ AR5K_PHY_GAIN_OFFSET,	0x1284613c },
	{ AR5K_PHY_PAPD_PROBE,	0x00004883 },
	{ 0x9940,		0x00000004 },
	{ 0x9958,		0x000000ff },
	{ 0x9974,		0x00000000 },
	{ AR5K_PHY_SPENDING,	0x00000018 },
	{ AR5K_PHY_CCKTXCTL,	0x00000000 },
	{ AR5K_PHY_CCK_CROSSCORR, 0xd03e6788 },
	{ AR5K_PHY_DAG_CCK_CTL,	0x000001b5 },
	{ 0xa23c,		0x13c889af },
};


/* Initial mode-specific settings for AR5212 + RF5112
 * (Written after ar5212_ini) */
static const struct ath5k_ini_mode rf5112_ini_mode_end[] = {
	{ AR5K_TXCFG,
	/*	A/XR          B           G       */
	   { 0x00008015, 0x00008015, 0x00008015 } },
	{ AR5K_USEC_5211,
	   { 0x128d93a7, 0x04e01395, 0x12e013ab } },
	{ AR5K_PHY_RF_CTL3,
	   { 0x0a020001, 0x05020100, 0x0a020001 } },
	{ AR5K_PHY_RF_CTL4,
	   { 0x00000e0e, 0x00000e0e, 0x00000e0e } },
	{ AR5K_PHY_PA_CTL,
	   { 0x00000007, 0x0000000b, 0x0000000b } },
	{ AR5K_PHY_GAIN,
	   { 0x0018da6d, 0x0018ca75, 0x0018ca75 } },
	{ AR5K_PHY_DESIRED_SIZE,
	   { 0x0de8b4e0, 0x0de8b4e0, 0x0de8b4e0 } },
	{ AR5K_PHY_SIG,
	   { 0x7e800d2e, 0x7ee80d2e, 0x7ee80d2e } },
	{ AR5K_PHY_AGCCOARSE,
	   { 0x3137665e, 0x3137665e, 0x3137665e } },
	{ AR5K_PHY_WEAK_OFDM_LOW_THR,
	   { 0x050cb081, 0x050cb081, 0x050cb081 } },
	{ AR5K_PHY_RX_DELAY,
	   { 0x000007d0, 0x0000044c, 0x00000898 } },
	{ AR5K_PHY_FRAME_CTL_5211,
	   { 0xf7b81020, 0xf7b80d10, 0xf7b81010 } },
	{ AR5K_PHY_CCKTXCTL,
	   { 0x00000000, 0x00000008, 0x00000008 } },
	{ AR5K_PHY_CCK_CROSSCORR,
	   { 0xd6be6788, 0xd03e6788, 0xd03e6788 } },
	{ AR5K_PHY_GAIN_2GHZ,
	   { 0x642c0140, 0x6442c160, 0x6442c160 } },
	{ AR5K_PHY_CCK_RX_CTL_4,
	   { 0x1883800a, 0x1873800a, 0x1883800a } },
};

static const struct ath5k_ini rf5112_ini_common_end[] = {
	{ AR5K_DCU_FP,		0x00000000 },
	{ AR5K_PHY_AGC,		0x00000000 },
	{ AR5K_PHY_ADC_CTL,	0x00022ffe },
	{ 0x983c,		0x00020100 },
	{ AR5K_PHY_GAIN_OFFSET,	0x1284613c },
	{ AR5K_PHY_PAPD_PROBE,	0x00004882 },
	{ 0x9940,		0x00000004 },
	{ 0x9958,		0x000000ff },
	{ 0x9974,		0x00000000 },
	{ AR5K_PHY_DAG_CCK_CTL,	0x000001b5 },
	{ 0xa23c,		0x13c889af },
};


/* Initial mode-specific settings for RF5413/5414
 * (Written after ar5212_ini) */
static const struct ath5k_ini_mode rf5413_ini_mode_end[] = {
	{ AR5K_TXCFG,
	/*	A/XR          B           G       */
	   { 0x00000015, 0x00000015, 0x00000015 } },
	{ AR5K_USEC_5211,
	   { 0x128d93a7, 0x04e01395, 0x12e013ab } },
	{ AR5K_PHY_RF_CTL3,
	   { 0x0a020001, 0x05020100, 0x0a020001 } },
	{ AR5K_PHY_RF_CTL4,
	   { 0x00000e0e, 0x00000e0e, 0x00000e0e } },
	{ AR5K_PHY_PA_CTL,
	   { 0x00000007, 0x0000000b, 0x0000000b } },
	{ AR5K_PHY_GAIN,
	   { 0x0018fa61, 0x001a1a63, 0x001a1a63 } },
	{ AR5K_PHY_DESIRED_SIZE,
	   { 0x0c98b4e0, 0x0c98b0da, 0x0c98b0da } },
	{ AR5K_PHY_SIG,
	   { 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e } },
	{ AR5K_PHY_AGCCOARSE,
	   { 0x3139605e, 0x3139605e, 0x3139605e } },
	{ AR5K_PHY_WEAK_OFDM_LOW_THR,
	   { 0x050cb081, 0x050cb081, 0x050cb081 } },
	{ AR5K_PHY_RX_DELAY,
	   { 0x000007d0, 0x0000044c, 0x00000898 } },
	{ AR5K_PHY_FRAME_CTL_5211,
	   { 0xf7b81000, 0xf7b80d00, 0xf7b81000 } },
	{ AR5K_PHY_CCKTXCTL,
	   { 0x00000000, 0x00000000, 0x00000000 } },
	{ AR5K_PHY_CCK_CROSSCORR,
	   { 0xd6be6788, 0xd03e6788, 0xd03e6788 } },
	{ AR5K_PHY_GAIN_2GHZ,
	   { 0x002ec1e0, 0x002ac120, 0x002ac120 } },
	{ AR5K_PHY_CCK_RX_CTL_4,
	   { 0x1883800a, 0x1863800a, 0x1883800a } },
	{ 0xa300,
	   { 0x18010000, 0x18010000, 0x18010000 } },
	{ 0xa304,
	   { 0x30032602, 0x30032602, 0x30032602 } },
	{ 0xa308,
	   { 0x48073e06, 0x48073e06, 0x48073e06 } },
	{ 0xa30c,
	   { 0x560b4c0a, 0x560b4c0a, 0x560b4c0a } },
	{ 0xa310,
	   { 0x641a600f, 0x641a600f, 0x641a600f } },
	{ 0xa314,
	   { 0x784f6e1b, 0x784f6e1b, 0x784f6e1b } },
	{ 0xa318,
	   { 0x868f7c5a, 0x868f7c5a, 0x868f7c5a } },
	{ 0xa31c,
	   { 0x90cf865b, 0x8ecf865b, 0x8ecf865b } },
	{ 0xa320,
	   { 0x9d4f970f, 0x9b4f970f, 0x9b4f970f } },
	{ 0xa324,
	   { 0xa7cfa38f, 0xa3cf9f8f, 0xa3cf9f8f } },
	{ 0xa328,
	   { 0xb55faf1f, 0xb35faf1f, 0xb35faf1f } },
	{ 0xa32c,
	   { 0xbddfb99f, 0xbbdfb99f, 0xbbdfb99f } },
	{ 0xa330,
	   { 0xcb7fc53f, 0xcb7fc73f, 0xcb7fc73f } },
	{ 0xa334,
	   { 0xd5ffd1bf, 0xd3ffd1bf, 0xd3ffd1bf } },
};

static const struct ath5k_ini rf5413_ini_common_end[] = {
	{ AR5K_DCU_FP,		0x000003e0 },
	{ AR5K_5414_CBCFG,	0x00000010 },
	{ AR5K_SEQ_MASK,	0x0000000f },
	{ 0x809c,		0x00000000 },
	{ 0x80a0,		0x00000000 },
	{ AR5K_MIC_QOS_CTL,	0x00000000 },
	{ AR5K_MIC_QOS_SEL,	0x00000000 },
	{ AR5K_MISC_MODE,	0x00000000 },
	{ AR5K_OFDM_FIL_CNT,	0x00000000 },
	{ AR5K_CCK_FIL_CNT,	0x00000000 },
	{ AR5K_PHYERR_CNT1,	0x00000000 },
	{ AR5K_PHYERR_CNT1_MASK, 0x00000000 },
	{ AR5K_PHYERR_CNT2,	0x00000000 },
	{ AR5K_PHYERR_CNT2_MASK, 0x00000000 },
	{ AR5K_TSF_THRES,	0x00000000 },
	{ 0x8140,		0x800003f9 },
	{ 0x8144,		0x00000000 },
	{ AR5K_PHY_AGC,		0x00000000 },
	{ AR5K_PHY_ADC_CTL,	0x0000a000 },
	{ 0x983c,		0x00200400 },
	{ AR5K_PHY_GAIN_OFFSET, 0x1284233c },
	{ AR5K_PHY_SCR,		0x0000001f },
	{ AR5K_PHY_SLMT,	0x00000080 },
	{ AR5K_PHY_SCAL,	0x0000000e },
	{ 0x9958,		0x00081fff },
	{ AR5K_PHY_TIMING_7,	0x00000000 },
	{ AR5K_PHY_TIMING_8,	0x02800000 },
	{ AR5K_PHY_TIMING_11,	0x00000000 },
	{ AR5K_PHY_HEAVY_CLIP_ENABLE, 0x00000000 },
	{ 0x99e4,		0xaaaaaaaa },
	{ 0x99e8,		0x3c466478 },
	{ 0x99ec,		0x000000aa },
	{ AR5K_PHY_SCLOCK,	0x0000000c },
	{ AR5K_PHY_SDELAY,	0x000000ff },
	{ AR5K_PHY_SPENDING,	0x00000014 },
	{ AR5K_PHY_DAG_CCK_CTL, 0x000009b5 },
	{ 0xa23c,		0x93c889af },
	{ AR5K_PHY_FAST_ADC,	0x00000001 },
	{ 0xa250,		0x0000a000 },
	{ AR5K_PHY_BLUETOOTH,	0x00000000 },
	{ AR5K_PHY_TPC_RG1,	0x0cc75380 },
	{ 0xa25c,		0x0f0f0f01 },
	{ 0xa260,		0x5f690f01 },
	{ 0xa264,		0x00418a11 },
	{ 0xa268,		0x00000000 },
	{ AR5K_PHY_TPC_RG5,	0x0c30c16a },
	{ 0xa270, 0x00820820 },
	{ 0xa274, 0x081b7caa },
	{ 0xa278, 0x1ce739ce },
	{ 0xa27c, 0x051701ce },
	{ 0xa338, 0x00000000 },
	{ 0xa33c, 0x00000000 },
	{ 0xa340, 0x00000000 },
	{ 0xa344, 0x00000000 },
	{ 0xa348, 0x3fffffff },
	{ 0xa34c, 0x3fffffff },
	{ 0xa350, 0x3fffffff },
	{ 0xa354, 0x0003ffff },
	{ 0xa358, 0x79a8aa1f },
	{ 0xa35c, 0x066c420f },
	{ 0xa360, 0x0f282207 },
	{ 0xa364, 0x17601685 },
	{ 0xa368, 0x1f801104 },
	{ 0xa36c, 0x37a00c03 },
	{ 0xa370, 0x3fc40883 },
	{ 0xa374, 0x57c00803 },
	{ 0xa378, 0x5fd80682 },
	{ 0xa37c, 0x7fe00482 },
	{ 0xa380, 0x7f3c7bba },
	{ 0xa384, 0xf3307ff0 },
};

/* Initial mode-specific settings for RF2413/2414
 * (Written after ar5212_ini) */
/* XXX: a mode ? */
static const struct ath5k_ini_mode rf2413_ini_mode_end[] = {
	{ AR5K_TXCFG,
	/*	A/XR          B           G       */
	   { 0x00000015, 0x00000015, 0x00000015 } },
	{ AR5K_USEC_5211,
	   { 0x128d93a7, 0x04e01395, 0x12e013ab } },
	{ AR5K_PHY_RF_CTL3,
	   { 0x0a020001, 0x05020000, 0x0a020001 } },
	{ AR5K_PHY_RF_CTL4,
	   { 0x00000e00, 0x00000e00, 0x00000e00 } },
	{ AR5K_PHY_PA_CTL,
	   { 0x00000002, 0x0000000a, 0x0000000a } },
	{ AR5K_PHY_GAIN,
	   { 0x0018da6d, 0x001a6a64, 0x001a6a64 } },
	{ AR5K_PHY_DESIRED_SIZE,
	   { 0x0de8b4e0, 0x0de8b0da, 0x0c98b0da } },
	{ AR5K_PHY_SIG,
	   { 0x7e800d2e, 0x7ee80d2e, 0x7ec80d2e } },
	{ AR5K_PHY_AGCCOARSE,
	   { 0x3137665e, 0x3137665e, 0x3139605e } },
	{ AR5K_PHY_WEAK_OFDM_LOW_THR,
	   { 0x050cb081, 0x050cb081, 0x050cb081 } },
	{ AR5K_PHY_RX_DELAY,
	   { 0x000007d0, 0x0000044c, 0x00000898 } },
	{ AR5K_PHY_FRAME_CTL_5211,
	   { 0xf7b81000, 0xf7b80d00, 0xf7b81000 } },
	{ AR5K_PHY_CCKTXCTL,
	   { 0x00000000, 0x00000000, 0x00000000 } },
	{ AR5K_PHY_CCK_CROSSCORR,
	   { 0xd6be6788, 0xd03e6788, 0xd03e6788 } },
	{ AR5K_PHY_GAIN_2GHZ,
	   { 0x002c0140, 0x0042c140, 0x0042c140 } },
	{ AR5K_PHY_CCK_RX_CTL_4,
	   { 0x1883800a, 0x1863800a, 0x1883800a } },
};

static const struct ath5k_ini rf2413_ini_common_end[] = {
	{ AR5K_DCU_FP,		0x000003e0 },
	{ AR5K_SEQ_MASK,	0x0000000f },
	{ AR5K_MIC_QOS_CTL,	0x00000000 },
	{ AR5K_MIC_QOS_SEL,	0x00000000 },
	{ AR5K_MISC_MODE,	0x00000000 },
	{ AR5K_OFDM_FIL_CNT,	0x00000000 },
	{ AR5K_CCK_FIL_CNT,	0x00000000 },
	{ AR5K_PHYERR_CNT1,	0x00000000 },
	{ AR5K_PHYERR_CNT1_MASK, 0x00000000 },
	{ AR5K_PHYERR_CNT2,	0x00000000 },
	{ AR5K_PHYERR_CNT2_MASK, 0x00000000 },
	{ AR5K_TSF_THRES,	0x00000000 },
	{ 0x8140,		0x800000a8 },
	{ 0x8144,		0x00000000 },
	{ AR5K_PHY_AGC,		0x00000000 },
	{ AR5K_PHY_ADC_CTL,	0x0000a000 },
	{ 0x983c,		0x00200400 },
	{ AR5K_PHY_GAIN_OFFSET,	0x1284233c },
	{ AR5K_PHY_SCR,		0x0000001f },
	{ AR5K_PHY_SLMT,	0x00000080 },
	{ AR5K_PHY_SCAL,	0x0000000e },
	{ 0x9958,		0x000000ff },
	{ AR5K_PHY_TIMING_7,	0x00000000 },
	{ AR5K_PHY_TIMING_8,	0x02800000 },
	{ AR5K_PHY_TIMING_11,	0x00000000 },
	{ AR5K_PHY_HEAVY_CLIP_ENABLE, 0x00000000 },
	{ 0x99e4,		0xaaaaaaaa },
	{ 0x99e8,		0x3c466478 },
	{ 0x99ec,		0x000000aa },
	{ AR5K_PHY_SCLOCK,	0x0000000c },
	{ AR5K_PHY_SDELAY,	0x000000ff },
	{ AR5K_PHY_SPENDING,	0x00000014 },
	{ AR5K_PHY_DAG_CCK_CTL,	0x000009b5 },
	{ 0xa23c,		0x93c889af },
	{ AR5K_PHY_FAST_ADC,	0x00000001 },
	{ 0xa250,		0x0000a000 },
	{ AR5K_PHY_BLUETOOTH,	0x00000000 },
	{ AR5K_PHY_TPC_RG1,	0x0cc75380 },
	{ 0xa25c,		0x0f0f0f01 },
	{ 0xa260,		0x5f690f01 },
	{ 0xa264,		0x00418a11 },
	{ 0xa268,		0x00000000 },
	{ AR5K_PHY_TPC_RG5,	0x0c30c16a },
	{ 0xa270, 0x00820820 },
	{ 0xa274, 0x001b7caa },
	{ 0xa278, 0x1ce739ce },
	{ 0xa27c, 0x051701ce },
	{ 0xa300, 0x18010000 },
	{ 0xa304, 0x30032602 },
	{ 0xa308, 0x48073e06 },
	{ 0xa30c, 0x560b4c0a },
	{ 0xa310, 0x641a600f },
	{ 0xa314, 0x784f6e1b },
	{ 0xa318, 0x868f7c5a },
	{ 0xa31c, 0x8ecf865b },
	{ 0xa320, 0x9d4f970f },
	{ 0xa324, 0xa5cfa18f },
	{ 0xa328, 0xb55faf1f },
	{ 0xa32c, 0xbddfb99f },
	{ 0xa330, 0xcd7fc73f },
	{ 0xa334, 0xd5ffd1bf },
	{ 0xa338, 0x00000000 },
	{ 0xa33c, 0x00000000 },
	{ 0xa340, 0x00000000 },
	{ 0xa344, 0x00000000 },
	{ 0xa348, 0x3fffffff },
	{ 0xa34c, 0x3fffffff },
	{ 0xa350, 0x3fffffff },
	{ 0xa354, 0x0003ffff },
	{ 0xa358, 0x79a8aa1f },
	{ 0xa35c, 0x066c420f },
	{ 0xa360, 0x0f282207 },
	{ 0xa364, 0x17601685 },
	{ 0xa368, 0x1f801104 },
	{ 0xa36c, 0x37a00c03 },
	{ 0xa370, 0x3fc40883 },
	{ 0xa374, 0x57c00803 },
	{ 0xa378, 0x5fd80682 },
	{ 0xa37c, 0x7fe00482 },
	{ 0xa380, 0x7f3c7bba },
	{ 0xa384, 0xf3307ff0 },
};

/* Initial mode-specific settings for RF2425
 * (Written after ar5212_ini) */
/* XXX: a mode ? */
static const struct ath5k_ini_mode rf2425_ini_mode_end[] = {
	{ AR5K_TXCFG,
	/*	A/XR          B           G       */
	   { 0x00000015, 0x00000015, 0x00000015 } },
	{ AR5K_USEC_5211,
	   { 0x128d93a7, 0x04e01395, 0x12e013ab } },
	{ AR5K_PHY_RF_CTL3,
	   { 0x0a020001, 0x05020100, 0x0a020001 } },
	{ AR5K_PHY_RF_CTL4,
	   { 0x00000e0e, 0x00000e0e, 0x00000e0e } },
	{ AR5K_PHY_PA_CTL,
	   { 0x00000003, 0x0000000b, 0x0000000b } },
	{ AR5K_PHY_SETTLING,
	   { 0x1372161c, 0x13721722, 0x13721422 } },
	{ AR5K_PHY_GAIN,
	   { 0x0018fa61, 0x00199a65, 0x00199a65 } },
	{ AR5K_PHY_DESIRED_SIZE,
	   { 0x0c98b4e0, 0x0c98b0da, 0x0c98b0da } },
	{ AR5K_PHY_SIG,
	   { 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e } },
	{ AR5K_PHY_AGCCOARSE,
	   { 0x3139605e, 0x3139605e, 0x3139605e } },
	{ AR5K_PHY_WEAK_OFDM_LOW_THR,
	   { 0x050cb081, 0x050cb081, 0x050cb081 } },
	{ AR5K_PHY_RX_DELAY,
	   { 0x000007d0, 0x0000044c, 0x00000898 } },
	{ AR5K_PHY_FRAME_CTL_5211,
	   { 0xf7b81000, 0xf7b80d00, 0xf7b81000 } },
	{ AR5K_PHY_CCKTXCTL,
	   { 0x00000000, 0x00000000, 0x00000000 } },
	{ AR5K_PHY_CCK_CROSSCORR,
	   { 0xd6be6788, 0xd03e6788, 0xd03e6788 } },
	{ AR5K_PHY_GAIN_2GHZ,
	   { 0x00000140, 0x0052c140, 0x0052c140 } },
	{ AR5K_PHY_CCK_RX_CTL_4,
	   { 0x1883800a, 0x1863800a, 0x1883800a } },
	{ 0xa324,
	   { 0xa7cfa7cf, 0xa7cfa7cf, 0xa7cfa7cf } },
	{ 0xa328,
	   { 0xa7cfa7cf, 0xa7cfa7cf, 0xa7cfa7cf } },
	{ 0xa32c,
	   { 0xa7cfa7cf, 0xa7cfa7cf, 0xa7cfa7cf } },
	{ 0xa330,
	   { 0xa7cfa7cf, 0xa7cfa7cf, 0xa7cfa7cf } },
	{ 0xa334,
	   { 0xa7cfa7cf, 0xa7cfa7cf, 0xa7cfa7cf } },
};

static const struct ath5k_ini rf2425_ini_common_end[] = {
	{ AR5K_DCU_FP,		0x000003e0 },
	{ AR5K_SEQ_MASK,	0x0000000f },
	{ 0x809c,		0x00000000 },
	{ 0x80a0,		0x00000000 },
	{ AR5K_MIC_QOS_CTL,	0x00000000 },
	{ AR5K_MIC_QOS_SEL,	0x00000000 },
	{ AR5K_MISC_MODE,	0x00000000 },
	{ AR5K_OFDM_FIL_CNT,	0x00000000 },
	{ AR5K_CCK_FIL_CNT,	0x00000000 },
	{ AR5K_PHYERR_CNT1,	0x00000000 },
	{ AR5K_PHYERR_CNT1_MASK, 0x00000000 },
	{ AR5K_PHYERR_CNT2,	0x00000000 },
	{ AR5K_PHYERR_CNT2_MASK, 0x00000000 },
	{ AR5K_TSF_THRES,	0x00000000 },
	{ 0x8140,		0x800003f9 },
	{ 0x8144,		0x00000000 },
	{ AR5K_PHY_AGC,		0x00000000 },
	{ AR5K_PHY_ADC_CTL,	0x0000a000 },
	{ 0x983c,		0x00200400 },
	{ AR5K_PHY_GAIN_OFFSET, 0x1284233c },
	{ AR5K_PHY_SCR,		0x0000001f },
	{ AR5K_PHY_SLMT,	0x00000080 },
	{ AR5K_PHY_SCAL,	0x0000000e },
	{ 0x9958,		0x00081fff },
	{ AR5K_PHY_TIMING_7,	0x00000000 },
	{ AR5K_PHY_TIMING_8,	0x02800000 },
	{ AR5K_PHY_TIMING_11,	0x00000000 },
	{ 0x99dc,		0xfebadbe8 },
	{ AR5K_PHY_HEAVY_CLIP_ENABLE, 0x00000000 },
	{ 0x99e4,		0xaaaaaaaa },
	{ 0x99e8,		0x3c466478 },
	{ 0x99ec,		0x000000aa },
	{ AR5K_PHY_SCLOCK,	0x0000000c },
	{ AR5K_PHY_SDELAY,	0x000000ff },
	{ AR5K_PHY_SPENDING,	0x00000014 },
	{ AR5K_PHY_DAG_CCK_CTL,	0x000009b5 },
	{ AR5K_PHY_TXPOWER_RATE3, 0x20202020 },
	{ AR5K_PHY_TXPOWER_RATE4, 0x20202020 },
	{ 0xa23c,		0x93c889af },
	{ AR5K_PHY_FAST_ADC,	0x00000001 },
	{ 0xa250,		0x0000a000 },
	{ AR5K_PHY_BLUETOOTH,	0x00000000 },
	{ AR5K_PHY_TPC_RG1,	0x0cc75380 },
	{ 0xa25c,		0x0f0f0f01 },
	{ 0xa260,		0x5f690f01 },
	{ 0xa264,		0x00418a11 },
	{ 0xa268,		0x00000000 },
	{ AR5K_PHY_TPC_RG5,	0x0c30c166 },
	{ 0xa270, 0x00820820 },
	{ 0xa274, 0x081a3caa },
	{ 0xa278, 0x1ce739ce },
	{ 0xa27c, 0x051701ce },
	{ 0xa300, 0x16010000 },
	{ 0xa304, 0x2c032402 },
	{ 0xa308, 0x48433e42 },
	{ 0xa30c, 0x5a0f500b },
	{ 0xa310, 0x6c4b624a },
	{ 0xa314, 0x7e8b748a },
	{ 0xa318, 0x96cf8ccb },
	{ 0xa31c, 0xa34f9d0f },
	{ 0xa320, 0xa7cfa58f },
	{ 0xa348, 0x3fffffff },
	{ 0xa34c, 0x3fffffff },
	{ 0xa350, 0x3fffffff },
	{ 0xa354, 0x0003ffff },
	{ 0xa358, 0x79a8aa1f },
	{ 0xa35c, 0x066c420f },
	{ 0xa360, 0x0f282207 },
	{ 0xa364, 0x17601685 },
	{ 0xa368, 0x1f801104 },
	{ 0xa36c, 0x37a00c03 },
	{ 0xa370, 0x3fc40883 },
	{ 0xa374, 0x57c00803 },
	{ 0xa378, 0x5fd80682 },
	{ 0xa37c, 0x7fe00482 },
	{ 0xa380, 0x7f3c7bba },
	{ 0xa384, 0xf3307ff0 },
};

/*
 * Initial BaseBand Gain settings for RF5111/5112 (AR5210 comes with
 * RF5110 only so initial BB Gain settings are included in AR5K_AR5210_INI)
 */

/* RF5111 Initial BaseBand Gain settings */
static const struct ath5k_ini rf5111_ini_bbgain[] = {
	{ AR5K_BB_GAIN(0), 0x00000000 },
	{ AR5K_BB_GAIN(1), 0x00000020 },
	{ AR5K_BB_GAIN(2), 0x00000010 },
	{ AR5K_BB_GAIN(3), 0x00000030 },
	{ AR5K_BB_GAIN(4), 0x00000008 },
	{ AR5K_BB_GAIN(5), 0x00000028 },
	{ AR5K_BB_GAIN(6), 0x00000004 },
	{ AR5K_BB_GAIN(7), 0x00000024 },
	{ AR5K_BB_GAIN(8), 0x00000014 },
	{ AR5K_BB_GAIN(9), 0x00000034 },
	{ AR5K_BB_GAIN(10), 0x0000000c },
	{ AR5K_BB_GAIN(11), 0x0000002c },
	{ AR5K_BB_GAIN(12), 0x00000002 },
	{ AR5K_BB_GAIN(13), 0x00000022 },
	{ AR5K_BB_GAIN(14), 0x00000012 },
	{ AR5K_BB_GAIN(15), 0x00000032 },
	{ AR5K_BB_GAIN(16), 0x0000000a },
	{ AR5K_BB_GAIN(17), 0x0000002a },
	{ AR5K_BB_GAIN(18), 0x00000006 },
	{ AR5K_BB_GAIN(19), 0x00000026 },
	{ AR5K_BB_GAIN(20), 0x00000016 },
	{ AR5K_BB_GAIN(21), 0x00000036 },
	{ AR5K_BB_GAIN(22), 0x0000000e },
	{ AR5K_BB_GAIN(23), 0x0000002e },
	{ AR5K_BB_GAIN(24), 0x00000001 },
	{ AR5K_BB_GAIN(25), 0x00000021 },
	{ AR5K_BB_GAIN(26), 0x00000011 },
	{ AR5K_BB_GAIN(27), 0x00000031 },
	{ AR5K_BB_GAIN(28), 0x00000009 },
	{ AR5K_BB_GAIN(29), 0x00000029 },
	{ AR5K_BB_GAIN(30), 0x00000005 },
	{ AR5K_BB_GAIN(31), 0x00000025 },
	{ AR5K_BB_GAIN(32), 0x00000015 },
	{ AR5K_BB_GAIN(33), 0x00000035 },
	{ AR5K_BB_GAIN(34), 0x0000000d },
	{ AR5K_BB_GAIN(35), 0x0000002d },
	{ AR5K_BB_GAIN(36), 0x00000003 },
	{ AR5K_BB_GAIN(37), 0x00000023 },
	{ AR5K_BB_GAIN(38), 0x00000013 },
	{ AR5K_BB_GAIN(39), 0x00000033 },
	{ AR5K_BB_GAIN(40), 0x0000000b },
	{ AR5K_BB_GAIN(41), 0x0000002b },
	{ AR5K_BB_GAIN(42), 0x0000002b },
	{ AR5K_BB_GAIN(43), 0x0000002b },
	{ AR5K_BB_GAIN(44), 0x0000002b },
	{ AR5K_BB_GAIN(45), 0x0000002b },
	{ AR5K_BB_GAIN(46), 0x0000002b },
	{ AR5K_BB_GAIN(47), 0x0000002b },
	{ AR5K_BB_GAIN(48), 0x0000002b },
	{ AR5K_BB_GAIN(49), 0x0000002b },
	{ AR5K_BB_GAIN(50), 0x0000002b },
	{ AR5K_BB_GAIN(51), 0x0000002b },
	{ AR5K_BB_GAIN(52), 0x0000002b },
	{ AR5K_BB_GAIN(53), 0x0000002b },
	{ AR5K_BB_GAIN(54), 0x0000002b },
	{ AR5K_BB_GAIN(55), 0x0000002b },
	{ AR5K_BB_GAIN(56), 0x0000002b },
	{ AR5K_BB_GAIN(57), 0x0000002b },
	{ AR5K_BB_GAIN(58), 0x0000002b },
	{ AR5K_BB_GAIN(59), 0x0000002b },
	{ AR5K_BB_GAIN(60), 0x0000002b },
	{ AR5K_BB_GAIN(61), 0x0000002b },
	{ AR5K_BB_GAIN(62), 0x00000002 },
	{ AR5K_BB_GAIN(63), 0x00000016 },
};

/* RF5112 Initial BaseBand Gain settings (Same for RF5413/5414+) */
static const struct ath5k_ini rf5112_ini_bbgain[] = {
	{ AR5K_BB_GAIN(0), 0x00000000 },
	{ AR5K_BB_GAIN(1), 0x00000001 },
	{ AR5K_BB_GAIN(2), 0x00000002 },
	{ AR5K_BB_GAIN(3), 0x00000003 },
	{ AR5K_BB_GAIN(4), 0x00000004 },
	{ AR5K_BB_GAIN(5), 0x00000005 },
	{ AR5K_BB_GAIN(6), 0x00000008 },
	{ AR5K_BB_GAIN(7), 0x00000009 },
	{ AR5K_BB_GAIN(8), 0x0000000a },
	{ AR5K_BB_GAIN(9), 0x0000000b },
	{ AR5K_BB_GAIN(10), 0x0000000c },
	{ AR5K_BB_GAIN(11), 0x0000000d },
	{ AR5K_BB_GAIN(12), 0x00000010 },
	{ AR5K_BB_GAIN(13), 0x00000011 },
	{ AR5K_BB_GAIN(14), 0x00000012 },
	{ AR5K_BB_GAIN(15), 0x00000013 },
	{ AR5K_BB_GAIN(16), 0x00000014 },
	{ AR5K_BB_GAIN(17), 0x00000015 },
	{ AR5K_BB_GAIN(18), 0x00000018 },
	{ AR5K_BB_GAIN(19), 0x00000019 },
	{ AR5K_BB_GAIN(20), 0x0000001a },
	{ AR5K_BB_GAIN(21), 0x0000001b },
	{ AR5K_BB_GAIN(22), 0x0000001c },
	{ AR5K_BB_GAIN(23), 0x0000001d },
	{ AR5K_BB_GAIN(24), 0x00000020 },
	{ AR5K_BB_GAIN(25), 0x00000021 },
	{ AR5K_BB_GAIN(26), 0x00000022 },
	{ AR5K_BB_GAIN(27), 0x00000023 },
	{ AR5K_BB_GAIN(28), 0x00000024 },
	{ AR5K_BB_GAIN(29), 0x00000025 },
	{ AR5K_BB_GAIN(30), 0x00000028 },
	{ AR5K_BB_GAIN(31), 0x00000029 },
	{ AR5K_BB_GAIN(32), 0x0000002a },
	{ AR5K_BB_GAIN(33), 0x0000002b },
	{ AR5K_BB_GAIN(34), 0x0000002c },
	{ AR5K_BB_GAIN(35), 0x0000002d },
	{ AR5K_BB_GAIN(36), 0x00000030 },
	{ AR5K_BB_GAIN(37), 0x00000031 },
	{ AR5K_BB_GAIN(38), 0x00000032 },
	{ AR5K_BB_GAIN(39), 0x00000033 },
	{ AR5K_BB_GAIN(40), 0x00000034 },
	{ AR5K_BB_GAIN(41), 0x00000035 },
	{ AR5K_BB_GAIN(42), 0x00000035 },
	{ AR5K_BB_GAIN(43), 0x00000035 },
	{ AR5K_BB_GAIN(44), 0x00000035 },
	{ AR5K_BB_GAIN(45), 0x00000035 },
	{ AR5K_BB_GAIN(46), 0x00000035 },
	{ AR5K_BB_GAIN(47), 0x00000035 },
	{ AR5K_BB_GAIN(48), 0x00000035 },
	{ AR5K_BB_GAIN(49), 0x00000035 },
	{ AR5K_BB_GAIN(50), 0x00000035 },
	{ AR5K_BB_GAIN(51), 0x00000035 },
	{ AR5K_BB_GAIN(52), 0x00000035 },
	{ AR5K_BB_GAIN(53), 0x00000035 },
	{ AR5K_BB_GAIN(54), 0x00000035 },
	{ AR5K_BB_GAIN(55), 0x00000035 },
	{ AR5K_BB_GAIN(56), 0x00000035 },
	{ AR5K_BB_GAIN(57), 0x00000035 },
	{ AR5K_BB_GAIN(58), 0x00000035 },
	{ AR5K_BB_GAIN(59), 0x00000035 },
	{ AR5K_BB_GAIN(60), 0x00000035 },
	{ AR5K_BB_GAIN(61), 0x00000035 },
	{ AR5K_BB_GAIN(62), 0x00000010 },
	{ AR5K_BB_GAIN(63), 0x0000001a },
};


/**
 * ath5k_hw_ini_registers() - Write initial register dump common for all modes
 * @ah: The &struct ath5k_hw
 * @size: Dump size
 * @ini_regs: The array of &struct ath5k_ini
 * @skip_pcu: Skip PCU registers
 */
static void
ath5k_hw_ini_registers(struct ath5k_hw *ah, unsigned int size,
		const struct ath5k_ini *ini_regs, bool skip_pcu)
{
	unsigned int i;

	/* Write initial registers */
	for (i = 0; i < size; i++) {
		/* Skip PCU registers if
		 * requested */
		if (skip_pcu &&
				ini_regs[i].ini_register >= AR5K_PCU_MIN &&
				ini_regs[i].ini_register <= AR5K_PCU_MAX)
			continue;

		switch (ini_regs[i].ini_mode) {
		case AR5K_INI_READ:
			/* Cleared on read */
			ath5k_hw_reg_read(ah, ini_regs[i].ini_register);
			break;
		case AR5K_INI_WRITE:
		default:
			AR5K_REG_WAIT(i);
			ath5k_hw_reg_write(ah, ini_regs[i].ini_value,
					ini_regs[i].ini_register);
		}
	}
}

/**
 * ath5k_hw_ini_mode_registers() - Write initial mode-specific register dump
 * @ah: The &struct ath5k_hw
 * @size: Dump size
 * @ini_mode: The array of &struct ath5k_ini_mode
 * @mode: One of enum ath5k_driver_mode
 */
static void
ath5k_hw_ini_mode_registers(struct ath5k_hw *ah,
		unsigned int size, const struct ath5k_ini_mode *ini_mode,
		u8 mode)
{
	unsigned int i;

	for (i = 0; i < size; i++) {
		AR5K_REG_WAIT(i);
		ath5k_hw_reg_write(ah, ini_mode[i].mode_value[mode],
			(u32)ini_mode[i].mode_register);
	}

}

/**
 * ath5k_hw_write_initvals() - Write initial chip-specific register dump
 * @ah: The &struct ath5k_hw
 * @mode: One of enum ath5k_driver_mode
 * @skip_pcu: Skip PCU registers
 *
 * Write initial chip-specific register dump, to get the chipset on a
 * clean and ready-to-work state after warm reset.
 */
int
ath5k_hw_write_initvals(struct ath5k_hw *ah, u8 mode, bool skip_pcu)
{
	/*
	 * Write initial register settings
	 */

	/* For AR5212 and compatible */
	if (ah->ah_version == AR5K_AR5212) {

		/* First set of mode-specific settings */
		ath5k_hw_ini_mode_registers(ah,
			ARRAY_SIZE(ar5212_ini_mode_start),
			ar5212_ini_mode_start, mode);

		/*
		 * Write initial settings common for all modes
		 */
		ath5k_hw_ini_registers(ah, ARRAY_SIZE(ar5212_ini_common_start),
				ar5212_ini_common_start, skip_pcu);

		/* Second set of mode-specific settings */
		switch (ah->ah_radio) {
		case AR5K_RF5111:

			ath5k_hw_ini_mode_registers(ah,
					ARRAY_SIZE(rf5111_ini_mode_end),
					rf5111_ini_mode_end, mode);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5111_ini_common_end),
					rf5111_ini_common_end, skip_pcu);

			/* Baseband gain table */
			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5111_ini_bbgain),
					rf5111_ini_bbgain, skip_pcu);

			break;
		case AR5K_RF5112:

			ath5k_hw_ini_mode_registers(ah,
					ARRAY_SIZE(rf5112_ini_mode_end),
					rf5112_ini_mode_end, mode);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5112_ini_common_end),
					rf5112_ini_common_end, skip_pcu);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5112_ini_bbgain),
					rf5112_ini_bbgain, skip_pcu);

			break;
		case AR5K_RF5413:

			ath5k_hw_ini_mode_registers(ah,
					ARRAY_SIZE(rf5413_ini_mode_end),
					rf5413_ini_mode_end, mode);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5413_ini_common_end),
					rf5413_ini_common_end, skip_pcu);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5112_ini_bbgain),
					rf5112_ini_bbgain, skip_pcu);

			break;
		case AR5K_RF2316:
		case AR5K_RF2413:

			ath5k_hw_ini_mode_registers(ah,
					ARRAY_SIZE(rf2413_ini_mode_end),
					rf2413_ini_mode_end, mode);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf2413_ini_common_end),
					rf2413_ini_common_end, skip_pcu);

			/* Override settings from rf2413_ini_common_end */
			if (ah->ah_radio == AR5K_RF2316) {
				ath5k_hw_reg_write(ah, 0x00004000,
							AR5K_PHY_AGC);
				ath5k_hw_reg_write(ah, 0x081b7caa,
							0xa274);
			}

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5112_ini_bbgain),
					rf5112_ini_bbgain, skip_pcu);
			break;
		case AR5K_RF2317:

			ath5k_hw_ini_mode_registers(ah,
					ARRAY_SIZE(rf2413_ini_mode_end),
					rf2413_ini_mode_end, mode);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf2425_ini_common_end),
					rf2425_ini_common_end, skip_pcu);

			/* Override settings from rf2413_ini_mode_end */
			ath5k_hw_reg_write(ah, 0x00180a65, AR5K_PHY_GAIN);

			/* Override settings from rf2413_ini_common_end */
			ath5k_hw_reg_write(ah, 0x00004000, AR5K_PHY_AGC);
			AR5K_REG_WRITE_BITS(ah, AR5K_PHY_TPC_RG5,
				AR5K_PHY_TPC_RG5_PD_GAIN_OVERLAP, 0xa);
			ath5k_hw_reg_write(ah, 0x800000a8, 0x8140);
			ath5k_hw_reg_write(ah, 0x000000ff, 0x9958);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5112_ini_bbgain),
					rf5112_ini_bbgain, skip_pcu);
			break;
		case AR5K_RF2425:

			ath5k_hw_ini_mode_registers(ah,
					ARRAY_SIZE(rf2425_ini_mode_end),
					rf2425_ini_mode_end, mode);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf2425_ini_common_end),
					rf2425_ini_common_end, skip_pcu);

			ath5k_hw_ini_registers(ah,
					ARRAY_SIZE(rf5112_ini_bbgain),
					rf5112_ini_bbgain, skip_pcu);
			break;
		default:
			return -EINVAL;

		}

	/* For AR5211 */
	} else if (ah->ah_version == AR5K_AR5211) {

		/* AR5K_MODE_11B */
		if (mode > 2) {
			ATH5K_ERR(ah, "unsupported channel mode: %d\n", mode);
			return -EINVAL;
		}

		/* Mode-specific settings */
		ath5k_hw_ini_mode_registers(ah, ARRAY_SIZE(ar5211_ini_mode),
				ar5211_ini_mode, mode);

		/*
		 * Write initial settings common for all modes
		 */
		ath5k_hw_ini_registers(ah, ARRAY_SIZE(ar5211_ini),
				ar5211_ini, skip_pcu);

		/* AR5211 only comes with 5111 */

		/* Baseband gain table */
		ath5k_hw_ini_registers(ah, ARRAY_SIZE(rf5111_ini_bbgain),
				rf5111_ini_bbgain, skip_pcu);
	/* For AR5210 (for mode settings check out ath5k_hw_reset_tx_queue) */
	} else if (ah->ah_version == AR5K_AR5210) {
		ath5k_hw_ini_registers(ah, ARRAY_SIZE(ar5210_ini),
				ar5210_ini, skip_pcu);
	}

	return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * This file is part of wl1251
 *
 * Copyright (C) 2008 Nokia Corporation
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

#ifndef __BOOT_H__
#define __BOOT_H__

#include "wl1251.h"

int wl1251_boot_soft_reset(struct wl1251 *wl);
int wl1251_boot_init_seq(struct wl1251 *wl);
int wl1251_boot_run_firmware(struct wl1251 *wl);
void wl1251_boot_target_enable_interrupts(struct wl1251 *wl);
int wl1251_boot(struct wl1251 *wl);

/* number of times we try to read the INIT interrupt */
#define INIT_LOOP 20000

/* delay between retries */
#define INIT_LOOP_DELAY 50

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *  Unified handling of special chars.
 *
 *    Copyright IBM Corp. 2001
 *    Author(s): Fritz Elfert <felfert@millenux.com> <elfert@de.ibm.com>
 *
 */

#include <linux/stddef.h>
#include <asm/errno.h>
#include <linux/sysrq.h>
#include <linux/ctype.h>

#include "ctrlchar.h"

#ifdef CONFIG_MAGIC_SYSRQ
static int ctrlchar_sysrq_key;

static void
ctrlchar_handle_sysrq(struct work_struct *work)
{
	handle_sysrq(ctrlchar_sysrq_key);
}

static DECLARE_WORK(ctrlchar_work, ctrlchar_handle_sysrq);
#endif


/**
 * Check for special chars at start of input.
 *
 * @param buf Console input buffer.
 * @param len Length of valid data in buffer.
 * @param tty The tty struct for this console.
 * @return CTRLCHAR_NONE, if nothing matched,
 *         CTRLCHAR_SYSRQ, if sysrq was encountered
 *         otherwise char to be inserted logically or'ed
 *         with CTRLCHAR_CTRL
 */
unsigned int
ctrlchar_handle(const unsigned char *buf, int len, struct tty_struct *tty)
{
	if ((len < 2) || (len > 3))
		return CTRLCHAR_NONE;

	/* hat is 0xb1 in codepage 037 (US etc.) and thus */
	/* converted to 0x5e in ascii ('^') */
	if ((buf[0] != '^') && (buf[0] != '\252'))
		return CTRLCHAR_NONE;

#ifdef CONFIG_MAGIC_SYSRQ
	/* racy */
	if (len == 3 && buf[1] == '-') {
		ctrlchar_sysrq_key = buf[2];
		schedule_work(&ctrlchar_work);
		return CTRLCHAR_SYSRQ;
	}
#endif

	if (len != 2)
		return CTRLCHAR_NONE;

	switch (tolower(buf[1])) {
	case 'c':
		return INTR_CHAR(tty) | CTRLCHAR_CTRL;
	case 'd':
		return EOF_CHAR(tty)  | CTRLCHAR_CTRL;
	case 'z':
		return SUSP_CHAR(tty) | CTRLCHAR_CTRL;
	}
	return CTRLCHAR_NONE;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
    comedi/drivers/icp_multi.c

    COMEDI - Linux Control and Measurement Device Interface
    Copyright (C) 1997-2002 David A. Schleef <ds@schleef.org>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/

/*
Driver: icp_multi
Description: Inova ICP_MULTI
Author: Anne Smorthit <anne.smorthit@sfwte.ch>
Devices: [Inova] ICP_MULTI (icp_multi)
Status: works

The driver works for analog input and output and digital input and output.
It does not work with interrupts or with the counters.  Currently no support
for DMA.

It has 16 single-ended or 8 differential Analogue Input channels with 12-bit
resolution.  Ranges : 5V, 10V, +/-5V, +/-10V, 0..20mA and 4..20mA.  Input
ranges can be individually programmed for each channel.  Voltage or current
measurement is selected by jumper.

There are 4 x 12-bit Analogue Outputs.  Ranges : 5V, 10V, +/-5V, +/-10V

16 x Digital Inputs, 24V

8 x Digital Outputs, 24V, 1A

4 x 16-bit counters

Configuration options: not applicable, uses PCI auto config
*/

#include <linux/module.h>
#include <linux/pci.h>
#include <linux/delay.h>
#include <linux/interrupt.h>

#include "../comedidev.h"

#define ICP_MULTI_ADC_CSR	0	/* R/W: ADC command/status register */
#define ICP_MULTI_AI		2	/* R:   Analogue input data */
#define ICP_MULTI_DAC_CSR	4	/* R/W: DAC command/status register */
#define ICP_MULTI_AO		6	/* R/W: Analogue output data */
#define ICP_MULTI_DI		8	/* R/W: Digital inouts */
#define ICP_MULTI_DO		0x0A	/* R/W: Digital outputs */
#define ICP_MULTI_INT_EN	0x0C	/* R/W: Interrupt enable register */
#define ICP_MULTI_INT_STAT	0x0E	/* R/W: Interrupt status register */
#define ICP_MULTI_CNTR0		0x10	/* R/W: Counter 0 */
#define ICP_MULTI_CNTR1		0x12	/* R/W: counter 1 */
#define ICP_MULTI_CNTR2		0x14	/* R/W: Counter 2 */
#define ICP_MULTI_CNTR3		0x16	/* R/W: Counter 3 */

/*  Define bits from ADC command/status register */
#define	ADC_ST		0x0001	/* Start ADC */
#define	ADC_BSY		0x0001	/* ADC busy */
#define ADC_BI		0x0010	/* Bipolar input range 1 = bipolar */
#define ADC_RA		0x0020	/* Input range 0 = 5V, 1 = 10V */
#define	ADC_DI		0x0040	/* Differential input mode 1 = differential */

/*  Define bits from DAC command/status register */
#define	DAC_ST		0x0001	/* Start DAC */
#define DAC_BSY		0x0001	/* DAC busy */
#define	DAC_BI		0x0010	/* Bipolar input range 1 = bipolar */
#define	DAC_RA		0x0020	/* Input range 0 = 5V, 1 = 10V */

/*  Define bits from interrupt enable/status registers */
#define	ADC_READY	0x0001	/* A/d conversion ready interrupt */
#define	DAC_READY	0x0002	/* D/a conversion ready interrupt */
#define	DOUT_ERROR	0x0004	/* Digital output error interrupt */
#define	DIN_STATUS	0x0008	/* Digital input status change interrupt */
#define	CIE0		0x0010	/* Counter 0 overrun interrupt */
#define	CIE1		0x0020	/* Counter 1 overrun interrupt */
#define	CIE2		0x0040	/* Counter 2 overrun interrupt */
#define	CIE3		0x0080	/* Counter 3 overrun interrupt */

/*  Useful definitions */
#define	Status_IRQ	0x00ff	/*  All interrupts */

/*  Define analogue range */
static const struct comedi_lrange range_analog = {
	4, {
		UNI_RANGE(5),
		UNI_RANGE(10),
		BIP_RANGE(5),
		BIP_RANGE(10)
	}
};

static const char range_codes_analog[] = { 0x00, 0x20, 0x10, 0x30 };

/*
==============================================================================
	Data & Structure declarations
==============================================================================
*/

struct icp_multi_private {
	unsigned int AdcCmdStatus;	/*  ADC Command/Status register */
	unsigned int DacCmdStatus;	/*  DAC Command/Status register */
	unsigned int IntEnable;	/*  Interrupt Enable register */
	unsigned int IntStatus;	/*  Interrupt Status register */
	unsigned int act_chanlist[32];	/*  list of scanned channel */
	unsigned char act_chanlist_len;	/*  len of scanlist */
	unsigned char act_chanlist_pos;	/*  actual position in MUX list */
	unsigned int *ai_chanlist;	/*  actaul chanlist */
	unsigned int do_data;	/*  Remember digital output data */
};

static void setup_channel_list(struct comedi_device *dev,
			       struct comedi_subdevice *s,
			       unsigned int *chanlist, unsigned int n_chan)
{
	struct icp_multi_private *devpriv = dev->private;
	unsigned int i, range, chanprog;
	unsigned int diff;

	devpriv->act_chanlist_len = n_chan;
	devpriv->act_chanlist_pos = 0;

	for (i = 0; i < n_chan; i++) {
		/*  Get channel */
		chanprog = CR_CHAN(chanlist[i]);

		/*  Determine if it is a differential channel (Bit 15  = 1) */
		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
			diff = 1;
			chanprog &= 0x0007;
		} else {
			diff = 0;
			chanprog &= 0x000f;
		}

		/*  Clear channel, range and input mode bits
		 *  in A/D command/status register */
		devpriv->AdcCmdStatus &= 0xf00f;

		/*  Set channel number and differential mode status bit */
		if (diff) {
			/*  Set channel number, bits 9-11 & mode, bit 6 */
			devpriv->AdcCmdStatus |= (chanprog << 9);
			devpriv->AdcCmdStatus |= ADC_DI;
		} else
			/*  Set channel number, bits 8-11 */
			devpriv->AdcCmdStatus |= (chanprog << 8);

		/*  Get range for current channel */
		range = range_codes_analog[CR_RANGE(chanlist[i])];
		/*  Set range. bits 4-5 */
		devpriv->AdcCmdStatus |= range;

		/* Output channel, range, mode to ICP Multi */
		writew(devpriv->AdcCmdStatus, dev->mmio + ICP_MULTI_ADC_CSR);
	}
}

static int icp_multi_ai_eoc(struct comedi_device *dev,
			    struct comedi_subdevice *s,
			    struct comedi_insn *insn,
			    unsigned long context)
{
	unsigned int status;

	status = readw(dev->mmio + ICP_MULTI_ADC_CSR);
	if ((status & ADC_BSY) == 0)
		return 0;
	return -EBUSY;
}

static int icp_multi_insn_read_ai(struct comedi_device *dev,
				  struct comedi_subdevice *s,
				  struct comedi_insn *insn,
				  unsigned int *data)
{
	struct icp_multi_private *devpriv = dev->private;
	int ret = 0;
	int n;

	/*  Disable A/D conversion ready interrupt */
	devpriv->IntEnable &= ~ADC_READY;
	writew(devpriv->IntEnable, dev->mmio + ICP_MULTI_INT_EN);

	/*  Clear interrupt status */
	devpriv->IntStatus |= ADC_READY;
	writew(devpriv->IntStatus, dev->mmio + ICP_MULTI_INT_STAT);

	/*  Set up appropriate channel, mode and range data, for specified ch */
	setup_channel_list(dev, s, &insn->chanspec, 1);

	for (n = 0; n < insn->n; n++) {
		/*  Set start ADC bit */
		devpriv->AdcCmdStatus |= ADC_ST;
		writew(devpriv->AdcCmdStatus, dev->mmio + ICP_MULTI_ADC_CSR);
		devpriv->AdcCmdStatus &= ~ADC_ST;

		udelay(1);

		/*  Wait for conversion to complete, or get fed up waiting */
		ret = comedi_timeout(dev, s, insn, icp_multi_ai_eoc, 0);
		if (ret)
			break;

		data[n] = (readw(dev->mmio + ICP_MULTI_AI) >> 4) & 0x0fff;
	}

	/*  Disable interrupt */
	devpriv->IntEnable &= ~ADC_READY;
	writew(devpriv->IntEnable, dev->mmio + ICP_MULTI_INT_EN);

	/*  Clear interrupt status */
	devpriv->IntStatus |= ADC_READY;
	writew(devpriv->IntStatus, dev->mmio + ICP_MULTI_INT_STAT);

	return ret ? ret : n;
}

static int icp_multi_ao_eoc(struct comedi_device *dev,
			    struct comedi_subdevice *s,
			    struct comedi_insn *insn,
			    unsigned long context)
{
	unsigned int status;

	status = readw(dev->mmio + ICP_MULTI_DAC_CSR);
	if ((status & DAC_BSY) == 0)
		return 0;
	return -EBUSY;
}

static int icp_multi_ao_insn_write(struct comedi_device *dev,
				   struct comedi_subdevice *s,
				   struct comedi_insn *insn,
				   unsigned int *data)
{
	struct icp_multi_private *devpriv = dev->private;
	unsigned int chan = CR_CHAN(insn->chanspec);
	unsigned int range = CR_RANGE(insn->chanspec);
	int i;

	/*  Disable D/A conversion ready interrupt */
	devpriv->IntEnable &= ~DAC_READY;
	writew(devpriv->IntEnable, dev->mmio + ICP_MULTI_INT_EN);

	/*  Clear interrupt status */
	devpriv->IntStatus |= DAC_READY;
	writew(devpriv->IntStatus, dev->mmio + ICP_MULTI_INT_STAT);

	/*  Set up range and channel data */
	/*  Bit 4 = 1 : Bipolar */
	/*  Bit 5 = 0 : 5V */
	/*  Bit 5 = 1 : 10V */
	/*  Bits 8-9 : Channel number */
	devpriv->DacCmdStatus &= 0xfccf;
	devpriv->DacCmdStatus |= range_codes_analog[range];
	devpriv->DacCmdStatus |= (chan << 8);

	writew(devpriv->DacCmdStatus, dev->mmio + ICP_MULTI_DAC_CSR);

	for (i = 0; i < insn->n; i++) {
		unsigned int val = data[i];
		int ret;

		/*  Wait for analogue output data register to be
		 *  ready for new data, or get fed up waiting */
		ret = comedi_timeout(dev, s, insn, icp_multi_ao_eoc, 0);
		if (ret) {
			/*  Disable interrupt */
			devpriv->IntEnable &= ~DAC_READY;
			writew(devpriv->IntEnable,
			       dev->mmio + ICP_MULTI_INT_EN);

			/*  Clear interrupt status */
			devpriv->IntStatus |= DAC_READY;
			writew(devpriv->IntStatus,
			       dev->mmio + ICP_MULTI_INT_STAT);

			return ret;
		}

		writew(val, dev->mmio + ICP_MULTI_AO);

		/*  Set DAC_ST bit to write the data to selected channel */
		devpriv->DacCmdStatus |= DAC_ST;
		writew(devpriv->DacCmdStatus, dev->mmio + ICP_MULTI_DAC_CSR);
		devpriv->DacCmdStatus &= ~DAC_ST;

		s->readback[chan] = val;
	}

	return insn->n;
}

static int icp_multi_insn_bits_di(struct comedi_device *dev,
				  struct comedi_subdevice *s,
				  struct comedi_insn *insn,
				  unsigned int *data)
{
	data[1] = readw(dev->mmio + ICP_MULTI_DI);

	return insn->n;
}

static int icp_multi_insn_bits_do(struct comedi_device *dev,
				  struct comedi_subdevice *s,
				  struct comedi_insn *insn,
				  unsigned int *data)
{
	if (comedi_dio_update_state(s, data))
		writew(s->state, dev->mmio + ICP_MULTI_DO);

	data[1] = readw(dev->mmio + ICP_MULTI_DI);

	return insn->n;
}

static int icp_multi_insn_read_ctr(struct comedi_device *dev,
				   struct comedi_subdevice *s,
				   struct comedi_insn *insn, unsigned int *data)
{
	return 0;
}

static int icp_multi_insn_write_ctr(struct comedi_device *dev,
				    struct comedi_subdevice *s,
				    struct comedi_insn *insn,
				    unsigned int *data)
{
	return 0;
}

static irqreturn_t interrupt_service_icp_multi(int irq, void *d)
{
	struct comedi_device *dev = d;
	int int_no;

	/*  Is this interrupt from our board? */
	int_no = readw(dev->mmio + ICP_MULTI_INT_STAT) & Status_IRQ;
	if (!int_no)
		/*  No, exit */
		return IRQ_NONE;

	/*  Determine which interrupt is active & handle it */
	switch (int_no) {
	case ADC_READY:
		break;
	case DAC_READY:
		break;
	case DOUT_ERROR:
		break;
	case DIN_STATUS:
		break;
	case CIE0:
		break;
	case CIE1:
		break;
	case CIE2:
		break;
	case CIE3:
		break;
	default:
		break;

	}

	return IRQ_HANDLED;
}

#if 0
static int check_channel_list(struct comedi_device *dev,
			      struct comedi_subdevice *s,
			      unsigned int *chanlist, unsigned int n_chan)
{
	unsigned int i;

	/*  Check that we at least have one channel to check */
	if (n_chan < 1) {
		dev_err(dev->class_dev, "range/channel list is empty!\n");
		return 0;
	}
	/*  Check all channels */
	for (i = 0; i < n_chan; i++) {
		/*  Check that channel number is < maximum */
		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
			if (CR_CHAN(chanlist[i]) > (s->nchan / 2)) {
				dev_err(dev->class_dev,
					"Incorrect differential ai ch-nr\n");
				return 0;
			}
		} else {
			if (CR_CHAN(chanlist[i]) > s->n_chan) {
				dev_err(dev->class_dev,
					"Incorrect ai channel number\n");
				return 0;
			}
		}
	}
	return 1;
}
#endif

static int icp_multi_reset(struct comedi_device *dev)
{
	struct icp_multi_private *devpriv = dev->private;
	unsigned int i;

	/*  Clear INT enables and requests */
	writew(0, dev->mmio + ICP_MULTI_INT_EN);
	writew(0x00ff, dev->mmio + ICP_MULTI_INT_STAT);

	/* Set DACs to 0..5V range and 0V output */
	for (i = 0; i < 4; i++) {
		devpriv->DacCmdStatus &= 0xfcce;

		/*  Set channel number */
		devpriv->DacCmdStatus |= (i << 8);

		/*  Output 0V */
		writew(0, dev->mmio + ICP_MULTI_AO);

		/*  Set start conversion bit */
		devpriv->DacCmdStatus |= DAC_ST;

		/*  Output to command / status register */
		writew(devpriv->DacCmdStatus, dev->mmio + ICP_MULTI_DAC_CSR);

		/*  Delay to allow DAC time to recover */
		udelay(1);
	}

	/* Digital outputs to 0 */
	writew(0, dev->mmio + ICP_MULTI_DO);

	return 0;
}

static int icp_multi_auto_attach(struct comedi_device *dev,
					   unsigned long context_unused)
{
	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
	struct icp_multi_private *devpriv;
	struct comedi_subdevice *s;
	int ret;

	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
	if (!devpriv)
		return -ENOMEM;

	ret = comedi_pci_enable(dev);
	if (ret)
		return ret;

	dev->mmio = pci_ioremap_bar(pcidev, 2);
	if (!dev->mmio)
		return -ENOMEM;

	ret = comedi_alloc_subdevices(dev, 5);
	if (ret)
		return ret;

	icp_multi_reset(dev);

	if (pcidev->irq) {
		ret = request_irq(pcidev->irq, interrupt_service_icp_multi,
				  IRQF_SHARED, dev->board_name, dev);
		if (ret == 0)
			dev->irq = pcidev->irq;
	}

	s = &dev->subdevices[0];
	dev->read_subdev = s;
	s->type = COMEDI_SUBD_AI;
	s->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
	s->n_chan = 16;
	s->maxdata = 0x0fff;
	s->len_chanlist = 16;
	s->range_table = &range_analog;
	s->insn_read = icp_multi_insn_read_ai;

	s = &dev->subdevices[1];
	s->type = COMEDI_SUBD_AO;
	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
	s->n_chan = 4;
	s->maxdata = 0x0fff;
	s->len_chanlist = 4;
	s->range_table = &range_analog;
	s->insn_write = icp_multi_ao_insn_write;
	s->insn_read = comedi_readback_insn_read;

	ret = comedi_alloc_subdev_readback(s);
	if (ret)
		return ret;

	s = &dev->subdevices[2];
	s->type = COMEDI_SUBD_DI;
	s->subdev_flags = SDF_READABLE;
	s->n_chan = 16;
	s->maxdata = 1;
	s->len_chanlist = 16;
	s->range_table = &range_digital;
	s->insn_bits = icp_multi_insn_bits_di;

	s = &dev->subdevices[3];
	s->type = COMEDI_SUBD_DO;
	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
	s->n_chan = 8;
	s->maxdata = 1;
	s->len_chanlist = 8;
	s->range_table = &range_digital;
	s->insn_bits = icp_multi_insn_bits_do;

	s = &dev->subdevices[4];
	s->type = COMEDI_SUBD_COUNTER;
	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
	s->n_chan = 4;
	s->maxdata = 0xffff;
	s->len_chanlist = 4;
	s->state = 0;
	s->insn_read = icp_multi_insn_read_ctr;
	s->insn_write = icp_multi_insn_write_ctr;

	return 0;
}

static void icp_multi_detach(struct comedi_device *dev)
{
	if (dev->mmio)
		icp_multi_reset(dev);
	comedi_pci_detach(dev);
}

static struct comedi_driver icp_multi_driver = {
	.driver_name	= "icp_multi",
	.module		= THIS_MODULE,
	.auto_attach	= icp_multi_auto_attach,
	.detach		= icp_multi_detach,
};

static int icp_multi_pci_probe(struct pci_dev *dev,
			       const struct pci_device_id *id)
{
	return comedi_pci_auto_config(dev, &icp_multi_driver, id->driver_data);
}

static const struct pci_device_id icp_multi_pci_table[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_ICP, 0x8000) },
	{ 0 }
};
MODULE_DEVICE_TABLE(pci, icp_multi_pci_table);

static struct pci_driver icp_multi_pci_driver = {
	.name		= "icp_multi",
	.id_table	= icp_multi_pci_table,
	.probe		= icp_multi_pci_probe,
	.remove		= comedi_pci_auto_unconfig,
};
module_comedi_pci_driver(icp_multi_driver, icp_multi_pci_driver);

MODULE_AUTHOR("Comedi http://www.comedi.org");
MODULE_DESCRIPTION("Comedi low-level driver");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include <linux/interrupt.h>
#include <linux/ioport.h>

#include "spk_types.h"
#include "speakup.h"
#include "spk_priv.h"
#include "serialio.h"

#include <linux/serial_core.h>
/* WARNING:  Do not change this to <linux/serial.h> without testing that
 * SERIAL_PORT_DFNS does get defined to the appropriate value. */
#include <asm/serial.h>

#ifndef SERIAL_PORT_DFNS
#define SERIAL_PORT_DFNS
#endif

static void start_serial_interrupt(int irq);

static const struct old_serial_port rs_table[] = {
	SERIAL_PORT_DFNS
};
static const struct old_serial_port *serstate;
static int timeouts;

const struct old_serial_port *spk_serial_init(int index)
{
	int baud = 9600, quot = 0;
	unsigned int cval = 0;
	int cflag = CREAD | HUPCL | CLOCAL | B9600 | CS8;
	const struct old_serial_port *ser;
	int err;

	if (index >= ARRAY_SIZE(rs_table)) {
		pr_info("no port info for ttyS%d\n", index);
		return NULL;
	}
	ser = rs_table + index;

	/*	Divisor, bytesize and parity */
	quot = ser->baud_base / baud;
	cval = cflag & (CSIZE | CSTOPB);
#if defined(__powerpc__) || defined(__alpha__)
	cval >>= 8;
#else /* !__powerpc__ && !__alpha__ */
	cval >>= 4;
#endif /* !__powerpc__ && !__alpha__ */
	if (cflag & PARENB)
		cval |= UART_LCR_PARITY;
	if (!(cflag & PARODD))
		cval |= UART_LCR_EPAR;
	if (synth_request_region(ser->port, 8)) {
		/* try to take it back. */
		pr_info("Ports not available, trying to steal them\n");
		__release_region(&ioport_resource, ser->port, 8);
		err = synth_request_region(ser->port, 8);
		if (err) {
			pr_warn("Unable to allocate port at %x, errno %i",
				ser->port, err);
			return NULL;
		}
	}

	/*	Disable UART interrupts, set DTR and RTS high
	 *	and set speed. */
	outb(cval | UART_LCR_DLAB, ser->port + UART_LCR);	/* set DLAB */
	outb(quot & 0xff, ser->port + UART_DLL);	/* LS of divisor */
	outb(quot >> 8, ser->port + UART_DLM);		/* MS of divisor */
	outb(cval, ser->port + UART_LCR);		/* reset DLAB */

	/* Turn off Interrupts */
	outb(0, ser->port + UART_IER);
	outb(UART_MCR_DTR | UART_MCR_RTS, ser->port + UART_MCR);

	/* If we read 0xff from the LSR, there is no UART here. */
	if (inb(ser->port + UART_LSR) == 0xff) {
		synth_release_region(ser->port, 8);
		serstate = NULL;
		return NULL;
	}

	mdelay(1);
	speakup_info.port_tts = ser->port;
	serstate = ser;

	start_serial_interrupt(ser->irq);

	return ser;
}

static irqreturn_t synth_readbuf_handler(int irq, void *dev_id)
{
	unsigned long flags;
/*printk(KERN_ERR "in irq\n"); */
/*pr_warn("in IRQ\n"); */
	int c;

	spin_lock_irqsave(&speakup_info.spinlock, flags);
	while (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {

		c = inb_p(speakup_info.port_tts+UART_RX);
		synth->read_buff_add((u_char) c);
/*printk(KERN_ERR "c = %d\n", c); */
/*pr_warn("C = %d\n", c); */
	}
	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
	return IRQ_HANDLED;
}

static void start_serial_interrupt(int irq)
{
	int rv;

	if (synth->read_buff_add == NULL)
		return;

	rv = request_irq(irq, synth_readbuf_handler, IRQF_SHARED,
			 "serial", (void *) synth_readbuf_handler);

	if (rv)
		pr_err("Unable to request Speakup serial I R Q\n");
	/* Set MCR */
	outb(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2,
			speakup_info.port_tts + UART_MCR);
	/* Turn on Interrupts */
	outb(UART_IER_MSI|UART_IER_RLSI|UART_IER_RDI,
			speakup_info.port_tts + UART_IER);
	inb(speakup_info.port_tts+UART_LSR);
	inb(speakup_info.port_tts+UART_RX);
	inb(speakup_info.port_tts+UART_IIR);
	inb(speakup_info.port_tts+UART_MSR);
	outb(1, speakup_info.port_tts + UART_FCR);	/* Turn FIFO On */
}

void spk_stop_serial_interrupt(void)
{
	if (speakup_info.port_tts == 0)
		return;

	if (synth->read_buff_add == NULL)
		return;

	/* Turn off interrupts */
	outb(0, speakup_info.port_tts+UART_IER);
	/* Free IRQ */
	free_irq(serstate->irq, (void *) synth_readbuf_handler);
}

int spk_wait_for_xmitr(void)
{
	int tmout = SPK_XMITR_TIMEOUT;

	if ((synth->alive) && (timeouts >= NUM_DISABLE_TIMEOUTS)) {
		pr_warn("%s: too many timeouts, deactivating speakup\n",
			synth->long_name);
		synth->alive = 0;
		/* No synth any more, so nobody will restart TTYs, and we thus
		 * need to do it ourselves.  Now that there is no synth we can
		 * let application flood anyway */
		speakup_start_ttys();
		timeouts = 0;
		return 0;
	}
	while (spk_serial_tx_busy()) {
		if (--tmout == 0) {
			pr_warn("%s: timed out (tx busy)\n", synth->long_name);
			timeouts++;
			return 0;
		}
		udelay(1);
	}
	tmout = SPK_CTS_TIMEOUT;
	while (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {
		/* CTS */
		if (--tmout == 0) {
			/* pr_warn("%s: timed out (cts)\n",
			 * synth->long_name); */
			timeouts++;
			return 0;
		}
		udelay(1);
	}
	timeouts = 0;
	return 1;
}

unsigned char spk_serial_in(void)
{
	int tmout = SPK_SERIAL_TIMEOUT;

	while (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {
		if (--tmout == 0) {
			pr_warn("time out while waiting for input.\n");
			return 0xff;
		}
		udelay(1);
	}
	return inb_p(speakup_info.port_tts + UART_RX);
}
EXPORT_SYMBOL_GPL(spk_serial_in);

unsigned char spk_serial_in_nowait(void)
{
	unsigned char lsr;

	lsr = inb_p(speakup_info.port_tts + UART_LSR);
	if (!(lsr & UART_LSR_DR))
		return 0;
	return inb_p(speakup_info.port_tts + UART_RX);
}
EXPORT_SYMBOL_GPL(spk_serial_in_nowait);

int spk_serial_out(const char ch)
{
	if (synth->alive && spk_wait_for_xmitr()) {
		outb_p(ch, speakup_info.port_tts);
		return 1;
	}
	return 0;
}
EXPORT_SYMBOL_GPL(spk_serial_out);

void spk_serial_release(void)
{
	if (speakup_info.port_tts == 0)
		return;
	synth_release_region(speakup_info.port_tts, 8);
	speakup_info.port_tts = 0;
}
EXPORT_SYMBOL_GPL(spk_serial_release);

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * WUSB Wire Adapter: Control/Data Streaming Interface (WUSB[8])
 * Device Connect handling
 *
 * Copyright (C) 2006 Intel Corporation
 * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *
 *
 * FIXME: docs
 * FIXME: this file needs to be broken up, it's grown too big
 *
 *
 * WUSB1.0[7.1, 7.5.1, ]
 *
 * WUSB device connection is kind of messy. Some background:
 *
 *     When a device wants to connect it scans the UWB radio channels
 *     looking for a WUSB Channel; a WUSB channel is defined by MMCs
 *     (Micro Managed Commands or something like that) [see
 *     Design-overview for more on this] .
 *
 * So, device scans the radio, finds MMCs and thus a host and checks
 * when the next DNTS is. It sends a Device Notification Connect
 * (DN_Connect); the host picks it up (through nep.c and notif.c, ends
 * up in wusb_devconnect_ack(), which creates a wusb_dev structure in
 * wusbhc->port[port_number].wusb_dev), assigns an unauth address
 * to the device (this means from 0x80 to 0xfe) and sends, in the MMC
 * a Connect Ack Information Element (ConnAck IE).
 *
 * So now the device now has a WUSB address. From now on, we use
 * that to talk to it in the RPipes.
 *
 * ASSUMPTIONS:
 *
 *  - We use the the as device address the port number where it is
 *    connected (port 0 doesn't exist). For unauth, it is 128 + that.
 *
 * ROADMAP:
 *
 *   This file contains the logic for doing that--entry points:
 *
 *   wusb_devconnect_ack()      Ack a device until _acked() called.
 *                              Called by notif.c:wusb_handle_dn_connect()
 *                              when a DN_Connect is received.
 *
 *     wusb_devconnect_acked()  Ack done, release resources.
 *
 *   wusb_handle_dn_alive()     Called by notif.c:wusb_handle_dn()
 *                              for processing a DN_Alive pong from a device.
 *
 *   wusb_handle_dn_disconnect()Called by notif.c:wusb_handle_dn() to
 *                              process a disconenct request from a
 *                              device.
 *
 *   __wusb_dev_disable()       Called by rh.c:wusbhc_rh_clear_port_feat() when
 *                              disabling a port.
 *
 *   wusb_devconnect_create()   Called when creating the host by
 *                              lc.c:wusbhc_create().
 *
 *   wusb_devconnect_destroy()  Cleanup called removing the host. Called
 *                              by lc.c:wusbhc_destroy().
 *
 *   Each Wireless USB host maintains a list of DN_Connect requests
 *   (actually we maintain a list of pending Connect Acks, the
 *   wusbhc->ca_list).
 *
 * LIFE CYCLE OF port->wusb_dev
 *
 *   Before the @wusbhc structure put()s the reference it owns for
 *   port->wusb_dev [and clean the wusb_dev pointer], it needs to
 *   lock @wusbhc->mutex.
 */

#include <linux/jiffies.h>
#include <linux/ctype.h>
#include <linux/slab.h>
#include <linux/workqueue.h>
#include <linux/export.h>
#include "wusbhc.h"

static void wusbhc_devconnect_acked_work(struct work_struct *work);

static void wusb_dev_free(struct wusb_dev *wusb_dev)
{
	kfree(wusb_dev);
}

static struct wusb_dev *wusb_dev_alloc(struct wusbhc *wusbhc)
{
	struct wusb_dev *wusb_dev;

	wusb_dev = kzalloc(sizeof(*wusb_dev), GFP_KERNEL);
	if (wusb_dev == NULL)
		goto err;

	wusb_dev->wusbhc = wusbhc;

	INIT_WORK(&wusb_dev->devconnect_acked_work, wusbhc_devconnect_acked_work);

	return wusb_dev;
err:
	wusb_dev_free(wusb_dev);
	return NULL;
}


/*
 * Using the Connect-Ack list, fill out the @wusbhc Connect-Ack WUSB IE
 * properly so that it can be added to the MMC.
 *
 * We just get the @wusbhc->ca_list and fill out the first four ones or
 * less (per-spec WUSB1.0[7.5, before T7-38). If the ConnectAck WUSB
 * IE is not allocated, we alloc it.
 *
 * @wusbhc->mutex must be taken
 */
static void wusbhc_fill_cack_ie(struct wusbhc *wusbhc)
{
	unsigned cnt;
	struct wusb_dev *dev_itr;
	struct wuie_connect_ack *cack_ie;

	cack_ie = &wusbhc->cack_ie;
	cnt = 0;
	list_for_each_entry(dev_itr, &wusbhc->cack_list, cack_node) {
		cack_ie->blk[cnt].CDID = dev_itr->cdid;
		cack_ie->blk[cnt].bDeviceAddress = dev_itr->addr;
		if (++cnt >= WUIE_ELT_MAX)
			break;
	}
	cack_ie->hdr.bLength = sizeof(cack_ie->hdr)
		+ cnt * sizeof(cack_ie->blk[0]);
}

/*
 * Register a new device that wants to connect
 *
 * A new device wants to connect, so we add it to the Connect-Ack
 * list. We give it an address in the unauthorized range (bit 8 set);
 * user space will have to drive authorization further on.
 *
 * @dev_addr: address to use for the device (which is also the port
 *            number).
 *
 * @wusbhc->mutex must be taken
 */
static struct wusb_dev *wusbhc_cack_add(struct wusbhc *wusbhc,
					struct wusb_dn_connect *dnc,
					const char *pr_cdid, u8 port_idx)
{
	struct device *dev = wusbhc->dev;
	struct wusb_dev *wusb_dev;
	int new_connection = wusb_dn_connect_new_connection(dnc);
	u8 dev_addr;
	int result;

	/* Is it registered already? */
	list_for_each_entry(wusb_dev, &wusbhc->cack_list, cack_node)
		if (!memcmp(&wusb_dev->cdid, &dnc->CDID,
			    sizeof(wusb_dev->cdid)))
			return wusb_dev;
	/* We don't have it, create an entry, register it */
	wusb_dev = wusb_dev_alloc(wusbhc);
	if (wusb_dev == NULL)
		return NULL;
	wusb_dev_init(wusb_dev);
	wusb_dev->cdid = dnc->CDID;
	wusb_dev->port_idx = port_idx;

	/*
	 * Devices are always available within the cluster reservation
	 * and since the hardware will take the intersection of the
	 * per-device availability and the cluster reservation, the
	 * per-device availability can simply be set to always
	 * available.
	 */
	bitmap_fill(wusb_dev->availability.bm, UWB_NUM_MAS);

	/* FIXME: handle reconnects instead of assuming connects are
	   always new. */
	if (1 && new_connection == 0)
		new_connection = 1;
	if (new_connection) {
		dev_addr = (port_idx + 2) | WUSB_DEV_ADDR_UNAUTH;

		dev_info(dev, "Connecting new WUSB device to address %u, "
			"port %u\n", dev_addr, port_idx);

		result = wusb_set_dev_addr(wusbhc, wusb_dev, dev_addr);
		if (result < 0)
			return NULL;
	}
	wusb_dev->entry_ts = jiffies;
	list_add_tail(&wusb_dev->cack_node, &wusbhc->cack_list);
	wusbhc->cack_count++;
	wusbhc_fill_cack_ie(wusbhc);

	return wusb_dev;
}

/*
 * Remove a Connect-Ack context entry from the HCs view
 *
 * @wusbhc->mutex must be taken
 */
static void wusbhc_cack_rm(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev)
{
	list_del_init(&wusb_dev->cack_node);
	wusbhc->cack_count--;
	wusbhc_fill_cack_ie(wusbhc);
}

/*
 * @wusbhc->mutex must be taken */
static
void wusbhc_devconnect_acked(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev)
{
	wusbhc_cack_rm(wusbhc, wusb_dev);
	if (wusbhc->cack_count)
		wusbhc_mmcie_set(wusbhc, 0, 0, &wusbhc->cack_ie.hdr);
	else
		wusbhc_mmcie_rm(wusbhc, &wusbhc->cack_ie.hdr);
}

static void wusbhc_devconnect_acked_work(struct work_struct *work)
{
	struct wusb_dev *wusb_dev = container_of(work, struct wusb_dev,
						 devconnect_acked_work);
	struct wusbhc *wusbhc = wusb_dev->wusbhc;

	mutex_lock(&wusbhc->mutex);
	wusbhc_devconnect_acked(wusbhc, wusb_dev);
	mutex_unlock(&wusbhc->mutex);

	wusb_dev_put(wusb_dev);
}

/*
 * Ack a device for connection
 *
 * FIXME: docs
 *
 * @pr_cdid:	Printable CDID...hex Use @dnc->cdid for the real deal.
 *
 * So we get the connect ack IE (may have been allocated already),
 * find an empty connect block, an empty virtual port, create an
 * address with it (see below), make it an unauth addr [bit 7 set] and
 * set the MMC.
 *
 * Addresses: because WUSB hosts have no downstream hubs, we can do a
 *            1:1 mapping between 'port number' and device
 *            address. This simplifies many things, as during this
 *            initial connect phase the USB stack has no knowledge of
 *            the device and hasn't assigned an address yet--we know
 *            USB's choose_address() will use the same heuristics we
 *            use here, so we can assume which address will be assigned.
 *
 *            USB stack always assigns address 1 to the root hub, so
 *            to the port number we add 2 (thus virtual port #0 is
 *            addr #2).
 *
 * @wusbhc shall be referenced
 */
static
void wusbhc_devconnect_ack(struct wusbhc *wusbhc, struct wusb_dn_connect *dnc,
			   const char *pr_cdid)
{
	int result;
	struct device *dev = wusbhc->dev;
	struct wusb_dev *wusb_dev;
	struct wusb_port *port;
	unsigned idx;

	mutex_lock(&wusbhc->mutex);

	/* Check we are not handling it already */
	for (idx = 0; idx < wusbhc->ports_max; idx++) {
		port = wusb_port_by_idx(wusbhc, idx);
		if (port->wusb_dev
		    && memcmp(&dnc->CDID, &port->wusb_dev->cdid, sizeof(dnc->CDID)) == 0)
			goto error_unlock;
	}
	/* Look up those fake ports we have for a free one */
	for (idx = 0; idx < wusbhc->ports_max; idx++) {
		port = wusb_port_by_idx(wusbhc, idx);
		if ((port->status & USB_PORT_STAT_POWER)
		    && !(port->status & USB_PORT_STAT_CONNECTION))
			break;
	}
	if (idx >= wusbhc->ports_max) {
		dev_err(dev, "Host controller can't connect more devices "
			"(%u already connected); device %s rejected\n",
			wusbhc->ports_max, pr_cdid);
		/* NOTE: we could send a WUIE_Disconnect here, but we haven't
		 *       event acked, so the device will eventually timeout the
		 *       connection, right? */
		goto error_unlock;
	}

	/* Make sure we are using no crypto on that "virtual port" */
	wusbhc->set_ptk(wusbhc, idx, 0, NULL, 0);

	/* Grab a filled in Connect-Ack context, fill out the
	 * Connect-Ack Wireless USB IE, set the MMC */
	wusb_dev = wusbhc_cack_add(wusbhc, dnc, pr_cdid, idx);
	if (wusb_dev == NULL)
		goto error_unlock;
	result = wusbhc_mmcie_set(wusbhc, 0, 0, &wusbhc->cack_ie.hdr);
	if (result < 0)
		goto error_unlock;
	/* Give the device at least 2ms (WUSB1.0[7.5.1p3]), let's do
	 * three for a good measure */
	msleep(3);
	port->wusb_dev = wusb_dev;
	port->status |= USB_PORT_STAT_CONNECTION;
	port->change |= USB_PORT_STAT_C_CONNECTION;
	/* Now the port status changed to connected; hub_wq will
	 * pick the change up and try to reset the port to bring it to
	 * the enabled state--so this process returns up to the stack
	 * and it calls back into wusbhc_rh_port_reset().
	 */
error_unlock:
	mutex_unlock(&wusbhc->mutex);
	return;

}

/*
 * Disconnect a Wireless USB device from its fake port
 *
 * Marks the port as disconnected so that hub_wq can pick up the change
 * and drops our knowledge about the device.
 *
 * Assumes there is a device connected
 *
 * @port_index: zero based port number
 *
 * NOTE: @wusbhc->mutex is locked
 *
 * WARNING: From here it is not very safe to access anything hanging off
 *	    wusb_dev
 */
static void __wusbhc_dev_disconnect(struct wusbhc *wusbhc,
				    struct wusb_port *port)
{
	struct wusb_dev *wusb_dev = port->wusb_dev;

	port->status &= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE
			  | USB_PORT_STAT_SUSPEND | USB_PORT_STAT_RESET
			  | USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
	port->change |= USB_PORT_STAT_C_CONNECTION | USB_PORT_STAT_C_ENABLE;
	if (wusb_dev) {
		dev_dbg(wusbhc->dev, "disconnecting device from port %d\n", wusb_dev->port_idx);
		if (!list_empty(&wusb_dev->cack_node))
			list_del_init(&wusb_dev->cack_node);
		/* For the one in cack_add() */
		wusb_dev_put(wusb_dev);
	}
	port->wusb_dev = NULL;

	/* After a device disconnects, change the GTK (see [WUSB]
	 * section 6.2.11.2). */
	if (wusbhc->active)
		wusbhc_gtk_rekey(wusbhc);

	/* The Wireless USB part has forgotten about the device already; now
	 * hub_wq's timer will pick up the disconnection and remove the USB
	 * device from the system
	 */
}

/*
 * Refresh the list of keep alives to emit in the MMC
 *
 * We only publish the first four devices that have a coming timeout
 * condition. Then when we are done processing those, we go for the
 * next ones. We ignore the ones that have timed out already (they'll
 * be purged).
 *
 * This might cause the first devices to timeout the last devices in
 * the port array...FIXME: come up with a better algorithm?
 *
 * Note we can't do much about MMC's ops errors; we hope next refresh
 * will kind of handle it.
 *
 * NOTE: @wusbhc->mutex is locked
 */
static void __wusbhc_keep_alive(struct wusbhc *wusbhc)
{
	struct device *dev = wusbhc->dev;
	unsigned cnt;
	struct wusb_dev *wusb_dev;
	struct wusb_port *wusb_port;
	struct wuie_keep_alive *ie = &wusbhc->keep_alive_ie;
	unsigned keep_alives, old_keep_alives;

	old_keep_alives = ie->hdr.bLength - sizeof(ie->hdr);
	keep_alives = 0;
	for (cnt = 0;
	     keep_alives < WUIE_ELT_MAX && cnt < wusbhc->ports_max;
	     cnt++) {
		unsigned tt = msecs_to_jiffies(wusbhc->trust_timeout);

		wusb_port = wusb_port_by_idx(wusbhc, cnt);
		wusb_dev = wusb_port->wusb_dev;

		if (wusb_dev == NULL)
			continue;
		if (wusb_dev->usb_dev == NULL)
			continue;

		if (time_after(jiffies, wusb_dev->entry_ts + tt)) {
			dev_err(dev, "KEEPALIVE: device %u timed out\n",
				wusb_dev->addr);
			__wusbhc_dev_disconnect(wusbhc, wusb_port);
		} else if (time_after(jiffies, wusb_dev->entry_ts + tt/3)) {
			/* Approaching timeout cut off, need to refresh */
			ie->bDeviceAddress[keep_alives++] = wusb_dev->addr;
		}
	}
	if (keep_alives & 0x1)	/* pad to even number ([WUSB] section 7.5.9) */
		ie->bDeviceAddress[keep_alives++] = 0x7f;
	ie->hdr.bLength = sizeof(ie->hdr) +
		keep_alives*sizeof(ie->bDeviceAddress[0]);
	if (keep_alives > 0)
		wusbhc_mmcie_set(wusbhc, 10, 5, &ie->hdr);
	else if (old_keep_alives != 0)
		wusbhc_mmcie_rm(wusbhc, &ie->hdr);
}

/*
 * Do a run through all devices checking for timeouts
 */
static void wusbhc_keep_alive_run(struct work_struct *ws)
{
	struct delayed_work *dw = to_delayed_work(ws);
	struct wusbhc *wusbhc =	container_of(dw, struct wusbhc, keep_alive_timer);

	mutex_lock(&wusbhc->mutex);
	__wusbhc_keep_alive(wusbhc);
	mutex_unlock(&wusbhc->mutex);

	queue_delayed_work(wusbd, &wusbhc->keep_alive_timer,
			   msecs_to_jiffies(wusbhc->trust_timeout / 2));
}

/*
 * Find the wusb_dev from its device address.
 *
 * The device can be found directly from the address (see
 * wusb_cack_add() for where the device address is set to port_idx
 * +2), except when the address is zero.
 */
static struct wusb_dev *wusbhc_find_dev_by_addr(struct wusbhc *wusbhc, u8 addr)
{
	int p;

	if (addr == 0xff) /* unconnected */
		return NULL;

	if (addr > 0) {
		int port = (addr & ~0x80) - 2;
		if (port < 0 || port >= wusbhc->ports_max)
			return NULL;
		return wusb_port_by_idx(wusbhc, port)->wusb_dev;
	}

	/* Look for the device with address 0. */
	for (p = 0; p < wusbhc->ports_max; p++) {
		struct wusb_dev *wusb_dev = wusb_port_by_idx(wusbhc, p)->wusb_dev;
		if (wusb_dev && wusb_dev->addr == addr)
			return wusb_dev;
	}
	return NULL;
}

/*
 * Handle a DN_Alive notification (WUSB1.0[7.6.1])
 *
 * This just updates the device activity timestamp and then refreshes
 * the keep alive IE.
 *
 * @wusbhc shall be referenced and unlocked
 */
static void wusbhc_handle_dn_alive(struct wusbhc *wusbhc, u8 srcaddr)
{
	struct wusb_dev *wusb_dev;

	mutex_lock(&wusbhc->mutex);
	wusb_dev = wusbhc_find_dev_by_addr(wusbhc, srcaddr);
	if (wusb_dev == NULL) {
		dev_dbg(wusbhc->dev, "ignoring DN_Alive from unconnected device %02x\n",
			srcaddr);
	} else {
		wusb_dev->entry_ts = jiffies;
		__wusbhc_keep_alive(wusbhc);
	}
	mutex_unlock(&wusbhc->mutex);
}

/*
 * Handle a DN_Connect notification (WUSB1.0[7.6.1])
 *
 * @wusbhc
 * @pkt_hdr
 * @size:    Size of the buffer where the notification resides; if the
 *           notification data suggests there should be more data than
 *           available, an error will be signaled and the whole buffer
 *           consumed.
 *
 * @wusbhc->mutex shall be held
 */
static void wusbhc_handle_dn_connect(struct wusbhc *wusbhc,
				     struct wusb_dn_hdr *dn_hdr,
				     size_t size)
{
	struct device *dev = wusbhc->dev;
	struct wusb_dn_connect *dnc;
	char pr_cdid[WUSB_CKHDID_STRSIZE];
	static const char *beacon_behaviour[] = {
		"reserved",
		"self-beacon",
		"directed-beacon",
		"no-beacon"
	};

	if (size < sizeof(*dnc)) {
		dev_err(dev, "DN CONNECT: short notification (%zu < %zu)\n",
			size, sizeof(*dnc));
		return;
	}

	dnc = container_of(dn_hdr, struct wusb_dn_connect, hdr);
	ckhdid_printf(pr_cdid, sizeof(pr_cdid), &dnc->CDID);
	dev_info(dev, "DN CONNECT: device %s @ %x (%s) wants to %s\n",
		 pr_cdid,
		 wusb_dn_connect_prev_dev_addr(dnc),
		 beacon_behaviour[wusb_dn_connect_beacon_behavior(dnc)],
		 wusb_dn_connect_new_connection(dnc) ? "connect" : "reconnect");
	/* ACK the connect */
	wusbhc_devconnect_ack(wusbhc, dnc, pr_cdid);
}

/*
 * Handle a DN_Disconnect notification (WUSB1.0[7.6.1])
 *
 * Device is going down -- do the disconnect.
 *
 * @wusbhc shall be referenced and unlocked
 */
static void wusbhc_handle_dn_disconnect(struct wusbhc *wusbhc, u8 srcaddr)
{
	struct device *dev = wusbhc->dev;
	struct wusb_dev *wusb_dev;

	mutex_lock(&wusbhc->mutex);
	wusb_dev = wusbhc_find_dev_by_addr(wusbhc, srcaddr);
	if (wusb_dev == NULL) {
		dev_dbg(dev, "ignoring DN DISCONNECT from unconnected device %02x\n",
			srcaddr);
	} else {
		dev_info(dev, "DN DISCONNECT: device 0x%02x going down\n",
			wusb_dev->addr);
		__wusbhc_dev_disconnect(wusbhc, wusb_port_by_idx(wusbhc,
			wusb_dev->port_idx));
	}
	mutex_unlock(&wusbhc->mutex);
}

/*
 * Handle a Device Notification coming a host
 *
 * The Device Notification comes from a host (HWA, DWA or WHCI)
 * wrapped in a set of headers. Somebody else has peeled off those
 * headers for us and we just get one Device Notifications.
 *
 * Invalid DNs (e.g., too short) are discarded.
 *
 * @wusbhc shall be referenced
 *
 * FIXMES:
 *  - implement priorities as in WUSB1.0[Table 7-55]?
 */
void wusbhc_handle_dn(struct wusbhc *wusbhc, u8 srcaddr,
		      struct wusb_dn_hdr *dn_hdr, size_t size)
{
	struct device *dev = wusbhc->dev;

	if (size < sizeof(struct wusb_dn_hdr)) {
		dev_err(dev, "DN data shorter than DN header (%d < %d)\n",
			(int)size, (int)sizeof(struct wusb_dn_hdr));
		return;
	}
	switch (dn_hdr->bType) {
	case WUSB_DN_CONNECT:
		wusbhc_handle_dn_connect(wusbhc, dn_hdr, size);
		break;
	case WUSB_DN_ALIVE:
		wusbhc_handle_dn_alive(wusbhc, srcaddr);
		break;
	case WUSB_DN_DISCONNECT:
		wusbhc_handle_dn_disconnect(wusbhc, srcaddr);
		break;
	case WUSB_DN_MASAVAILCHANGED:
	case WUSB_DN_RWAKE:
	case WUSB_DN_SLEEP:
		/* FIXME: handle these DNs. */
		break;
	case WUSB_DN_EPRDY:
		/* The hardware handles these. */
		break;
	default:
		dev_warn(dev, "unknown DN %u (%d octets) from %u\n",
			 dn_hdr->bType, (int)size, srcaddr);
	}
}
EXPORT_SYMBOL_GPL(wusbhc_handle_dn);

/*
 * Disconnect a WUSB device from a the cluster
 *
 * @wusbhc
 * @port     Fake port where the device is (wusbhc index, not USB port number).
 *
 * In Wireless USB, a disconnect is basically telling the device he is
 * being disconnected and forgetting about him.
 *
 * We send the device a Device Disconnect IE (WUSB1.0[7.5.11]) for 100
 * ms and then keep going.
 *
 * We don't do much in case of error; we always pretend we disabled
 * the port and disconnected the device. If physically the request
 * didn't get there (many things can fail in the way there), the stack
 * will reject the device's communication attempts.
 *
 * @wusbhc should be refcounted and locked
 */
void __wusbhc_dev_disable(struct wusbhc *wusbhc, u8 port_idx)
{
	int result;
	struct device *dev = wusbhc->dev;
	struct wusb_dev *wusb_dev;
	struct wuie_disconnect *ie;

	wusb_dev = wusb_port_by_idx(wusbhc, port_idx)->wusb_dev;
	if (wusb_dev == NULL) {
		/* reset no device? ignore */
		dev_dbg(dev, "DISCONNECT: no device at port %u, ignoring\n",
			port_idx);
		return;
	}
	__wusbhc_dev_disconnect(wusbhc, wusb_port_by_idx(wusbhc, port_idx));

	ie = kzalloc(sizeof(*ie), GFP_KERNEL);
	if (ie == NULL)
		return;
	ie->hdr.bLength = sizeof(*ie);
	ie->hdr.bIEIdentifier = WUIE_ID_DEVICE_DISCONNECT;
	ie->bDeviceAddress = wusb_dev->addr;
	result = wusbhc_mmcie_set(wusbhc, 0, 0, &ie->hdr);
	if (result < 0)
		dev_err(dev, "DISCONNECT: can't set MMC: %d\n", result);
	else {
		/* At least 6 MMCs, assuming at least 1 MMC per zone. */
		msleep(7*4);
		wusbhc_mmcie_rm(wusbhc, &ie->hdr);
	}
	kfree(ie);
}

/*
 * Walk over the BOS descriptor, verify and grok it
 *
 * @usb_dev: referenced
 * @wusb_dev: referenced and unlocked
 *
 * The BOS descriptor is defined at WUSB1.0[7.4.1], and it defines a
 * "flexible" way to wrap all kinds of descriptors inside an standard
 * descriptor (wonder why they didn't use normal descriptors,
 * btw). Not like they lack code.
 *
 * At the end we go to look for the WUSB Device Capabilities
 * (WUSB1.0[7.4.1.1]) that is wrapped in a device capability descriptor
 * that is part of the BOS descriptor set. That tells us what does the
 * device support (dual role, beacon type, UWB PHY rates).
 */
static int wusb_dev_bos_grok(struct usb_device *usb_dev,
			     struct wusb_dev *wusb_dev,
			     struct usb_bos_descriptor *bos, size_t desc_size)
{
	ssize_t result;
	struct device *dev = &usb_dev->dev;
	void *itr, *top;

	/* Walk over BOS capabilities, verify them */
	itr = (void *)bos + sizeof(*bos);
	top = itr + desc_size - sizeof(*bos);
	while (itr < top) {
		struct usb_dev_cap_header *cap_hdr = itr;
		size_t cap_size;
		u8 cap_type;
		if (top - itr < sizeof(*cap_hdr)) {
			dev_err(dev, "Device BUG? premature end of BOS header "
				"data [offset 0x%02x]: only %zu bytes left\n",
				(int)(itr - (void *)bos), top - itr);
			result = -ENOSPC;
			goto error_bad_cap;
		}
		cap_size = cap_hdr->bLength;
		cap_type = cap_hdr->bDevCapabilityType;
		if (cap_size == 0)
			break;
		if (cap_size > top - itr) {
			dev_err(dev, "Device BUG? premature end of BOS data "
				"[offset 0x%02x cap %02x %zu bytes]: "
				"only %zu bytes left\n",
				(int)(itr - (void *)bos),
				cap_type, cap_size, top - itr);
			result = -EBADF;
			goto error_bad_cap;
		}
		switch (cap_type) {
		case USB_CAP_TYPE_WIRELESS_USB:
			if (cap_size != sizeof(*wusb_dev->wusb_cap_descr))
				dev_err(dev, "Device BUG? WUSB Capability "
					"descriptor is %zu bytes vs %zu "
					"needed\n", cap_size,
					sizeof(*wusb_dev->wusb_cap_descr));
			else
				wusb_dev->wusb_cap_descr = itr;
			break;
		default:
			dev_err(dev, "BUG? Unknown BOS capability 0x%02x "
				"(%zu bytes) at offset 0x%02x\n", cap_type,
				cap_size, (int)(itr - (void *)bos));
		}
		itr += cap_size;
	}
	result = 0;
error_bad_cap:
	return result;
}

/*
 * Add information from the BOS descriptors to the device
 *
 * @usb_dev: referenced
 * @wusb_dev: referenced and unlocked
 *
 * So what we do is we alloc a space for the BOS descriptor of 64
 * bytes; read the first four bytes which include the wTotalLength
 * field (WUSB1.0[T7-26]) and if it fits in those 64 bytes, read the
 * whole thing. If not we realloc to that size.
 *
 * Then we call the groking function, that will fill up
 * wusb_dev->wusb_cap_descr, which is what we'll need later on.
 */
static int wusb_dev_bos_add(struct usb_device *usb_dev,
			    struct wusb_dev *wusb_dev)
{
	ssize_t result;
	struct device *dev = &usb_dev->dev;
	struct usb_bos_descriptor *bos;
	size_t alloc_size = 32, desc_size = 4;

	bos = kmalloc(alloc_size, GFP_KERNEL);
	if (bos == NULL)
		return -ENOMEM;
	result = usb_get_descriptor(usb_dev, USB_DT_BOS, 0, bos, desc_size);
	if (result < 4) {
		dev_err(dev, "Can't get BOS descriptor or too short: %zd\n",
			result);
		goto error_get_descriptor;
	}
	desc_size = le16_to_cpu(bos->wTotalLength);
	if (desc_size >= alloc_size) {
		kfree(bos);
		alloc_size = desc_size;
		bos = kmalloc(alloc_size, GFP_KERNEL);
		if (bos == NULL)
			return -ENOMEM;
	}
	result = usb_get_descriptor(usb_dev, USB_DT_BOS, 0, bos, desc_size);
	if (result < 0 || result != desc_size) {
		dev_err(dev, "Can't get  BOS descriptor or too short (need "
			"%zu bytes): %zd\n", desc_size, result);
		goto error_get_descriptor;
	}
	if (result < sizeof(*bos)
	    || le16_to_cpu(bos->wTotalLength) != desc_size) {
		dev_err(dev, "Can't get  BOS descriptor or too short (need "
			"%zu bytes): %zd\n", desc_size, result);
		goto error_get_descriptor;
	}

	result = wusb_dev_bos_grok(usb_dev, wusb_dev, bos, result);
	if (result < 0)
		goto error_bad_bos;
	wusb_dev->bos = bos;
	return 0;

error_bad_bos:
error_get_descriptor:
	kfree(bos);
	wusb_dev->wusb_cap_descr = NULL;
	return result;
}

static void wusb_dev_bos_rm(struct wusb_dev *wusb_dev)
{
	kfree(wusb_dev->bos);
	wusb_dev->wusb_cap_descr = NULL;
};

/*
 * USB stack's device addition Notifier Callback
 *
 * Called from drivers/usb/core/hub.c when a new device is added; we
 * use this hook to perform certain WUSB specific setup work on the
 * new device. As well, it is the first time we can connect the
 * wusb_dev and the usb_dev. So we note it down in wusb_dev and take a
 * reference that we'll drop.
 *
 * First we need to determine if the device is a WUSB device (else we
 * ignore it). For that we use the speed setting (USB_SPEED_WIRELESS)
 * [FIXME: maybe we'd need something more definitive]. If so, we track
 * it's usb_busd and from there, the WUSB HC.
 *
 * Because all WUSB HCs are contained in a 'struct wusbhc', voila, we
 * get the wusbhc for the device.
 *
 * We have a reference on @usb_dev (as we are called at the end of its
 * enumeration).
 *
 * NOTE: @usb_dev locked
 */
static void wusb_dev_add_ncb(struct usb_device *usb_dev)
{
	int result = 0;
	struct wusb_dev *wusb_dev;
	struct wusbhc *wusbhc;
	struct device *dev = &usb_dev->dev;
	u8 port_idx;

	if (usb_dev->wusb == 0 || usb_dev->devnum == 1)
		return;		/* skip non wusb and wusb RHs */

	usb_set_device_state(usb_dev, USB_STATE_UNAUTHENTICATED);

	wusbhc = wusbhc_get_by_usb_dev(usb_dev);
	if (wusbhc == NULL)
		goto error_nodev;
	mutex_lock(&wusbhc->mutex);
	wusb_dev = __wusb_dev_get_by_usb_dev(wusbhc, usb_dev);
	port_idx = wusb_port_no_to_idx(usb_dev->portnum);
	mutex_unlock(&wusbhc->mutex);
	if (wusb_dev == NULL)
		goto error_nodev;
	wusb_dev->usb_dev = usb_get_dev(usb_dev);
	usb_dev->wusb_dev = wusb_dev_get(wusb_dev);
	result = wusb_dev_sec_add(wusbhc, usb_dev, wusb_dev);
	if (result < 0) {
		dev_err(dev, "Cannot enable security: %d\n", result);
		goto error_sec_add;
	}
	/* Now query the device for it's BOS and attach it to wusb_dev */
	result = wusb_dev_bos_add(usb_dev, wusb_dev);
	if (result < 0) {
		dev_err(dev, "Cannot get BOS descriptors: %d\n", result);
		goto error_bos_add;
	}
	result = wusb_dev_sysfs_add(wusbhc, usb_dev, wusb_dev);
	if (result < 0)
		goto error_add_sysfs;
out:
	wusb_dev_put(wusb_dev);
	wusbhc_put(wusbhc);
error_nodev:
	return;

	wusb_dev_sysfs_rm(wusb_dev);
error_add_sysfs:
	wusb_dev_bos_rm(wusb_dev);
error_bos_add:
	wusb_dev_sec_rm(wusb_dev);
error_sec_add:
	mutex_lock(&wusbhc->mutex);
	__wusbhc_dev_disconnect(wusbhc, wusb_port_by_idx(wusbhc, port_idx));
	mutex_unlock(&wusbhc->mutex);
	goto out;
}

/*
 * Undo all the steps done at connection by the notifier callback
 *
 * NOTE: @usb_dev locked
 */
static void wusb_dev_rm_ncb(struct usb_device *usb_dev)
{
	struct wusb_dev *wusb_dev = usb_dev->wusb_dev;

	if (usb_dev->wusb == 0 || usb_dev->devnum == 1)
		return;		/* skip non wusb and wusb RHs */

	wusb_dev_sysfs_rm(wusb_dev);
	wusb_dev_bos_rm(wusb_dev);
	wusb_dev_sec_rm(wusb_dev);
	wusb_dev->usb_dev = NULL;
	usb_dev->wusb_dev = NULL;
	wusb_dev_put(wusb_dev);
	usb_put_dev(usb_dev);
}

/*
 * Handle notifications from the USB stack (notifier call back)
 *
 * This is called when the USB stack does a
 * usb_{bus,device}_{add,remove}() so we can do WUSB specific
 * handling. It is called with [for the case of
 * USB_DEVICE_{ADD,REMOVE} with the usb_dev locked.
 */
int wusb_usb_ncb(struct notifier_block *nb, unsigned long val,
		 void *priv)
{
	int result = NOTIFY_OK;

	switch (val) {
	case USB_DEVICE_ADD:
		wusb_dev_add_ncb(priv);
		break;
	case USB_DEVICE_REMOVE:
		wusb_dev_rm_ncb(priv);
		break;
	case USB_BUS_ADD:
		/* ignore (for now) */
	case USB_BUS_REMOVE:
		break;
	default:
		WARN_ON(1);
		result = NOTIFY_BAD;
	}
	return result;
}

/*
 * Return a referenced wusb_dev given a @wusbhc and @usb_dev
 */
struct wusb_dev *__wusb_dev_get_by_usb_dev(struct wusbhc *wusbhc,
					   struct usb_device *usb_dev)
{
	struct wusb_dev *wusb_dev;
	u8 port_idx;

	port_idx = wusb_port_no_to_idx(usb_dev->portnum);
	BUG_ON(port_idx > wusbhc->ports_max);
	wusb_dev = wusb_port_by_idx(wusbhc, port_idx)->wusb_dev;
	if (wusb_dev != NULL)		/* ops, device is gone */
		wusb_dev_get(wusb_dev);
	return wusb_dev;
}
EXPORT_SYMBOL_GPL(__wusb_dev_get_by_usb_dev);

void wusb_dev_destroy(struct kref *_wusb_dev)
{
	struct wusb_dev *wusb_dev = container_of(_wusb_dev, struct wusb_dev, refcnt);

	list_del_init(&wusb_dev->cack_node);
	wusb_dev_free(wusb_dev);
}
EXPORT_SYMBOL_GPL(wusb_dev_destroy);

/*
 * Create all the device connect handling infrastructure
 *
 * This is basically the device info array, Connect Acknowledgement
 * (cack) lists, keep-alive timers (and delayed work thread).
 */
int wusbhc_devconnect_create(struct wusbhc *wusbhc)
{
	wusbhc->keep_alive_ie.hdr.bIEIdentifier = WUIE_ID_KEEP_ALIVE;
	wusbhc->keep_alive_ie.hdr.bLength = sizeof(wusbhc->keep_alive_ie.hdr);
	INIT_DELAYED_WORK(&wusbhc->keep_alive_timer, wusbhc_keep_alive_run);

	wusbhc->cack_ie.hdr.bIEIdentifier = WUIE_ID_CONNECTACK;
	wusbhc->cack_ie.hdr.bLength = sizeof(wusbhc->cack_ie.hdr);
	INIT_LIST_HEAD(&wusbhc->cack_list);

	return 0;
}

/*
 * Release all resources taken by the devconnect stuff
 */
void wusbhc_devconnect_destroy(struct wusbhc *wusbhc)
{
	/* no op */
}

/*
 * wusbhc_devconnect_start - start accepting device connections
 * @wusbhc: the WUSB HC
 *
 * Sets the Host Info IE to accept all new connections.
 *
 * FIXME: This also enables the keep alives but this is not necessary
 * until there are connected and authenticated devices.
 */
int wusbhc_devconnect_start(struct wusbhc *wusbhc)
{
	struct device *dev = wusbhc->dev;
	struct wuie_host_info *hi;
	int result;

	hi = kzalloc(sizeof(*hi), GFP_KERNEL);
	if (hi == NULL)
		return -ENOMEM;

	hi->hdr.bLength       = sizeof(*hi);
	hi->hdr.bIEIdentifier = WUIE_ID_HOST_INFO;
	hi->attributes        = cpu_to_le16((wusbhc->rsv->stream << 3) | WUIE_HI_CAP_ALL);
	hi->CHID              = wusbhc->chid;
	result = wusbhc_mmcie_set(wusbhc, 0, 0, &hi->hdr);
	if (result < 0) {
		dev_err(dev, "Cannot add Host Info MMCIE: %d\n", result);
		goto error_mmcie_set;
	}
	wusbhc->wuie_host_info = hi;

	queue_delayed_work(wusbd, &wusbhc->keep_alive_timer,
			   msecs_to_jiffies(wusbhc->trust_timeout / 2));

	return 0;

error_mmcie_set:
	kfree(hi);
	return result;
}

/*
 * wusbhc_devconnect_stop - stop managing connected devices
 * @wusbhc: the WUSB HC
 *
 * Disconnects any devices still connected, stops the keep alives and
 * removes the Host Info IE.
 */
void wusbhc_devconnect_stop(struct wusbhc *wusbhc)
{
	int i;

	mutex_lock(&wusbhc->mutex);
	for (i = 0; i < wusbhc->ports_max; i++) {
		if (wusbhc->port[i].wusb_dev)
			__wusbhc_dev_disconnect(wusbhc, &wusbhc->port[i]);
	}
	mutex_unlock(&wusbhc->mutex);

	cancel_delayed_work_sync(&wusbhc->keep_alive_timer);
	wusbhc_mmcie_rm(wusbhc, &wusbhc->wuie_host_info->hdr);
	kfree(wusbhc->wuie_host_info);
	wusbhc->wuie_host_info = NULL;
}

/*
 * wusb_set_dev_addr - set the WUSB device address used by the host
 * @wusbhc: the WUSB HC the device is connect to
 * @wusb_dev: the WUSB device
 * @addr: new device address
 */
int wusb_set_dev_addr(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev, u8 addr)
{
	int result;

	wusb_dev->addr = addr;
	result = wusbhc->dev_info_set(wusbhc, wusb_dev);
	if (result < 0)
		dev_err(wusbhc->dev, "device %d: failed to set device "
			"address\n", wusb_dev->port_idx);
	else
		dev_info(wusbhc->dev, "device %d: %s addr %u\n",
			 wusb_dev->port_idx,
			 (addr & WUSB_DEV_ADDR_UNAUTH) ? "unauth" : "auth",
			 wusb_dev->addr);

	return result;
}
                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright (C) 2012 Alexander Block.  All rights reserved.
 * Copyright (C) 2012 STRATO.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License v2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 021110-1307, USA.
 */

#include "ctree.h"

#define BTRFS_SEND_STREAM_MAGIC "btrfs-stream"
#define BTRFS_SEND_STREAM_VERSION 1

#define BTRFS_SEND_BUF_SIZE (1024 * 64)
#define BTRFS_SEND_READ_SIZE (1024 * 48)

enum btrfs_tlv_type {
	BTRFS_TLV_U8,
	BTRFS_TLV_U16,
	BTRFS_TLV_U32,
	BTRFS_TLV_U64,
	BTRFS_TLV_BINARY,
	BTRFS_TLV_STRING,
	BTRFS_TLV_UUID,
	BTRFS_TLV_TIMESPEC,
};

struct btrfs_stream_header {
	char magic[sizeof(BTRFS_SEND_STREAM_MAGIC)];
	__le32 version;
} __attribute__ ((__packed__));

struct btrfs_cmd_header {
	/* len excluding the header */
	__le32 len;
	__le16 cmd;
	/* crc including the header with zero crc field */
	__le32 crc;
} __attribute__ ((__packed__));

struct btrfs_tlv_header {
	__le16 tlv_type;
	/* len excluding the header */
	__le16 tlv_len;
} __attribute__ ((__packed__));

/* commands */
enum btrfs_send_cmd {
	BTRFS_SEND_C_UNSPEC,

	BTRFS_SEND_C_SUBVOL,
	BTRFS_SEND_C_SNAPSHOT,

	BTRFS_SEND_C_MKFILE,
	BTRFS_SEND_C_MKDIR,
	BTRFS_SEND_C_MKNOD,
	BTRFS_SEND_C_MKFIFO,
	BTRFS_SEND_C_MKSOCK,
	BTRFS_SEND_C_SYMLINK,

	BTRFS_SEND_C_RENAME,
	BTRFS_SEND_C_LINK,
	BTRFS_SEND_C_UNLINK,
	BTRFS_SEND_C_RMDIR,

	BTRFS_SEND_C_SET_XATTR,
	BTRFS_SEND_C_REMOVE_XATTR,

	BTRFS_SEND_C_WRITE,
	BTRFS_SEND_C_CLONE,

	BTRFS_SEND_C_TRUNCATE,
	BTRFS_SEND_C_CHMOD,
	BTRFS_SEND_C_CHOWN,
	BTRFS_SEND_C_UTIMES,

	BTRFS_SEND_C_END,
	BTRFS_SEND_C_UPDATE_EXTENT,
	__BTRFS_SEND_C_MAX,
};
#define BTRFS_SEND_C_MAX (__BTRFS_SEND_C_MAX - 1)

/* attributes in send stream */
enum {
	BTRFS_SEND_A_UNSPEC,

	BTRFS_SEND_A_UUID,
	BTRFS_SEND_A_CTRANSID,

	BTRFS_SEND_A_INO,
	BTRFS_SEND_A_SIZE,
	BTRFS_SEND_A_MODE,
	BTRFS_SEND_A_UID,
	BTRFS_SEND_A_GID,
	BTRFS_SEND_A_RDEV,
	BTRFS_SEND_A_CTIME,
	BTRFS_SEND_A_MTIME,
	BTRFS_SEND_A_ATIME,
	BTRFS_SEND_A_OTIME,

	BTRFS_SEND_A_XATTR_NAME,
	BTRFS_SEND_A_XATTR_DATA,

	BTRFS_SEND_A_PATH,
	BTRFS_SEND_A_PATH_TO,
	BTRFS_SEND_A_PATH_LINK,

	BTRFS_SEND_A_FILE_OFFSET,
	BTRFS_SEND_A_DATA,

	BTRFS_SEND_A_CLONE_UUID,
	BTRFS_SEND_A_CLONE_CTRANSID,
	BTRFS_SEND_A_CLONE_PATH,
	BTRFS_SEND_A_CLONE_OFFSET,
	BTRFS_SEND_A_CLONE_LEN,

	__BTRFS_SEND_A_MAX,
};
#define BTRFS_SEND_A_MAX (__BTRFS_SEND_A_MAX - 1)

#ifdef __KERNEL__
long btrfs_ioctl_send(struct file *mnt_file, void __user *arg);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is part of UBIFS.
 *
 * Copyright (C) 2006-2008 Nokia Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * Authors: Adrian Hunter
 *          Artem Bityutskiy ( )
 */

/*
 * This file implements garbage collection. The procedure for garbage collection
 * is different depending on whether a LEB as an index LEB (contains index
 * nodes) or not. For non-index LEBs, garbage collection finds a LEB which
 * contains a lot of dirty space (obsolete nodes), and copies the non-obsolete
 * nodes to the journal, at which point the garbage-collected LEB is free to be
 * reused. For index LEBs, garbage collection marks the non-obsolete index nodes
 * dirty in the TNC, and after the next commit, the garbage-collected LEB is
 * to be reused. Garbage collection will cause the number of dirty index nodes
 * to grow, however sufficient space is reserved for the index to ensure the
 * commit will never run out of space.
 *
 * Notes about dead watermark. At current UBIFS implementation we assume that
 * LEBs which have less than @c->dead_wm bytes of free + dirty space are full
 * and not worth garbage-collecting. The dead watermark is one min. I/O unit
 * size, or min. UBIFS node size, depending on what is greater. Indeed, UBIFS
 * Garbage Collector has to synchronize the GC head's write buffer before
 * returning, so this is about wasting one min. I/O unit. However, UBIFS GC can
 * actually reclaim even very small pieces of dirty space by garbage collecting
 * enough dirty LEBs, but we do not bother doing this at this implementation.
 *
 * Notes about dark watermark. The results of GC work depends on how big are
 * the UBIFS nodes GC deals with. Large nodes make GC waste more space. Indeed,
 * if GC move data from LEB A to LEB B and nodes in LEB A are large, GC would
 * have to waste large pieces of free space at the end of LEB B, because nodes
 * from LEB A would not fit. And the worst situation is when all nodes are of
 * maximum size. So dark watermark is the amount of free + dirty space in LEB
 * which are guaranteed to be reclaimable. If LEB has less space, the GC might
 * be unable to reclaim it. So, LEBs with free + dirty greater than dark
 * watermark are "good" LEBs from GC's point of few. The other LEBs are not so
 * good, and GC takes extra care when moving them.
 */

#include <linux/slab.h>
#include <linux/pagemap.h>
#include <linux/list_sort.h>
#include "ubifs.h"

/*
 * GC may need to move more than one LEB to make progress. The below constants
 * define "soft" and "hard" limits on the number of LEBs the garbage collector
 * may move.
 */
#define SOFT_LEBS_LIMIT 4
#define HARD_LEBS_LIMIT 32

/**
 * switch_gc_head - switch the garbage collection journal head.
 * @c: UBIFS file-system description object
 * @buf: buffer to write
 * @len: length of the buffer to write
 * @lnum: LEB number written is returned here
 * @offs: offset written is returned here
 *
 * This function switch the GC head to the next LEB which is reserved in
 * @c->gc_lnum. Returns %0 in case of success, %-EAGAIN if commit is required,
 * and other negative error code in case of failures.
 */
static int switch_gc_head(struct ubifs_info *c)
{
	int err, gc_lnum = c->gc_lnum;
	struct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;

	ubifs_assert(gc_lnum != -1);
	dbg_gc("switch GC head from LEB %d:%d to LEB %d (waste %d bytes)",
	       wbuf->lnum, wbuf->offs + wbuf->used, gc_lnum,
	       c->leb_size - wbuf->offs - wbuf->used);

	err = ubifs_wbuf_sync_nolock(wbuf);
	if (err)
		return err;

	/*
	 * The GC write-buffer was synchronized, we may safely unmap
	 * 'c->gc_lnum'.
	 */
	err = ubifs_leb_unmap(c, gc_lnum);
	if (err)
		return err;

	err = ubifs_wbuf_sync_nolock(wbuf);
	if (err)
		return err;

	err = ubifs_add_bud_to_log(c, GCHD, gc_lnum, 0);
	if (err)
		return err;

	c->gc_lnum = -1;
	err = ubifs_wbuf_seek_nolock(wbuf, gc_lnum, 0);
	return err;
}

/**
 * data_nodes_cmp - compare 2 data nodes.
 * @priv: UBIFS file-system description object
 * @a: first data node
 * @a: second data node
 *
 * This function compares data nodes @a and @b. Returns %1 if @a has greater
 * inode or block number, and %-1 otherwise.
 */
static int data_nodes_cmp(void *priv, struct list_head *a, struct list_head *b)
{
	ino_t inuma, inumb;
	struct ubifs_info *c = priv;
	struct ubifs_scan_node *sa, *sb;

	cond_resched();
	if (a == b)
		return 0;

	sa = list_entry(a, struct ubifs_scan_node, list);
	sb = list_entry(b, struct ubifs_scan_node, list);

	ubifs_assert(key_type(c, &sa->key) == UBIFS_DATA_KEY);
	ubifs_assert(key_type(c, &sb->key) == UBIFS_DATA_KEY);
	ubifs_assert(sa->type == UBIFS_DATA_NODE);
	ubifs_assert(sb->type == UBIFS_DATA_NODE);

	inuma = key_inum(c, &sa->key);
	inumb = key_inum(c, &sb->key);

	if (inuma == inumb) {
		unsigned int blka = key_block(c, &sa->key);
		unsigned int blkb = key_block(c, &sb->key);

		if (blka <= blkb)
			return -1;
	} else if (inuma <= inumb)
		return -1;

	return 1;
}

/*
 * nondata_nodes_cmp - compare 2 non-data nodes.
 * @priv: UBIFS file-system description object
 * @a: first node
 * @a: second node
 *
 * This function compares nodes @a and @b. It makes sure that inode nodes go
 * first and sorted by length in descending order. Directory entry nodes go
 * after inode nodes and are sorted in ascending hash valuer order.
 */
static int nondata_nodes_cmp(void *priv, struct list_head *a,
			     struct list_head *b)
{
	ino_t inuma, inumb;
	struct ubifs_info *c = priv;
	struct ubifs_scan_node *sa, *sb;

	cond_resched();
	if (a == b)
		return 0;

	sa = list_entry(a, struct ubifs_scan_node, list);
	sb = list_entry(b, struct ubifs_scan_node, list);

	ubifs_assert(key_type(c, &sa->key) != UBIFS_DATA_KEY &&
		     key_type(c, &sb->key) != UBIFS_DATA_KEY);
	ubifs_assert(sa->type != UBIFS_DATA_NODE &&
		     sb->type != UBIFS_DATA_NODE);

	/* Inodes go before directory entries */
	if (sa->type == UBIFS_INO_NODE) {
		if (sb->type == UBIFS_INO_NODE)
			return sb->len - sa->len;
		return -1;
	}
	if (sb->type == UBIFS_INO_NODE)
		return 1;

	ubifs_assert(key_type(c, &sa->key) == UBIFS_DENT_KEY ||
		     key_type(c, &sa->key) == UBIFS_XENT_KEY);
	ubifs_assert(key_type(c, &sb->key) == UBIFS_DENT_KEY ||
		     key_type(c, &sb->key) == UBIFS_XENT_KEY);
	ubifs_assert(sa->type == UBIFS_DENT_NODE ||
		     sa->type == UBIFS_XENT_NODE);
	ubifs_assert(sb->type == UBIFS_DENT_NODE ||
		     sb->type == UBIFS_XENT_NODE);

	inuma = key_inum(c, &sa->key);
	inumb = key_inum(c, &sb->key);

	if (inuma == inumb) {
		uint32_t hasha = key_hash(c, &sa->key);
		uint32_t hashb = key_hash(c, &sb->key);

		if (hasha <= hashb)
			return -1;
	} else if (inuma <= inumb)
		return -1;

	return 1;
}

/**
 * sort_nodes - sort nodes for GC.
 * @c: UBIFS file-system description object
 * @sleb: describes nodes to sort and contains the result on exit
 * @nondata: contains non-data nodes on exit
 * @min: minimum node size is returned here
 *
 * This function sorts the list of inodes to garbage collect. First of all, it
 * kills obsolete nodes and separates data and non-data nodes to the
 * @sleb->nodes and @nondata lists correspondingly.
 *
 * Data nodes are then sorted in block number order - this is important for
 * bulk-read; data nodes with lower inode number go before data nodes with
 * higher inode number, and data nodes with lower block number go before data
 * nodes with higher block number;
 *
 * Non-data nodes are sorted as follows.
 *   o First go inode nodes - they are sorted in descending length order.
 *   o Then go directory entry nodes - they are sorted in hash order, which
 *     should supposedly optimize 'readdir()'. Direntry nodes with lower parent
 *     inode number go before direntry nodes with higher parent inode number,
 *     and direntry nodes with lower name hash values go before direntry nodes
 *     with higher name hash values.
 *
 * This function returns zero in case of success and a negative error code in
 * case of failure.
 */
static int sort_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb,
		      struct list_head *nondata, int *min)
{
	int err;
	struct ubifs_scan_node *snod, *tmp;

	*min = INT_MAX;

	/* Separate data nodes and non-data nodes */
	list_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {
		ubifs_assert(snod->type == UBIFS_INO_NODE  ||
			     snod->type == UBIFS_DATA_NODE ||
			     snod->type == UBIFS_DENT_NODE ||
			     snod->type == UBIFS_XENT_NODE ||
			     snod->type == UBIFS_TRUN_NODE);

		if (snod->type != UBIFS_INO_NODE  &&
		    snod->type != UBIFS_DATA_NODE &&
		    snod->type != UBIFS_DENT_NODE &&
		    snod->type != UBIFS_XENT_NODE) {
			/* Probably truncation node, zap it */
			list_del(&snod->list);
			kfree(snod);
			continue;
		}

		ubifs_assert(key_type(c, &snod->key) == UBIFS_DATA_KEY ||
			     key_type(c, &snod->key) == UBIFS_INO_KEY  ||
			     key_type(c, &snod->key) == UBIFS_DENT_KEY ||
			     key_type(c, &snod->key) == UBIFS_XENT_KEY);

		err = ubifs_tnc_has_node(c, &snod->key, 0, sleb->lnum,
					 snod->offs, 0);
		if (err < 0)
			return err;

		if (!err) {
			/* The node is obsolete, remove it from the list */
			list_del(&snod->list);
			kfree(snod);
			continue;
		}

		if (snod->len < *min)
			*min = snod->len;

		if (key_type(c, &snod->key) != UBIFS_DATA_KEY)
			list_move_tail(&snod->list, nondata);
	}

	/* Sort data and non-data nodes */
	list_sort(c, &sleb->nodes, &data_nodes_cmp);
	list_sort(c, nondata, &nondata_nodes_cmp);

	err = dbg_check_data_nodes_order(c, &sleb->nodes);
	if (err)
		return err;
	err = dbg_check_nondata_nodes_order(c, nondata);
	if (err)
		return err;
	return 0;
}

/**
 * move_node - move a node.
 * @c: UBIFS file-system description object
 * @sleb: describes the LEB to move nodes from
 * @snod: the mode to move
 * @wbuf: write-buffer to move node to
 *
 * This function moves node @snod to @wbuf, changes TNC correspondingly, and
 * destroys @snod. Returns zero in case of success and a negative error code in
 * case of failure.
 */
static int move_node(struct ubifs_info *c, struct ubifs_scan_leb *sleb,
		     struct ubifs_scan_node *snod, struct ubifs_wbuf *wbuf)
{
	int err, new_lnum = wbuf->lnum, new_offs = wbuf->offs + wbuf->used;

	cond_resched();
	err = ubifs_wbuf_write_nolock(wbuf, snod->node, snod->len);
	if (err)
		return err;

	err = ubifs_tnc_replace(c, &snod->key, sleb->lnum,
				snod->offs, new_lnum, new_offs,
				snod->len);
	list_del(&snod->list);
	kfree(snod);
	return err;
}

/**
 * move_nodes - move nodes.
 * @c: UBIFS file-system description object
 * @sleb: describes the LEB to move nodes from
 *
 * This function moves valid nodes from data LEB described by @sleb to the GC
 * journal head. This function returns zero in case of success, %-EAGAIN if
 * commit is required, and other negative error codes in case of other
 * failures.
 */
static int move_nodes(struct ubifs_info *c, struct ubifs_scan_leb *sleb)
{
	int err, min;
	LIST_HEAD(nondata);
	struct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;

	if (wbuf->lnum == -1) {
		/*
		 * The GC journal head is not set, because it is the first GC
		 * invocation since mount.
		 */
		err = switch_gc_head(c);
		if (err)
			return err;
	}

	err = sort_nodes(c, sleb, &nondata, &min);
	if (err)
		goto out;

	/* Write nodes to their new location. Use the first-fit strategy */
	while (1) {
		int avail;
		struct ubifs_scan_node *snod, *tmp;

		/* Move data nodes */
		list_for_each_entry_safe(snod, tmp, &sleb->nodes, list) {
			avail = c->leb_size - wbuf->offs - wbuf->used;
			if  (snod->len > avail)
				/*
				 * Do not skip data nodes in order to optimize
				 * bulk-read.
				 */
				break;

			err = move_node(c, sleb, snod, wbuf);
			if (err)
				goto out;
		}

		/* Move non-data nodes */
		list_for_each_entry_safe(snod, tmp, &nondata, list) {
			avail = c->leb_size - wbuf->offs - wbuf->used;
			if (avail < min)
				break;

			if  (snod->len > avail) {
				/*
				 * Keep going only if this is an inode with
				 * some data. Otherwise stop and switch the GC
				 * head. IOW, we assume that data-less inode
				 * nodes and direntry nodes are roughly of the
				 * same size.
				 */
				if (key_type(c, &snod->key) == UBIFS_DENT_KEY ||
				    snod->len == UBIFS_INO_NODE_SZ)
					break;
				continue;
			}

			err = move_node(c, sleb, snod, wbuf);
			if (err)
				goto out;
		}

		if (list_empty(&sleb->nodes) && list_empty(&nondata))
			break;

		/*
		 * Waste the rest of the space in the LEB and switch to the
		 * next LEB.
		 */
		err = switch_gc_head(c);
		if (err)
			goto out;
	}

	return 0;

out:
	list_splice_tail(&nondata, &sleb->nodes);
	return err;
}

/**
 * gc_sync_wbufs - sync write-buffers for GC.
 * @c: UBIFS file-system description object
 *
 * We must guarantee that obsoleting nodes are on flash. Unfortunately they may
 * be in a write-buffer instead. That is, a node could be written to a
 * write-buffer, obsoleting another node in a LEB that is GC'd. If that LEB is
 * erased before the write-buffer is sync'd and then there is an unclean
 * unmount, then an existing node is lost. To avoid this, we sync all
 * write-buffers.
 *
 * This function returns %0 on success or a negative error code on failure.
 */
static int gc_sync_wbufs(struct ubifs_info *c)
{
	int err, i;

	for (i = 0; i < c->jhead_cnt; i++) {
		if (i == GCHD)
			continue;
		err = ubifs_wbuf_sync(&c->jheads[i].wbuf);
		if (err)
			return err;
	}
	return 0;
}

/**
 * ubifs_garbage_collect_leb - garbage-collect a logical eraseblock.
 * @c: UBIFS file-system description object
 * @lp: describes the LEB to garbage collect
 *
 * This function garbage-collects an LEB and returns one of the @LEB_FREED,
 * @LEB_RETAINED, etc positive codes in case of success, %-EAGAIN if commit is
 * required, and other negative error codes in case of failures.
 */
int ubifs_garbage_collect_leb(struct ubifs_info *c, struct ubifs_lprops *lp)
{
	struct ubifs_scan_leb *sleb;
	struct ubifs_scan_node *snod;
	struct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;
	int err = 0, lnum = lp->lnum;

	ubifs_assert(c->gc_lnum != -1 || wbuf->offs + wbuf->used == 0 ||
		     c->need_recovery);
	ubifs_assert(c->gc_lnum != lnum);
	ubifs_assert(wbuf->lnum != lnum);

	if (lp->free + lp->dirty == c->leb_size) {
		/* Special case - a free LEB  */
		dbg_gc("LEB %d is free, return it", lp->lnum);
		ubifs_assert(!(lp->flags & LPROPS_INDEX));

		if (lp->free != c->leb_size) {
			/*
			 * Write buffers must be sync'd before unmapping
			 * freeable LEBs, because one of them may contain data
			 * which obsoletes something in 'lp->pnum'.
			 */
			err = gc_sync_wbufs(c);
			if (err)
				return err;
			err = ubifs_change_one_lp(c, lp->lnum, c->leb_size,
						  0, 0, 0, 0);
			if (err)
				return err;
		}
		err = ubifs_leb_unmap(c, lp->lnum);
		if (err)
			return err;

		if (c->gc_lnum == -1) {
			c->gc_lnum = lnum;
			return LEB_RETAINED;
		}

		return LEB_FREED;
	}

	/*
	 * We scan the entire LEB even though we only really need to scan up to
	 * (c->leb_size - lp->free).
	 */
#ifdef CONFIG_UBIFS_SHARE_BUFFER
	if (mutex_trylock(&ubifs_sbuf_mutex) == 0) {
		atomic_long_inc(&ubifs_sbuf_lock_count);
		ubifs_err("trylock fail count %ld\n", atomic_long_read(&ubifs_sbuf_lock_count));
		mutex_lock(&ubifs_sbuf_mutex);
		ubifs_err("locked count %ld\n", atomic_long_read(&ubifs_sbuf_lock_count));
	}
#endif
	sleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);
	if (IS_ERR(sleb)) {
#ifdef CONFIG_UBIFS_SHARE_BUFFER
		mutex_unlock(&ubifs_sbuf_mutex);
#endif
		return PTR_ERR(sleb);
	}

	ubifs_assert(!list_empty(&sleb->nodes));
	snod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);

	if (snod->type == UBIFS_IDX_NODE) {
		struct ubifs_gced_idx_leb *idx_gc;

		dbg_gc("indexing LEB %d (free %d, dirty %d)",
		       lnum, lp->free, lp->dirty);
		list_for_each_entry(snod, &sleb->nodes, list) {
			struct ubifs_idx_node *idx = snod->node;
			int level = le16_to_cpu(idx->level);

			ubifs_assert(snod->type == UBIFS_IDX_NODE);
			key_read(c, ubifs_idx_key(c, idx), &snod->key);
			err = ubifs_dirty_idx_node(c, &snod->key, level, lnum,
						   snod->offs);
			if (err)
				goto out;
		}

		idx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);
		if (!idx_gc) {
			err = -ENOMEM;
			goto out;
		}

		idx_gc->lnum = lnum;
		idx_gc->unmap = 0;
		list_add(&idx_gc->list, &c->idx_gc);

		/*
		 * Don't release the LEB until after the next commit, because
		 * it may contain data which is needed for recovery. So
		 * although we freed this LEB, it will become usable only after
		 * the commit.
		 */
		err = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0,
					  LPROPS_INDEX, 1);
		if (err)
			goto out;
		err = LEB_FREED_IDX;
	} else {
		dbg_gc("data LEB %d (free %d, dirty %d)",
		       lnum, lp->free, lp->dirty);

		err = move_nodes(c, sleb);
		if (err)
			goto out_inc_seq;

		err = gc_sync_wbufs(c);
		if (err)
			goto out_inc_seq;

		err = ubifs_change_one_lp(c, lnum, c->leb_size, 0, 0, 0, 0);
		if (err)
			goto out_inc_seq;

		/* Allow for races with TNC */
		c->gced_lnum = lnum;
		smp_wmb();
		c->gc_seq += 1;
		smp_wmb();

		if (c->gc_lnum == -1) {
			c->gc_lnum = lnum;
			err = LEB_RETAINED;
		} else {
			err = ubifs_wbuf_sync_nolock(wbuf);
			if (err)
				goto out;

			err = ubifs_leb_unmap(c, lnum);
			if (err)
				goto out;

			err = LEB_FREED;
		}
	}

out:
	ubifs_scan_destroy(sleb);
#ifdef CONFIG_UBIFS_SHARE_BUFFER
	mutex_unlock(&ubifs_sbuf_mutex);
#endif
	return err;

out_inc_seq:
	/* We may have moved at least some nodes so allow for races with TNC */
	c->gced_lnum = lnum;
	smp_wmb();
	c->gc_seq += 1;
	smp_wmb();
	goto out;
}

/**
 * ubifs_garbage_collect - UBIFS garbage collector.
 * @c: UBIFS file-system description object
 * @anyway: do GC even if there are free LEBs
 *
 * This function does out-of-place garbage collection. The return codes are:
 *   o positive LEB number if the LEB has been freed and may be used;
 *   o %-EAGAIN if the caller has to run commit;
 *   o %-ENOSPC if GC failed to make any progress;
 *   o other negative error codes in case of other errors.
 *
 * Garbage collector writes data to the journal when GC'ing data LEBs, and just
 * marking indexing nodes dirty when GC'ing indexing LEBs. Thus, at some point
 * commit may be required. But commit cannot be run from inside GC, because the
 * caller might be holding the commit lock, so %-EAGAIN is returned instead;
 * And this error code means that the caller has to run commit, and re-run GC
 * if there is still no free space.
 *
 * There are many reasons why this function may return %-EAGAIN:
 * o the log is full and there is no space to write an LEB reference for
 *   @c->gc_lnum;
 * o the journal is too large and exceeds size limitations;
 * o GC moved indexing LEBs, but they can be used only after the commit;
 * o the shrinker fails to find clean znodes to free and requests the commit;
 * o etc.
 *
 * Note, if the file-system is close to be full, this function may return
 * %-EAGAIN infinitely, so the caller has to limit amount of re-invocations of
 * the function. E.g., this happens if the limits on the journal size are too
 * tough and GC writes too much to the journal before an LEB is freed. This
 * might also mean that the journal is too large, and the TNC becomes to big,
 * so that the shrinker is constantly called, finds not clean znodes to free,
 * and requests commit. Well, this may also happen if the journal is all right,
 * but another kernel process consumes too much memory. Anyway, infinite
 * %-EAGAIN may happen, but in some extreme/misconfiguration cases.
 */
int ubifs_garbage_collect(struct ubifs_info *c, int anyway)
{
	int i, err, ret, min_space = c->dead_wm;
	struct ubifs_lprops lp;
	struct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;

	ubifs_assert_cmt_locked(c);
	ubifs_assert(!c->ro_media && !c->ro_mount);

	if (ubifs_gc_should_commit(c))
		return -EAGAIN;

	mutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);

	if (c->ro_error) {
		ret = -EROFS;
		goto out_unlock;
	}

	/* We expect the write-buffer to be empty on entry */
	ubifs_assert(!wbuf->used);

	for (i = 0; ; i++) {
		int space_before, space_after;

		cond_resched();

		/* Give the commit an opportunity to run */
		if (ubifs_gc_should_commit(c)) {
			ret = -EAGAIN;
			break;
		}

		if (i > SOFT_LEBS_LIMIT && !list_empty(&c->idx_gc)) {
			/*
			 * We've done enough iterations. Indexing LEBs were
			 * moved and will be available after the commit.
			 */
			dbg_gc("soft limit, some index LEBs GC'ed, -EAGAIN");
			ubifs_commit_required(c);
			ret = -EAGAIN;
			break;
		}

		if (i > HARD_LEBS_LIMIT) {
			/*
			 * We've moved too many LEBs and have not made
			 * progress, give up.
			 */
			dbg_gc("hard limit, -ENOSPC");
			ret = -ENOSPC;
			break;
		}

		/*
		 * Empty and freeable LEBs can turn up while we waited for
		 * the wbuf lock, or while we have been running GC. In that
		 * case, we should just return one of those instead of
		 * continuing to GC dirty LEBs. Hence we request
		 * 'ubifs_find_dirty_leb()' to return an empty LEB if it can.
		 */
		ret = ubifs_find_dirty_leb(c, &lp, min_space, anyway ? 0 : 1);
		if (ret) {
			if (ret == -ENOSPC)
				dbg_gc("no more dirty LEBs");
			break;
		}

		dbg_gc("found LEB %d: free %d, dirty %d, sum %d (min. space %d)",
		       lp.lnum, lp.free, lp.dirty, lp.free + lp.dirty,
		       min_space);

		space_before = c->leb_size - wbuf->offs - wbuf->used;
		if (wbuf->lnum == -1)
			space_before = 0;

		ret = ubifs_garbage_collect_leb(c, &lp);
		if (ret < 0) {
			if (ret == -EAGAIN) {
				/*
				 * This is not error, so we have to return the
				 * LEB to lprops. But if 'ubifs_return_leb()'
				 * fails, its failure code is propagated to the
				 * caller instead of the original '-EAGAIN'.
				 */
				err = ubifs_return_leb(c, lp.lnum);
				if (err)
					ret = err;
				break;
			}
			goto out;
		}

		if (ret == LEB_FREED) {
			/* An LEB has been freed and is ready for use */
			dbg_gc("LEB %d freed, return", lp.lnum);
			ret = lp.lnum;
			break;
		}

		if (ret == LEB_FREED_IDX) {
			/*
			 * This was an indexing LEB and it cannot be
			 * immediately used. And instead of requesting the
			 * commit straight away, we try to garbage collect some
			 * more.
			 */
			dbg_gc("indexing LEB %d freed, continue", lp.lnum);
			continue;
		}

		ubifs_assert(ret == LEB_RETAINED);
		space_after = c->leb_size - wbuf->offs - wbuf->used;
		dbg_gc("LEB %d retained, freed %d bytes", lp.lnum,
		       space_after - space_before);

		if (space_after > space_before) {
			/* GC makes progress, keep working */
			min_space >>= 1;
			if (min_space < c->dead_wm)
				min_space = c->dead_wm;
			continue;
		}

		dbg_gc("did not make progress");

		/*
		 * GC moved an LEB bud have not done any progress. This means
		 * that the previous GC head LEB contained too few free space
		 * and the LEB which was GC'ed contained only large nodes which
		 * did not fit that space.
		 *
		 * We can do 2 things:
		 * 1. pick another LEB in a hope it'll contain a small node
		 *    which will fit the space we have at the end of current GC
		 *    head LEB, but there is no guarantee, so we try this out
		 *    unless we have already been working for too long;
		 * 2. request an LEB with more dirty space, which will force
		 *    'ubifs_find_dirty_leb()' to start scanning the lprops
		 *    table, instead of just picking one from the heap
		 *    (previously it already picked the dirtiest LEB).
		 */
		if (i < SOFT_LEBS_LIMIT) {
			dbg_gc("try again");
			continue;
		}

		min_space <<= 1;
		if (min_space > c->dark_wm)
			min_space = c->dark_wm;
		dbg_gc("set min. space to %d", min_space);
	}

	if (ret == -ENOSPC && !list_empty(&c->idx_gc)) {
		dbg_gc("no space, some index LEBs GC'ed, -EAGAIN");
		ubifs_commit_required(c);
		ret = -EAGAIN;
	}

	err = ubifs_wbuf_sync_nolock(wbuf);
	if (!err)
		err = ubifs_leb_unmap(c, c->gc_lnum);
	if (err) {
		ret = err;
		goto out;
	}
out_unlock:
	mutex_unlock(&wbuf->io_mutex);
	return ret;

out:
	ubifs_assert(ret < 0);
	ubifs_assert(ret != -ENOSPC && ret != -EAGAIN);
	ubifs_wbuf_sync_nolock(wbuf);
	ubifs_ro_mode(c, ret);
	mutex_unlock(&wbuf->io_mutex);
	ubifs_return_leb(c, lp.lnum);
	return ret;
}

/**
 * ubifs_gc_start_commit - garbage collection at start of commit.
 * @c: UBIFS file-system description object
 *
 * If a LEB has only dirty and free space, then we may safely unmap it and make
 * it free.  Note, we cannot do this with indexing LEBs because dirty space may
 * correspond index nodes that are required for recovery.  In that case, the
 * LEB cannot be unmapped until after the next commit.
 *
 * This function returns %0 upon success and a negative error code upon failure.
 */
int ubifs_gc_start_commit(struct ubifs_info *c)
{
	struct ubifs_gced_idx_leb *idx_gc;
	const struct ubifs_lprops *lp;
	int err = 0, flags;

	ubifs_get_lprops(c);

	/*
	 * Unmap (non-index) freeable LEBs. Note that recovery requires that all
	 * wbufs are sync'd before this, which is done in 'do_commit()'.
	 */
	while (1) {
		lp = ubifs_fast_find_freeable(c);
		if (IS_ERR(lp)) {
			err = PTR_ERR(lp);
			goto out;
		}
		if (!lp)
			break;
		ubifs_assert(!(lp->flags & LPROPS_TAKEN));
		ubifs_assert(!(lp->flags & LPROPS_INDEX));
		err = ubifs_leb_unmap(c, lp->lnum);
		if (err)
			goto out;
		lp = ubifs_change_lp(c, lp, c->leb_size, 0, lp->flags, 0);
		if (IS_ERR(lp)) {
			err = PTR_ERR(lp);
			goto out;
		}
		ubifs_assert(!(lp->flags & LPROPS_TAKEN));
		ubifs_assert(!(lp->flags & LPROPS_INDEX));
	}

	/* Mark GC'd index LEBs OK to unmap after this commit finishes */
	list_for_each_entry(idx_gc, &c->idx_gc, list)
		idx_gc->unmap = 1;

	/* Record index freeable LEBs for unmapping after commit */
	while (1) {
		lp = ubifs_fast_find_frdi_idx(c);
		if (IS_ERR(lp)) {
			err = PTR_ERR(lp);
			goto out;
		}
		if (!lp)
			break;
		idx_gc = kmalloc(sizeof(struct ubifs_gced_idx_leb), GFP_NOFS);
		if (!idx_gc) {
			err = -ENOMEM;
			goto out;
		}
		ubifs_assert(!(lp->flags & LPROPS_TAKEN));
		ubifs_assert(lp->flags & LPROPS_INDEX);
		/* Don't release the LEB until after the next commit */
		flags = (lp->flags | LPROPS_TAKEN) ^ LPROPS_INDEX;
		lp = ubifs_change_lp(c, lp, c->leb_size, 0, flags, 1);
		if (IS_ERR(lp)) {
			err = PTR_ERR(lp);
			kfree(idx_gc);
			goto out;
		}
		ubifs_assert(lp->flags & LPROPS_TAKEN);
		ubifs_assert(!(lp->flags & LPROPS_INDEX));
		idx_gc->lnum = lp->lnum;
		idx_gc->unmap = 1;
		list_add(&idx_gc->list, &c->idx_gc);
	}
out:
	ubifs_release_lprops(c);
	return err;
}

/**
 * ubifs_gc_end_commit - garbage collection at end of commit.
 * @c: UBIFS file-system description object
 *
 * This function completes out-of-place garbage collection of index LEBs.
 */
int ubifs_gc_end_commit(struct ubifs_info *c)
{
	struct ubifs_gced_idx_leb *idx_gc, *tmp;
	struct ubifs_wbuf *wbuf;
	int err = 0;

	wbuf = &c->jheads[GCHD].wbuf;
	mutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);
	list_for_each_entry_safe(idx_gc, tmp, &c->idx_gc, list)
		if (idx_gc->unmap) {
			dbg_gc("LEB %d", idx_gc->lnum);
			err = ubifs_leb_unmap(c, idx_gc->lnum);
			if (err)
				goto out;
			err = ubifs_change_one_lp(c, idx_gc->lnum, LPROPS_NC,
					  LPROPS_NC, 0, LPROPS_TAKEN, -1);
			if (err)
				goto out;
			list_del(&idx_gc->list);
			kfree(idx_gc);
		}
out:
	mutex_unlock(&wbuf->io_mutex);
	return err;
}

/**
 * ubifs_destroy_idx_gc - destroy idx_gc list.
 * @c: UBIFS file-system description object
 *
 * This function destroys the @c->idx_gc list. It is called when unmounting
 * so locks are not needed. Returns zero in case of success and a negative
 * error code in case of failure.
 */
void ubifs_destroy_idx_gc(struct ubifs_info *c)
{
	while (!list_empty(&c->idx_gc)) {
		struct ubifs_gced_idx_leb *idx_gc;

		idx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb,
				    list);
		c->idx_gc_cnt -= 1;
		list_del(&idx_gc->list);
		kfree(idx_gc);
	}
}

/**
 * ubifs_get_idx_gc_leb - get a LEB from GC'd index LEB list.
 * @c: UBIFS file-system description object
 *
 * Called during start commit so locks are not needed.
 */
int ubifs_get_idx_gc_leb(struct ubifs_info *c)
{
	struct ubifs_gced_idx_leb *idx_gc;
	int lnum;

	if (list_empty(&c->idx_gc))
		return -ENOSPC;
	idx_gc = list_entry(c->idx_gc.next, struct ubifs_gced_idx_leb, list);
	lnum = idx_gc->lnum;
	/* c->idx_gc_cnt is updated by the caller when lprops are updated */
	list_del(&idx_gc->list);
	kfree(idx_gc);
	return lnum;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 *  linux/include/linux/mmc/card.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 *  Card driver specific definitions.
 */
#ifndef LINUX_MMC_CARD_H
#define LINUX_MMC_CARD_H

#include <linux/device.h>
#include <linux/mmc/core.h>
#include <linux/mod_devicetable.h>

struct mmc_cid {
	unsigned int		manfid;
	char			prod_name[8];
	unsigned char		prv;
	unsigned int		serial;
	unsigned short		oemid;
	unsigned short		year;
	unsigned char		hwrev;
	unsigned char		fwrev;
	unsigned char		month;
};

struct mmc_csd {
	unsigned char		structure;
	unsigned char		mmca_vsn;
	unsigned short		cmdclass;
	unsigned short		tacc_clks;
	unsigned int		tacc_ns;
	unsigned int		c_size;
	unsigned int		r2w_factor;
	unsigned int		max_dtr;
	unsigned int		erase_size;		/* In sectors */
	unsigned int		wp_grp_size;
	unsigned int		read_blkbits;
	unsigned int		write_blkbits;
	unsigned int		capacity;
	unsigned int		read_partial:1,
				read_misalign:1,
				write_partial:1,
				write_misalign:1,
				dsr_imp:1;
};

struct mmc_ext_csd {
	u8			rev;
	u8			erase_group_def;
	u8			sec_feature_support;
	u8			rel_sectors;
	u8			rel_param;
	u8			part_config;
	u8			cache_ctrl;
	u8			rst_n_function;
	u8			max_packed_writes;
	u8			max_packed_reads;
	u8			packed_event_en;
	unsigned int		part_time;		/* Units: ms */
	unsigned int		sa_timeout;		/* Units: 100ns */
	unsigned int		sleep_notification_time;	/* Units: 10us */
	unsigned int		generic_cmd6_time;	/* Units: 10ms */
	unsigned int            power_off_longtime;     /* Units: ms */
	u8			power_off_notification;	/* state */
	unsigned int		hs_max_dtr;
	unsigned int		hs200_max_dtr;
#define MMC_HIGH_26_MAX_DTR	26000000
#define MMC_HIGH_52_MAX_DTR	52000000
#define MMC_HIGH_DDR_MAX_DTR	52000000
#define MMC_HS200_MAX_DTR	200000000
	unsigned int		sectors;
	unsigned int		hc_erase_size;		/* In sectors */
	unsigned int		hc_erase_timeout;	/* In milliseconds */
	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
	unsigned int		sec_erase_mult;	/* Secure erase multiplier */
	unsigned int		trim_timeout;		/* In milliseconds */
	bool			partition_setting_completed;	/* enable bit */
	unsigned long long	enhanced_area_offset;	/* Units: Byte */
	unsigned int		enhanced_area_size;	/* Units: KB */
	unsigned int		cache_size;		/* Units: KB */
	bool			hpi_en;			/* HPI enablebit */
	bool			hpi;			/* HPI support bit */
	unsigned int		hpi_cmd;		/* cmd used as HPI */
	bool			bkops;		/* background support bit */
	bool			bkops_en;	/* background enable bit */
	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
	unsigned int		boot_ro_lock;		/* ro lock support */
	bool			boot_ro_lockable;
	u8			raw_exception_status;	/* 54 */
	u8			raw_partition_support;	/* 160 */
	u8			raw_rpmb_size_mult;	/* 168 */
	u8			raw_erased_mem_count;	/* 181 */
	u8			raw_ext_csd_structure;	/* 194 */
	u8			raw_card_type;		/* 196 */
	u8			out_of_int_time;	/* 198 */
	u8			raw_pwr_cl_52_195;	/* 200 */
	u8			raw_pwr_cl_26_195;	/* 201 */
	u8			raw_pwr_cl_52_360;	/* 202 */
	u8			raw_pwr_cl_26_360;	/* 203 */
	u8			raw_s_a_timeout;	/* 217 */
	u8			raw_hc_erase_gap_size;	/* 221 */
	u8			raw_erase_timeout_mult;	/* 223 */
	u8			raw_hc_erase_grp_size;	/* 224 */
	u8			raw_sec_trim_mult;	/* 229 */
	u8			raw_sec_erase_mult;	/* 230 */
	u8			raw_sec_feature_support;/* 231 */
	u8			raw_trim_mult;		/* 232 */
	u8			raw_pwr_cl_200_195;	/* 236 */
	u8			raw_pwr_cl_200_360;	/* 237 */
	u8			raw_pwr_cl_ddr_52_195;	/* 238 */
	u8			raw_pwr_cl_ddr_52_360;	/* 239 */
	u8			raw_pwr_cl_ddr_200_360;	/* 253 */
	u8			raw_bkops_status;	/* 246 */
	u8			raw_sectors[4];		/* 212 - 4 bytes */

#ifdef CONFIG_MTK_EMMC_CQ_SUPPORT
	#define MMC_CMDQ_MODE_EN	(1)
	u8			cmdq_support;
	u8			cmdq_mode_en;
	u8			cmdq_depth;
#endif

	unsigned int            feature_support;
#define MMC_DISCARD_FEATURE	BIT(0)                  /* CMD38 feature */
};

struct sd_scr {
	unsigned char		sda_vsn;
	unsigned char		sda_spec3;
	unsigned char		bus_widths;
#define SD_SCR_BUS_WIDTH_1	(1<<0)
#define SD_SCR_BUS_WIDTH_4	(1<<2)
	unsigned char		cmds;
#define SD_SCR_CMD20_SUPPORT   (1<<0)
#define SD_SCR_CMD23_SUPPORT   (1<<1)
};

struct sd_ssr {
	unsigned int		au;			/* In sectors */
	unsigned int		erase_timeout;		/* In milliseconds */
	unsigned int		erase_offset;		/* In milliseconds */
};

struct sd_switch_caps {
	unsigned int		hs_max_dtr;
	unsigned int		uhs_max_dtr;
#define HIGH_SPEED_MAX_DTR	50000000
#define UHS_SDR104_MAX_DTR	208000000
#define UHS_SDR50_MAX_DTR	100000000
#define UHS_DDR50_MAX_DTR	50000000
#define UHS_SDR25_MAX_DTR	UHS_DDR50_MAX_DTR
#define UHS_SDR12_MAX_DTR	25000000
	unsigned int		sd3_bus_mode;
#define UHS_SDR12_BUS_SPEED	0
#define HIGH_SPEED_BUS_SPEED	1
#define UHS_SDR25_BUS_SPEED	1
#define UHS_SDR50_BUS_SPEED	2
#define UHS_SDR104_BUS_SPEED	3
#define UHS_DDR50_BUS_SPEED	4

#define SD_MODE_HIGH_SPEED	(1 << HIGH_SPEED_BUS_SPEED)
#define SD_MODE_UHS_SDR12	(1 << UHS_SDR12_BUS_SPEED)
#define SD_MODE_UHS_SDR25	(1 << UHS_SDR25_BUS_SPEED)
#define SD_MODE_UHS_SDR50	(1 << UHS_SDR50_BUS_SPEED)
#define SD_MODE_UHS_SDR104	(1 << UHS_SDR104_BUS_SPEED)
#define SD_MODE_UHS_DDR50	(1 << UHS_DDR50_BUS_SPEED)
	unsigned int		sd3_drv_type;
#define SD_DRIVER_TYPE_B	0x01
#define SD_DRIVER_TYPE_A	0x02
#define SD_DRIVER_TYPE_C	0x04
#define SD_DRIVER_TYPE_D	0x08
	unsigned int		sd3_curr_limit;
#define SD_SET_CURRENT_LIMIT_200	0
#define SD_SET_CURRENT_LIMIT_400	1
#define SD_SET_CURRENT_LIMIT_600	2
#define SD_SET_CURRENT_LIMIT_800	3
#define SD_SET_CURRENT_NO_CHANGE	(-1)

#define SD_MAX_CURRENT_200	(1 << SD_SET_CURRENT_LIMIT_200)
#define SD_MAX_CURRENT_400	(1 << SD_SET_CURRENT_LIMIT_400)
#define SD_MAX_CURRENT_600	(1 << SD_SET_CURRENT_LIMIT_600)
#define SD_MAX_CURRENT_800	(1 << SD_SET_CURRENT_LIMIT_800)
};

struct sdio_cccr {
	unsigned int		sdio_vsn;
	unsigned int		sd_vsn;
	unsigned int		multi_block:1,
				low_speed:1,
				wide_bus:1,
				high_power:1,
				high_speed:1,
				disable_cd:1;
};

struct sdio_cis {
	unsigned short		vendor;
	unsigned short		device;
	unsigned short		blksize;
	unsigned int		max_dtr;
};

struct mmc_host;
struct mmc_ios;
struct sdio_func;
struct sdio_func_tuple;

#define SDIO_MAX_FUNCS		7

enum mmc_blk_status {
	MMC_BLK_SUCCESS = 0,
	MMC_BLK_PARTIAL,
	MMC_BLK_CMD_ERR,
	MMC_BLK_RETRY,
	MMC_BLK_ABORT,
	MMC_BLK_DATA_ERR,
	MMC_BLK_ECC_ERR,
	MMC_BLK_NOMEDIUM,
	MMC_BLK_NEW_REQUEST,
};

/* The number of MMC physical partitions.  These consist of:
 * boot partitions (2), general purpose partitions (4) and
 * RPMB partition (1) in MMC v4.4.
 */
#define MMC_NUM_BOOT_PARTITION	2
#define MMC_NUM_GP_PARTITION	4
#define MMC_NUM_PHY_PARTITION	7
#define MAX_MMC_PART_NAME_LEN	20

/*
 * MMC Physical partitions
 */
struct mmc_part {
	unsigned int	size;	/* partition size (in bytes) */
	unsigned int	part_cfg;	/* partition type */
	char	name[MAX_MMC_PART_NAME_LEN];
	bool	force_ro;	/* to make boot parts RO by default */
	unsigned int	area_type;
#define MMC_BLK_DATA_AREA_MAIN	(1<<0)
#define MMC_BLK_DATA_AREA_BOOT	(1<<1)
#define MMC_BLK_DATA_AREA_GP	(1<<2)
#define MMC_BLK_DATA_AREA_RPMB	(1<<3)
};
#ifdef MTK_BKOPS_IDLE_MAYA
#define BKOPS_NUM_OF_SEVERITY_LEVELS 4
struct mmc_bkops_stats {
	spinlock_t lock;
	bool enabled;
	unsigned int hpi;	/*hpi issued */
	unsigned int suspend;	/*card sleed issued */
	bool print_stats;
	unsigned int bkops_level[BKOPS_NUM_OF_SEVERITY_LEVELS];
};

/**
 * struct mmc_bkops_info - BKOPS data
 * @dw:	Idle time bkops delayed work
 * @host_delay_ms:	The host controller time to start bkops
 * @delay_ms:	The time to start the BKOPS
 *        delayed work once MMC thread is idle
 * @min_sectors_to_queue_delayed_work: the changed
 *        number of sectors that should issue check for BKOPS
 *        need
 * @bkops_stats: BKOPS statistics
 * @size_percentage_to_queue_delayed_work: the changed
 *        percentage of sectors that should issue check for
 *        BKOPS need
 * @cancel_delayed_work: A flag to indicate if the delayed work
 *        should be cancelled
 * @sectors_changed:  number of  sectors written or
 *       discard since the last idle BKOPS were scheduled
 */
struct mmc_bkops_info {
	struct delayed_work dw;
	unsigned int host_delay_ms;
	unsigned int delay_ms;
	unsigned int min_sectors_to_queue_delayed_work;
	unsigned int size_percentage_to_queue_delayed_work;
	struct mmc_bkops_stats bkops_stats;
/*
 * A default time for checking the need for non urgent BKOPS once mmcqd
 * is idle.
 */
#define MMC_IDLE_BKOPS_TIME_MS 200
	bool cancel_delayed_work;
	unsigned int sectors_changed;
/*
 * Since canceling the delayed work might have significant effect on the
 * performance of small requests we won't queue the delayed work every time
 * mmcqd thread is idle.
 * The delayed work for idle BKOPS will be scheduled only after a
 * significant
 * amount of write or discard data.
 */
#define BKOPS_SIZE_PERCENTAGE_TO_QUEUE_DELAYED_WORK 0	/* 1% */
};
#endif
/*
 * MMC device
 */
struct mmc_card {
	struct mmc_host		*host;		/* the host this device belongs to */
	struct device		dev;		/* the device */
	u32			ocr;		/* the current OCR setting */
	unsigned int		rca;		/* relative card address of device */
	unsigned int		type;		/* card type */
#define MMC_TYPE_MMC		0		/* MMC card */
#define MMC_TYPE_SD		1		/* SD card */
#define MMC_TYPE_SDIO		2		/* SDIO card */
#define MMC_TYPE_SD_COMBO	3		/* SD combo (IO+mem) card */
	unsigned int		state;		/* (our) card state */
#define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
#define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
#define MMC_STATE_BLOCKADDR	(1<<2)		/* card uses block-addressing */
#define MMC_CARD_SDXC		(1<<3)		/* card is SDXC */
#define MMC_CARD_REMOVED	(1<<4)		/* card has been removed */
#define MMC_STATE_DOING_BKOPS	(1<<5)		/* card is doing BKOPS */
#ifdef MTK_BKOPS_IDLE_MAYA	/* maya is 1<<11 */
#define MMC_STATE_NEED_BKOPS	(1<<12)	/* card needs to do BKOPS */
#endif
#ifdef CONFIG_MMC_FFU
#define MMC_STATE_FFUED         (1<<22)     /* card has been FFUed */
#endif
#define MMC_STATE_SUSPENDED	(1<<6)		/* card is suspended */
#define MMC_STATE_SLEEP     (1<<9)      /*card is sleep */
	unsigned int		quirks; 	/* card quirks */
#define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
#define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
						/* for byte mode */
#define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
						/* (missing CIA registers) */
#define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
#define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
#define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
#define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
#define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
#define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
						/* byte mode */
#define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
#define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
#define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */
#ifdef CONFIG_MTK_EMMC_CACHE
#define MMC_QUIRK_DISABLE_CACHE     (1<<12) /* eMMC cache feature */
#endif
/* disable sleep notifation, this may cause card busy long time on some eMMC*/
#define MMC_QUIRK_DISABLE_SNO       (1<<13)

	unsigned int		erase_size;	/* erase size in sectors */
 	unsigned int		erase_shift;	/* if erase unit is power 2 */
 	unsigned int		pref_erase;	/* in sectors */
 	u8			erased_byte;	/* value of erased bytes */
	unsigned int		wp_grp_size;	/* write group size in sectors */

	u32			raw_cid[4];	/* raw card CID */
	u32			raw_csd[4];	/* raw card CSD */
	u32			raw_scr[2];	/* raw card SCR */
	struct mmc_cid		cid;		/* card identification */
	struct mmc_csd		csd;		/* card specific */
	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
	struct sd_scr		scr;		/* extra SD information */
	struct sd_ssr		ssr;		/* yet more SD information */
	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */

	unsigned int		sdio_funcs;	/* number of SDIO functions */
	struct sdio_cccr	cccr;		/* common card info */
	struct sdio_cis		cis;		/* common tuple info */
	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
	struct sdio_func	*sdio_single_irq; /* SDIO function when only one IRQ active */
	unsigned		num_info;	/* number of info strings */
	const char		**info;		/* info strings */
	struct sdio_func_tuple	*tuples;	/* unknown common tuples */

	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
	unsigned int		mmc_avail_type;	/* supported device type by both host and card */

	struct dentry		*debugfs_root;
	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
	unsigned int    nr_parts;
#ifdef MTK_BKOPS_IDLE_MAYA
	struct mmc_bkops_info bkops_info;
#endif
};

/*
 * This function fill contents in mmc_part.
 */
static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
			unsigned int part_cfg, char *name, int idx, bool ro,
			int area_type)
{
	card->part[card->nr_parts].size = size;
	card->part[card->nr_parts].part_cfg = part_cfg;
	sprintf(card->part[card->nr_parts].name, name, idx);
	card->part[card->nr_parts].force_ro = ro;
	card->part[card->nr_parts].area_type = area_type;
	card->nr_parts++;
}

static inline bool mmc_large_sector(struct mmc_card *card)
{
	return card->ext_csd.data_sector_size == 4096;
}

/*
 *  The world is not perfect and supplies us with broken mmc/sdio devices.
 *  For at least some of these bugs we need a work-around.
 */

struct mmc_fixup {
	/* CID-specific fields. */
	const char *name;

	/* Valid revision range */
	u64 rev_start, rev_end;

	unsigned int manfid;
	unsigned short oemid;

	/* SDIO-specfic fields. You can use SDIO_ANY_ID here of course */
	u16 cis_vendor, cis_device;

	void (*vendor_fixup)(struct mmc_card *card, int data);
	int data;
};

#define CID_MANFID_ANY (-1u)
#define CID_OEMID_ANY ((unsigned short) -1)
#define CID_NAME_ANY (NULL)

#define END_FIXUP { NULL }

#define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
		   _cis_vendor, _cis_device,				\
		   _fixup, _data)					\
	{						   \
		.name = (_name),			   \
		.manfid = (_manfid),			   \
		.oemid = (_oemid),			   \
		.rev_start = (_rev_start),		   \
		.rev_end = (_rev_end),			   \
		.cis_vendor = (_cis_vendor),		   \
		.cis_device = (_cis_device),		   \
		.vendor_fixup = (_fixup),		   \
		.data = (_data),			   \
	 }

#define MMC_FIXUP_REV(_name, _manfid, _oemid, _rev_start, _rev_end,	\
		      _fixup, _data)					\
	_FIXUP_EXT(_name, _manfid,					\
		   _oemid, _rev_start, _rev_end,			\
		   SDIO_ANY_ID, SDIO_ANY_ID,				\
		   _fixup, _data)					\

#define MMC_FIXUP(_name, _manfid, _oemid, _fixup, _data) \
	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data)

#define SDIO_FIXUP(_vendor, _device, _fixup, _data)			\
	_FIXUP_EXT(CID_NAME_ANY, CID_MANFID_ANY,			\
		    CID_OEMID_ANY, 0, -1ull,				\
		   _vendor, _device,					\
		   _fixup, _data)					\

#define cid_rev(hwrev, fwrev, year, month)	\
	(((u64) hwrev) << 40 |                  \
	 ((u64) fwrev) << 32 |                  \
	 ((u64) year) << 16 |                   \
	 ((u64) month))

#define cid_rev_card(card)		  \
	cid_rev(card->cid.hwrev,	  \
		    card->cid.fwrev,      \
		    card->cid.year,	  \
		    card->cid.month)

/*
 * Unconditionally quirk add/remove.
 */

static inline void __maybe_unused add_quirk(struct mmc_card *card, int data)
{
	card->quirks |= data;
}

static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
{
	card->quirks &= ~data;
}

#define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
#define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
#define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)

#define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
#define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
#define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
#define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
#define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
#define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
#ifdef MTK_BKOPS_IDLE_MAYA
#define mmc_card_need_bkops(c)	((c)->state & MMC_STATE_NEED_BKOPS)
#endif
#define mmc_card_suspended(c)	((c)->state & MMC_STATE_SUSPENDED)

#define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
#define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
#define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
#define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
#define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
#define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
#define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
#ifdef MTK_BKOPS_IDLE_MAYA
#define mmc_card_set_need_bkops(c)	((c)->state |= MMC_STATE_NEED_BKOPS)
#define mmc_card_clr_need_bkops(c)	((c)->state &= ~MMC_STATE_NEED_BKOPS)
#endif
#define mmc_card_set_suspended(c) ((c)->state |= MMC_STATE_SUSPENDED)
#define mmc_card_clr_suspended(c) ((c)->state &= ~MMC_STATE_SUSPENDED)

#define mmc_card_is_sleep(c)      ((c)->state & MMC_STATE_SLEEP)
#define mmc_card_set_sleep(c)     ((c)->state |= MMC_STATE_SLEEP)
#define mmc_card_clr_sleep(c)     ((c)->state &= ~MMC_STATE_SLEEP)
/*
 * Quirk add/remove for MMC products.
 */

static inline void __maybe_unused add_quirk_mmc(struct mmc_card *card, int data)
{
	if (mmc_card_mmc(card))
		card->quirks |= data;
}

static inline void __maybe_unused remove_quirk_mmc(struct mmc_card *card,
						   int data)
{
	if (mmc_card_mmc(card))
		card->quirks &= ~data;
}

/*
 * Quirk add/remove for SD products.
 */

static inline void __maybe_unused add_quirk_sd(struct mmc_card *card, int data)
{
	if (mmc_card_sd(card))
		card->quirks |= data;
}

static inline void __maybe_unused remove_quirk_sd(struct mmc_card *card,
						   int data)
{
	if (mmc_card_sd(card))
		card->quirks &= ~data;
}

static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_LENIENT_FN0;
}

static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
}

static inline int mmc_card_disable_cd(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_DISABLE_CD;
}

static inline int mmc_card_nonstd_func_interface(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_NONSTD_FUNC_IF;
}

static inline int mmc_card_broken_byte_mode_512(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
}

static inline int mmc_card_long_read_time(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
}

static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
}

#define mmc_card_name(c)	((c)->cid.prod_name)
#define mmc_card_id(c)		(dev_name(&(c)->dev))

#define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)

#define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
#define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)
#define mmc_set_drvdata(c,d)	dev_set_drvdata(&(c)->dev, d)

/*
 * MMC device driver (e.g., Flash card, I/O card...)
 */
struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	int (*suspend)(struct mmc_card *);
	int (*resume)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

extern int mmc_register_driver(struct mmc_driver *);
extern void mmc_unregister_driver(struct mmc_driver *);

extern void mmc_fixup_device(struct mmc_card *card,
			     const struct mmc_fixup *table);

#endif /* LINUX_MMC_CARD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef _SCSI_SCSI_DEVINFO_H
#define _SCSI_SCSI_DEVINFO_H
/*
 * Flags for SCSI devices that need special treatment
 */
#define BLIST_NOLUN     	0x001	/* Only scan LUN 0 */
#define BLIST_FORCELUN  	0x002	/* Known to have LUNs, force scanning,
					   deprecated: Use max_luns=N */
#define BLIST_BORKEN    	0x004	/* Flag for broken handshaking */
#define BLIST_KEY       	0x008	/* unlock by special command */
#define BLIST_SINGLELUN 	0x010	/* Do not use LUNs in parallel */
#define BLIST_NOTQ		0x020	/* Buggy Tagged Command Queuing */
#define BLIST_SPARSELUN 	0x040	/* Non consecutive LUN numbering */
#define BLIST_MAX5LUN		0x080	/* Avoid LUNS >= 5 */
#define BLIST_ISROM     	0x100	/* Treat as (removable) CD-ROM */
#define BLIST_LARGELUN		0x200	/* LUNs past 7 on a SCSI-2 device */
#define BLIST_INQUIRY_36	0x400	/* override additional length field */
#define BLIST_INQUIRY_58	0x800	/* ... for broken inquiry responses */
#define BLIST_NOSTARTONADD	0x1000	/* do not do automatic start on add */
#define BLIST_MS_SKIP_PAGE_08	0x2000	/* do not send ms page 0x08 */
#define BLIST_MS_SKIP_PAGE_3F	0x4000	/* do not send ms page 0x3f */
#define BLIST_USE_10_BYTE_MS	0x8000	/* use 10 byte ms before 6 byte ms */
#define BLIST_MS_192_BYTES_FOR_3F	0x10000	/*  192 byte ms page 0x3f request */
#define BLIST_REPORTLUN2	0x20000	/* try REPORT_LUNS even for SCSI-2 devs
 					   (if HBA supports more than 8 LUNs) */
#define BLIST_NOREPORTLUN	0x40000	/* don't try REPORT_LUNS scan (SCSI-3 devs) */
#define BLIST_NOT_LOCKABLE	0x80000	/* don't use PREVENT-ALLOW commands */
#define BLIST_NO_ULD_ATTACH	0x100000 /* device is actually for RAID config */
#define BLIST_SELECT_NO_ATN	0x200000 /* select without ATN */
#define BLIST_RETRY_HWERROR	0x400000 /* retry HARDWARE_ERROR */
#define BLIST_MAX_512		0x800000 /* maximum 512 sector cdb length */
#define BLIST_ATTACH_PQ3	0x1000000 /* Scan: Attach to PQ3 devices */
#define BLIST_NO_DIF		0x2000000 /* Disable T10 PI (DIF) */
#define BLIST_SKIP_VPD_PAGES	0x4000000 /* Ignore SBC-3 VPD pages */
#define BLIST_SCSI3LUN		0x8000000 /* Scan more than 256 LUNs
					     for sequential scan */
#define BLIST_TRY_VPD_PAGES	0x10000000 /* Attempt to read VPD pages */
#define BLIST_NO_RSOC		0x20000000 /* don't try to issue RSOC */
#define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #include <linux/module.h>
#include <linux/rbtree_augmented.h>
#include <linux/random.h>
#include <asm/timex.h>

#define NODES       100
#define PERF_LOOPS  100000
#define CHECK_LOOPS 100

struct test_node {
	u32 key;
	struct rb_node rb;

	/* following fields used for testing augmented rbtree functionality */
	u32 val;
	u32 augmented;
};

static struct rb_root root = RB_ROOT;
static struct test_node nodes[NODES];

static struct rnd_state rnd;

static void insert(struct test_node *node, struct rb_root *root)
{
	struct rb_node **new = &root->rb_node, *parent = NULL;
	u32 key = node->key;

	while (*new) {
		parent = *new;
		if (key < rb_entry(parent, struct test_node, rb)->key)
			new = &parent->rb_left;
		else
			new = &parent->rb_right;
	}

	rb_link_node(&node->rb, parent, new);
	rb_insert_color(&node->rb, root);
}

static inline void erase(struct test_node *node, struct rb_root *root)
{
	rb_erase(&node->rb, root);
}

static inline u32 augment_recompute(struct test_node *node)
{
	u32 max = node->val, child_augmented;
	if (node->rb.rb_left) {
		child_augmented = rb_entry(node->rb.rb_left, struct test_node,
					   rb)->augmented;
		if (max < child_augmented)
			max = child_augmented;
	}
	if (node->rb.rb_right) {
		child_augmented = rb_entry(node->rb.rb_right, struct test_node,
					   rb)->augmented;
		if (max < child_augmented)
			max = child_augmented;
	}
	return max;
}

RB_DECLARE_CALLBACKS(static, augment_callbacks, struct test_node, rb,
		     u32, augmented, augment_recompute)

static void insert_augmented(struct test_node *node, struct rb_root *root)
{
	struct rb_node **new = &root->rb_node, *rb_parent = NULL;
	u32 key = node->key;
	u32 val = node->val;
	struct test_node *parent;

	while (*new) {
		rb_parent = *new;
		parent = rb_entry(rb_parent, struct test_node, rb);
		if (parent->augmented < val)
			parent->augmented = val;
		if (key < parent->key)
			new = &parent->rb.rb_left;
		else
			new = &parent->rb.rb_right;
	}

	node->augmented = val;
	rb_link_node(&node->rb, rb_parent, new);
	rb_insert_augmented(&node->rb, root, &augment_callbacks);
}

static void erase_augmented(struct test_node *node, struct rb_root *root)
{
	rb_erase_augmented(&node->rb, root, &augment_callbacks);
}

static void init(void)
{
	int i;
	for (i = 0; i < NODES; i++) {
		nodes[i].key = prandom_u32_state(&rnd);
		nodes[i].val = prandom_u32_state(&rnd);
	}
}

static bool is_red(struct rb_node *rb)
{
	return !(rb->__rb_parent_color & 1);
}

static int black_path_count(struct rb_node *rb)
{
	int count;
	for (count = 0; rb; rb = rb_parent(rb))
		count += !is_red(rb);
	return count;
}

static void check_postorder_foreach(int nr_nodes)
{
	struct test_node *cur, *n;
	int count = 0;
	rbtree_postorder_for_each_entry_safe(cur, n, &root, rb)
		count++;

	WARN_ON_ONCE(count != nr_nodes);
}

static void check_postorder(int nr_nodes)
{
	struct rb_node *rb;
	int count = 0;
	for (rb = rb_first_postorder(&root); rb; rb = rb_next_postorder(rb))
		count++;

	WARN_ON_ONCE(count != nr_nodes);
}

static void check(int nr_nodes)
{
	struct rb_node *rb;
	int count = 0, blacks = 0;
	u32 prev_key = 0;

	for (rb = rb_first(&root); rb; rb = rb_next(rb)) {
		struct test_node *node = rb_entry(rb, struct test_node, rb);
		WARN_ON_ONCE(node->key < prev_key);
		WARN_ON_ONCE(is_red(rb) &&
			     (!rb_parent(rb) || is_red(rb_parent(rb))));
		if (!count)
			blacks = black_path_count(rb);
		else
			WARN_ON_ONCE((!rb->rb_left || !rb->rb_right) &&
				     blacks != black_path_count(rb));
		prev_key = node->key;
		count++;
	}

	WARN_ON_ONCE(count != nr_nodes);
	WARN_ON_ONCE(count < (1 << black_path_count(rb_last(&root))) - 1);

	check_postorder(nr_nodes);
	check_postorder_foreach(nr_nodes);
}

static void check_augmented(int nr_nodes)
{
	struct rb_node *rb;

	check(nr_nodes);
	for (rb = rb_first(&root); rb; rb = rb_next(rb)) {
		struct test_node *node = rb_entry(rb, struct test_node, rb);
		WARN_ON_ONCE(node->augmented != augment_recompute(node));
	}
}

static int __init rbtree_test_init(void)
{
	int i, j;
	cycles_t time1, time2, time;

	printk(KERN_ALERT "rbtree testing");

	prandom_seed_state(&rnd, 3141592653589793238ULL);
	init();

	time1 = get_cycles();

	for (i = 0; i < PERF_LOOPS; i++) {
		for (j = 0; j < NODES; j++)
			insert(nodes + j, &root);
		for (j = 0; j < NODES; j++)
			erase(nodes + j, &root);
	}

	time2 = get_cycles();
	time = time2 - time1;

	time = div_u64(time, PERF_LOOPS);
	printk(" -> %llu cycles\n", (unsigned long long)time);

	for (i = 0; i < CHECK_LOOPS; i++) {
		init();
		for (j = 0; j < NODES; j++) {
			check(j);
			insert(nodes + j, &root);
		}
		for (j = 0; j < NODES; j++) {
			check(NODES - j);
			erase(nodes + j, &root);
		}
		check(0);
	}

	printk(KERN_ALERT "augmented rbtree testing");

	init();

	time1 = get_cycles();

	for (i = 0; i < PERF_LOOPS; i++) {
		for (j = 0; j < NODES; j++)
			insert_augmented(nodes + j, &root);
		for (j = 0; j < NODES; j++)
			erase_augmented(nodes + j, &root);
	}

	time2 = get_cycles();
	time = time2 - time1;

	time = div_u64(time, PERF_LOOPS);
	printk(" -> %llu cycles\n", (unsigned long long)time);

	for (i = 0; i < CHECK_LOOPS; i++) {
		init();
		for (j = 0; j < NODES; j++) {
			check_augmented(j);
			insert_augmented(nodes + j, &root);
		}
		for (j = 0; j < NODES; j++) {
			check_augmented(NODES - j);
			erase_augmented(nodes + j, &root);
		}
		check_augmented(0);
	}

	return -EAGAIN; /* Fail will directly unload the module */
}

static void __exit rbtree_test_exit(void)
{
	printk(KERN_ALERT "test exit\n");
}

module_init(rbtree_test_init)
module_exit(rbtree_test_exit)

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Michel Lespinasse");
MODULE_DESCRIPTION("Red Black Tree test");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Copyright (c) 2006 Oracle.  All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directory of this source tree, or the
 * OpenIB.org BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
#include <linux/kernel.h>
#include <linux/in.h>
#include <linux/device.h>
#include <linux/dmapool.h>
#include <linux/ratelimit.h>

#include "rds.h"
#include "iw.h"

static void rds_iw_send_rdma_complete(struct rds_message *rm,
				      int wc_status)
{
	int notify_status;

	switch (wc_status) {
	case IB_WC_WR_FLUSH_ERR:
		return;

	case IB_WC_SUCCESS:
		notify_status = RDS_RDMA_SUCCESS;
		break;

	case IB_WC_REM_ACCESS_ERR:
		notify_status = RDS_RDMA_REMOTE_ERROR;
		break;

	default:
		notify_status = RDS_RDMA_OTHER_ERROR;
		break;
	}
	rds_rdma_send_complete(rm, notify_status);
}

static void rds_iw_send_unmap_rdma(struct rds_iw_connection *ic,
				   struct rm_rdma_op *op)
{
	if (op->op_mapped) {
		ib_dma_unmap_sg(ic->i_cm_id->device,
			op->op_sg, op->op_nents,
			op->op_write ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
		op->op_mapped = 0;
	}
}

static void rds_iw_send_unmap_rm(struct rds_iw_connection *ic,
			  struct rds_iw_send_work *send,
			  int wc_status)
{
	struct rds_message *rm = send->s_rm;

	rdsdebug("ic %p send %p rm %p\n", ic, send, rm);

	ib_dma_unmap_sg(ic->i_cm_id->device,
		     rm->data.op_sg, rm->data.op_nents,
		     DMA_TO_DEVICE);

	if (rm->rdma.op_active) {
		rds_iw_send_unmap_rdma(ic, &rm->rdma);

		/* If the user asked for a completion notification on this
		 * message, we can implement three different semantics:
		 *  1.	Notify when we received the ACK on the RDS message
		 *	that was queued with the RDMA. This provides reliable
		 *	notification of RDMA status at the expense of a one-way
		 *	packet delay.
		 *  2.	Notify when the IB stack gives us the completion event for
		 *	the RDMA operation.
		 *  3.	Notify when the IB stack gives us the completion event for
		 *	the accompanying RDS messages.
		 * Here, we implement approach #3. To implement approach #2,
		 * call rds_rdma_send_complete from the cq_handler. To implement #1,
		 * don't call rds_rdma_send_complete at all, and fall back to the notify
		 * handling in the ACK processing code.
		 *
		 * Note: There's no need to explicitly sync any RDMA buffers using
		 * ib_dma_sync_sg_for_cpu - the completion for the RDMA
		 * operation itself unmapped the RDMA buffers, which takes care
		 * of synching.
		 */
		rds_iw_send_rdma_complete(rm, wc_status);

		if (rm->rdma.op_write)
			rds_stats_add(s_send_rdma_bytes, rm->rdma.op_bytes);
		else
			rds_stats_add(s_recv_rdma_bytes, rm->rdma.op_bytes);
	}

	/* If anyone waited for this message to get flushed out, wake
	 * them up now */
	rds_message_unmapped(rm);

	rds_message_put(rm);
	send->s_rm = NULL;
}

void rds_iw_send_init_ring(struct rds_iw_connection *ic)
{
	struct rds_iw_send_work *send;
	u32 i;

	for (i = 0, send = ic->i_sends; i < ic->i_send_ring.w_nr; i++, send++) {
		struct ib_sge *sge;

		send->s_rm = NULL;
		send->s_op = NULL;
		send->s_mapping = NULL;

		send->s_wr.next = NULL;
		send->s_wr.wr_id = i;
		send->s_wr.sg_list = send->s_sge;
		send->s_wr.num_sge = 1;
		send->s_wr.opcode = IB_WR_SEND;
		send->s_wr.send_flags = 0;
		send->s_wr.ex.imm_data = 0;

		sge = rds_iw_data_sge(ic, send->s_sge);
		sge->lkey = 0;

		sge = rds_iw_header_sge(ic, send->s_sge);
		sge->addr = ic->i_send_hdrs_dma + (i * sizeof(struct rds_header));
		sge->length = sizeof(struct rds_header);
		sge->lkey = 0;

		send->s_mr = ib_alloc_fast_reg_mr(ic->i_pd, fastreg_message_size);
		if (IS_ERR(send->s_mr)) {
			printk(KERN_WARNING "RDS/IW: ib_alloc_fast_reg_mr failed\n");
			break;
		}

		send->s_page_list = ib_alloc_fast_reg_page_list(
			ic->i_cm_id->device, fastreg_message_size);
		if (IS_ERR(send->s_page_list)) {
			printk(KERN_WARNING "RDS/IW: ib_alloc_fast_reg_page_list failed\n");
			break;
		}
	}
}

void rds_iw_send_clear_ring(struct rds_iw_connection *ic)
{
	struct rds_iw_send_work *send;
	u32 i;

	for (i = 0, send = ic->i_sends; i < ic->i_send_ring.w_nr; i++, send++) {
		BUG_ON(!send->s_mr);
		ib_dereg_mr(send->s_mr);
		BUG_ON(!send->s_page_list);
		ib_free_fast_reg_page_list(send->s_page_list);
		if (send->s_wr.opcode == 0xdead)
			continue;
		if (send->s_rm)
			rds_iw_send_unmap_rm(ic, send, IB_WC_WR_FLUSH_ERR);
		if (send->s_op)
			rds_iw_send_unmap_rdma(ic, send->s_op);
	}
}

/*
 * The _oldest/_free ring operations here race cleanly with the alloc/unalloc
 * operations performed in the send path.  As the sender allocs and potentially
 * unallocs the next free entry in the ring it doesn't alter which is
 * the next to be freed, which is what this is concerned with.
 */
void rds_iw_send_cq_comp_handler(struct ib_cq *cq, void *context)
{
	struct rds_connection *conn = context;
	struct rds_iw_connection *ic = conn->c_transport_data;
	struct ib_wc wc;
	struct rds_iw_send_work *send;
	u32 completed;
	u32 oldest;
	u32 i;
	int ret;

	rdsdebug("cq %p conn %p\n", cq, conn);
	rds_iw_stats_inc(s_iw_tx_cq_call);
	ret = ib_req_notify_cq(cq, IB_CQ_NEXT_COMP);
	if (ret)
		rdsdebug("ib_req_notify_cq send failed: %d\n", ret);

	while (ib_poll_cq(cq, 1, &wc) > 0) {
		rdsdebug("wc wr_id 0x%llx status %u byte_len %u imm_data %u\n",
			 (unsigned long long)wc.wr_id, wc.status, wc.byte_len,
			 be32_to_cpu(wc.ex.imm_data));
		rds_iw_stats_inc(s_iw_tx_cq_event);

		if (wc.status != IB_WC_SUCCESS) {
			printk(KERN_ERR "WC Error:  status = %d opcode = %d\n", wc.status, wc.opcode);
			break;
		}

		if (wc.opcode == IB_WC_LOCAL_INV && wc.wr_id == RDS_IW_LOCAL_INV_WR_ID) {
			ic->i_fastreg_posted = 0;
			continue;
		}

		if (wc.opcode == IB_WC_FAST_REG_MR && wc.wr_id == RDS_IW_FAST_REG_WR_ID) {
			ic->i_fastreg_posted = 1;
			continue;
		}

		if (wc.wr_id == RDS_IW_ACK_WR_ID) {
			if (time_after(jiffies, ic->i_ack_queued + HZ/2))
				rds_iw_stats_inc(s_iw_tx_stalled);
			rds_iw_ack_send_complete(ic);
			continue;
		}

		oldest = rds_iw_ring_oldest(&ic->i_send_ring);

		completed = rds_iw_ring_completed(&ic->i_send_ring, wc.wr_id, oldest);

		for (i = 0; i < completed; i++) {
			send = &ic->i_sends[oldest];

			/* In the error case, wc.opcode sometimes contains garbage */
			switch (send->s_wr.opcode) {
			case IB_WR_SEND:
				if (send->s_rm)
					rds_iw_send_unmap_rm(ic, send, wc.status);
				break;
			case IB_WR_FAST_REG_MR:
			case IB_WR_RDMA_WRITE:
			case IB_WR_RDMA_READ:
			case IB_WR_RDMA_READ_WITH_INV:
				/* Nothing to be done - the SG list will be unmapped
				 * when the SEND completes. */
				break;
			default:
				printk_ratelimited(KERN_NOTICE
						"RDS/IW: %s: unexpected opcode 0x%x in WR!\n",
						__func__, send->s_wr.opcode);
				break;
			}

			send->s_wr.opcode = 0xdead;
			send->s_wr.num_sge = 1;
			if (time_after(jiffies, send->s_queued + HZ/2))
				rds_iw_stats_inc(s_iw_tx_stalled);

			/* If a RDMA operation produced an error, signal this right
			 * away. If we don't, the subsequent SEND that goes with this
			 * RDMA will be canceled with ERR_WFLUSH, and the application
			 * never learn that the RDMA failed. */
			if (unlikely(wc.status == IB_WC_REM_ACCESS_ERR && send->s_op)) {
				struct rds_message *rm;

				rm = rds_send_get_message(conn, send->s_op);
				if (rm)
					rds_iw_send_rdma_complete(rm, wc.status);
			}

			oldest = (oldest + 1) % ic->i_send_ring.w_nr;
		}

		rds_iw_ring_free(&ic->i_send_ring, completed);

		if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||
		    test_bit(0, &conn->c_map_queued))
			queue_delayed_work(rds_wq, &conn->c_send_w, 0);

		/* We expect errors as the qp is drained during shutdown */
		if (wc.status != IB_WC_SUCCESS && rds_conn_up(conn)) {
			rds_iw_conn_error(conn,
				"send completion on %pI4 "
				"had status %u, disconnecting and reconnecting\n",
				&conn->c_faddr, wc.status);
		}
	}
}

/*
 * This is the main function for allocating credits when sending
 * messages.
 *
 * Conceptually, we have two counters:
 *  -	send credits: this tells us how many WRs we're allowed
 *	to submit without overruning the receiver's queue. For
 *	each SEND WR we post, we decrement this by one.
 *
 *  -	posted credits: this tells us how many WRs we recently
 *	posted to the receive queue. This value is transferred
 *	to the peer as a "credit update" in a RDS header field.
 *	Every time we transmit credits to the peer, we subtract
 *	the amount of transferred credits from this counter.
 *
 * It is essential that we avoid situations where both sides have
 * exhausted their send credits, and are unable to send new credits
 * to the peer. We achieve this by requiring that we send at least
 * one credit update to the peer before exhausting our credits.
 * When new credits arrive, we subtract one credit that is withheld
 * until we've posted new buffers and are ready to transmit these
 * credits (see rds_iw_send_add_credits below).
 *
 * The RDS send code is essentially single-threaded; rds_send_xmit
 * grabs c_send_lock to ensure exclusive access to the send ring.
 * However, the ACK sending code is independent and can race with
 * message SENDs.
 *
 * In the send path, we need to update the counters for send credits
 * and the counter of posted buffers atomically - when we use the
 * last available credit, we cannot allow another thread to race us
 * and grab the posted credits counter.  Hence, we have to use a
 * spinlock to protect the credit counter, or use atomics.
 *
 * Spinlocks shared between the send and the receive path are bad,
 * because they create unnecessary delays. An early implementation
 * using a spinlock showed a 5% degradation in throughput at some
 * loads.
 *
 * This implementation avoids spinlocks completely, putting both
 * counters into a single atomic, and updating that atomic using
 * atomic_add (in the receive path, when receiving fresh credits),
 * and using atomic_cmpxchg when updating the two counters.
 */
int rds_iw_send_grab_credits(struct rds_iw_connection *ic,
			     u32 wanted, u32 *adv_credits, int need_posted, int max_posted)
{
	unsigned int avail, posted, got = 0, advertise;
	long oldval, newval;

	*adv_credits = 0;
	if (!ic->i_flowctl)
		return wanted;

try_again:
	advertise = 0;
	oldval = newval = atomic_read(&ic->i_credits);
	posted = IB_GET_POST_CREDITS(oldval);
	avail = IB_GET_SEND_CREDITS(oldval);

	rdsdebug("rds_iw_send_grab_credits(%u): credits=%u posted=%u\n",
			wanted, avail, posted);

	/* The last credit must be used to send a credit update. */
	if (avail && !posted)
		avail--;

	if (avail < wanted) {
		struct rds_connection *conn = ic->i_cm_id->context;

		/* Oops, there aren't that many credits left! */
		set_bit(RDS_LL_SEND_FULL, &conn->c_flags);
		got = avail;
	} else {
		/* Sometimes you get what you want, lalala. */
		got = wanted;
	}
	newval -= IB_SET_SEND_CREDITS(got);

	/*
	 * If need_posted is non-zero, then the caller wants
	 * the posted regardless of whether any send credits are
	 * available.
	 */
	if (posted && (got || need_posted)) {
		advertise = min_t(unsigned int, posted, max_posted);
		newval -= IB_SET_POST_CREDITS(advertise);
	}

	/* Finally bill everything */
	if (atomic_cmpxchg(&ic->i_credits, oldval, newval) != oldval)
		goto try_again;

	*adv_credits = advertise;
	return got;
}

void rds_iw_send_add_credits(struct rds_connection *conn, unsigned int credits)
{
	struct rds_iw_connection *ic = conn->c_transport_data;

	if (credits == 0)
		return;

	rdsdebug("rds_iw_send_add_credits(%u): current=%u%s\n",
			credits,
			IB_GET_SEND_CREDITS(atomic_read(&ic->i_credits)),
			test_bit(RDS_LL_SEND_FULL, &conn->c_flags) ? ", ll_send_full" : "");

	atomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);
	if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))
		queue_delayed_work(rds_wq, &conn->c_send_w, 0);

	WARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);

	rds_iw_stats_inc(s_iw_rx_credit_updates);
}

void rds_iw_advertise_credits(struct rds_connection *conn, unsigned int posted)
{
	struct rds_iw_connection *ic = conn->c_transport_data;

	if (posted == 0)
		return;

	atomic_add(IB_SET_POST_CREDITS(posted), &ic->i_credits);

	/* Decide whether to send an update to the peer now.
	 * If we would send a credit update for every single buffer we
	 * post, we would end up with an ACK storm (ACK arrives,
	 * consumes buffer, we refill the ring, send ACK to remote
	 * advertising the newly posted buffer... ad inf)
	 *
	 * Performance pretty much depends on how often we send
	 * credit updates - too frequent updates mean lots of ACKs.
	 * Too infrequent updates, and the peer will run out of
	 * credits and has to throttle.
	 * For the time being, 16 seems to be a good compromise.
	 */
	if (IB_GET_POST_CREDITS(atomic_read(&ic->i_credits)) >= 16)
		set_bit(IB_ACK_REQUESTED, &ic->i_ack_flags);
}

static inline void
rds_iw_xmit_populate_wr(struct rds_iw_connection *ic,
		struct rds_iw_send_work *send, unsigned int pos,
		unsigned long buffer, unsigned int length,
		int send_flags)
{
	struct ib_sge *sge;

	WARN_ON(pos != send - ic->i_sends);

	send->s_wr.send_flags = send_flags;
	send->s_wr.opcode = IB_WR_SEND;
	send->s_wr.num_sge = 2;
	send->s_wr.next = NULL;
	send->s_queued = jiffies;
	send->s_op = NULL;

	if (length != 0) {
		sge = rds_iw_data_sge(ic, send->s_sge);
		sge->addr = buffer;
		sge->length = length;
		sge->lkey = rds_iw_local_dma_lkey(ic);

		sge = rds_iw_header_sge(ic, send->s_sge);
	} else {
		/* We're sending a packet with no payload. There is only
		 * one SGE */
		send->s_wr.num_sge = 1;
		sge = &send->s_sge[0];
	}

	sge->addr = ic->i_send_hdrs_dma + (pos * sizeof(struct rds_header));
	sge->length = sizeof(struct rds_header);
	sge->lkey = rds_iw_local_dma_lkey(ic);
}

/*
 * This can be called multiple times for a given message.  The first time
 * we see a message we map its scatterlist into the IB device so that
 * we can provide that mapped address to the IB scatter gather entries
 * in the IB work requests.  We translate the scatterlist into a series
 * of work requests that fragment the message.  These work requests complete
 * in order so we pass ownership of the message to the completion handler
 * once we send the final fragment.
 *
 * The RDS core uses the c_send_lock to only enter this function once
 * per connection.  This makes sure that the tx ring alloc/unalloc pairs
 * don't get out of sync and confuse the ring.
 */
int rds_iw_xmit(struct rds_connection *conn, struct rds_message *rm,
		unsigned int hdr_off, unsigned int sg, unsigned int off)
{
	struct rds_iw_connection *ic = conn->c_transport_data;
	struct ib_device *dev = ic->i_cm_id->device;
	struct rds_iw_send_work *send = NULL;
	struct rds_iw_send_work *first;
	struct rds_iw_send_work *prev;
	struct ib_send_wr *failed_wr;
	struct scatterlist *scat;
	u32 pos;
	u32 i;
	u32 work_alloc;
	u32 credit_alloc;
	u32 posted;
	u32 adv_credits = 0;
	int send_flags = 0;
	int sent;
	int ret;
	int flow_controlled = 0;

	BUG_ON(off % RDS_FRAG_SIZE);
	BUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));

	/* Fastreg support */
	if (rds_rdma_cookie_key(rm->m_rdma_cookie) && !ic->i_fastreg_posted) {
		ret = -EAGAIN;
		goto out;
	}

	/* FIXME we may overallocate here */
	if (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)
		i = 1;
	else
		i = ceil(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);

	work_alloc = rds_iw_ring_alloc(&ic->i_send_ring, i, &pos);
	if (work_alloc == 0) {
		set_bit(RDS_LL_SEND_FULL, &conn->c_flags);
		rds_iw_stats_inc(s_iw_tx_ring_full);
		ret = -ENOMEM;
		goto out;
	}

	credit_alloc = work_alloc;
	if (ic->i_flowctl) {
		credit_alloc = rds_iw_send_grab_credits(ic, work_alloc, &posted, 0, RDS_MAX_ADV_CREDIT);
		adv_credits += posted;
		if (credit_alloc < work_alloc) {
			rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc - credit_alloc);
			work_alloc = credit_alloc;
			flow_controlled++;
		}
		if (work_alloc == 0) {
			set_bit(RDS_LL_SEND_FULL, &conn->c_flags);
			rds_iw_stats_inc(s_iw_tx_throttle);
			ret = -ENOMEM;
			goto out;
		}
	}

	/* map the message the first time we see it */
	if (!ic->i_rm) {
		/*
		printk(KERN_NOTICE "rds_iw_xmit prep msg dport=%u flags=0x%x len=%d\n",
				be16_to_cpu(rm->m_inc.i_hdr.h_dport),
				rm->m_inc.i_hdr.h_flags,
				be32_to_cpu(rm->m_inc.i_hdr.h_len));
		   */
		if (rm->data.op_nents) {
			rm->data.op_count = ib_dma_map_sg(dev,
							  rm->data.op_sg,
							  rm->data.op_nents,
							  DMA_TO_DEVICE);
			rdsdebug("ic %p mapping rm %p: %d\n", ic, rm, rm->data.op_count);
			if (rm->data.op_count == 0) {
				rds_iw_stats_inc(s_iw_tx_sg_mapping_failure);
				rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc);
				ret = -ENOMEM; /* XXX ? */
				goto out;
			}
		} else {
			rm->data.op_count = 0;
		}

		ic->i_unsignaled_wrs = rds_iw_sysctl_max_unsig_wrs;
		ic->i_unsignaled_bytes = rds_iw_sysctl_max_unsig_bytes;
		rds_message_addref(rm);
		ic->i_rm = rm;

		/* Finalize the header */
		if (test_bit(RDS_MSG_ACK_REQUIRED, &rm->m_flags))
			rm->m_inc.i_hdr.h_flags |= RDS_FLAG_ACK_REQUIRED;
		if (test_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags))
			rm->m_inc.i_hdr.h_flags |= RDS_FLAG_RETRANSMITTED;

		/* If it has a RDMA op, tell the peer we did it. This is
		 * used by the peer to release use-once RDMA MRs. */
		if (rm->rdma.op_active) {
			struct rds_ext_header_rdma ext_hdr;

			ext_hdr.h_rdma_rkey = cpu_to_be32(rm->rdma.op_rkey);
			rds_message_add_extension(&rm->m_inc.i_hdr,
					RDS_EXTHDR_RDMA, &ext_hdr, sizeof(ext_hdr));
		}
		if (rm->m_rdma_cookie) {
			rds_message_add_rdma_dest_extension(&rm->m_inc.i_hdr,
					rds_rdma_cookie_key(rm->m_rdma_cookie),
					rds_rdma_cookie_offset(rm->m_rdma_cookie));
		}

		/* Note - rds_iw_piggyb_ack clears the ACK_REQUIRED bit, so
		 * we should not do this unless we have a chance of at least
		 * sticking the header into the send ring. Which is why we
		 * should call rds_iw_ring_alloc first. */
		rm->m_inc.i_hdr.h_ack = cpu_to_be64(rds_iw_piggyb_ack(ic));
		rds_message_make_checksum(&rm->m_inc.i_hdr);

		/*
		 * Update adv_credits since we reset the ACK_REQUIRED bit.
		 */
		rds_iw_send_grab_credits(ic, 0, &posted, 1, RDS_MAX_ADV_CREDIT - adv_credits);
		adv_credits += posted;
		BUG_ON(adv_credits > 255);
	}

	send = &ic->i_sends[pos];
	first = send;
	prev = NULL;
	scat = &rm->data.op_sg[sg];
	sent = 0;
	i = 0;

	/* Sometimes you want to put a fence between an RDMA
	 * READ and the following SEND.
	 * We could either do this all the time
	 * or when requested by the user. Right now, we let
	 * the application choose.
	 */
	if (rm->rdma.op_active && rm->rdma.op_fence)
		send_flags = IB_SEND_FENCE;

	/*
	 * We could be copying the header into the unused tail of the page.
	 * That would need to be changed in the future when those pages might
	 * be mapped userspace pages or page cache pages.  So instead we always
	 * use a second sge and our long-lived ring of mapped headers.  We send
	 * the header after the data so that the data payload can be aligned on
	 * the receiver.
	 */

	/* handle a 0-len message */
	if (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0) {
		rds_iw_xmit_populate_wr(ic, send, pos, 0, 0, send_flags);
		goto add_header;
	}

	/* if there's data reference it with a chain of work reqs */
	for (; i < work_alloc && scat != &rm->data.op_sg[rm->data.op_count]; i++) {
		unsigned int len;

		send = &ic->i_sends[pos];

		len = min(RDS_FRAG_SIZE, ib_sg_dma_len(dev, scat) - off);
		rds_iw_xmit_populate_wr(ic, send, pos,
				ib_sg_dma_address(dev, scat) + off, len,
				send_flags);

		/*
		 * We want to delay signaling completions just enough to get
		 * the batching benefits but not so much that we create dead time
		 * on the wire.
		 */
		if (ic->i_unsignaled_wrs-- == 0) {
			ic->i_unsignaled_wrs = rds_iw_sysctl_max_unsig_wrs;
			send->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;
		}

		ic->i_unsignaled_bytes -= len;
		if (ic->i_unsignaled_bytes <= 0) {
			ic->i_unsignaled_bytes = rds_iw_sysctl_max_unsig_bytes;
			send->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;
		}

		/*
		 * Always signal the last one if we're stopping due to flow control.
		 */
		if (flow_controlled && i == (work_alloc-1))
			send->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;

		rdsdebug("send %p wr %p num_sge %u next %p\n", send,
			 &send->s_wr, send->s_wr.num_sge, send->s_wr.next);

		sent += len;
		off += len;
		if (off == ib_sg_dma_len(dev, scat)) {
			scat++;
			off = 0;
		}

add_header:
		/* Tack on the header after the data. The header SGE should already
		 * have been set up to point to the right header buffer. */
		memcpy(&ic->i_send_hdrs[pos], &rm->m_inc.i_hdr, sizeof(struct rds_header));

		if (0) {
			struct rds_header *hdr = &ic->i_send_hdrs[pos];

			printk(KERN_NOTICE "send WR dport=%u flags=0x%x len=%d\n",
				be16_to_cpu(hdr->h_dport),
				hdr->h_flags,
				be32_to_cpu(hdr->h_len));
		}
		if (adv_credits) {
			struct rds_header *hdr = &ic->i_send_hdrs[pos];

			/* add credit and redo the header checksum */
			hdr->h_credit = adv_credits;
			rds_message_make_checksum(hdr);
			adv_credits = 0;
			rds_iw_stats_inc(s_iw_tx_credit_updates);
		}

		if (prev)
			prev->s_wr.next = &send->s_wr;
		prev = send;

		pos = (pos + 1) % ic->i_send_ring.w_nr;
	}

	/* Account the RDS header in the number of bytes we sent, but just once.
	 * The caller has no concept of fragmentation. */
	if (hdr_off == 0)
		sent += sizeof(struct rds_header);

	/* if we finished the message then send completion owns it */
	if (scat == &rm->data.op_sg[rm->data.op_count]) {
		prev->s_rm = ic->i_rm;
		prev->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;
		ic->i_rm = NULL;
	}

	if (i < work_alloc) {
		rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc - i);
		work_alloc = i;
	}
	if (ic->i_flowctl && i < credit_alloc)
		rds_iw_send_add_credits(conn, credit_alloc - i);

	/* XXX need to worry about failed_wr and partial sends. */
	failed_wr = &first->s_wr;
	ret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);
	rdsdebug("ic %p first %p (wr %p) ret %d wr %p\n", ic,
		 first, &first->s_wr, ret, failed_wr);
	BUG_ON(failed_wr != &first->s_wr);
	if (ret) {
		printk(KERN_WARNING "RDS/IW: ib_post_send to %pI4 "
		       "returned %d\n", &conn->c_faddr, ret);
		rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc);
		if (prev->s_rm) {
			ic->i_rm = prev->s_rm;
			prev->s_rm = NULL;
		}
		goto out;
	}

	ret = sent;
out:
	BUG_ON(adv_credits);
	return ret;
}

static void rds_iw_build_send_fastreg(struct rds_iw_device *rds_iwdev, struct rds_iw_connection *ic, struct rds_iw_send_work *send, int nent, int len, u64 sg_addr)
{
	BUG_ON(nent > send->s_page_list->max_page_list_len);
	/*
	 * Perform a WR for the fast_reg_mr. Each individual page
	 * in the sg list is added to the fast reg page list and placed
	 * inside the fast_reg_mr WR.
	 */
	send->s_wr.opcode = IB_WR_FAST_REG_MR;
	send->s_wr.wr.fast_reg.length = len;
	send->s_wr.wr.fast_reg.rkey = send->s_mr->rkey;
	send->s_wr.wr.fast_reg.page_list = send->s_page_list;
	send->s_wr.wr.fast_reg.page_list_len = nent;
	send->s_wr.wr.fast_reg.page_shift = PAGE_SHIFT;
	send->s_wr.wr.fast_reg.access_flags = IB_ACCESS_REMOTE_WRITE;
	send->s_wr.wr.fast_reg.iova_start = sg_addr;

	ib_update_fast_reg_key(send->s_mr, send->s_remap_count++);
}

int rds_iw_xmit_rdma(struct rds_connection *conn, struct rm_rdma_op *op)
{
	struct rds_iw_connection *ic = conn->c_transport_data;
	struct rds_iw_send_work *send = NULL;
	struct rds_iw_send_work *first;
	struct rds_iw_send_work *prev;
	struct ib_send_wr *failed_wr;
	struct rds_iw_device *rds_iwdev;
	struct scatterlist *scat;
	unsigned long len;
	u64 remote_addr = op->op_remote_addr;
	u32 pos, fr_pos;
	u32 work_alloc;
	u32 i;
	u32 j;
	int sent;
	int ret;
	int num_sge;

	rds_iwdev = ib_get_client_data(ic->i_cm_id->device, &rds_iw_client);

	/* map the message the first time we see it */
	if (!op->op_mapped) {
		op->op_count = ib_dma_map_sg(ic->i_cm_id->device,
					     op->op_sg, op->op_nents, (op->op_write) ?
					     DMA_TO_DEVICE : DMA_FROM_DEVICE);
		rdsdebug("ic %p mapping op %p: %d\n", ic, op, op->op_count);
		if (op->op_count == 0) {
			rds_iw_stats_inc(s_iw_tx_sg_mapping_failure);
			ret = -ENOMEM; /* XXX ? */
			goto out;
		}

		op->op_mapped = 1;
	}

	if (!op->op_write) {
		/* Alloc space on the send queue for the fastreg */
		work_alloc = rds_iw_ring_alloc(&ic->i_send_ring, 1, &fr_pos);
		if (work_alloc != 1) {
			rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc);
			rds_iw_stats_inc(s_iw_tx_ring_full);
			ret = -ENOMEM;
			goto out;
		}
	}

	/*
	 * Instead of knowing how to return a partial rdma read/write we insist that there
	 * be enough work requests to send the entire message.
	 */
	i = ceil(op->op_count, rds_iwdev->max_sge);

	work_alloc = rds_iw_ring_alloc(&ic->i_send_ring, i, &pos);
	if (work_alloc != i) {
		rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc);
		rds_iw_stats_inc(s_iw_tx_ring_full);
		ret = -ENOMEM;
		goto out;
	}

	send = &ic->i_sends[pos];
	if (!op->op_write) {
		first = prev = &ic->i_sends[fr_pos];
	} else {
		first = send;
		prev = NULL;
	}
	scat = &op->op_sg[0];
	sent = 0;
	num_sge = op->op_count;

	for (i = 0; i < work_alloc && scat != &op->op_sg[op->op_count]; i++) {
		send->s_wr.send_flags = 0;
		send->s_queued = jiffies;

		/*
		 * We want to delay signaling completions just enough to get
		 * the batching benefits but not so much that we create dead time on the wire.
		 */
		if (ic->i_unsignaled_wrs-- == 0) {
			ic->i_unsignaled_wrs = rds_iw_sysctl_max_unsig_wrs;
			send->s_wr.send_flags = IB_SEND_SIGNALED;
		}

		/* To avoid the need to have the plumbing to invalidate the fastreg_mr used
		 * for local access after RDS is finished with it, using
		 * IB_WR_RDMA_READ_WITH_INV will invalidate it after the read has completed.
		 */
		if (op->op_write)
			send->s_wr.opcode = IB_WR_RDMA_WRITE;
		else
			send->s_wr.opcode = IB_WR_RDMA_READ_WITH_INV;

		send->s_wr.wr.rdma.remote_addr = remote_addr;
		send->s_wr.wr.rdma.rkey = op->op_rkey;
		send->s_op = op;

		if (num_sge > rds_iwdev->max_sge) {
			send->s_wr.num_sge = rds_iwdev->max_sge;
			num_sge -= rds_iwdev->max_sge;
		} else
			send->s_wr.num_sge = num_sge;

		send->s_wr.next = NULL;

		if (prev)
			prev->s_wr.next = &send->s_wr;

		for (j = 0; j < send->s_wr.num_sge && scat != &op->op_sg[op->op_count]; j++) {
			len = ib_sg_dma_len(ic->i_cm_id->device, scat);

			if (send->s_wr.opcode == IB_WR_RDMA_READ_WITH_INV)
				send->s_page_list->page_list[j] = ib_sg_dma_address(ic->i_cm_id->device, scat);
			else {
				send->s_sge[j].addr = ib_sg_dma_address(ic->i_cm_id->device, scat);
				send->s_sge[j].length = len;
				send->s_sge[j].lkey = rds_iw_local_dma_lkey(ic);
			}

			sent += len;
			rdsdebug("ic %p sent %d remote_addr %llu\n", ic, sent, remote_addr);
			remote_addr += len;

			scat++;
		}

		if (send->s_wr.opcode == IB_WR_RDMA_READ_WITH_INV) {
			send->s_wr.num_sge = 1;
			send->s_sge[0].addr = conn->c_xmit_rm->m_rs->rs_user_addr;
			send->s_sge[0].length = conn->c_xmit_rm->m_rs->rs_user_bytes;
			send->s_sge[0].lkey = ic->i_sends[fr_pos].s_mr->lkey;
		}

		rdsdebug("send %p wr %p num_sge %u next %p\n", send,
			&send->s_wr, send->s_wr.num_sge, send->s_wr.next);

		prev = send;
		if (++send == &ic->i_sends[ic->i_send_ring.w_nr])
			send = ic->i_sends;
	}

	/* if we finished the message then send completion owns it */
	if (scat == &op->op_sg[op->op_count])
		first->s_wr.send_flags = IB_SEND_SIGNALED;

	if (i < work_alloc) {
		rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc - i);
		work_alloc = i;
	}

	/* On iWARP, local memory access by a remote system (ie, RDMA Read) is not
	 * recommended.  Putting the lkey on the wire is a security hole, as it can
	 * allow for memory access to all of memory on the remote system.  Some
	 * adapters do not allow using the lkey for this at all.  To bypass this use a
	 * fastreg_mr (or possibly a dma_mr)
	 */
	if (!op->op_write) {
		rds_iw_build_send_fastreg(rds_iwdev, ic, &ic->i_sends[fr_pos],
			op->op_count, sent, conn->c_xmit_rm->m_rs->rs_user_addr);
		work_alloc++;
	}

	failed_wr = &first->s_wr;
	ret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);
	rdsdebug("ic %p first %p (wr %p) ret %d wr %p\n", ic,
		 first, &first->s_wr, ret, failed_wr);
	BUG_ON(failed_wr != &first->s_wr);
	if (ret) {
		printk(KERN_WARNING "RDS/IW: rdma ib_post_send to %pI4 "
		       "returned %d\n", &conn->c_faddr, ret);
		rds_iw_ring_unalloc(&ic->i_send_ring, work_alloc);
		goto out;
	}

out:
	return ret;
}

void rds_iw_xmit_complete(struct rds_connection *conn)
{
	struct rds_iw_connection *ic = conn->c_transport_data;

	/* We may have a pending ACK or window update we were unable
	 * to send previously (due to flow control). Try again. */
	rds_iw_attempt_ack(ic);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* Data structs */

static u16 asEqCoefsZeros[50] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

static u16 asEqCoefsPipes[64] = {
	0x0000, 0x0000,
	0x0000, 0x0666, 0x0000, 0x0000, 0x0666,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0666, 0x0000, 0x0000, 0x0666,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0666, 0x0000, 0x0000, 0x0666,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0666, 0x0000, 0x0000, 0x0666,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0666, 0x0000, 0x0000, 0x066a,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000
};

/* More coef sets can be found in the win2k "inf" file. */
static auxxEqCoeffSet_t asEqCoefsNormal = {
	.LeftCoefs = {
		      0x7e60, 0xc19e, 0x0001, 0x0002, 0x0001,
		      0x7fa0, 0xc05f, 0x004f, 0x0000, 0xffb1,
		      0x7f3f, 0xc0bc, 0x00c2, 0x0000, 0xff3e,
		      0x7e78, 0xc177, 0x011f, 0x0000, 0xfee1,
		      0x7cd6, 0xc2e5, 0x025c, 0x0000, 0xfda4,
		      0x7949, 0xc5aa, 0x0467, 0x0000, 0xfb99,
		      0x7120, 0xcadf, 0x0864, 0x0000, 0xf79c,
		      0x5d33, 0xd430, 0x0f7e, 0x0000, 0xf082,
		      0x2beb, 0xe3ca, 0x1bd3, 0x0000, 0xe42d,
		      0xd740, 0xf01d, 0x2ac5, 0x0000, 0xd53b},

	.RightCoefs = {
		       0x7e60, 0xc19e, 0x0001, 0x0002, 0x0001,
		       0x7fa0, 0xc05f, 0x004f, 0x0000, 0xffb1,
		       0x7f3f, 0xc0bc, 0x00c2, 0x0000, 0xff3e,
		       0x7e78, 0xc177, 0x011f, 0x0000, 0xfee1,
		       0x7cd6, 0xc2e5, 0x025c, 0x0000, 0xfda4,
		       0x7949, 0xc5aa, 0x0467, 0x0000, 0xfb99,
		       0x7120, 0xcadf, 0x0864, 0x0000, 0xf79c,
		       0x5d33, 0xd430, 0x0f7e, 0x0000, 0xf082,
		       0x2beb, 0xe3ca, 0x1bd3, 0x0000, 0xe42d,
		       0xd740, 0xf01d, 0x2ac5, 0x0000, 0xd53b},

	.LeftGains = {
		      0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96,
		      0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96},
	.RightGains = {
		       0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96,
		       0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96}
};

static u16 eq_gains_normal[20] = {
	0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96,
	0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96,
	0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96,
	0x3e96, 0x3e96, 0x3e96, 0x3e96, 0x3e96
};

/* _rodatab60 */
static u16 eq_gains_zero[10] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

/* _rodatab7c:  ProgramPipe */
static u16 eq_gains_current[12] = {
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff,
	0x7fff,
	0x7fff, 0x7fff, 0x7fff
};

/* _rodatab78 */
static u16 eq_states_zero[2] = { 0x0000, 0x0000 };

static u16 asEqOutStateZeros[48] = {
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000
};

/*_rodataba0:*/
static u16 eq_levels[64] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};
                                                                                                                                                /*
 * spitz.c  --  SoC audio for Sharp SL-Cxx00 models Spitz, Borzoi and Akita
 *
 * Copyright 2005 Wolfson Microelectronics PLC.
 * Copyright 2005 Openedhand Ltd.
 *
 * Authors: Liam Girdwood <lrg@slimlogic.co.uk>
 *          Richard Purdie <richard@openedhand.com>
 *
 *  This program is free software; you can redistribute  it and/or modify it
 *  under  the terms of  the GNU General  Public License as published by the
 *  Free Software Foundation;  either version 2 of the  License, or (at your
 *  option) any later version.
 *
 */

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/timer.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>
#include <linux/gpio.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/soc.h>

#include <asm/mach-types.h>
#include <mach/spitz.h>
#include "../codecs/wm8750.h"
#include "pxa2xx-i2s.h"

#define SPITZ_HP        0
#define SPITZ_MIC       1
#define SPITZ_LINE      2
#define SPITZ_HEADSET   3
#define SPITZ_HP_OFF    4
#define SPITZ_SPK_ON    0
#define SPITZ_SPK_OFF   1

 /* audio clock in Hz - rounded from 12.235MHz */
#define SPITZ_AUDIO_CLOCK 12288000

static int spitz_jack_func;
static int spitz_spk_func;
static int spitz_mic_gpio;

static void spitz_ext_control(struct snd_soc_dapm_context *dapm)
{
	snd_soc_dapm_mutex_lock(dapm);

	if (spitz_spk_func == SPITZ_SPK_ON)
		snd_soc_dapm_enable_pin_unlocked(dapm, "Ext Spk");
	else
		snd_soc_dapm_disable_pin_unlocked(dapm, "Ext Spk");

	/* set up jack connection */
	switch (spitz_jack_func) {
	case SPITZ_HP:
		/* enable and unmute hp jack, disable mic bias */
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headset Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Mic Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Line Jack");
		snd_soc_dapm_enable_pin_unlocked(dapm, "Headphone Jack");
		gpio_set_value(SPITZ_GPIO_MUTE_L, 1);
		gpio_set_value(SPITZ_GPIO_MUTE_R, 1);
		break;
	case SPITZ_MIC:
		/* enable mic jack and bias, mute hp */
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headphone Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headset Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Line Jack");
		snd_soc_dapm_enable_pin_unlocked(dapm, "Mic Jack");
		gpio_set_value(SPITZ_GPIO_MUTE_L, 0);
		gpio_set_value(SPITZ_GPIO_MUTE_R, 0);
		break;
	case SPITZ_LINE:
		/* enable line jack, disable mic bias and mute hp */
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headphone Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headset Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Mic Jack");
		snd_soc_dapm_enable_pin_unlocked(dapm, "Line Jack");
		gpio_set_value(SPITZ_GPIO_MUTE_L, 0);
		gpio_set_value(SPITZ_GPIO_MUTE_R, 0);
		break;
	case SPITZ_HEADSET:
		/* enable and unmute headset jack enable mic bias, mute L hp */
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headphone Jack");
		snd_soc_dapm_enable_pin_unlocked(dapm, "Mic Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Line Jack");
		snd_soc_dapm_enable_pin_unlocked(dapm, "Headset Jack");
		gpio_set_value(SPITZ_GPIO_MUTE_L, 0);
		gpio_set_value(SPITZ_GPIO_MUTE_R, 1);
		break;
	case SPITZ_HP_OFF:

		/* jack removed, everything off */
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headphone Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Headset Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Mic Jack");
		snd_soc_dapm_disable_pin_unlocked(dapm, "Line Jack");
		gpio_set_value(SPITZ_GPIO_MUTE_L, 0);
		gpio_set_value(SPITZ_GPIO_MUTE_R, 0);
		break;
	}

	snd_soc_dapm_sync_unlocked(dapm);

	snd_soc_dapm_mutex_unlock(dapm);
}

static int spitz_startup(struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;

	/* check the jack status at stream startup */
	spitz_ext_control(&rtd->card->dapm);

	return 0;
}

static int spitz_hw_params(struct snd_pcm_substream *substream,
	struct snd_pcm_hw_params *params)
{
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;
	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
	unsigned int clk = 0;
	int ret = 0;

	switch (params_rate(params)) {
	case 8000:
	case 16000:
	case 48000:
	case 96000:
		clk = 12288000;
		break;
	case 11025:
	case 22050:
	case 44100:
		clk = 11289600;
		break;
	}

	/* set the codec system clock for DAC and ADC */
	ret = snd_soc_dai_set_sysclk(codec_dai, WM8750_SYSCLK, clk,
		SND_SOC_CLOCK_IN);
	if (ret < 0)
		return ret;

	/* set the I2S system clock as input (unused) */
	ret = snd_soc_dai_set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,
		SND_SOC_CLOCK_IN);
	if (ret < 0)
		return ret;

	return 0;
}

static struct snd_soc_ops spitz_ops = {
	.startup = spitz_startup,
	.hw_params = spitz_hw_params,
};

static int spitz_get_jack(struct snd_kcontrol *kcontrol,
	struct snd_ctl_elem_value *ucontrol)
{
	ucontrol->value.integer.value[0] = spitz_jack_func;
	return 0;
}

static int spitz_set_jack(struct snd_kcontrol *kcontrol,
	struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);

	if (spitz_jack_func == ucontrol->value.integer.value[0])
		return 0;

	spitz_jack_func = ucontrol->value.integer.value[0];
	spitz_ext_control(&card->dapm);
	return 1;
}

static int spitz_get_spk(struct snd_kcontrol *kcontrol,
	struct snd_ctl_elem_value *ucontrol)
{
	ucontrol->value.integer.value[0] = spitz_spk_func;
	return 0;
}

static int spitz_set_spk(struct snd_kcontrol *kcontrol,
	struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);

	if (spitz_spk_func == ucontrol->value.integer.value[0])
		return 0;

	spitz_spk_func = ucontrol->value.integer.value[0];
	spitz_ext_control(&card->dapm);
	return 1;
}

static int spitz_mic_bias(struct snd_soc_dapm_widget *w,
	struct snd_kcontrol *k, int event)
{
	gpio_set_value_cansleep(spitz_mic_gpio, SND_SOC_DAPM_EVENT_ON(event));
	return 0;
}

/* spitz machine dapm widgets */
static const struct snd_soc_dapm_widget wm8750_dapm_widgets[] = {
	SND_SOC_DAPM_HP("Headphone Jack", NULL),
	SND_SOC_DAPM_MIC("Mic Jack", spitz_mic_bias),
	SND_SOC_DAPM_SPK("Ext Spk", NULL),
	SND_SOC_DAPM_LINE("Line Jack", NULL),

	/* headset is a mic and mono headphone */
	SND_SOC_DAPM_HP("Headset Jack", NULL),
};

/* Spitz machine audio_map */
static const struct snd_soc_dapm_route spitz_audio_map[] = {

	/* headphone connected to LOUT1, ROUT1 */
	{"Headphone Jack", NULL, "LOUT1"},
	{"Headphone Jack", NULL, "ROUT1"},

	/* headset connected to ROUT1 and LINPUT1 with bias (def below) */
	{"Headset Jack", NULL, "ROUT1"},

	/* ext speaker connected to LOUT2, ROUT2  */
	{"Ext Spk", NULL , "ROUT2"},
	{"Ext Spk", NULL , "LOUT2"},

	/* mic is connected to input 1 - with bias */
	{"LINPUT1", NULL, "Mic Bias"},
	{"Mic Bias", NULL, "Mic Jack"},

	/* line is connected to input 1 - no bias */
	{"LINPUT1", NULL, "Line Jack"},
};

static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
	"Off"};
static const char *spk_function[] = {"On", "Off"};
static const struct soc_enum spitz_enum[] = {
	SOC_ENUM_SINGLE_EXT(5, jack_function),
	SOC_ENUM_SINGLE_EXT(2, spk_function),
};

static const struct snd_kcontrol_new wm8750_spitz_controls[] = {
	SOC_ENUM_EXT("Jack Function", spitz_enum[0], spitz_get_jack,
		spitz_set_jack),
	SOC_ENUM_EXT("Speaker Function", spitz_enum[1], spitz_get_spk,
		spitz_set_spk),
};

/*
 * Logic for a wm8750 as connected on a Sharp SL-Cxx00 Device
 */
static int spitz_wm8750_init(struct snd_soc_pcm_runtime *rtd)
{
	struct snd_soc_codec *codec = rtd->codec;
	struct snd_soc_dapm_context *dapm = &codec->dapm;

	/* NC codec pins */
	snd_soc_dapm_nc_pin(dapm, "RINPUT1");
	snd_soc_dapm_nc_pin(dapm, "LINPUT2");
	snd_soc_dapm_nc_pin(dapm, "RINPUT2");
	snd_soc_dapm_nc_pin(dapm, "LINPUT3");
	snd_soc_dapm_nc_pin(dapm, "RINPUT3");
	snd_soc_dapm_nc_pin(dapm, "OUT3");
	snd_soc_dapm_nc_pin(dapm, "MONO1");

	return 0;
}

/* spitz digital audio interface glue - connects codec <--> CPU */
static struct snd_soc_dai_link spitz_dai = {
	.name = "wm8750",
	.stream_name = "WM8750",
	.cpu_dai_name = "pxa2xx-i2s",
	.codec_dai_name = "wm8750-hifi",
	.platform_name = "pxa-pcm-audio",
	.codec_name = "wm8750.0-001b",
	.init = spitz_wm8750_init,
	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
		   SND_SOC_DAIFMT_CBS_CFS,
	.ops = &spitz_ops,
};

/* spitz audio machine driver */
static struct snd_soc_card snd_soc_spitz = {
	.name = "Spitz",
	.owner = THIS_MODULE,
	.dai_link = &spitz_dai,
	.num_links = 1,

	.controls = wm8750_spitz_controls,
	.num_controls = ARRAY_SIZE(wm8750_spitz_controls),
	.dapm_widgets = wm8750_dapm_widgets,
	.num_dapm_widgets = ARRAY_SIZE(wm8750_dapm_widgets),
	.dapm_routes = spitz_audio_map,
	.num_dapm_routes = ARRAY_SIZE(spitz_audio_map),
};

static struct platform_device *spitz_snd_device;

static int __init spitz_init(void)
{
	int ret;

	if (!(machine_is_spitz() || machine_is_borzoi() || machine_is_akita()))
		return -ENODEV;

	if (machine_is_borzoi() || machine_is_spitz())
		spitz_mic_gpio = SPITZ_GPIO_MIC_BIAS;
	else
		spitz_mic_gpio = AKITA_GPIO_MIC_BIAS;

	ret = gpio_request(spitz_mic_gpio, "MIC GPIO");
	if (ret)
		goto err1;

	ret = gpio_direction_output(spitz_mic_gpio, 0);
	if (ret)
		goto err2;

	spitz_snd_device = platform_device_alloc("soc-audio", -1);
	if (!spitz_snd_device) {
		ret = -ENOMEM;
		goto err2;
	}

	platform_set_drvdata(spitz_snd_device, &snd_soc_spitz);

	ret = platform_device_add(spitz_snd_device);
	if (ret)
		goto err3;

	return 0;

err3:
	platform_device_put(spitz_snd_device);
err2:
	gpio_free(spitz_mic_gpio);
err1:
	return ret;
}

static void __exit spitz_exit(void)
{
	platform_device_unregister(spitz_snd_device);
	gpio_free(spitz_mic_gpio);
}

module_init(spitz_init);
module_exit(spitz_exit);

MODULE_AUTHOR("Richard Purdie");
MODULE_DESCRIPTION("ALSA SoC Spitz");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 *  Shared Memory Communications over RDMA (SMC-R) and RoCE
 *
 *  Definitions for generic netlink based configuration of an SMC-R PNET table
 *
 *  Copyright IBM Corp. 2016
 *
 *  Author(s):  Thomas Richter <tmricht@linux.vnet.ibm.com>
 */

#ifndef _LINUX_SMC_H_
#define _LINUX_SMC_H_

/* Netlink SMC_PNETID attributes */
enum {
	SMC_PNETID_UNSPEC,
	SMC_PNETID_NAME,
	SMC_PNETID_ETHNAME,
	SMC_PNETID_IBNAME,
	SMC_PNETID_IBPORT,
	__SMC_PNETID_MAX,
	SMC_PNETID_MAX = __SMC_PNETID_MAX - 1
};

enum {				/* SMC PNET Table commands */
	SMC_PNETID_GET = 1,
	SMC_PNETID_ADD,
	SMC_PNETID_DEL,
	SMC_PNETID_FLUSH
};

#define SMCR_GENL_FAMILY_NAME		"SMC_PNETID"
#define SMCR_GENL_FAMILY_VERSION	1

#endif /* _LINUX_SMC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* Copyright (C) 1991-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

#ifndef _LIMITS_H___
#define _LIMITS_H___

/* Number of bits in a `char'.  */
#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__

/* Maximum length of a multibyte character.  */
#ifndef MB_LEN_MAX
#define MB_LEN_MAX 1
#endif

/* Minimum and maximum values a `signed char' can hold.  */
#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__

/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
#undef UCHAR_MAX
#if __SCHAR_MAX__ == __INT_MAX__
# define UCHAR_MAX (SCHAR_MAX * 2U + 1U)
#else
# define UCHAR_MAX (SCHAR_MAX * 2 + 1)
#endif

/* Minimum and maximum values a `char' can hold.  */
#ifdef __CHAR_UNSIGNED__
# undef CHAR_MIN
# if __SCHAR_MAX__ == __INT_MAX__
#  define CHAR_MIN 0U
# else
#  define CHAR_MIN 0
# endif
# undef CHAR_MAX
# define CHAR_MAX UCHAR_MAX
#else
# undef CHAR_MIN
# define CHAR_MIN SCHAR_MIN
# undef CHAR_MAX
# define CHAR_MAX SCHAR_MAX
#endif

/* Minimum and maximum values a `signed short int' can hold.  */
#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
#undef USHRT_MAX
#if __SHRT_MAX__ == __INT_MAX__
# define USHRT_MAX (SHRT_MAX * 2U + 1U)
#else
# define USHRT_MAX (SHRT_MAX * 2 + 1)
#endif

/* Minimum and maximum values a `signed int' can hold.  */
#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__

/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)

/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */
#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
/* Minimum and maximum values a `signed long long int' can hold.  */
# undef LLONG_MIN
# define LLONG_MIN (-LLONG_MAX - 1LL)
# undef LLONG_MAX
# define LLONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
# undef ULLONG_MAX
# define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
#endif

#if defined (__GNU_LIBRARY__) ? defined (__USE_GNU) : !defined (__STRICT_ANSI__)
/* Minimum and maximum values a `signed long long int' can hold.  */
# undef LONG_LONG_MIN
# define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)
# undef LONG_LONG_MAX
# define LONG_LONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
# undef ULONG_LONG_MAX
# define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)
#endif

#ifdef __STDC_WANT_IEC_60559_BFP_EXT__
/* TS 18661-1 widths of integer types.  */
# undef CHAR_WIDTH
# define CHAR_WIDTH __SCHAR_WIDTH__
# undef SCHAR_WIDTH
# define SCHAR_WIDTH __SCHAR_WIDTH__
# undef UCHAR_WIDTH
# define UCHAR_WIDTH __SCHAR_WIDTH__
# undef SHRT_WIDTH
# define SHRT_WIDTH __SHRT_WIDTH__
# undef USHRT_WIDTH
# define USHRT_WIDTH __SHRT_WIDTH__
# undef INT_WIDTH
# define INT_WIDTH __INT_WIDTH__
# undef UINT_WIDTH
# define UINT_WIDTH __INT_WIDTH__
# undef LONG_WIDTH
# define LONG_WIDTH __LONG_WIDTH__
# undef ULONG_WIDTH
# define ULONG_WIDTH __LONG_WIDTH__
# undef LLONG_WIDTH
# define LLONG_WIDTH __LONG_LONG_WIDTH__
# undef ULLONG_WIDTH
# define ULLONG_WIDTH __LONG_LONG_WIDTH__
#endif

#endif /* _LIMITS_H___ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        INDX( 	                 (                                     h T         5T 3uH9uH9htH9                       	 w a k e l o c k s                   5T 3 h2T 3htH9                       	 w a k e l o c k s                   5T 3 h2T 3htH9                       	 w a k e l o c k s                       S 3 h2S 3S 3                         w a k e l o c k s . h                   S 3 h2S 3 S 3                         w a k e l o c k s . h               S 3 h2S 3S 3                         w a k e l o c k s . h                   S 3 h2S 3S 3                         w a k e l o c k s . h               S 3 h2S 3S 3                         w a k e l o c k s . h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        cmd_fs/cifs/transport.o := /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/aarch64-linux-gnu-gcc -Wp,-MD,fs/cifs/.transport.o.d  -nostdinc -isystem /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/../lib/gcc/aarch64-linux-gnu/7.3.1/include -I../arch/arm64/include -Iarch/arm64/include/generated  -I../include -Iinclude -I../arch/arm64/include/uapi -Iarch/arm64/include/generated/uapi -I../include/uapi -Iinclude/generated/uapi -include ../include/linux/kconfig.h   -I../fs/cifs -Ifs/cifs -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -mgeneral-regs-only -fno-pic -fstack-usage -mpc-relative-literal-loads -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -fno-PIE -Os -Wno-maybe-uninitialized -fno-store-merging -Wno-misleading-indentation -Wno-duplicate-decl-specifier -Wno-logical-not-parentheses --param=allow-store-data-races=0 -Werror=frame-larger-than=1 -Wframe-larger-than=1400 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -DCC_HAVE_ASM_GOTO -Werror    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(transport)"  -D"KBUILD_MODNAME=KBUILD_STR(cifs)" -c -o fs/cifs/transport.o ../fs/cifs/transport.c

source_fs/cifs/transport.o := ../fs/cifs/transport.c

deps_fs/cifs/transport.o := \
    $(wildcard include/config/cifs/stats2.h) \
  ../include/linux/fs.h \
    $(wildcard include/config/sysfs.h) \
    $(wildcard include/config/smp.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/ima.h) \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/debug/lock/alloc.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  ../include/linux/linkage.h \
  ../include/linux/compiler.h \
    $(wildcard include/config/sparse/rcu/pointer.h) \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/64bit.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
    $(wildcard include/config/kprobes.h) \
  ../include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
    $(wildcard include/config/gcov/kernel.h) \
    $(wildcard include/config/arch/use/builtin/bswap.h) \
  ../include/uapi/linux/types.h \
  arch/arm64/include/generated/asm/types.h \
  ../include/uapi/asm-generic/types.h \
  ../include/asm-generic/int-ll64.h \
  ../include/uapi/asm-generic/int-ll64.h \
  ../arch/arm64/include/uapi/asm/bitsperlong.h \
  ../include/asm-generic/bitsperlong.h \
  ../include/uapi/asm-generic/bitsperlong.h \
  ../include/uapi/linux/posix_types.h \
  ../include/linux/stddef.h \
  ../include/uapi/linux/stddef.h \
  ../arch/arm64/include/uapi/asm/posix_types.h \
  ../include/uapi/asm-generic/posix_types.h \
  ../include/linux/stringify.h \
  ../include/linux/export.h \
    $(wildcard include/config/have/underscore/symbol/prefix.h) \
    $(wildcard include/config/modules.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
  ../arch/arm64/include/asm/linkage.h \
  ../include/linux/wait.h \
    $(wildcard include/config/lockdep.h) \
  ../include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  ../include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
  ../include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  ../include/uapi/linux/const.h \
  ../include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/atomic/sleep.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/panic/timeout.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/lib/gcc/aarch64-linux-gnu/7.3.1/include/stdarg.h \
  ../include/linux/bitops.h \
  ../arch/arm64/include/asm/bitops.h \
  ../arch/arm64/include/asm/barrier.h \
  ../include/asm-generic/bitops/builtin-__ffs.h \
  ../include/asm-generic/bitops/builtin-ffs.h \
  ../include/asm-generic/bitops/builtin-__fls.h \
  ../include/asm-generic/bitops/builtin-fls.h \
  ../include/asm-generic/bitops/ffz.h \
  ../include/asm-generic/bitops/fls64.h \
  ../include/asm-generic/bitops/find.h \
    $(wildcard include/config/generic/find/first/bit.h) \
  ../include/asm-generic/bitops/sched.h \
  ../include/asm-generic/bitops/hweight.h \
  ../include/asm-generic/bitops/arch_hweight.h \
  ../include/asm-generic/bitops/const_hweight.h \
  ../include/asm-generic/bitops/lock.h \
  ../include/asm-generic/bitops/non-atomic.h \
  ../include/asm-generic/bitops/le.h \
  ../arch/arm64/include/uapi/asm/byteorder.h \
  ../include/linux/byteorder/little_endian.h \
  ../include/uapi/linux/byteorder/little_endian.h \
  ../include/linux/swab.h \
  ../include/uapi/linux/swab.h \
  arch/arm64/include/generated/asm/swab.h \
  ../include/uapi/asm-generic/swab.h \
  ../include/linux/byteorder/generic.h \
  ../include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  ../include/linux/typecheck.h \
  ../include/linux/printk.h \
    $(wildcard include/config/mt/printk/uart/console.h) \
    $(wildcard include/config/mtk/aee/feature.h) \
    $(wildcard include/config/printk/mt/prefix.h) \
    $(wildcard include/config/mt/eng/build.h) \
    $(wildcard include/config/log/too/much/warning.h) \
    $(wildcard include/config/message/loglevel/default.h) \
    $(wildcard include/config/early/printk.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
  ../include/linux/init.h \
    $(wildcard include/config/broken/rodata.h) \
    $(wildcard include/config/lto.h) \
  ../include/linux/kern_levels.h \
  ../include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  ../include/uapi/linux/kernel.h \
  ../include/uapi/linux/sysinfo.h \
  ../arch/arm64/include/asm/cache.h \
  ../arch/arm64/include/asm/cachetype.h \
  ../arch/arm64/include/asm/cputype.h \
  ../include/linux/dynamic_debug.h \
  ../include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  ../include/uapi/linux/string.h \
  ../arch/arm64/include/asm/string.h \
  ../include/linux/errno.h \
  ../include/uapi/linux/errno.h \
  arch/arm64/include/generated/asm/errno.h \
  ../include/uapi/asm-generic/errno.h \
  ../include/uapi/asm-generic/errno-base.h \
  ../include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
  ../include/linux/preempt.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/preempt/count.h) \
    $(wildcard include/config/context/tracking.h) \
    $(wildcard include/config/preempt/notifiers.h) \
  arch/arm64/include/generated/asm/preempt.h \
  ../include/asm-generic/preempt.h \
  ../include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
    $(wildcard include/config/debug/stack/usage.h) \
  ../include/linux/bug.h \
    $(wildcard include/config/generic/bug.h) \
  arch/arm64/include/generated/asm/bug.h \
  ../include/asm-generic/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  ../arch/arm64/include/asm/memory.h \
    $(wildcard include/config/arm64/va/bits.h) \
  arch/arm64/include/generated/asm/sizes.h \
  ../include/asm-generic/sizes.h \
  ../include/linux/sizes.h \
  ../include/asm-generic/memory_model.h \
    $(wildcard include/config/flatmem.h) \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  ../arch/arm64/include/asm/thread_info.h \
    $(wildcard include/config/arm64/64k/pages.h) \
  ../include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/preempt/monitor.h) \
    $(wildcard include/config/mtprof.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  ../arch/arm64/include/asm/irqflags.h \
  ../arch/arm64/include/asm/ptrace.h \
    $(wildcard include/config/cpu/big/endian.h) \
  ../arch/arm64/include/uapi/asm/ptrace.h \
  ../arch/arm64/include/asm/hwcap.h \
  ../arch/arm64/include/uapi/asm/hwcap.h \
  ../include/linux/bottom_half.h \
  ../include/linux/preempt_mask.h \
  ../include/linux/spinlock_types.h \
  ../arch/arm64/include/asm/spinlock_types.h \
  ../include/linux/lockdep.h \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/prove/rcu.h) \
  ../include/linux/rwlock_types.h \
  ../arch/arm64/include/asm/spinlock.h \
  ../arch/arm64/include/asm/processor.h \
  ../arch/arm64/include/asm/fpsimd.h \
  ../arch/arm64/include/asm/hw_breakpoint.h \
    $(wildcard include/config/have/hw/breakpoint.h) \
  ../include/linux/rwlock.h \
  ../include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/uninline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  ../include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  ../include/linux/atomic.h \
    $(wildcard include/config/arch/has/atomic/or.h) \
    $(wildcard include/config/generic/atomic64.h) \
  ../arch/arm64/include/asm/atomic.h \
  ../arch/arm64/include/asm/cmpxchg.h \
  ../include/asm-generic/atomic-long.h \
  arch/arm64/include/generated/asm/current.h \
  ../include/asm-generic/current.h \
  ../include/uapi/linux/wait.h \
  ../include/linux/kdev_t.h \
  ../include/uapi/linux/kdev_t.h \
  ../include/linux/dcache.h \
  ../include/linux/rculist.h \
  ../include/linux/rcupdate.h \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/rcu/trace.h) \
    $(wildcard include/config/preempt/rcu.h) \
    $(wildcard include/config/rcu/stall/common.h) \
    $(wildcard include/config/rcu/user/qs.h) \
    $(wildcard include/config/rcu/nocb/cpu.h) \
    $(wildcard include/config/tasks/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/rcu/boost.h) \
    $(wildcard include/config/rcu/nocb/cpu/all.h) \
    $(wildcard include/config/no/hz/full/sysidle.h) \
  ../include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  ../include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  ../include/linux/bitmap.h \
  ../include/linux/seqlock.h \
  ../include/linux/completion.h \
  ../include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  ../include/linux/rcutree.h \
  ../include/linux/rculist_bl.h \
  ../include/linux/list_bl.h \
  ../include/linux/bit_spinlock.h \
  ../include/linux/lockref.h \
    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
  include/generated/bounds.h \
  ../include/linux/path.h \
  ../include/linux/stat.h \
  ../arch/arm64/include/asm/stat.h \
  ../arch/arm64/include/uapi/asm/stat.h \
  ../include/uapi/asm-generic/stat.h \
  ../arch/arm64/include/asm/compat.h \
  ../include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/no/hz/common.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/sched/autogroup.h) \
    $(wildcard include/config/virt/cpu/accounting/native.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/fanotify.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/mtk/sched/cmp/tgs.h) \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/disable/cpu/sched/domain/balance.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/mtk/sched/cmp.h) \
    $(wildcard include/config/sched/hmp.h) \
    $(wildcard include/config/sched/hmp/prio/filter.h) \
    $(wildcard include/config/hmp/tracer.h) \
    $(wildcard include/config/mtprof/cputime.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/mt/rt/throttle/mon.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/mt/sched/trace.h) \
    $(wildcard include/config/mt/sched/debug.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/compat/brk.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/virt/cpu/accounting/gen.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/debug/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/numa/balancing.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/memcg.h) \
    $(wildcard include/config/uprobes.h) \
    $(wildcard include/config/bcache.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/irq/time/accounting.h) \
    $(wildcard include/config/no/hz/full.h) \
    $(wildcard include/config/proc/fs.h) \
    $(wildcard include/config/stack/growsup.h) \
  ../include/uapi/linux/sched.h \
  ../include/linux/sched/prio.h \
  ../arch/arm64/include/uapi/asm/param.h \
  ../include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  ../include/uapi/asm-generic/param.h \
  ../include/linux/capability.h \
  ../include/uapi/linux/capability.h \
  ../include/linux/timex.h \
  ../include/uapi/linux/timex.h \
  ../include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  ../include/linux/math64.h \
    $(wildcard include/config/arch/supports/int128.h) \
  arch/arm64/include/generated/asm/div64.h \
  ../include/asm-generic/div64.h \
  ../include/linux/time64.h \
  ../include/uapi/linux/time.h \
  ../include/uapi/linux/param.h \
  ../arch/arm64/include/asm/timex.h \
  ../arch/arm64/include/asm/arch_timer.h \
  ../include/clocksource/arm_arch_timer.h \
    $(wildcard include/config/arm/arch/timer.h) \
  ../include/linux/clocksource.h \
    $(wildcard include/config/arch/clocksource/data.h) \
    $(wildcard include/config/clocksource/watchdog.h) \
    $(wildcard include/config/clksrc/of.h) \
  ../include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  ../include/linux/ktime.h \
  ../include/linux/jiffies.h \
  ../include/linux/timekeeping.h \
  ../arch/arm64/include/asm/io.h \
  ../include/linux/blk_types.h \
    $(wildcard include/config/blk/cgroup.h) \
    $(wildcard include/config/blk/dev/integrity.h) \
  ../arch/arm64/include/asm/pgtable.h \
    $(wildcard include/config/transparent/hugepage.h) \
    $(wildcard include/config/have/rcu/table/free.h) \
    $(wildcard include/config/arm64/pgtable/levels.h) \
  ../arch/arm64/include/asm/proc-fns.h \
  ../arch/arm64/include/asm/page.h \
    $(wildcard include/config/have/arch/pfn/valid.h) \
  ../arch/arm64/include/asm/pgtable-types.h \
  ../include/asm-generic/pgtable-nopud.h \
  ../include/asm-generic/getorder.h \
  ../arch/arm64/include/asm/pgtable-hwdef.h \
  ../include/asm-generic/pgtable.h \
    $(wildcard include/config/have/arch/soft/dirty.h) \
  ../include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
    $(wildcard include/config/have/cmpxchg/double.h) \
    $(wildcard include/config/have/aligned/struct/page.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
    $(wildcard include/config/compaction.h) \
  ../include/linux/auxvec.h \
  ../include/uapi/linux/auxvec.h \
  ../arch/arm64/include/uapi/asm/auxvec.h \
  ../include/linux/rbtree.h \
  ../include/linux/rwsem.h \
    $(wildcard include/config/rwsem/spin/on/owner.h) \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  ../include/linux/osq_lock.h \
  arch/arm64/include/generated/asm/rwsem.h \
  ../include/asm-generic/rwsem.h \
  ../include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/guard.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  ../include/linux/uprobes.h \
  ../include/linux/page-flags-layout.h \
  ../include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  ../arch/arm64/include/asm/sparsemem.h \
  ../arch/arm64/include/asm/mmu.h \
  arch/arm64/include/generated/asm/early_ioremap.h \
  ../include/asm-generic/early_ioremap.h \
    $(wildcard include/config/generic/early/ioremap.h) \
  ../arch/arm64/include/asm/alternative.h \
  ../arch/arm64/include/asm/cpufeature.h \
  ../include/xen/xen.h \
    $(wildcard include/config/xen.h) \
    $(wildcard include/config/xen/dom0.h) \
    $(wildcard include/config/xen/pvh.h) \
  ../include/asm-generic/iomap.h \
    $(wildcard include/config/has/ioport/map.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/generic/iomap.h) \
  ../include/asm-generic/pci_iomap.h \
    $(wildcard include/config/no/generic/pci/ioport/map.h) \
    $(wildcard include/config/generic/pci/iomap.h) \
  ../include/asm-generic/timex.h \
  ../include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  ../include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/movable/node.h) \
  ../include/linux/cputime.h \
  arch/arm64/include/generated/asm/cputime.h \
  ../include/asm-generic/cputime.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  ../include/asm-generic/cputime_jiffies.h \
  ../include/linux/smp.h \
    $(wildcard include/config/profile/cpu.h) \
    $(wildcard include/config/mtk/cpu/hotplug/debug/3.h) \
    $(wildcard include/config/mtk/ram/console.h) \
  ../include/linux/llist.h \
    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
  ../arch/arm64/include/asm/smp.h \
  ../include/linux/sem.h \
  ../include/uapi/linux/sem.h \
  ../include/linux/ipc.h \
  ../include/linux/uidgid.h \
    $(wildcard include/config/user/ns.h) \
  ../include/linux/highuid.h \
  ../include/uapi/linux/ipc.h \
  arch/arm64/include/generated/asm/ipcbuf.h \
  ../include/uapi/asm-generic/ipcbuf.h \
  arch/arm64/include/generated/asm/sembuf.h \
  ../include/uapi/asm-generic/sembuf.h \
  ../include/linux/shm.h \
  ../include/uapi/linux/shm.h \
  arch/arm64/include/generated/asm/shmbuf.h \
  ../include/uapi/asm-generic/shmbuf.h \
  ../arch/arm64/include/asm/shmparam.h \
  ../include/uapi/asm-generic/shmparam.h \
  ../include/linux/signal.h \
    $(wildcard include/config/old/sigaction.h) \
  ../include/uapi/linux/signal.h \
  ../arch/arm64/include/uapi/asm/signal.h \
  ../include/asm-generic/signal.h \
  ../include/uapi/asm-generic/signal.h \
  ../include/uapi/asm-generic/signal-defs.h \
  ../arch/arm64/include/uapi/asm/sigcontext.h \
  ../arch/arm64/include/uapi/asm/siginfo.h \
  ../include/asm-generic/siginfo.h \
  ../include/uapi/asm-generic/siginfo.h \
  ../include/linux/pid.h \
  ../include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  ../include/linux/mmdebug.h \
    $(wildcard include/config/debug/vm.h) \
    $(wildcard include/config/debug/virtual.h) \
  ../include/linux/pfn.h \
  ../arch/arm64/include/asm/percpu.h \
  ../include/asm-generic/percpu.h \
  ../include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  ../include/linux/topology.h \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
  ../include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/cma.h) \
    $(wildcard include/config/memory/isolation.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/have/memblock/node/map.h) \
    $(wildcard include/config/mtk/memcfg.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/page/extension.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  ../include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  ../include/linux/memory_hotplug.h \
    $(wildcard include/config/memory/hotremove.h) \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/have/bootmem/info/node.h) \
  ../include/linux/notifier.h \
  ../include/linux/mutex.h \
    $(wildcard include/config/mutex/spin/on/owner.h) \
  ../include/linux/srcu.h \
  ../include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  ../arch/arm64/include/asm/topology.h \
    $(wildcard include/config/arm/cpu/topology.h) \
    $(wildcard include/config/mtk/cpu/topology.h) \
  ../include/asm-generic/topology.h \
  ../include/linux/proportions.h \
  ../include/linux/percpu_counter.h \
  ../include/linux/gfp.h \
    $(wildcard include/config/dmauser/pages.h) \
    $(wildcard include/config/zone/movable/cma.h) \
    $(wildcard include/config/pm/sleep.h) \
  ../include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
    $(wildcard include/config/have/arch/seccomp/filter.h) \
    $(wildcard include/config/seccomp/filter.h) \
  ../include/uapi/linux/seccomp.h \
  ../arch/arm64/include/asm/seccomp.h \
  ../arch/arm64/include/asm/unistd.h \
  ../arch/arm64/include/uapi/asm/unistd.h \
  ../include/asm-generic/unistd.h \
  ../include/uapi/asm-generic/unistd.h \
  ../include/asm-generic/seccomp.h \
  ../include/uapi/linux/unistd.h \
  ../include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  ../include/linux/resource.h \
  ../include/uapi/linux/resource.h \
  arch/arm64/include/generated/asm/resource.h \
  ../include/asm-generic/resource.h \
  ../include/uapi/asm-generic/resource.h \
  ../include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
    $(wildcard include/config/timerfd.h) \
  ../include/linux/timerqueue.h \
  ../include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  ../include/linux/latencytop.h \
  ../include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  ../include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  ../include/linux/sysctl.h \
  ../include/uapi/linux/sysctl.h \
  ../include/linux/assoc_array.h \
    $(wildcard include/config/associative/array.h) \
  ../include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  ../include/uapi/linux/magic.h \
  ../include/linux/ptrace.h \
  ../include/linux/err.h \
  ../include/linux/pid_namespace.h \
    $(wildcard include/config/pid/ns.h) \
  ../include/linux/mm.h \
    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
    $(wildcard include/config/mem/soft/dirty.h) \
    $(wildcard include/config/x86.h) \
    $(wildcard include/config/ppc.h) \
    $(wildcard include/config/parisc.h) \
    $(wildcard include/config/metag.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/shmem.h) \
    $(wildcard include/config/debug/vm/rb.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/hugetlbfs.h) \
  ../include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  ../include/linux/range.h \
  ../include/linux/shrinker.h \
  ../include/linux/page_ext.h \
    $(wildcard include/config/page/owner.h) \
  ../include/linux/stacktrace.h \
    $(wildcard include/config/stacktrace.h) \
    $(wildcard include/config/user/stacktrace/support.h) \
  ../include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/memory/failure.h) \
    $(wildcard include/config/toi/incremental.h) \
  ../include/linux/huge_mm.h \
  ../include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
    $(wildcard include/config/debug/tlbflush.h) \
    $(wildcard include/config/debug/vm/vmacache.h) \
  ../include/linux/vm_event_item.h \
    $(wildcard include/config/memory/balloon.h) \
    $(wildcard include/config/balloon/compaction.h) \
  ../include/linux/nsproxy.h \
  ../include/linux/kref.h \
  ../include/uapi/linux/ptrace.h \
  ../include/uapi/linux/stat.h \
  ../include/linux/list_lru.h \
  ../include/linux/radix-tree.h \
  ../include/linux/semaphore.h \
  ../include/uapi/linux/fiemap.h \
  ../include/linux/migrate_mode.h \
  ../include/linux/percpu-rwsem.h \
  ../include/uapi/linux/fs.h \
  ../include/uapi/linux/limits.h \
  ../include/uapi/linux/ioctl.h \
  arch/arm64/include/generated/asm/ioctl.h \
  ../include/asm-generic/ioctl.h \
  ../include/uapi/asm-generic/ioctl.h \
  ../include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  ../include/uapi/linux/dqblk_xfs.h \
  ../include/linux/dqblk_v1.h \
  ../include/linux/dqblk_v2.h \
  ../include/linux/dqblk_qtree.h \
  ../include/linux/projid.h \
  ../include/uapi/linux/quota.h \
  ../include/linux/nfs_fs_i.h \
  ../include/linux/fcntl.h \
  ../include/uapi/linux/fcntl.h \
  ../arch/arm64/include/uapi/asm/fcntl.h \
  ../include/uapi/asm-generic/fcntl.h \
  ../include/linux/net.h \
  ../include/linux/random.h \
    $(wildcard include/config/arch/random.h) \
  ../include/uapi/linux/random.h \
  ../include/linux/irqnr.h \
  ../include/uapi/linux/irqnr.h \
  ../include/linux/kmemcheck.h \
  ../include/linux/jump_label.h \
    $(wildcard include/config/jump/label.h) \
  ../include/uapi/linux/net.h \
  ../include/linux/socket.h \
  arch/arm64/include/generated/asm/socket.h \
  ../include/uapi/asm-generic/socket.h \
  arch/arm64/include/generated/asm/sockios.h \
  ../include/uapi/asm-generic/sockios.h \
  ../include/uapi/linux/sockios.h \
  ../include/linux/uio.h \
  ../include/uapi/linux/uio.h \
  ../include/uapi/linux/socket.h \
  ../include/linux/delay.h \
  arch/arm64/include/generated/asm/delay.h \
  ../include/asm-generic/delay.h \
  ../include/linux/freezer.h \
    $(wildcard include/config/microtrust/tee/support.h) \
    $(wildcard include/config/cgroup/freezer.h) \
  ../include/linux/cgroup.h \
  ../include/uapi/linux/cgroupstats.h \
  ../include/uapi/linux/taskstats.h \
  ../include/linux/idr.h \
  ../include/linux/percpu-refcount.h \
  ../include/linux/seq_file.h \
  ../include/linux/kernfs.h \
    $(wildcard include/config/kernfs.h) \
  ../include/linux/cgroup_subsys.h \
    $(wildcard include/config/cgroup/cpuacct.h) \
    $(wildcard include/config/cgroup/device.h) \
    $(wildcard include/config/cgroup/net/classid.h) \
    $(wildcard include/config/cgroup/bfqio.h) \
    $(wildcard include/config/cgroup/perf.h) \
    $(wildcard include/config/cgroup/net/prio.h) \
    $(wildcard include/config/cgroup/hugetlb.h) \
    $(wildcard include/config/cgroup/debug.h) \
  ../include/linux/tcp.h \
    $(wildcard include/config/tcp/md5sig.h) \
  ../include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/net/rx/busy/poll.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
    $(wildcard include/config/netfilter/xt/target/trace.h) \
    $(wildcard include/config/nf/tables.h) \
    $(wildcard include/config/ip/vs.h) \
  ../include/linux/textsearch.h \
  ../include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/memcg/kmem.h) \
    $(wildcard include/config/slab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
  ../include/linux/kmemleak.h \
    $(wildcard include/config/debug/kmemleak.h) \
  ../include/net/checksum.h \
  ../arch/arm64/include/asm/uaccess.h \
  ../arch/arm64/include/asm/sysreg.h \
  ../arch/arm64/include/asm/compiler.h \
  arch/arm64/include/generated/asm/checksum.h \
  ../include/asm-generic/checksum.h \
  ../include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/arch/has/dma/set/coherent/mask.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  ../include/linux/device.h \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/acpi.h) \
    $(wildcard include/config/pinctrl.h) \
    $(wildcard include/config/dma/cma.h) \
    $(wildcard include/config/devtmpfs.h) \
    $(wildcard include/config/sysfs/deprecated.h) \
  ../include/linux/ioport.h \
  ../include/linux/kobject.h \
    $(wildcard include/config/uevent/helper.h) \
    $(wildcard include/config/debug/kobject/release.h) \
  ../include/linux/sysfs.h \
  ../include/linux/kobject_ns.h \
  ../include/linux/klist.h \
  ../include/linux/pinctrl/devinfo.h \
    $(wildcard include/config/pm.h) \
  ../include/linux/pinctrl/consumer.h \
  ../include/linux/pinctrl/pinctrl-state.h \
  ../include/linux/pm.h \
    $(wildcard include/config/vt/console/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/clk.h) \
    $(wildcard include/config/pm/generic/domains.h) \
  ../include/linux/ratelimit.h \
  ../arch/arm64/include/asm/device.h \
    $(wildcard include/config/iommu/api.h) \
  ../include/linux/pm_wakeup.h \
  ../include/linux/dma-attrs.h \
  ../include/linux/dma-direction.h \
  ../include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
    $(wildcard include/config/arch/has/sg/chain.h) \
  arch/arm64/include/generated/asm/scatterlist.h \
  ../include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  ../arch/arm64/include/asm/dma-mapping.h \
  ../include/linux/vmalloc.h \
  ../include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  ../arch/arm64/include/asm/xen/hypervisor.h \
  ../arch/arm64/include/../../arm/include/asm/xen/hypervisor.h \
  ../include/asm-generic/dma-mapping-common.h \
  ../include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  ../include/linux/netdev_features.h \
  ../include/net/flow_keys.h \
  ../include/net/sock.h \
    $(wildcard include/config/net.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/inet.h) \
  ../include/linux/hardirq.h \
  ../include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  ../include/linux/vtime.h \
  ../include/linux/context_tracking_state.h \
  ../include/linux/static_key.h \
  ../arch/arm64/include/asm/hardirq.h \
  ../arch/arm64/include/asm/irq.h \
  ../include/asm-generic/irq.h \
  ../include/linux/irq_cpustat.h \
  ../include/linux/list_nulls.h \
  ../include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/xps.h) \
    $(wildcard include/config/bql.h) \
    $(wildcard include/config/rfs/accel.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/libfcoe.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/vlan/8021q.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/tipc.h) \
    $(wildcard include/config/net/flow/limit.h) \
  ../include/linux/pm_qos.h \
  ../include/linux/miscdevice.h \
  ../include/uapi/linux/major.h \
  ../include/linux/prefetch.h \
  ../include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/enable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/rapidio/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  ../include/linux/dynamic_queue_limits.h \
  ../include/linux/ethtool.h \
  ../include/linux/compat.h \
    $(wildcard include/config/compat/old/sigaction.h) \
    $(wildcard include/config/odd/rt/sigaction.h) \
  ../include/uapi/linux/if.h \
  ../include/uapi/linux/hdlc/ioctl.h \
  ../include/uapi/linux/aio_abi.h \
  ../include/uapi/linux/ethtool.h \
  ../include/linux/if_ether.h \
  ../include/uapi/linux/if_ether.h \
  ../include/net/net_namespace.h \
    $(wildcard include/config/ieee802154/6lowpan.h) \
    $(wildcard include/config/ip/sctp.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/nf/defrag/ipv6.h) \
    $(wildcard include/config/wext/core.h) \
  ../include/net/flow.h \
  ../include/linux/in6.h \
  ../include/uapi/linux/in6.h \
  ../include/uapi/linux/libc-compat.h \
  ../include/net/netns/core.h \
  ../include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  ../include/net/snmp.h \
  ../include/uapi/linux/snmp.h \
  ../include/linux/u64_stats_sync.h \
  ../include/net/netns/unix.h \
  ../include/net/netns/packet.h \
  ../include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/ip/route/classid.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  ../include/net/inet_frag.h \
  ../include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  ../include/net/dst_ops.h \
  ../include/net/netns/ieee802154_6lowpan.h \
  ../include/net/netns/sctp.h \
  ../include/net/netns/dccp.h \
  ../include/net/netns/netfilter.h \
  ../include/linux/proc_fs.h \
  ../include/linux/netfilter.h \
    $(wildcard include/config/nf/nat/needed.h) \
  ../include/linux/in.h \
  ../include/uapi/linux/in.h \
  ../include/uapi/linux/netfilter.h \
  ../include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  ../include/net/netns/conntrack.h \
    $(wildcard include/config/nf/conntrack/proc/compat.h) \
    $(wildcard include/config/nf/conntrack/events.h) \
    $(wildcard include/config/nf/conntrack/labels.h) \
  ../include/linux/netfilter/nf_conntrack_tcp.h \
  ../include/uapi/linux/netfilter/nf_conntrack_tcp.h \
  ../include/net/netns/nftables.h \
  ../include/net/netns/xfrm.h \
  ../include/uapi/linux/xfrm.h \
  ../include/net/flowcache.h \
  ../include/linux/interrupt.h \
    $(wildcard include/config/irq/forced/threading.h) \
    $(wildcard include/config/generic/irq/probe.h) \
  ../include/linux/irqreturn.h \
  ../include/linux/seq_file_net.h \
  ../include/net/dsa.h \
  ../include/linux/of.h \
    $(wildcard include/config/sparc.h) \
    $(wildcard include/config/of/dynamic.h) \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/attach/node.h) \
    $(wildcard include/config/detach/node.h) \
    $(wildcard include/config/add/property.h) \
    $(wildcard include/config/remove/property.h) \
    $(wildcard include/config/update/property.h) \
    $(wildcard include/config/of/resolve.h) \
  ../include/linux/mod_devicetable.h \
  ../include/linux/uuid.h \
  ../include/uapi/linux/uuid.h \
  ../include/linux/property.h \
  ../include/linux/phy.h \
  ../include/linux/mii.h \
  ../include/uapi/linux/mii.h \
  ../include/linux/phy_fixed.h \
    $(wildcard include/config/fixed/phy.h) \
  ../include/net/netprio_cgroup.h \
  ../include/uapi/linux/neighbour.h \
  ../include/linux/netlink.h \
  ../include/net/scm.h \
    $(wildcard include/config/security/network.h) \
  ../include/linux/security.h \
    $(wildcard include/config/fw/loader/user/helper.h) \
    $(wildcard include/config/security/path.h) \
    $(wildcard include/config/security/network/xfrm.h) \
    $(wildcard include/config/securityfs.h) \
    $(wildcard include/config/security/yama.h) \
    $(wildcard include/config/mtk/root/trace.h) \
  ../include/uapi/linux/netlink.h \
  ../include/uapi/linux/netdevice.h \
  ../include/uapi/linux/if_packet.h \
  ../include/linux/if_link.h \
  ../include/uapi/linux/if_link.h \
  ../include/linux/uaccess.h \
  ../include/linux/memcontrol.h \
    $(wildcard include/config/memcg/swap.h) \
  ../include/linux/res_counter.h \
  ../include/linux/aio.h \
  ../include/linux/filter.h \
    $(wildcard include/config/debug/set/module/ronx.h) \
    $(wildcard include/config/bpf/jit.h) \
  ../arch/arm64/include/asm/cacheflush.h \
    $(wildcard include/config/debug/rodata.h) \
  ../include/uapi/linux/filter.h \
  ../include/uapi/linux/bpf_common.h \
  ../include/uapi/linux/bpf.h \
  ../include/linux/rculist_nulls.h \
  ../include/linux/poll.h \
  ../include/uapi/linux/poll.h \
  arch/arm64/include/generated/asm/poll.h \
  ../include/uapi/asm-generic/poll.h \
  ../include/net/dst.h \
  ../include/linux/rtnetlink.h \
  ../include/uapi/linux/rtnetlink.h \
  ../include/uapi/linux/if_addr.h \
  ../include/net/neighbour.h \
  ../include/net/rtnetlink.h \
  ../include/net/netlink.h \
  ../include/net/tcp_states.h \
  ../include/uapi/linux/net_tstamp.h \
  ../include/net/inet_connection_sock.h \
  ../include/net/inet_sock.h \
  ../include/linux/jhash.h \
  ../include/linux/unaligned/packed_struct.h \
  ../include/net/request_sock.h \
  ../include/net/netns/hash.h \
  ../include/net/inet_timewait_sock.h \
  ../include/net/timewait_sock.h \
  ../include/uapi/linux/tcp.h \
  ../include/linux/highmem.h \
    $(wildcard include/config/x86/32.h) \
    $(wildcard include/config/debug/highmem.h) \
  arch/arm64/include/generated/asm/kmap_types.h \
  ../include/asm-generic/kmap_types.h \
  ../include/linux/mempool.h \
  ../fs/cifs/cifspdu.h \
    $(wildcard include/config/cifs/weak/pw/hash.h) \
    $(wildcard include/config/cifs/posix.h) \
  arch/arm64/include/generated/asm/unaligned.h \
  ../include/asm-generic/unaligned.h \
    $(wildcard include/config/have/efficient/unaligned/access.h) \
  ../include/linux/unaligned/access_ok.h \
  ../include/linux/unaligned/generic.h \
  ../fs/cifs/smbfsctl.h \
  ../fs/cifs/cifsglob.h \
    $(wildcard include/config/cifs/smb2.h) \
    $(wildcard include/config/cifs/fscache.h) \
    $(wildcard include/config/cifs/stats.h) \
    $(wildcard include/config/cifs/upcall.h) \
    $(wildcard include/config/cifs/dnotify/experimental.h) \
    $(wildcard include/config/cifs/acl.h) \
  ../fs/cifs/cifs_fs_sb.h \
  ../include/linux/backing-dev.h \
    $(wildcard include/config/debug/fs.h) \
  ../include/linux/flex_proportions.h \
  ../include/linux/writeback.h \
  ../fs/cifs/cifsacl.h \
  ../include/crypto/internal/hash.h \
  ../include/crypto/algapi.h \
  ../include/linux/crypto.h \
  ../include/crypto/hash.h \
  ../include/uapi/linux/cifs/cifs_mount.h \
  ../fs/cifs/cifsproto.h \
    $(wildcard include/config/cifs/dfs/upcall.h) \
  ../include/linux/nls.h \
  ../fs/cifs/cifs_debug.h \
    $(wildcard include/config/cifs/debug2.h) \
    $(wildcard include/config/cifs/debug.h) \

fs/cifs/transport.o: $(deps_fs/cifs/transport.o)

$(deps_fs/cifs/transport.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ELF                                       @     @    {   @      !     @{_{*  B      {_{C$FD cp   B      R{_{*  B      {_{ S  [ c#  <@ @ Q?0 q	 Tt       ` ?|@ T  R  ? *` |@!  R  ? *` |@  R  ? *s a~@!  R  ? *    ***B  !     SA  R[BcC#@{_
@A   ? *
@@ R  a !@ j T
@ *C` ?*  qM TC@   b  R R R R  Rs a~@   ? *  !       R       _{ R   S   [   c              "   RX R@@ # j  T@" _$R   @ s~@ s~       js                RSA[BcC{_s b * qT                                                                                                                                                                                                                                            chip 3[CHIP_COMMON] create /proc/chip fails
 3[CHIP_COMMON] create /proc/chip/%s fail
 %04d %04d%02d %04X %-16s : %s (%04x)
 NULL reg %-16s : %04X %04X %04X %04X
 %04X
 hw_code hw_subcode hw_ver sw_ver code_func code_date code_proj code_fab wafer_big_ver info                                                                                                       	                       
                                                                                                                                   GCC: (Linaro GCC 7.3-2018.05~dev) 7.3.1 20180522 <                     t                                                                            4           F       F           d           v   int v                                          s8 4   u8 F   u16 d   s32 v   u32    s64    u64              .  	   
@  .      9  P  v        [      [            v       0       1       Gg      HP  v     	       W       XP      YP      Zv       [v   
9                   d       r            8          }             -      6      ;      E                                                     v                 [              3      3       3   
      R      w        w      w       }   
R  
w                      
       
        
  v   
                               9                                   -      (  @  m   b      
m      m      -      v   v          _      v       v       v       	\      	~*       	      	      	      	Y       	Y  (    	s  0    	s  8    	  @    	  H    	  P    	  X    	  `    	+  h    	E  p    	+  x    	i      	      	      	      	      	0*      	      	      	-      	V      	z      	      	         6\      
;      
<g       
=S<       m  [    v          
      v       v       v       v       v       v       v       -         P                                  m      m                             3      v         cap          	               +      ,      j  ([      [   val                            [    
           !"       "      $      &       	      
       [   
      E      F[       G    
   )5	      *e	       +v       ,v       -      .       #e	  fd $v        %R       &R    
5	  (	      
      'a      /       0	  fn 	    k	   [  	  	   
	  
	      (      h.R
      /       0	      1@      2K      3	       4v   Pcpu 5v   T    6  X    7v   ` !    W@      Xb       Y      Z      [       \       _p+       `v   (    a@  0    b  8    c  @    ev   H    gv   L    iv   P    iv   T    iv   X    j   \    k"R  `"se l|O  h#rt mfP  ($    o-R  p%dl qP  x$    |   $    }v   $    ~   $    v   ($    Q  ,$      0$    8R  @$    	I  H$      h$    *  x&      #mm    $       '       $       $    >R  $    )  $    v    $    v   $    v   $    v   $       $       '       '       '       '       $       #pid   ($      ,$    @  0$    @  8$      @$      P$    @  `$      h$      x$    NR  $      $      $    A  $    @  $    @   $    e+  $    e+  $    e+  $    e+   $    e+  ($       0$    D  8$      H$      P$      X$      `$      h$      p$      x$      $      $    E  $    6  $     ^R  $    ^R  $    dR  $    	v   $    	v   $       #fs yR  	$    R  	$    A  	$    R  	$    R  	$    .  	$    .  	$     .  	$    !@1  	$    #  
$    $`  
$    %R  
$    &   
$    'R  (
$    (  0
$    *R  8
$    ,-  @
$    -   D
$    /9>  H
$    2   X
$    3   \
&    6g  `
&    90  d
$    =  h
$    >  p
$    @R  x
$    `  
$    cR  
$    gR  
$    kR  
$    mR  
$    oR  
$    q  
$    rR  
$    s@  
$    	S  
$      
$    S  
$    OS  
$      
$    ZS  
$    `S   &    :  $      8$      H#rcu   P$    T  `$    &  h$    v   x$    v   |$    v   $      $      $      $      $       
R
  (    
F  )    M      4       4       7  *    C      D   sp E   +pc F    ,    G         	   *    J      K   ,    L    ,    M        	       -nP      oP   sp p  +pc q   ,    r     `  	   .lz      m}  /   *     k   `   ,    u  ,    v   0                  1    !  %      &         '      v       v   2         0          1       3AR  4    B       @g  5<    1    LR                s  -"      #   ,    $    ,    %    .       !  /   *           +cpu )        V  6        7len     6        6        6                                     8pmu              ~*  dev o      
x       .  (    v   0    v   4    @  8      @    v   H    v   L      P      X      `add   hdel   p      x                                        	         *    2      4v        6v       7v       9      :       	   
!  !    H4:      ;       E      F       M  0    OR  @    P  P    Qv   `    Rv   d    S  h9pmu T  p    V  x    W   |    X      Y      d      e      q      r      s      }        $        $       "$       $%hw {  (#ctx pS  $    9  $      $      &    :  $       $      0$    v   8#cpu v   <$      @$    @  P&    :  X$      #rb _  $      $      $    v   &      $      $    v   $    v   $    v   $      $      $       $      #ns (3  #id    $    D  ($      0$      8$      @     h=  x19 >   x20 ?  x21 @  x22 A  x23 B   x24 C  (x25 D  0x26 E  8x27 F  @x28 G  Hfp H  Psp I  Xpc J  ` *    M9      N:       O  h    P  p,    Q  ,    R  ,    S              .]       /          3D  :        D   ;     g   <     h            v        v        !	      "L      "M      "  =    #%      #&        #)      $v       $-      $v       8%      %       %      %      %       %  (    %v   0 (    
       
      %$      &      &       &       &          8',      '.    #   X%   %   5%  0 
  >    	J      	       	v       	L      	  ;    	:      	  @    	  P    	  X    	v   `    	-  d    	  h    	J  x    	       	4      	       	v       	?      	J      	      	      	v   ;    	:   
      (      (      (?P      (O[      (SP      )t  q    ?       )      )      *#      *$       *%      *&   
      **      *+        +%      +        (,p      ,[       ,      ,0  osq ,       ,%@        -'      -(g       -)   1    -+p       .      .        .       /      /          	        /      /v       /O   
         /P       /Q       /R   @    /Q     a   	      q   	    a       /q        	  @	           /
   
z  
   !    '^L#      '_(       '`      'a       'c0*      'g       'h  (    'i  0    'j  89pgd 'k6*  @    'l  H    'm  L    'n9  P    'ov   X;    'qg  \;    'r%  `    't      'z      '{      '}      '~      '      '      '      '      '      '      '      '      '  $    '   #brk '  $    '  $    '  $    '   $    '  ($    '  0$    '<*  8$    ')  $    'Q*  $    'E   &    '#  $    '  $    'W*  &    'g  $    'b*  $    'U'  $    '-  $    'L#   A     001#  id 1        10      1   1    1T#  '0#      '1$      '8   >    	$      	L       	F  ;    	g      	      	       	  (;    	:  8    	  `    	  h    	  p    	)  x    	      	R  ;    	g      	      	   
#  '=$      '>      '?      '@-   'n$  6    'o    6    'p    6    'q      '[%      'l  /$      'sv    'Y4%   $       'u   'KX%      'V   /%      'w    '<m%   $    4%   '%      '       'v       'v    '|%  Blru '}  /m%      '%      '   (    
%  3'&      '  Cptl 'g      '&      '   (    
&      'G&      '       '       '    !     	P'  9f_u 	`       	      	L       	  (;    	"g  0    	#9  8    	$   @    	%  D;    	&:  H    	'U  p    	(  x    	)^R      	*      	,      	.      	1      	5      	6      	8$   G&  
G&  : ''  "rb '       '   D ''  E    '['  F    '  F    ' .       '(      '       '      '(      '(  ;    '       '	  8    '   @    '|  H    '  P;    '!'  X    ')  x    '+(      '.)      '1      '3U'      '4   
'  (    
(      @2 )      2W       2W      2W      2W      2W       2X  (    2X  0    2/=X  8 (  
)      '>F)      '?@       '@F)   
)  >    8'C)      'D       'E)  ;    'F   G   'I)                        'S)      'Tv        'U)   v   )  	       'Y)      'Z)    9  *  	     0*  U'           
*  
q    L*  	  ) (    
L*  
L)  (    
]*  
      3   (    
y*        41*  
*      5      5      (6U*      6Vv        6W      6X   7b*      7b        7b*      7c*         7I+                                *  Y+  	       7I+      8      9A+      9B+    
p+  
+  +         :   +             ;3+  
+      ;=+      ;>        ;@+      @:?],      :@       :A      :B      :C      :D       :E  (    :F  0    :G  8     :Jh,  
+  @:S,      :T.       :Uv       :V       :W       :X       :Y  (    :Z  0    :[  8 *    K:R-  rec :\-   ,    :^    K,    :_   K n,  -  ?  +     :a,      :bg      :c       :       <1v       =R      =S      =`v       >"v       >#v       >Qv       >Rv   (        ?-  ?-  val ??        ?-  ?-  val ?J        ?-      X.                                      9               (    9  0    R  89uid -  H    9  P 
-  @W.  sig @X        @Y.      AE      A.  
.      A      A.  
.  =    B/      Bv       B	       B
.  B9G/      B:r       B;}   B?/      B@       BAv       BB/      BC/      BDv    9  /  H   BH/      BIr       BJ}      BK/    BO0      BPr       BQ}      BRv       BS      BT   BX.0      BY       B]R    BaO0      Bb[   _fd Bcv    Bg|0      Bh       Biv       Bj    pB50      B60      B<&/      BEG/  B_rt BL/      BU/      B^0      Bd.0      BkO0   v   0  	       B0*1      B1v        B2v       B3v       Bl|0       Bm0      Cv       Ce1      C       C.       Cv        C1      C.       C      C.      C.        C1  9sa Cp1        C,&  I       D2                             D422  nr D6v    ns D7(3      D8R   *    E(3      EZ       EZ  +rcu E  ,    Ev   ,    E   ,    E@   ,    E&  (,    E   0,    E (3  8,    E"[  @,    E#[  H,    E$[  P,    E)C  X,    E*];  `,    E+-  ,    E,v   ,    E-v   ,    E.    
22  8pid PD;w3      D=       D>       D@w3  rcu DA       DB3  0 9  3  	   2  3  	        DE.3      DG3      DIR   pid DJ3   
.3      De22    3  	       F3      G8      G9	4  
  
   I       GN?4                    4  O4  	   ?4      GUO4      GW4  J   H&4                                        HLv       hH\4      H]4       H^  `   4  	        @Hj 5  x Hk 5    9  5  H   I       Hr5                                               	    
                                                                                             ! I       H)6                                 HN6      H       H       pHs6      Hs6       H)6  P   6  	       H   I       H6                        @H6      Hv        Hv       Hv       H6     7  	       hH;7  9pcp H6       H   @    H;7  A    K7  	           Hv7                    !    @HGF9      HKF9       HUV9      H_   0    Ha :  8    Hb&:  @    Hh  H    H{  P    H  X    H  `    H  h    H.  p    Hv   x    H      H,:      H      H  ;    H4  @;    Hg      H2:  $    H  @&    H4  @&    Hg  $    HN6  $    H9  $    H   $    H  $    H  $    H    $    H   $$    Hv   ($    H-  ,&    H4  @@$    HB:  @   V9  	   [  f9  	   !    @@H :  ;    H:  @ $    H:  $    Hv   $    H  $    H  $    H  $    Hv   &    H  &    H  $    H@   $    Hv   ($    HK7  , 
f9  
7  
  4  B:  	  
 9  R:  	        Hz:      Hz:       Hv    
v7      HH:      H:       H:   (    
:  R:  :  	       H  Kv7  @:  	   :  :  	        (I2;;      I4       I5g      I6      I8@  osq I;        JF;  
L;  W;  W;   
];       Jd;      Je9       Jf      Jg;;       hJq;      Jr];       Js0   wq Jv;  Xcpu Jwv   ` (    
;      Je;      Jf;      Jg;      Jh;      Ji;      Jj;      Jk;      
24<  
:<  v   S<  S<       
Y<      
5<      
6)<       
7S<      
8v        0
@<      
A%       
BS<  (     
E<      
FS<        
<      
<      H:      HRv       H      H      Hf9      H@D=      HM       HPD=   
  [=  [=  ?   
=      HrJ=       K=      K	v        K
v       Kv       K       K      K   m=  =  	       K=      L      (M(>      M0       M       M      M(>    
       Mv       N^>      Nv        Nc>   (    
^>      Ov       P*>      P+g       P,g        Q>      Q	       Q
       Q>      Q       Q>   
>  I       R,	?                @RlT?      Rm>       Rn       Roi?  (    Rp?  0    Rq  8 >  c?  c?   
	?  
T?      @R?      R@       Rv       R"      R>      R       R@  (    R  0    R  8 
o?  L    @R@      R0   cpu R       R       R       R      Rv       Rv       R       R  (    R  0    R  8    R@  @ 
?    
@  I       R@                        o?  @  	   (        RI@  A     S
v   
`    A  	       T%A  v   6A  6A  v     @  A   
<A      @TiA      Tk.       Tl      Tmv       Tn      To6A      TpA       TqA  (    Tr  0    Ts  8 
U       TWA      TX       TY   
A  
A  
  
A      0UOB      U       UZ      U Z      U!Z      U"(3       U#Z  (     V B      V!       V"v       V#v       V$B      V%B   -  B  	   B  B  H   
-      VBOB      VgC      Vh   uid Vp-  gid Vq-      Vr-      Vs-      Vt-      Vu-      Vv-      Vw-       Vx   $    Vy  (    Vz  0    V{  8    V|  @    V}  H    V  P    V.  X    VC  `    VC  hrcu V  p B  
-  
OB    C       C            v         9  D  	        D            g      y      y  !    (D             D  &    g  &       1  D  	  ?     D      e+       e+                     E      e+       e+       OE      e+       e+          >     +E      ,E       -v   ;    .0   !    ;H      <       =      >v       ?  ;    A       D@  8    G@1  @    Jv   X    Pv   \    Q@  `    Tv   h    U   lM    `   pM    a   p    dv   t    e  x;    h	?      i3      j  9it qH  &    wOE  $    zE  ($    |6  @$    ~3  p$    v   x#tty H  &      $    e+  $    e+  $    e+  $    e+  $    e+  $    e+  $    D  $      $      $      $      $      $      $       $      $      $      $       $      ($      0$      8$    @  @$       @$    H  H$       H$       L$    H  P&    %  X$      $    R   $    R   &    :   D  H  	   (    
H  t>  H  	   (    
H      -       $KI      &       '       *       +           ]vI                        v   NI  F      Orcu    P    (L      L       L      L                      (       ,       0       4       8       <       @       D       H    v   L    v   P    v   T      X       `       d      h      p    L  x    L      L      L      L      L      L      L                                                                        $        $       $      QI  $        $    )L  ( 
I  (    
L     )L  	     8L  H   @    DL  
JL     YL  v    @          L  9sd L   9sg  L  9sgc !L   
L  
L  (    
L  
L      8$M      %8L       &YL      'v       (v       )eL      +  0     /M  
L      hKM      i       j        `mN      n       o       x      x      x          (       ,       0      8       @       D       H      P      X     |O                                        (      0      8       @      H      P      X      `      h      p      x                                                                   !    UP      #M   ;            (       8      @      H      P      X      `    N  h$    v   @$    UP  H$    `P  P$    `P  X#avg KM  ` 
|O  (    
[P      HP                                 P  (    P  0    P  8    P  @ 
fP  (    
P  >    Q  ;                          (      0       8      @       H    v   L    v   P    v   T    v   X;    "	?  ` R&Q      '-       (-   S    %Q  Ob )Q  Os *R        v   .R  T                  (    R  
R  (    
(R  (    
3R  (  NR  	   3  ^R  	   
C  9  tR  	   (    
tR  (    
R  
E  
XD  v   R     
R  
.  (    
R  (    
R  (    
R  (    
R  (    
R  (    
R  (    
R  
*1  (    
S  (    
S      WOS      Wt       W[      W	\   
S  (    
US  pS  pS  	   
vS  !    HT  9pmu    ;    0  ;    :        8      H      X    v   h    v   l    v   p    v   t    v   x    v   |          @                  pS                  v       v       v             ;  $    -  @ (    
T      3      X	F  U     @Z	U  F    [		  F    \	U     )U  ?       i	T      j	R
      l	       %(R      X
v       Xv        YU      Y       Y      Y*  nid Yv        @Y0V      Y1-V       Y3-V      Y6v       Y7[      Y8       Y;  (    Y=3V  8   !V  !V  'V   
U  
oU  
V  
9      Z^V      Z	cV       Z
   -  
^V      2.      28      29      2:v       2=v       2C}       2D}       2Ev       2H}       2I}       2Jv       2U      2V      2Xv       2Yv       2Z      2r&  |  4W  	       2$W      02W      2        2      2      2      2   pte 2W  ( 
f  W  (   
W  v   W  (  W   
?W  
W  W  (  W   
W  v   X  (      v   v    
W  .  X  (   

X  v   =X  (         
X  NX     I       [Y                                           	    
                                                                                             !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /    0    1    2    3    4    5    6     \v   *    \Y      \Y      Y  	  5     \Y      \oB:  4   Z   Y      \  Z      2v       29      2      2v       2v       2v       2v       29      29V      29V  (    
Z  (    
Z  (    
Z  Vnet 
Z      U%A      ]Z      ]        EZ      E       E   Z  [  	   (    
[      ^m[      ^o        ^p]      ^q}      ^r[      ^sc~       ^tL  0    ^vR  8    ^y~  X    ^z  `    ^{  h    ^|  p    ^}  x    ^      ^      ^  d_u ^~   [  
[      %       =       C       h_\  ino _   dev _      _      _   uid _-  gid _-      _      _U       _  (    _  8    _   H    _!  X    _"   ` <A  \       `P\      a       a       a   a]      a\      a\   a4]      a\       a\       a]  4]  J]       b?]   c#t]      c%@      c&   *    0c]      cv        c v   ary c!]  ,    c"v   QU]   ]  ]  	   
t]  Widr (c*3^      c+]   top c,]      c-v   cur c.v       c/g      c0v       c1]        cX^      c[       cX^     h^  	   Wida 0c^  Xidr c]       c^  ( 
3^      dJ^      dK       dM      dS_       pd_  kn d_       d       dh^      dZb  @    d  H    d  X 
^      dV<_      dW_        xdj_      dk       dl      dv_      dw.  Xrb dy  ns d{`  0    d|   8 `  @    d  `    dd   h    d  jino d   l    d`  p 
<_       dZ"`  ops d[`       d\`      d]U      d^_       @d`      db       dc      d'c      d=c      dgc       d`  (    dgc  0    dc  8 "`  
`  (    
`   d}`  Bdir d~^      d#_      d_   
`  Y(    
`      (d*a      dCa       db      d b      d5b      dTb    v   Ca  _  @     
*a  v   ]a  ]a  _   
ca      eb  buf e       e`      e`      e`      e`       eU  (    eU  0    e  8    e:  @op em  h    ev   p    e!  x 
Ia  v    b  _  .     
b  v   5b  _   
&b  v   Tb  _  _  .   
;b  
`      pdb  kn d_       dU'      d      d:      dv   @    d  H    d`  X    d-  `    d)  h v   b  ]a     
b    c  ]a  A   
b    'c  ]a    A   
c  =c  ]a     
-c  k  ac  ac    `  U   
`b  
Cc  v   c  ac  (   
mc  I       fc                    0f( d      f)c       f*cV      f+
d      f,*d      f-5d       f.+  ( c    
d  `  d  d   
%d  (    
d  `  
0d      g`d      g.       g        g<d      g=.       g>re      g@xe      gAe   `d    d  d  le  v    
d      @h?le      h@.       hA      hBd      hCf       hDBg  (sd hE_  0    hFZ  86    hJ   <6    hK   <6    hL   <6    hM   <6    hN   < 
;d  
d  
le      8ge      g;d       g`      g      gf       gf  (    g+f  0 
e  
~e  k  f  U'  d  e    U  `   
e  v   +f  U'  d  e  (   
f      gVf      gtf       gf   1f  k  tf  d  le     
[f  k  f  d  le  .  `   
zf      h%      h)      `hf      h       hg      hd      hh  X 
f      (hsBg      htSg       huYg      hvxe      hwtg      hxg    
f  Sg  d   
Hg  
Vf  ng  ng  d   
 d  
_g  `  g  d   
zg  *     	h{g      h|g       h}g  ,    h~v   +buf hg  ,    hv   	   g  	     g  	   9  h  ?       h>h      h]h       h|h      hh   h  v   Wh  f  d   
Ch  Wh  .  vh  f  d   
bh  vh  v   h  f  d  h   
g  
h  h      hVf  
>h      hd      hd      hd      hd      hd       i00i      i2    set i4i  get i6i      i8+   h  v   Ii  .  Ii   
i       iDi      iE.   ops iFqj      iG       iH       iI    i   Oi  
5i  v   i    Ii   
i  iJi  Barg iK  Bstr iLj  Barr iMkj       iTj      iU        iV   i  
j       iZfj  max i\        i]   num i^4  ops i_qj      i`   j  
fj  
0i  i  j   wj      iQj      iQj      i{h      ih      ih      ih      ih      ih      ih      ih      ih      ih      ih      ih      ih      ih      j4-      jHik      jI        `k'k      k(d   mod k)~*  @    k*d  Hmp k+k  P    k,A  X (    
k      8k/l      k0;d       k16l      k3Zl      k5pl       k6l  (    k7l  0 k  *l  *l  0l     
k  
ik  
l  k  Zl  *l  0l  .  `   
<l  pl  ~*  .   
`l  v   l  ~*   
vl  l  ~*   
l      kCk      kyf      kzf      k{v       8l,m      l   end l      l.      l      l,m       l,m  (    l,m  0 
l      ll      ll       m'ym      m(       m)      m*Z        e$m      e%c       e&=c      e''c      e(b   ym  
m       nm  p nn       nn      n n      n!n   (    
m  (    
n      o"      o#      o9m      o>Ln      o?v         o@3n      o'o      o(q       o)q      o*q      o+q      o,q       o-q  (    o.q  0    o/q  8    o0q  @    o1q  H    o2q  P    o3q  X    o4q  `    o5q  h    o6q  p    o7q  x    o8q      o9q      o:q      o;q      o<q      o=q      o>q   Wn  v   o  o   
o  !    pq      po   9p p|      pd      p.  P    py  X;    p:  `9bus pv      p*x      p      p  ;    phr  $    p|  $    p|  $    p|  $    p  $    p  $    p |  $    p  $    p|  $    pv  $    pb}  $    pv|   $    p   #id p   $&    pg  ($    p  0$    pHm  @$    pe{  `$    p
x  h$    pq  p$    pm}  x'    p-  '    p-   
o  q  o   
q         oq                           oq                            or      o   9dev o o   >     o#br  ;    o$g       o%       o'      o*br   
q  !     o.t      o/Ln   M    o0   M    o1   M    o2-  M    o3-  M    o4-  M    o5-  M    o6-  M    o7-   M    o8-  ;    o9g      o;  ;    o<       o=u  @M    o>-  HM    o?-  H    oD0  P    oE      oF];  ;    oG      oH      oI  M    oJ   M    oK   M    oL   M    oM   M    oN   M    oO   M    oP   M    oQ   M    oR   M    oS   M    oT       oUq      oVq      oWv       oXv       oY      oZ      o[  $    o\   $    o^u  $    o_u  #qos o`v       q.u      q/.       q0      q1g      q20       q3  X    q4  `    q5  h    q6  p    q7  x    q8      q9      q:      q;      q<      q=  6    q>-  6    q?-   
t  
r  u  o      
u  (    
 v      ol3v  9ops omWn       onCv   Cv  o  -   
3v       r
v      r0       rv       rv       rv       rv       r       r'Iv      sv      sv    (    
v  
v      phw      pi.       pj.      pko      plx      pm
x       pn
x  (    po
x  0    pqx  8    pry  @    psq  H    ptq  P    puq  X    pwq  `    pxq  h    pz"y  p    p{q  xpm p}(y      p8y  p pCy      p        px      p;d       p$|      pH|   
w  
x  
d  v   *x  o  *x   
0x      xpx      p.   bus pv      p~*      p.      p-       py  (    p z  0    pq  8    pq  @    pq  H    p"y  P    pq  X    p
x  `pm p(y  hp p+z  p 
x  v   y  o  h   
x  v   "y  o  Ln   
y  
o  (    .y  
3y  (    
>y      0py      p.       p
x      py      p|      pq   9pm p(y  ( Iy  
y      ty      t!       t!       tQ  @    t`   y  
y      tz  id tA       t6   y  
z  (    
&z      xp`z      pa.       pb~*      pd4{      pe
x      pfd       phy  (    piT{  0    pkk{  8    plq  @    pn"y  H    poq  P    pqng  X    pr{  `9pm pt(y  h9p pvCy  p      p4{      p;d       p{      p{   
z    N{  o  N{   
  
:{  e{  e{   
1z  
Z{  `  {  o   
q{      p~d      pd  k  {  e{  4{     
{  k  {  e{  4{  .  `   
{    {  o  N{  {  B   
-  
{  k  $|  o  x     
|  k  H|  o  x  .  `   
*|      pv|      p        p   2     p(    
|  
v  
m  
  
N|  (    
|      u0b}      u1.       u2.      u3w      u4.      u6       u7  (    u8b}  0    u9b}  8    u:b}  @    u;b}  H    u<b}  P    u=d  X    u>      u?   
|  (    
h}      pq      pq      v!}      v"}        v%}      v&}       v&}   
}  
}  0w}      wg       wv    3w~  4    w   Z}       w)~  5}    ^/J~      ^0    len ^0    ^.c~  /)~      ^2       ^-~   J~       ^4~   c~  
M       0^<~      ^=[       ^>[      ^?[      ^@[      ^A~    [  ~  	       ^C~  ^      ^R      ^   !    0	L      	       	d       	-      	 -      	!       	$"      	%"      	(       	)  (    	*$  0    	-  8    	1  @ P  H    	=  L    	>U  P    	?  X    	@  h    	A  x;    	Bg      	Cd       	D       	E      	L  ;    	M:      	O      	QR      	R      	S  $    	T  Qr  $    	Y  ($    	Z  0$    	[  4$    	\  8$    	`  @$    	a  H&    	b#  P$    	f   Q  $    	m   $    	p   $    	q9   $    	t  ( 
  F   b  	       @^      ^       ^      ^      ^      ^)       ^:  (    ^:  0    ^P  8    ^o  @    ^  H    ^  P    ^  X    ^  ` b  
  !    @@	      	       	      	F       	      	U       	  (    	  0    	  8    	  @    	  H    	  P    	  X    	[  `;    	%  h    	v       	      	      	      	      	}      	      	J      	R      	      	R  ;    	  &    	j   $    	!  $    	  $    	  $    	   $    	  $    	   &    	:  $    	   $    	  ($    	  0$    	v   8$    	U  @$    	9  $    	v   $    	;  $    	9  &    	d  @&    	d  @ #rcu 	  $    	
v     
  v     [      
  v          
[  
c~  
  v            .     
~  
  v   )     
  :  [   
/  P  [  L   
@    o  [    v    
V  [       
      x  mnt x[       x	[     
u  v     [  -   
  L    [      
         
  
      ^      ^v   9  1  	       @@yd      yg       y      y[       y      y        y!*   
1  z[      z]       z_   *    @zW      zX        zY          ze      zf   (,    zg0  ( 
  zZ   /      zb     0  	  ?   F  	  	        zkw      zl        zm      zn       8{      {        {       {       {      {   (    {  ,      	        	   I       |
                    }
       ~1L      ~2       ~3      ~4       8~7}      ~8[       ~9[      ~:}   [    	       	9      	;v       	<L      	=v       	=v       	>v       	?v   
  (        P	_      	        	      	-      	-      	U      	      	  (    	  8    	 U'  H                                  _      P,      )        Y       )                       8    k   <    k   @    k   D    Y   H    Y   J     i                                          )        ;       Y              ,      ,       ,  8    k   P    k   T    k   X    Y   \    Y   ^      `    "  	   
(  >          R                      0;    :  @      h;      p                U             !       }    val               =                                I       5a                    <   ?  Buid @-  Bgid A-      B       >   l       D=       g      H9      a       a      a      a      a       a  (    a  0    v  8    v  @     H             v                       (       ,    a  0    a  8      @      z      {v        |      }~*      ~   
  J   >                                        L    `f      f       v    v   v  	   K=    	         
>      >      8%      &%       '%      (%      )%      *:       +:  (    ,:  0   v   %    v    
  v   :  "   
+      @0      1:       2      3      4:      5:       6:  (    7%  0    :  8 @  "      v    
    "   
      L   
a  
      x@      Av        B      C      D      E       F  (    G  0    H   8    J   @    Kv   H    Lv   L    M  P    N  X    O  `    P   h    Qv   p     `k      l       m      n%      o%      p       q  (    r  0    s  8    t5  @    uT  H    vt  P    w  X   v       v   v      
  v       v   v    
  v       v      
   
  v            
  
  v   /    /   
  
  v   T       v    
;  v   n    n   
i  
Z  v           
z  
  !              ;    :  ;    :  0      X    
  h9ops    L  
  	   9    	     *  	       	PV      	Qz       	R      	U      	X      	Z       	]   (    	`S  0    	em  8    	f  @    	g  H    	h  P    	i  X    	j>  `    	pb  h    	r|  p    	s  x    	t      	u      	w      	x      	{      	}   *  v   o    o   
u  (    
[  v     U'     
  v     $  o   
  v        
  v     U'  $  3      
  v     U'  $  U        h*     
  
  v   S  U'  $  U             
&    m  $     
Y             
s  v          
  
CX  k    v       U   
      (      v        `      `   O      $    
  v   >  $    v     D=   
  v   b  $         
D  -  |    6   
h  v            
           
-  
  v     $     
  v       U'      
  (    
  
    U'   
      	V  
V  (    
/  (    
:  (    
E  N	9r  F    	:   F    	;    N	U  F    	V9  F    	W   N	g  F    	hT  F    	iJ  F    	j       h      d       ~*  @ops   H      Pdev   `       d 
  (    
  !     @	      	       	      	      	0      	O       	j  (    	  0    	  8    	  @    	  H    	  P    	  X    	)  `    	 M  h    	v  p    	  x    	      	      	      	'      		A      	
k      	      	      	      	   (  
  
\  >    	      	       	R      	      	  (    	   0    	F   4    	   8    	v   <    	3  @;    	  H    	U'  `    	U  h    	U  p    	  x    	      	      	      	      	   
       	      	   9pid 	3      	1  9uid 	-      	-      	v         	 `      	       	       	       	       	       	U   N	  F    	p+  F    	   @    	g      	i      	j       	k            
       
      H	ne      	o~       	p      	q      	r      	s       	t  (    	u  0    	v  8    	w  @   v   ~       
j         
  v       v    
  -       
  v       v   3   
  
         
       	4      
        9         (    
4      X      ]    (    
X  R	      	       	v    N 	  F    	  F    	?  Oafs 	c   >    0	l  ;    	mg       	nv       	ov       	p      	qU'      	r    
  
  
e      	      	g  G   	j                        >    	  ;    	   ;    	  x    	v   ;    	   K=    	       8	      	.       	v       	B      	S      		~*       	
  (    	9  0    	  8    	  8    	  8    	H  8    	  8    	  8    	  8 
      	"      	#       	$      	&      	'-      	(B       	)  (    	*S  0    	+%  8    	,h  @    	-h  H    	.  P    	/  X    	0S  `    	2  h    	3  p    	4  x    	5      	:      	;      	<     
  
  
  (      
  (      
  
  (    
       	       	7      	        	       	       	7   
w  @    	N  =  
T  v   |    .  v   U            	      	I   9pos 	U   U    U'  U  v    
  k    U'    `  A   
  k    U'  .  `  A   
  k  )    )    U   
T      T                /  
  k  s       
_  v     U'     
|  
y       U'     
      %      &N       '   
  [    U'        
  v     U'  (   
  v   +  L  U'   
  v   E  U'     
1  v   i  U'  U  U  v    
K  v       v    
o  v     v   U'  v    
  v     U'  v      
  k    U'    v   `  A  v    
  v     v    
  k  -  T  U'  A  `      

  k  V  U'  A  T  `      
3  v   z  U'  [       
\  [    U'  v   U  U   
  v     ]a  U'   
  [    L  [      
      [     
  (    
  v     L  v    
  "  0  L  v    
  v   O  [    v    
6  j  [       
U  v     L  [    -   
p  v     [  L  [   
  v     L  [   
  v     L  [  .   
  v     L  [     
  v   )  L  [       
  v   M  L  [  L  [   
/  v   v  L  [  L  [      
S  v     [     
  
|  v     [  [     
\  
  v     [  .  `  `  v    
  k    [  .    `   
  k  '  [    `   
  v   A  [  .   
-  v   e  L  e       
  
G  v     L    v    
q  v     L  [  U'       @   
  v     L  "  v    
  L       
    L   
    L  v    
  v   -  L  o   
  v   B  L   
3  S     
H  v   h     
Y  v     [     
  (    
n  v       @     
  v     ]a  [   
  v            
  [      v    
  [      [  v    
  [  B    v   .     
$    X  	       	hd      	2&      	p\      	q\      	r\      	
\      	
      	S
      	W
\      	X
      !R      v   0@@                      	   1      @K  @0       $  (    
;      E   G                                              	    
 4    	  	             @                          (!=      ".   key #Pk      $      %      &=    
      \      Y  
_  t  U'  ,:     *             +len     ,       ,    v    F     ?   I       f                                           	    
 N<  F       F        N4^  F    5   F    6    N:  F    ;   F    <    N>  F    ?   F    @        `                                          M       ?(M       >(M       =(M       <(M       ;(M       :(M       9(M       8(M       7(M       6(M       5(M       4(M       3(M       2(M       1(M    '   /(M    (   .(M    )   -(M    +   ,(M    ,   +(M    .   *(M    /   )(M    0   ((M    1   '(M    2   ' ( <  0    9   4 ^  8   @    B   H    H   P    M   X    P   \ RA  M       ; M       - M       ( M       & M        M          S    `  Oval    /       .      /    9to 0   M    1   ?M    2   >M    3   =M    4   <M    5   <    a 9            a               D                   I     
D   n  Biov !)      "n   
      W      W	\          G   $                Mt      Pv   L      Xdev o         
            v      A             p+      R   L  L   
  
A      q  key Pk    *     :  nr ;    ip <        	  ~     ?      @        A       M  nr N        O   `    H       R"  abi S        T        \_      ]   reg ^       _v   idx `v    hk      l       m      n      o      pv    idx qv   $    rv   (    sv   ,    u"  0    v"  H    x  ` (    
  0@z      {	?    }/      ~@          0\      @       V          3hj{  /_  Z  /  //       h  5\       v   h      p      x                                     !      "ctx 	vS   $    
pS  H$    v   P$    v   T&    	?  X$      $      $      $       
       
  
  v        
  v       v    
      v    
       
  v        
      v   D  T    }T    ~T              @    P  
V  k    k      
q      @Z      A   9ip C      G$      H      I   9id J  (    K  0    OH  8    P  @    QA  H    Rl  P9raw Sr  X    Tx  `    U  h    V  x    W  9txn [   (    
Z            	       
                .  P      X9mod   `      h    v   p    !v   t    "  x    $   
e  (    
  (    
  RDH  9pid E    9tid F    RLl  9cpu M        N    
q  
  
  Pk    	  	     ~  z    	             X        
      q      v       v       v       v       ;M      <d        =F       >F   pid ?v    L     IV  tr J[       Kf      Lq      M      Nv        O:  (    P|  P    Q  X    Tt  `,    VE   p,    Y-  x+seq \t  |+ent ]   ,    ^   ,    _v    ,    `v    +cpu av    +ts b   +pos dU   +idx e[    (    
V  (    
a  (    
l  (    
  
w  
      q  
  I                                 v      
M  
      0{+      |R       }      ~v        h  (      th      u   raw v  hex w      x   
+  I                                               H                     reg 6      K       `  (      0    K  @ v   6    n     
  v   K     
<  3  `     
Q  J                                   N  F      Otp    
  
  
9  v          
  G   5*                                        Az      t  ;   Q  	   9  a  	       /v      0o      u       hu"      u#       u$v       u%      u&      u'       u(   (    u)~e  0 
      uOf      upb}      uqb}      urb}      usb}      ut0  I                                                  	    
                                                   
  [    %  	            .      /.   id 0       15   v   5    `  v    
  \    H@  	          `  	  	 \    IP  	        \    z\  	        \      	        ]    v                  +  ^+              _    `7      aB        bC  c        F  c        Q   c        \  c        Q     d    P  eidx v   feent P    
  g    uv           8         h    uL      h    uU'      c        g  c        r   i    Vv     js V]a  jv V  eent XP  feidx ]v   ebuf ^dR  feent aP  eval b      g    >v           ,         kbuf >      klen >`      kval >v       l    @   l    A   c        }   g    9v                     kbuf 9      klen 9`      kval 9v       c        }   g    4v                   8  kbuf 4      klen 4`      kval 4v       c        }   m    )U                 
  n    	bL  w  of 	bw   
P'  i    v     jfmt .  p q                F  r      r      b  a      8  s  s  _    b  t      b  u  pa      (  b  b   c           c             c           v        v        v        v        'v        ew        v        ek %U   :;I  $ >  & I  $ >  5 I   :;I  I  	! I/  
 I  '   I  :;   :;I8  :;      'I   '  !   4 :;I?<  :;   :;I8  4 :;I?<  :;   :;I8  'I  >I:;  (    :;I8  :;   :;I    I8  !:;  " :;I8  # :;I8  $ :;I8  % :;I8  & :;I8  ' :;I8  ( <  )4 :;I?  *:;  + :;I8  , :;I8  -:;  .:;  / I  0:;  1 :;I  2 :;  3:;  4 :;I  5 I8  6 :;I8  7 :;I8  8:;  9 :;I8  ::;  ; :;I8  < :;I  =:;  >:;  ?! I/  @ :;I  A :;  B :;I  C :;I  D:;  E :;I  F :;I  G>I:;  H! I  I>I:;  J>I:;  KI  L:;  M :;I8  N:;  O :;I  P:;  Q I8  R:;  S:;  T(   U:;  V <  W:;  X :;I8  Y&   Z I  [4 :;I?  \4 :;I  ].?:;'I@B  ^1RUXY  _U  `4 1  a1U  b4 1  c 1  d.:;'   e4 :;I  f  g.:;'I@B  h :;I  i.:;'I   j :;I  k :;I  l4 :;I  m. ?:;'I@B  n.:;'I   o :;I  p   q.1@B  r 1  s 1  t1U  u4 1  v. ?<n:;  w. ?<n:;   	   7	        ../drivers/misc/mediatek/chip ../include/uapi/asm-generic ../include/asm-generic ../include/linux ../arch/arm64/include/asm ../include/uapi/linux ../arch/arm64/include/uapi/asm ../include/clocksource ../include/linux/pinctrl ../drivers/misc/mediatek/include/mt-plat  mt_chip_common.c   int-ll64.h   int-ll64.h   posix_types.h   types.h   init.h   cachetype.h   printk.h   fs.h   notifier.h   kernel.h   capability.h   memory.h   thread_info.h   time.h   compat.h   poll.h   thread_info.h   sched.h   hwcap.h   ptrace.h   ptrace.h   spinlock_types.h   lockdep.h   spinlock_types.h   rwlock_types.h   fpsimd.h   hw_breakpoint.h   perf_event.h   processor.h   atomic-long.h   seqlock.h   time.h   jiffies.h   ktime.h   timekeeping.h   timer.h   blk_types.h   mm_types.h   pgtable-types.h   pgtable.h   rbtree.h   osq_lock.h   rwsem.h   wait.h   completion.h   cpumask.h   uprobes.h   mmu.h   mm.h   cpufeature.h   arm_arch_timer.h   timex.h   plist.h   nodemask.h   cputime_jiffies.h   llist.h   smp.h   smp.h   rcupdate.h   rcutree.h   highuid.h   uidgid.h   signal.h   signal-defs.h   siginfo.h   signal.h   pid.h   pid_namespace.h   percpu.h   percpu.h   mmzone.h   mutex.h   workqueue.h   topology.h   gfp.h   percpu_counter.h   seccomp.h   rtmutex.h   resource.h   timerqueue.h   hrtimer.h   task_io_accounting.h   sysctl.h   nsproxy.h   cred.h   compat.h   debug_locks.h   shrinker.h   page_ext.h   vm_event_item.h   vmstat.h   kref.h   dcache.h   stat.h   kmod.h   elf.h   elf.h   idr.h   kernfs.h   seq_file.h   kobject_ns.h   sysfs.h   kobject.h   moduleparam.h   jump_label.h   module.h   ioport.h   klist.h   devinfo.h 	  pm.h   device.h   pm_wakeup.h   ratelimit.h   device.h   mod_devicetable.h   of.h   list_bl.h   lockref.h   path.h   list_lru.h   radix-tree.h   fiemap.h   migrate_mode.h   ioctl.h   fs.h   dqblk_xfs.h   quota.h   projid.h   quota.h   uio.h   cdev.h   nfs_fs_i.h   uio.h   poll.h   irqnr.h   hardirq.h   irq_cpustat.h   interrupt.h   tracepoint.h   trace_seq.h   perf_event.h   local.h   local64.h   ftrace.h   ftrace.h   node.h   cpu.h   irq_work.h   jump_label_ratelimit.h   ftrace_event.h   platform_device.h   mt_chip.h 
  mt_chip_common.h   proc_fs.h     	        k <k. k  k =<E#hut<pf  	         <!uB<!;!!1!#*$/q<!;!! .fuf<L,M+M+o>v0K/"wf	.0n    fO.            x <                      A@DEh
 A  ,               8       A AAJ     $                       ADB $               ,       ADE $                       ADB D                     A`AA
	BCt
 A                           sched_entity long long int __u64 audit_context notifier_call is_in_guest line link zone_stat_item console_printk param_ops_invbool vm_page_prot enabled init_pid_ns shared_vm sample_stack_user vm_stat_diff si_errno tasks read file_ra_state TRACE_EVENT_FL_NO_SET_FILTER_BIT setattr long unsigned int if_dqinfo ino_ida compact_cached_migrate_pfn atomic_notifier_head fs_overflowgid NR_KERNEL_STACK LRU_UNEVICTABLE pi_lock tmpfile private lowmem_reserve state_remove_uevent_sent personality error_remove_page NR_ISOLATED_FILE jiffies map_count exclude_callchain_kernel file_inode system_freezable_power_efficient_wq version target_kn CHIP_INFO_REG_HW_SUBCODE mmap_rnd_bits release UNEVICTABLE_PGCLEARED mmap_base restart_block sibling nr_migrations delta_us layer file_lock_operations s_id PGREFILL_NORMAL stack_guard_gap fe_logical pinned_groups ioac rcu_read_lock_nesting lb_imbalance dqi_format timer_expires platform_bus dentry_stat_t request_pending s_qcop dl_period __kernel_gid32_t kstat LRU_ACTIVE_ANON usermodehelper_table vm_rb generation UNEVICTABLE_PGMUNLOCKED mnt_namespace vfsmount dirty_inode COMPACTFREE_SCANNED request_queue rt_priority ngroups seccomp_filter height alloc_inode s_max_links tstamp_enabled year umode_t exit_state offline nr_dirtied addr_limit self_exec_id dumper resolution dqonoff_mutex stime PSWPOUT num_poisoned_pages to_str list ia_size TRACE_EVENT_FL_TRACEPOINT_BIT TSK_TRACE_FL_TRACE_BIT name section_mem_map page_frag dqb_ihardlimit kernel_cap_struct HRTIMER_MAX_CLOCK_BASES k_sigaction total_vm fs_flags subdirs qs_itimelimit task_list NR_WRITEBACK_TEMP id_lock platform_bus_type loff_t ratelimit_state fl_owner sysctl_nr_open dec2str max_segment_size overflowgid __security_initcall_start nanosleep NR_FILE_DIRTY system_highpri_wq vmstat_text block_device n_ref totalram_pages seeks i_bytes COMPACTFAIL iowait_sum perf_overflow_handler_t device_attribute HRTIMER_BASE_MONOTONIC iov_len started regs exec_domain dev_groups tty_audit_buf perf_event_mutex nameidata iattr trigger resume lru_list BLOCK_SOFTIRQ magic kptr_restrict load_weight waitq chip_ent stop per_cpu_pageset kset_uevent_ops thread_struct sched_reset_on_fork suspend d_seq splice_write ../drivers/misc/mediatek/chip/mt_chip_common.c lb_failed child_ns_type live quota_type PERF_EVENT_STATE_OFF mapping rb_root mt_chip_drv qsize_t sendpage hrtimer_interval_ms group_info cancel_txn root_user list_lock high async_suspend sa_restorer PERF_COUNT_SW_PAGE_FAULTS_MAJ TRACE_REG_PERF_OPEN cap_effective Elf64_Dyn net_ns reclaim_stat COMPACTISOLATED config s_magic vm_fault node_id pcpu_chosen_fc s_flags uidhash_node max_mapnr sched_domain_topology qs_incoredqs sigaction uevent_suppress group_stop_count destroy_dquot s_mem CHIP_INFO_PROJECT_CODE arch_hw_breakpoint generic_ro_fops s_stack_depth remove sival_int nr_dirtied_pause idle_idx kernel_param_ops jobctl param_ops_uint kprojid_t pushable_dl_tasks rcu_pending perf_raw_record _call_addr mmap2 pcpu_fc_names fown_struct cmaxrss perf_callchain_entry predicted _pad2_ rmdir pi_state_list panic_on_oops _softexpires segment_boundary_mask __cap_empty_set fl_wait pdeath_signal MM_SWAPENTS thaw releasepage fi_extents_max KOBJ_NS_TYPES i_cdev __security_initcall_end wait_lock _pad3_ s_remove_count expires d_rcu highest_vm_end pfmemalloc static_prio COMPACTSTALL mmap_mutex brk_randomized freeze_late lost_events NR_PAGES_SCANNED nr_failed_migrations_affine FTRACE_EVENT_FL_ENABLED_BIT rb_node get_guest_ip lb_balanced subsys_data acpi_node WMARK_MIN disable_depth module_kobject pid_gid nlm_lockowner CPU_MAX_IDLE_TYPES ksoftirqd inv_weight iomem_resource i_lru runtime_resume backing_dev_info pteval_t end_data poweroff_noirq poll_queue_proc panic_timeout timer_autosuspends fsync actor running_avg_sum cnvcsw lruvec last_queued pid_type plist_node bool FTRACE_EVENT_FL_FILTERED_BIT _addr ia_mode sysctl_legacy_va_layout dl_throttled inodes_stat dentry_operations timer_list CHIP_INFO_WAFER_BIG_VER dq_hash quota_on orphans_remove_sched _status cpu_itimer frozen aio_write sysctl_vfs_cache_pressure sched_info kiocb capabilities sbe_balanced of_allnodes mount N_ONLINE BLOCK_IOPOLL_SOFTIRQ dqb_curinodes last_balance param_ops_bint preempt_count size proc_work pending compat_elf_hwcap migrate_entry nohz_idle check_flags s_op pm_power_off_prepare percpu_counter in_iowait first prefix mtime commit_txn compact_blockskip_flush get_reserved_space active_mm zone_reclaim_stat id_free_cnt FTRACE_EVENT_FL_NO_SET_FILTER_BIT user_fpsimd_state s_writers_key ctrl compat_timespec mmap_rnd_compat_bits_max simple_dir_inode_operations time_slice config_base ia_ctime param_ops_charp running cpu_possible_mask burst boot_command_line posix_timer_id task_size cpu_idle_type objects event_constraint nr_busy active_nodes wakeup_count block_max size_t extra_reg atomic_flags blocking_notifier_head kref sched_statistics page_tree fl_type interrupts export_operations __smp_cross_call statfs newidle_idx PGSCAN_DIRECT_NORMAL wakeup_events fl_break_time event_base_rdpmc s_dev PGSCAN_DIRECT_THROTTLE mm_count kernfs_syscall_ops zonelist_cache N_MEMORY hiwater_vm PGSCAN_DIRECT_DMA MIGRATE_TYPES poll fl_nspid NR_SLAB_RECLAIMABLE perf_event_ctxp event time_t mem_op seqcount perf_invalid_context chip_proc_show ftrace_event_class show_path dq_sb ttwu_move_affine idle_state mmap_sem qfs_nblks d_rt_space cpumask_var_t PERF_COUNT_SW_EMULATION_FAULTS bd_dev seqlock_t resume_noirq exclude_guest layers setup_max_cpus period PGSTEAL_KSWAPD_NORMAL trace_reg prev_pos is_suspended current_may_mount tstamp_running print_fmt sa_flags DUMP_ALL callback_head user_namespace sleep_start anon_name user_fpsimd SB_FREEZE_COMPLETE mem_dtlb _arch irq_work kobj_sysfs_ops dquot_operations init_task PGPGIN last_siginfo event_base private_data kernfs_elem_symlink _pad1_ stat_threshold system_freezable_wq PGMIGRATE_SUCCESS make_it_fail core_id acpi_dev_node FTRACE_EVENT_FL_SOFT_MODE_BIT s_subtype page_ext_operations probe single_open panic_on_io_nmi need PAGEOUTRUN class_attribute page_group_by_mobility_disabled attr RPM_SUSPENDING close free_bitmap s_time_gran dqi_dirty_list TRACE_REG_REGISTER mmlist security thread_id sleep_state dquot bd_mutex evict_inode elf_hwcap bio_vec comm_exec s_fs_info uprobes_state PGSCAN_DIRECT_MOVABLE f_cred cpu_base is_user_mode PIDTYPE_SID vm_event_item iowait_count hotplug_down_time get_time f_flags sysctl_stat_interval nr_threads last_period preempt_disable_ip buflen debug_locks_silent hd_struct readpages NR_ISOLATED_ANON ignore_children shared debug cap_ambient i_mtime qs_uquota DQST_SYNCS NR_ALLOC_BATCH PCPU_FC_AUTO device _qproc group_node cpu_subsys N_NORMAL_MEMORY _uid zone_watermarks suspend_late mmap_rnd_compat_bits_min RPM_REQ_AUTOSUSPEND define_fields priority nr_files N_CPU dqb_curspace check_quota_file stats_lock d_space of_node_ktype usage s_mtd lock_key _mapcount prio_list sysctl_overcommit_kbytes lock devt sd_flags rb_left fsgid tree_lock alloc_lock gtime timespec bio_list printk_disable_uart dqi_bgrace trace_recursion tty_struct thread_sibling fs_quota_stat pmu_cpu_context fl_owner_t boot_tvec_bases wakeup_source f_tfile_llink qs_btimelimit map_pages i_sb_list system_unbound_wq mm_context_t PGSTEAL_DIRECT_DMA HRTIMER_NORESTART cap_permitted fl_u __s8 g_chip_drv freq_time_stamp ZONE_MOVABLE bd_block_size pushable_tasks i_mutex quota_format_type d_name lru_lock fault_address vfork_done seqcount_t f_op PERF_COUNT_SW_CPU_MIGRATIONS read_file_info root nrshadows list_lru_node direct_complete update_time nr_wakeups_affine start_code kobj_ns_type dma_parms inherit wakee_flips sock local_t DUMP_ORIG start_time hrtimer_clock_base notifier_block oom_flags vm_file super_operations mtd_info hmp_last_up_migration set_child_tid ia_uid __u8 i_rdev nr_dentry next_decay_max_lb_cost sched_group hotplug_down_lat_max notifier_fn_t MIGRATE_RESERVE pending_wakeup mmap_legacy_base s_active real_timer access accounting_timestamp max_pgoff perf_cpu_context NR_SHMEM ttwu_wake_remote read_dqblk chip_proc qf_owner write_dquot d_compare CHIP_INFO_FUNCTION_CODE imbalance_pct PERF_EVENT_STATE_ERROR dqi_valid _overrun no_printk hex_asc_upper qstr dqb_isoftlimit hint bitset tgid d_subdirs bp_list f_ra cputime module_sysfs_initialized NR_VM_EVENT_ITEMS bd_inodes cpu_active_mask zone_start_pfn thread_group_cputimer sa_handler notifier_mask freepage event_init i_security d_manage unfreeze_fs span_weight system_wq fl_pid fe_flags orig_x0 task_ctx_nr sighand_struct s_vfs_rename_mutex swap_info_struct full ent_size NR_INACTIVE_FILE trace_array kparam_string level rename_lock bd_contains module free_area qs_pad1 qs_pad2 state_add_uevent_sent exe_file persistent_clock_exist chip_common_init forkexec_idx perf_sched_events set_info upid kernfs_open_node nr_active uts_ns processes fl_end hrtimer_base_type total_time_enabled HI_SOFTIRQ suspend_timer dqb_bsoftlimit unregfunc kqid CHIP_INFO_DATE_CODE disabled fl_release_private mmapped NR_MLOCK fe_reserved func core_sibling pcount expire_count autosleep_enabled maj_flt tstamp_stopped i_default_acl release_dqblk small_block owner SB_FREEZE_WRITE first_page user_ns flush_branch_stack PGSTEAL_DIRECT_MOVABLE MIGRATE_PCPTYPES i_rcu qf_ops PERF_COUNT_SW_ALIGNMENT_FAULTS param_ops_short epoll_table TSK_TRACE_FL_GRAPH_BIT constraint USRQUOTA __per_cpu_offset param_array_ops fs_qfilestat_t precise_ip addr runnable_avg_sum start_prevent_time active_jiffies quota_on_meta rb_subtree_gap fl_copy_lock d_rt_spc_timer sysctl_memory_failure_recovery wps_disabled write fl_file poweroff_late atime timestamp snprintf restore_early arch_hw_breakpoint_ctrl power_state stimescaled hrtimer_restart perf_sw_ids scan_objects cputime_expires mod_name exclude_user pte_t dev_name HRTIMER_RESTART s_bdi kernfs_open_file fu_llist inactive_age address_space_operations alb_failed filter show_unhandled_signals sysctl_memory_failure_early_kill domain_data raw_init vm_prev seq_operations policy a_ops cnivcsw driver_private trace MIGRATE_RECLAIMABLE MIGRATE_ISOLATE CHIP_INFO_SW_VER sigset_t seq_show perf_event_task_context set_acl hotplug_down_lat_min nr_wakeups_passive ptrace_entry real_blocked __con_initcall_start on_cpu SYSTEM_POWER_OFF private_list dev_release compat_rmtp rb_subtree_last sched_domain_mask_f Elf64_Xword perf_branch_stack readlink PGREFILL_MOVABLE i_writecount prepare compat_time_t nr_failed_migrations_running d_iname oom_score_adj_min UNEVICTABLE_PGMLOCKED files_stat_struct oublock irq_default_affinity function inode_operations PIDTYPE_PGID s_shrink lb_gained prevent_sleep_time s_inode_lru active_oncpu dev_pm_ops free_cached_objects callchain llnode param_ops_string NR_FILE_PAGES sched_rt_entity sleep_max zlcache_ptr mmap_miss task_ctx timestamp_enable state_initialized fmode_t qc_dqblk __kernel_timer_t busy_idx uaddr2 bd_write_holder i_fsnotify_marks simple_dentry_operations vmacache tail env_end mm_kobj s_options wait_queue_head_t d_prune mark_dirty TASKLET_SOFTIRQ core_thread raw_notifier_head last_runnable_update tracepoint incr_error __i_nlink module_attribute qs_rtbtimelimit env_start sched_avg rlim_max linux_proc_banner next sched_domain dma_pfn_offset f_path nfs4_fl total_cpus nrpages partno d_lru nr_siblings percpu_counter_batch nr_free SYSTEM_HALT __perf_regs tick_cpu_device nr_freq back _Bool min_free_kbytes netlink_ns freelist i_atime zone free_list linear parent rlock dirtied_when s_vfs_rename_key deactivate_waitq cg_list cap_bset mem_lvl total_forks task_cputime system_states put_super attrs utime prev_count alb_count drv_groups softirq_time leftover nr_normal_prio s_export_op _sigval isolate_page PERF_COUNT_SW_PAGE_FAULTS_MIN d_flags group_leader pi_waiters __sched_text_start setup is_late_suspended trace_event_functions hash_len names_cachep nr_forced_migrations s_umount devtree_lock node_zones destroy allnext min_interval runtime_idle migrate_mode is_dirty_writeback setlease subsys_private age_limit my_q siginfo_t fa_lock wait_table_bits nr_events lock_count detach store fpsimd_state nr_deferred DQST_FREE_DQUOTS DQST_ALLOC_DQUOTS LRU_INACTIVE_FILE NR_UNSTABLE_NFS hrtimer_cpu_base journal_info header_size min_flt avg_period tv_nsec set_dqblk mask rcu_blocked_node bd_claiming jiffies_64 s_writers bps_disabled is_noirq_suspended hres_active UNEVICTABLE_PGSCANNED of_stdout tracepoint_func fiemap_extent arch_spinlock_t saved_auxv hbp_break free_file_info event_limit secondary_data fl_lmops interrupts_seq futex_offset pmu_disable release_dquot kmsg_fops clear_child_tid cpu_file s_dquot load s_type rcutorture_testseq ioctx_lock inactive_ratio bp_len _pad user_pt_regs fiemap blocks grab_current_ns audit_tty zone_type total_time_running cred pgd_t dqi_igrace iommu_group pending_disable anon_vma_chain __stop___param compact_considered kobj_completion index prove_locking clock_base dev_pm_qos string start_data id_free buffer_iter thaw_noirq list_node ipc_ns notify_count init_user_ns radix_tree_root task lm_setup rwlock_t vm_event_states cgtime perf_events UNEVICTABLE_PGCULLED recent_rotated workqueue_struct empty_aops ALLOCSTALL inotify_devs tv64 trace_event slab_cache i_sb platform_notify freq_count_stamp devnode tmp_seq chip_proc_fops sbf_balanced vm_end error nsproxy pstate swap_deactivate i_devices parent_exec_id loginuid sched_dl_entity hex_asc TRACE_EVENT_FL_IGNORE_ENABLE_BIT inode pipe_inode_info dqio_mutex sbe_pushed d_weak_revalidate mknod cmaj_flt create tick_nsec perf_event_active_state param_ops_bool match ipi_irqs PGSCAN_KSWAPD_MOVABLE timer param_ops_ulong dma_coherent_mem PERF_EVENT_STATE_INACTIVE FTRACE_EVENT_FL_TRIGGER_MODE_BIT max_time get_xstatev SCHED_SOFTIRQ dl_bw lb_nobusyq lm_change siginfo pfmemalloc_wait _stime rw_semaphore PERF_EVENT_STATE_ACTIVE i_ino tasklist_lock funcs chip_proc_open file_operations s_lock_key s_security has_timeout pid_chain radix_tree_node files_struct llseek file_lock lock_class_key fiemap_extent_info sa_mask page data_src dl_new fpcr sched_task_group zone_idx parent_ctx tp_event runtime lookup sighand_cachep invalidatepage persistent_clock_is_local N_HIGH_MEMORY reserved kernel_kobj sbf_count TRACE_REG_PERF_CLOSE KSWAPD_LOW_WMARK_HIT_QUICKLY d_child f_pos_lock gid_t compact_cached_free_pfn short unsigned int refcount device_node tick_usec sync_fs per_cpu_pages TRACE_REG_PERF_DEL dev_pm_info state_in_sysfs PCPU_FC_EMBED active_bases lb_hot_gained CHIP_INFO_HW_SUBCODE panic_on_unrecovered_nmi CHIP_INFO_HW_CODE rt_rq module_ktype group_exit_task bd_private pid_namespace destroy_inode _pid private_lock i_blkbits dev_archdata is_child_subreaper poweroff nr_wakeups_local dq_wait_unused sys_tz CHIP_INFO_REG_SW_VER deadline host sched_domain_topology_level event_filter perf_hw_context cpu_timers getxattr inotify_watches get_fields it_real_incr f_ep_links coublock last_cpu rm_xquota need_qs rwsem dqb_bhardlimit s_root iov_iter remount_fs kernfs_elem_dir sysctl_protected_symlinks vruntime nr_retries NR_VMSCAN_WRITE atomic_write_len mmap_data ida_bitmap qfs_nextents deferred_resume wait_queue perf_swevent_enabled attach_state compact_defer_shift DQST_LOOKUPS exec_start vm_ops base s_inodes PERF_COUNT_SW_PAGE_FAULTS address bp_addr seq_file regs_on_excp hotplug_up_lat_max kobj sum_sched_runtime cpu_hwcaps is_prepared printk page_symlink_inode_operations timestamp_us cpu_online_mask wait WORKINGSET_NODERECLAIM show_fdinfo audit_tty_log_passwd pgoff ring_buffer alb_pushed exec_vm cpu_all_bits interval ctl_table_poll unix_inflight poll_event nr_isolate_pageblock default_timer_slack_ns nodemask_t max_files printk_delay_msec pcpu_fc nvcsw def_blk_fops completion vdso PGALLOC_NORMAL vm_area_struct signal d_rt_spc_warns maxlen pglist_data super_blocks SB_FREEZE_FS gfp_mask ia_valid PRJQUOTA pgprot_t direct_IO default_exec_domain show idr_layer atomic_open s_xattr phandle ipc_namespace is_active d_spc_hardlimit MM_ANONPAGES get_dqblk pcpu_base_addr utilization_avg_contrib i_data hw_perf_event create_procfs tid_entry virtual_address thread_info wait_table_hash_nr_entries NET_TX_SOFTIRQ __count unsigned char rdev exclude_idle file_caps_enabled uts_namespace umount_begin _kill bd_list sigval_t incr dq_op fu_rcuhead PGSTEAL_KSWAPD_MOVABLE work quota_off fa_next pid_cachep hotplug_up_time KSWAPD_HIGH_WMARK_HIT_QUICKLY __rb_parent_color DQST_READS page_mkwrite tlb_flush_pending bv_page hotplug_down_lat_us projid __kernel_clockid_t class dma_pools of_chosen uevent_helper DQST_DROPS watchdog_stamp rename euid sysctl_protected_hardlinks TRACE_TYPE_PARTIAL_LINE read_iter hrtimer parent_gen flock bin_attribute freeze_noirq process_counts phys_addr_t drop_ns vm_stat files_stat i_hash sigcnt envp PGDEACTIVATE i_blocks run_delay RPM_REQ_NONE notify_next cap_inheritable DROP_PAGECACHE rlim_cur MIGRATE_MOVABLE /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out platform_data dev_pm_domain kswapd_wait write_inode __sighandler_t __kernel_pid_t cfs_rq tz_dsttime task_frag cpu_topology bd_holder_disks arch_timer_read_counter PGSCAN_KSWAPD_NORMAL sysctl_lowmem_reserve_ratio trace_print_func begin i_mmap_nonlinear last_pid CHIP_INFO_REG_HW_VER usage_count period_left debug_info sas_ss_sp mt_need_uart_console type s_umount_key mem_section softirq_to_name TRACE_REG_PERF_REGISTER qfs_ino lm_get_owner resource_size_t sighand span sample_regs_user cmin_flt in_execve d_dname fs_struct dq_lock list_op_pending child_count i_mmap quota_format_ops kmem_cache mem_dqblk hotplug_up_lat_min real_cred proc_inum pi_state_cache wait_unfrozen numbers si_code s_readonly_remount mm_struct done stream_id nlink d_parent nfs4_lock_state atomic_t path elem sysctl_user_reserve_kbytes anon_vma restore lm_compare_owner d_ptr PGREFILL_DMA owner_entry sample_type runtime_auto init i_lock_key LRU_INACTIVE_ANON init_nsproxy present_pages current_stack_pointer compat_long_t PGSCAN_KSWAPD_DMA free rmtp group_exit_code d_lockref active_count freq info perf_event_list robust_list_head last_arrival permission zone_padding put_link cred_guard_mutex migratepage bv_len printed memalloc_noio CPU_NEWLY_IDLE fl_start core_state show_devname ia_gid debug_guardpage_ops wakeup pinctrl_state sample_freq value pinned RPM_REQ_RESUME SB_FREEZE_PAGEFAULT kobj_uevent_env devres_head mnt_ns suid d_ino_warns UNEVICTABLE_PGSTRANDED NR_BOUNCE init_groups slab NR_FILE_MAPPED uevent_seqnum MIGRATE_UNMOVABLE prev_cputime suspend_noirq nr_balance_failed fs_supers kgid_t watermark thread SYSTEM_RESTART class_release CHIP_INFO_NONE linux_binfmt __reserved_1 fpsr iov_offset RPM_REQ_SUSPEND TRACE_EVENT_FL_CAP_ANY_BIT perf_event i_flock attribute ioctx_table vm_pgoff NR_ACTIVE_FILE nr_cgroups sb_lock reboot get_unmapped_area units fe_physical swapper_pg_dir seq_next poll_table_struct pm_domain_data nr_segs __kernel_loff_t wait_sum initial_ns suppress_bind_attrs wait_chldexit pid_link pm_subsys_data page_table_lock stack plug quota_info wakeup_path node_devices d_tag counter set_page_dirty vm_private_data node_states PGPGOUT count power_kobj HRTIMER_SOFTIRQ CHIP_INFO_FAB_CODE list_head bv_offset nr_to_scan nr_cpus_allowed epoll_watches pprev last_time i_generation f_owner timerqueue_node rec_idx _zonerefs ia_file fl_fasync quota_sync bus_groups ctime fl_downgrade_time init_thread_union rpm_status rb_entry RPM_RESUMING dma_mem of_aliases d_ino_hardlimit rcu_node use_autosuspend sessionid ttwu_move_balance device_type def_flags uid_t _flags f_version slab_page freeze __invalid_size_argument_for_IOC dqstats module_kset test system_power_efficient_wq compatible swap_in sysctl_drop_caches __reserved_2 enable_on_exec nr_dequeuing_low_prio drop_inode signum dentry print_fatal_signals default_attrs no_callbacks d_rt_spc_hardlimit mispred fs_quota_statv wakeup_watermark rcutorture_vernum arg_end PGALLOC_DMA resume_early fa_rcu MM_FILEPAGES tty_old_pgrp arch_rwlock_t NR_VM_ZONE_STAT_ITEMS MIGRATE_CMA i_nlink dl_boosted d_fieldmask WMARK_LOW suspended_jiffies NR_LRU_BASE ptrace_message late_time_init proc_handler balance_interval lists of_node normal_prio TRACE_TYPE_HANDLED seq_start of_match_table fl_link dmesg_restrict signalfd_wqh remap_pages proc_mkdir_data action sibling_list PGSTEAL_KSWAPD_DMA bd_part_count d_spc_timer compat_robust_list_head spanned_pages memstart_addr nr_wakeups_affine_attempts HRTIMER_BASE_REALTIME group_entry sched_class rcu_batches event_idx request i_mutex_key statistics kobj_ns_type_operations thread_node __restorefn_t TRACE_TYPE_UNHANDLED qs_bwarnlimit user_struct exit_code start_txn dqstats_pcpu PGMIGRATE_FAIL i_pipe wake_entry qs_iwarnlimit ktime_t compat_robust_list nr_ptes blkcnt_t xattr_handler device_driver N_POSSIBLE privilege suspended_step tags thread_union __kernel_time_t sector_t PCPU_FC_NR write_begin sysfs_dev_block_kobj fs_kobj from ctl_table GNU C89 7.3.1 20180522 -mlittle-endian -mgeneral-regs-only -mpc-relative-literal-loads -mabi=lp64 -g -Os -std=gnu90 -fno-strict-aliasing -fno-common -fstack-usage -fno-delete-null-pointer-checks -fno-PIE -fno-store-merging -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -fno-strict-overflow -fstack-check=no -fconserve-stack --param allow-store-data-races=0 NR_WRITTEN d_automount futex_pi_state dma_map_ops posix_acl dq_inuse start_brk system_state hbp_watch week fl_block device_private inblock __softirq_pending prev_sum_exec_runtime dq_dirty dqi_max_spc_limit dqi_flags mm_rss_stat param_ops_long MIGRATE_SYNC max_hang_time KOBJ_NS_TYPE_NONE compat_ioctl mem_lock COMPACTSUCCESS trace_iterator slots f_mapping ns_type unique_pmu early_boot_irqs_disabled FTRACE_EVENT_FL_TRIGGER_COND_BIT shutdown leader_pid nblocks note1 note2 note3 note4 async_size node _tid pmu_disable_count id_header_size cad_pid i_mmap_mutex sched_contributes_to_load total_time slice_max PIDTYPE_PID i_ctime hypervisor_kobj runtime_status s_count PGMAJFAULT fl_flags syscallno nr_wakeups_sync last_tag NR_ANON_PAGES reboot_notifier_list kstatfs sysctl_overcommit_ratio lock_manager_operations count_objects i_mode linux_banner dummy entry __int128 unsigned root_mountflags mm_rb __kernel_size_t splice_pipe dev_pin_info avenrun exclude_hv _band bits numa_level chip_inf_entry dl_timer __con_initcall_end chip_info_id short int __kernel_dev_t exclude_callchain_user cpu_power firmware_kobj notifier sched_group_capacity si_signo hotplug_timestamp_lock max_newidle_lb_cost profile_cpu_stats active set_latency_tolerance commit_dqblk vregs hrtimer_interval i_opflags file ia_mtime klist_node abort vm_area_cachep i_gid FTRACE_EVENT_FL_SOFT_DISABLED_BIT nr_cpu_ids bin_attrs __PIDTYPE_TGID nr_zones CHIP_INFO_REG_HW_CODE d_val dq_flags dev_uevent pm_message atomic_long_t archdata sysfs_ops f_security cstime nr_migrate_reserve_block sb_writers sched_domain_flags_f preset_lpj curr_target sbe_count io_context perf_event_attr dl_deadline namespace fl_link_cpu kernfs_root wake_cpu _key sas_ss_size is_partially_uptodate param_ops_ullong sysfs_dev_char_kobj thread_group SB_UNFROZEN on_rq fs_overflowuid write_info lm_owner_key s_bdev s_maxbytes qs_pad hlist_bl_node qf_fmt_id dirty_balance_reserve NR_SLAB_UNRECLAIMABLE sbf_pushed timer_slack_ns total_link_count kset group_rwsem i_count PERF_COUNT_SW_CONTEXT_SWITCHES regs_user PGFMFAULT gfp_allowed_mask revents s_anon NR_VMSCAN_IMMEDIATE long int zonelist sigpending seq_printf mmap_pages_allocated counters perf_guest_cbs shrink_control start perf_event_context arg_start s_blocksize_bits compact_order_failed TRACE_EVENT_FL_WAS_ENABLED_BIT recent_scanned panic_notifier_list startup bd_queue pinned_vm NR_NODE_STATES branch_reg idmap_pg_dir initcall_t hotplug_up_lat_us power proc_mnt uevent_ops dev_attrs coherent_dma_mask address_space irq_cpustat_t CHIP_INFO_MAX writepages optimistic_spin_queue symlink trace_seq fi_extents_mapped dl_runtime dev_kobj NR_FREE_CMA_PAGES read_pos ___assert_task_state wait_count ktype cpu_entry bd_fsfreeze_count nfds KOBJ_NS_TYPE_NET kernfs_node directly_mappable_cdev_bdi state kernfs_iattrs pinctrl perf_perm protection_map perm proc_self f_mode can_wakeup run_wake dq_id kuid_t wait_max expires_next cdev nr_pending decay_count pt_regs nr_hashed NR_UNEVICTABLE syscore files reclaim_state TRACE_REG_UNREGISTER write_file_info cache_nice_tries batch mem_map overflowuid s_instances node_start_pfn weight bdev_try_to_free_page date2str nr_wakeups bd_openers PDE_DATA locked_vm writeback_control s_pins real_start_time pad_until list_lru get_xstate i_bdev perf_nr_task_contexts fi_extents_start config1 COMPACTMIGRATE_SCANNED f_inode task_rss_stat bp_type nr_free_files futex blk_plug readpage properties _utime time child_total_time_enabled iov_base DQST_WRITES cluster_id prev seccomp cleancache_poolid ufds __kernel_clock_t i_op __initcall_chip_common_init3 stack_user_size dentry_stat s_dio_done_wq _sigfault NR_SOFTIRQS getattr event_list event_count child_list NR_FREE_PAGES NR_ACTIVE_ANON perf_refcount fe_length nr_wakeups_remote sysctl_panic_on_stackoverflow fault_code kernfs_ops NET_RX_SOFTIRQ bd_disk d_revalidate iterate nr_stat _DYNAMIC removexattr mm_segment_t branch_sample_type load_avg_contrib want_pages run_list device_dma_parameters context node_zonelists printk_ratelimit_state bd_invalidated locked_shm n_klist rotation_list get_acl last_wakee pmu_enable oops_in_progress hiwater_rss hide_pid proc_dir_entry nfs_lock_info ZONE_NORMAL runtime_suspend DROP_SLAB _sys_private d_fsdata dma_ops br_stack fl_ops full_name busy_factor rcu_expedited __icache_flags attr_groups launder_page tp_target dq_count setxattr robust_list initcall_debug sysctl_admin_reserve_kbytes timezone nodes_to_scan children pi_blocked_on exclusive mem_rsvd writeback_index Elf64_Addr dq_data_lock mach_panic_string inherit_stat PERF_COUNT_SW_DUMMY child_mutex _sifields dqb_rsvspace acpi_match_table zone_pgdat unlocked_ioctl nivcsw platform_notify_remove timerqueue_head prio perf_probe atomic64_t priv tv_sec dqi_fmt_id swap_activate bp_target max_lock_depth proc_thread_self KSWAPD_INODESTEAL qs_gquota _DQST_DQSTAT_LAST binary css_set pages task_works nr_inodes relax_count offset read_size saved_command_line init_mm offline_disabled PERF_COUNT_SW_MAX work_func_t listxattr s_mode cpu_vm_mask_var timekeeping_suspended __signalfn_t in_tx system_long_wq events d_release uevent acpi_device_id complete sysctl_overcommit_memory splice_read max_interval iter_flags d_op _sigpoll ftrace_dump_on_oops notifier_data unlink groups hash cpu_stats clockid_t nr_items zonelists_mutex cputime_t dl_yielded alloc pm_power_off RPM_ACTIVE wakee_flip_decay_ts entries i_state fe_reserved64 UNEVICTABLE_PGRESCUED PGSTEAL_DIRECT_NORMAL module_param_attrs lockref rb_right sched_domain_level_max SYSTEM_BOOTING s_mounts cinblock rnode signed char i_fop def_chr_fops pidmap TRACE_REG_PERF_ADD pids dqb_btime readpos NR_INACTIVE_ANON thread_head mmap_rnd_compat_bits kill_sb NR_DIRTIED nr_cached_objects exclude_kernel static_key _timer vm_start bad_sock_fops quotactl_ops init_name sysctl_perf_event_mlock kparam_array mmap sequence nr_unused NR_WRITEBACK i_private proc_create_data user_regs knode_class posix_timers property f_pos hlist_node siglock mutex _sigchld d_sb slack page_poisoning_ops comm i_version cpu_excp mm_users _addr_lsb sigval event_entry i_wb_list _syscall sysctl_perf_event_paranoid ktime supers reset_devices nr_branch_stack pageblock_flags dq_off isolate_mode_t inuse tracer ia_atime dirty_paused_when super_block group_flags init_struct_pid head child_total_time_running securebits SYSTEM_RUNNING d_un pid_t alloc_dquot qf_next perf_ops_bp show_options ring_buffer_iter long long unsigned int PGINODESTEAL egid cpu_context nonlinear thaw_early __kernel_uid32_t numa_zonelist_order d_spc_softlimit pipe_bufs overflow_handler FTRACE_EVENT_FL_RECORDED_CMD_BIT wait_table filldir_t debug_locks mem_snoop pin_count real_parent leases_enable SLABS_SCANNED cpu_present_mask system wait_start fa_file static_key_deferred lm_notify lease_break_time s_d_op restore_noirq hang_detected perf_sw_context __wait_queue_head perf_branch_entry static_key_initialized i_mmap_writable dev_root nfs_fl compat_uptr_t s_dentry_lru NR_LRU_LISTS clock_was_set tp_value depth s_uuid fa_fd vm_event_state hlist_entry ioport_resource kernel_cap_t i_size d_ino_count nr_hangs mem_dqinfo iommu_ops spinlock_t node_list LRU_ACTIVE_FILE oncpu exit_signal print_line_t high_memory pobjects shrinker work_struct kobject i_mapping exclude_host lb_nobusyg end_code CHIP_INFO_HW_VER bvec gfp_t __disable_trace_on_warning fields kobj_type run_node argv mmap_count mmlist_lock flags lb_count binfmt local64_t seq_stop user leader NR_MM_COUNTERS snapshot hlist_bl_head wake_idx irq_safe __kernel_long_t spinlock empty_zero_page fallocate fsuid oom_score_adj dqb_itime vmacache_seqnum RPM_REQ_IDLE MIGRATE_SYNC_LIGHT TRACE_TYPE_NO_CONSUME cpumask __kernel_ssize_t info_bit_mask pins __s32 block_start get_mt_chip_drv pending_load cgrp char orphans_remove kioctx_table dq_free sum_exec_runtime nr_wakeups_migrate d_spc_warns freeze_fs uaddr dq_dqb vm_next fs_qfilestat PERF_COUNT_SW_CPU_CLOCK GRPQUOTA cpu_bit_bitmap driver_data qs_version maxrss mkdir sgid syscall_ops regfunc pm_message_t vm_operations_struct swap_out rcu_special sample_id_all utimescaled s_list power_group_name ftrace_graph_call irq_stat elemsize extra1 extra2 hw_perf_event_extra task_struct nr_migrations_cold autosuspend_delay f_count PGROTATED fasync deadprops buffer ftrace_dump_mode procname bmap child_reaper mmap_rnd_bits_max DUMP_NONE d_inode __s64 follow_link pgdval_t PCPU_FC_PAGE bd_holders CHIP_INFO_ALL _sigsys fi_flags aio_read perf_cgroup cpus_allowed HRTIMER_BASE_TAI ptraced RPM_SUSPENDED rename2 active_entry dir_context hmp_last_down_migration rlim online oom_flags_t d_iput bd_super cputimer trace_entry task_group clockid rss_stat shared_pending node_present_pages d_time PGALLOC_MOVABLE d_delete __kernel_ulong_t fs_qfilestatv data sd_data rcu_scheduler_active projid_t tz_minuteswest perf_sample_data qs_pquota bitmap __reserved nfs4_lock_info i_fsnotify_mask drivers_dir d_ino_timer param_ops_ushort open d_alias writepage lock_stat MIGRATE_ASYNC blksize timestamp_rec kernfs_elem_attr pi_waiters_leftmost qs_flags bd_holder flush get_xip_mem mode bus_type saved_sigmask i_lock nr_failed_migrations_hot panic_blink dqi_priv lm_put_owner pageset attribute_group idle_notification rpm_request classzone_idx loadwop_avg_contrib i_flags TRACE_REG_PERF_UNREGISTER devres_lock perf_guest_info_callbacks is_visible d_ino_softlimit i_dentry fl_next rcu_node_entry gendisk wait_list param_ops_byte n_node kernel_ulong_t WMARK_HIGH aio_fsync nr_irqs nr_wakeups_idle start_stack PIDTYPE_MAX PGFAULT d_rt_spc_softlimit exec_max config2 raw_lock envp_idx __sigrestore_t bd_fsfreeze_mutex hex2str s_blocksize timeout raw_spinlock_t tvec_base fm_flt overflow_handler_context unique_id compat_elf_hwcap2 stat perf_trace_regs show_stats contig_page_data CPU_NOT_IDLE signal_struct get_chip_info __cap_init_eff_set link_count pid_ns_for_children fasync_struct DQST_CACHE_HITS i_acl read_format write_end d_hash TRACE_EVENT_FL_FILTERED_BIT perf_mem_data_src sample_period set_xstate child CPU_IDLE NR_ANON_TRANSPARENT_HUGEPAGES stack_vm cpu_chain rotate_disable _count pm_domain missed __sched_text_end pollfd HRTIMER_BASE_BOOTTIME __u16 d_select_inode putback_page task_io_accounting sysctl_perf_cpu_time_max_percent llist_node pcpu_unit_offsets has_child_subreaper i_uid vm_flags kernel_param kswapd_max_order pending_kill PERF_EVENT_STATE_EXIT fault rcu_read_unlock_special Elf64_Sxword blocked get_info sival_ptr raw_spinlock sum_sleep_runtime ftrace_event_call mmap_rnd_bits_min write_iter randomize_va_space hotplug_ts_rec kswapd percpu_drift_mark clock_list PGACTIVATE ssize_t default_state rlimit shadow_ctx_time ra_pages WORKINGSET_REFAULT dev_t cgroups NR_WMARK zoneref RCU_SOFTIRQ __u32 tp_list PGFREE cpumask_t WORKINGSET_ACTIVATE iovec of_device_id lm_grant __start___param node_spanned_pages bd_part PSWPIN TIMER_SOFTIRQ length simple_dir_operations module_uevent acquire_dquot class_attrs rt_mutex_waiter _unused_nodemask_arg_ trace_buffer lm_break file_system_type __MAX_NR_ZONES TRACE_EVENT_FL_USE_CALL_FILTER_BIT d_canonical_path page_cluster cutime i_dio_count ptrace dma_mask runtime_error perf_regs_user root_task_group qfs_pad delayed_work NR_PAGETABLE smt_gain param_ops_int managed_pages last_busy inodes_stat_t sysctl_perf_event_sample_rate flexible_groups bd_inode f_lock dqi_max_ino_limit driver unsigned int PERF_COUNT_SW_TASK_CLOCK movable_zone hlist_head vm_mm ZONE_DMA early_init resource tick_device i_mutex_dir_key                  c                 c                 c                                 P                                 Q                 c                                 P                                 Q                                 R                                 P                                 Q                                 R                                 P                                 Q                                 R                                 P                 e                 e                                 Q                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                ,                    9                    F                    S                    `                    m                    z                         	                    
                                                                                                                                                                                                                     .                   <                   J                   X                   f                   t                                                                                                                                                                        8                            8                   X       ,                                                                                                                                                      
                 '   
                D                     M    d             ]                     g                     x                                                                                                                                                                                         mt_chip_common.c __reg_num_x0 __reg_num_x1 __reg_num_x2 __reg_num_x3 __reg_num_x4 __reg_num_x5 __reg_num_x6 __reg_num_x7 __reg_num_x8 __reg_num_x9 __reg_num_x10 __reg_num_x11 __reg_num_x12 __reg_num_x13 __reg_num_x14 __reg_num_x15 __reg_num_x16 __reg_num_x17 __reg_num_x18 __reg_num_x19 __reg_num_x20 __reg_num_x21 __reg_num_x22 __reg_num_x23 __reg_num_x24 __reg_num_x25 __reg_num_x26 __reg_num_x27 __reg_num_x28 __reg_num_x29 __reg_num_x30 __reg_num_xzr $x chip_proc_open chip_proc_show dec2str date2str hex2str $d chip_proc_fops chip_ent chip_proc __initcall_chip_common_init3 snprintf get_mt_chip_drv seq_lseek proc_create_data proc_mkdir_data g_chip_drv printk PDE_DATA seq_read seq_printf chip_common_init single_release single_open               I                              $                   (         N           @            Y       D            Y       L         B           l            ^       p            ^       t         B                       g                   g                B                                                                                  l                                      l                                              (                   @                   X                  \                  l                  p                  x        K                                      K           4                   H                  P                  T        K           d                   h                                                            (         F           ,                    0                    8                    <                    @                    L                    l                             E                       .                   .                H                                                          H                    D                    J           h                    x         M                                                                     (                   0                   @                   H                   X                   `                   p                   x                               X                                      8                                                                                                               L                                                                                                        P                                    <A                         %                    *            M      7            h      <            2      I            p>      U            V      Z            y      g            U7      l            kp                  |                  ~                  r                                                        rk                       <           p      Q           o      ^           Z      h           Zt      s           A      ~           k                                  V                 Gp                 I                 P                 ?`                 )                 ?                 V                 {                                  .k      #           g      .                 ;           +      @           K      K           77      V           R      a                 l           {      w           F                 P                 .P                 n                 )                 s                 @                 JC                 I                 D                 I                 d                 J                 O+      '           `      :           ~      F                 S           i      _           O+      k           \J                                  O+                 "                 [                 '                 oV                                   z      !           4      ,           e      7           ]j      B           M      M           c      X           2c      s           U      ~           =+                 6                 B                 b                  <                 /N                                  5                 f#                 5                        
           %                 =s      $                 1           D@      >           E{      K           {a      X                 e           d      r           S                 2i                 (u                 u                                                   2w                 r                                  	                 H                                  a@                       (           f      5           R.      B           o      O           ;      b           0      n           W      {                            j                 [                 u                 wb                 p                                  	8                 H                 #a                 U                 S                  ,      2           g      8           k      >           +      D           '      J           G      Q           R      ]           3      i                 u           r                 r                                                   d                 >                                  m                                  x                  N                 q      +           ;o      7                 C           _      O           *      j           t      v           E                 '                                  $                 d                 X/                                  d                 X/                 :`      	           !]      	           5      	           d      )	           X/      6	           y      M	           Gf      Y	           Z      t	           _      	                 	                 	                 	           a      	           2>      	           ;o      	                 	           d2      

                 
                 "
           Z      :
           ;      F
           i      S
           @r      b
           ^]      o
           {I      |
                 
           ;o      
           }      
           O      
           '      
           ab      
                 
           Wg      
           Y      
           Y      
           d                                  M      %           r      2           O      Y           P6      u           &                 >J                 Rs                 P                 z                 v                 o/                                                                     G                 0      +                 <           o      J           O*      X           t      f                 t           O                 Xn                 +                 '                                  C                                  `                 T                                        (           bl      6           E,      D           c      R                 `           c-      n           ps      |           k'                 Ph                 oY                 rO                                                   0                 ,                 &                 q                 |%                       $           V      2           }G      @           <      N           d      \                 j           _      x           E/                 '#                  x                 
L                 q                 %                 F9                 D                 [1                 i                 x                 ,Z                  G      ;           %^      I           q3      W           <      e           ZC      s           z                 x'                 u                 w                 B                 (Y                 V                 f                 x                  re                 !                  3                 RK      )            `      7           3      E                 S                 b                 q           p-                 ~u                 c                 ,/                 -                 I                 +^                 .                 X                 M                 b                 K                 {      '           ,      5           vc      C           P      Q                 _           D      m           0      {                            E                 
                 V                 A                                                   
                 j                 Z                 X<      $           &      2           U      G                 R           RE      ]                 h           *x      s           -      ~           	1                                  y3                 z                 eW                 H                 K6                 U                        C           y3      j           ri      {           ]                                   1U                 f#                 O+                 0                                  .M                 1                 ?u                 6                 {      #           w      1           w      F           L,      S           o      h           -n      |           w                 r2                 eW                 H                 K6                                  .                 X%                 t      )           B      8           ^P      G                  W           
      c           :      o                 {                            U                 ~!                 Ac                                  B                                  }T                                                     (	                 lb      $           0      0                  T           ![      `           -      l                  x           O                                  G	                 1O                 #                 Hk                 B                 hP                 /                 %                 &0                 R      "           MH      1           j      >           O      K           nN      X                 e           m      r           s                 +                 j                 c-                 ^]                 :                 I                 C                 X"                 H1                                                   /#      (           {      5                 B           9/      P           T      ^           e                 h7                 _                 j                 Id                 `                 E,                 Rn                 D                 f#                       $           $o      ?            K      M           %O      [           Y      i                 x           r                                  z                 }1                 w                 ?0                 .                                  k                 x                 u6      ,           G&      ;           k                 R                 k                 m                 .                                  Aa      ,           s      :           DX      E           T      Q           7i      ^                 s           T                                                   c                 t                 A                 8                 /                 
                 X                 Pj                 2                 P                 f                 !      &           6      1           N      =           U      I                 U           :      a           (      m           yt      y           i                 w                                  7                 ?                 /F                 )J                 66                 ;o                       *                 7           ^      D           c~      Q           s      ^                 l           .       y           /                 u                 s                 *                 B                 r!                 z                 |                 N                 )b                 fa                 [                 >      "           W8      /           ]      <           w      Q           ?      \           r      g           %      r           `1      }           ==                 o                 H                 [                 n                 Q?                 g                                  	                  n                 v\                 X*      &           T5      3           I      ?           v      K                 d           f#      q           m      ~                                             w*                 <                 _D                 ;                 ?p                 GV                 *|                  W                        %            ;      0            l      ;            8       F                  w            <                  Eq                  UD                  2i                  U                  o                  H                        !                 !           U       !                 :!           i      G!                 T!           &P      a!                 n!           kI      |!                 !                 !           b      !                 !                 !           ^      !           [      !                  !           ;      !           }y      !           zK      "           a      "           n      &"           1      3"           H      @"           R      \"           Tw      j"           :[      x"           L      "            +      "           ]*      "           0      "           t      "           Jo      "           e      "           a      "           ;o      "           dF      #           0      #           jH      "#           !      0#           {?      >#           S      M#           S      i#           8      v#           <      #                 #                 #           
      #           A\      #           9      #                 #           	      #           Rm      #           C      #           ~B      $           T      $           +      &$                 3$           c      @$           &      M$           ;o      Z$           .      g$           8      u$           '      $           z      $           1      $           ,      $                 $           j      $           m      $                 $                 %           H      (%           y      =%           Z      M%           ;W      v%           O+      %           le      %           }n      %           K      %                 %           IG      %                 %           3       &           |#      &           C      &                 #&           66      /&           e      ;&           h      H&           W      d&           p+      q&           _      ~&                 &           l~      &           qr      &                 &           ]      &           ,7      &           i      &           yJ      &           w      &                 '           K      '           eX      '           z      )'           9      6'                 C'           S      s'           '      '           >,      '           k      '                 '           <      '           h      '           d3      '           q      '           &      '                 '           $      	(           ~      (                  #(           rz      0(           l      >(           1      K(           D      X(           :      e(           vH      r(                 (           I      (           D      (           q      (           (u      (                 (           z      (                 (           n?      (                 (                 )           KN      )           *      ,)           d2      9)           O+      M)           dF      [)                 h)                 u)           [      )           M      )           =      )           9      )           po      )           _      )           Gf      )           I      )           [S      )           I      M*           G      ^*           p      o*           J;      z*           ~!      *           B      *           }7      *           ?4      *                 *           d      *                 *           8n      *           GV      *           o<      +           |      +           I      +           SP      %+                 ++                 1+           6      7+                 =+           a      C+           [      Z+           I      f+           $g      q+           ;z      }+           O+      +           +      +           ,      +           K0      +           {I      +           K0      +           )W      +           #?      	,                 ,           [      !,           ?      -,            ;      9,           k      E,           C      Q,           C'      ^,           f      w,           "      ,           I       ,           ;      ,                 ,           PT      ,           VT      ,           \T      ,           bT      ,           _u      ,           J      ,           G&      -           c{      (-           V      3-           )      >-           >      I-           $c      T-           0      _-           L      j-           t      u-           }^      -                 -           Y      -           l      -                 -           G2      -           ]      -           G      -           O      -           h>      .           5"      .           Z      %.           Z9      2.           2      ?.           NJ      L.           8b      Y.           *<      f.           k      s.           *
      .           ^      .           '      .           %f      .           A      .           ~O      .           w      .           j      /           
      /           z      /           >      //           ~8      ;/                 P/           xT      \/                 h/           1      t/           (-      /           b      /           ~8      /                 /           (-      /           ~8      /                 /                 /           _      0           M5      0                 "0           j      70           AV      X0           u      d0           ,j      p0           "      0           1      0           >      0           h      0           i      0           `      0           f      0           ,s      0           55      0           V      1                  1           :D      1           Ud      +1           y.      61           pL      A1           Z      M1           N      Y1           <      f1           N&      q1           d
      }1           m       1                 1           y	      1           .6      1                 1           6      1                 1           T      1           (      1                 1           `w      1           W      2           "      &2           5      32           b8      @2                 L2           6h      e2           B      r2           ^      2           r      2           ?      2           `!      2           E,      2           \      2           ]      2           e      2           #      2           m      2                 3           b      3           H      3           D      ;3           I      G3           `!      S3                  k3           2D      3           j      3           SI      3           sT      3                  3           =$      3           =      3           Fz      4           <      '4                 -4           7      34           s      94           P      U4                 `4           
      x4           kG      ~4           &      4           ,A      4           #      4                 4           RM      4           &      4                  4           x      4           !      4           4,      4           +      4           E      5           S       !5           `      '5                 -5           M      35           gh      95           `      ?5           5!      E5           H      K5           ^      Q5           "      W5           TU      ]5           NG      c5           y)      i5                 o5           Ji      u5                 {5           Y      5           }      5           {      5           /      5           3G      5           :      5           Z      5           &      5           K      5                 5           	      5           h      5           R      5           %      5           {      5           4|      5           ;      5           _y      5           \      5           <M      5                 6           %E      6                 6           .      6           Bn      6                 #6           m      *6           :      66           2      B6           [      O6                 [6           M      g6           	      6           j      6                 6                 6           }M      6           'w      6           {      6           7      6           I      6           f	      6           o^      6           M      7           2      !7                 .7                  L7           >1      ^7           ~      d7           b      j7           m      p7           6}      w7           /,      7           G      7                 7           0      7           }d      7           v      7           Y      7           H       7           ~      7           N      7           DE      8                 8           wX      "8           C<      /8           -l      <8           >>      I8           .      V8                 d8                 r8           !      8           ;o      8                 8                 8                 8           &      8           y{      8           =7      8           <      8           1      8           :      9           U[      9                 )9                 89           @      g9           <      v9           -      9           b      9            X      9           ^      9           't      9           t|      9           
      9           A      9           =5      9           r{      :           z      :           Kv      S:           |      `:           /,      m:           a6      :           Z      :           )      :           J      :                 :           u^      :           i      :           I      
;                 ;           v      #;           f#      <;           e      ^;           n      j;           yt      v;           U      ;           "      ;           }      ;           ?      ;           4      ;           2      ;                  ;                 ;           8f      ;                 <                 <           K      <           @      *<                 Z<                 f<           /       r<           O+      ~<           O      <                 <           9      <           j      <           *      <           j      <           y      <           bU      <           g      <           ~      <           KB      =           k      =           \x      =           C      *=                 7=           {j      b=           C      n=           B      z=                 =                 =           `      =           +      =           p      =           "      =           B      =           Z      =                 =                 >           I      >           N      >           Z      />           +      :>            `      F>           u      R>           G&      _>                 j>           e      u>           {      >           #A      >           4+      >           J      >           sT      >                 >           d      >           j      >           O+      >           %      >           (      ?           %      
?           N@      ?           sT      $?                 0?           (      <?           :      H?           ^]      p?                 |?           ~      ?           1      ?           t      ?           ;W      ?                 ?                 ?           ,      ?           e      ?           /      ?                 
@           7      @           m      "@           ]      .@           /      :@           l      F@           .      R@           :      ^@           n      j@           S      v@           1      @           F"      @           f      @           N      @           y      @           _s      @                 @           ~      @           +      @           z      	A           M      =A           P      IA           r      UA           yt      aA           <      mA           u      yA           Py      A           M      A                 A           r      A           %r      A           <      A           @      A           ;      A           q3      B           I      B           ."      B           32      +B           G      7B           x      CB           	      PB           <	      \B                 hB           ~      tB           HT      B           Z#      B           1      B           =G      B           [1      B                 B           G      C           xq      C           @      C           k      )C           o      5C                 AC           k      MC           A      YC           :      eC           	      qC           ,      }C           y      C                 C           do      C           #      C           <	      C           .V      C           ,      C                 D           @      D           \      )D           5      5D           /o      AD           {-      MD           y      YD                  hD           I      uD           gN      D           i      D           >N      D                 D                 D           >      D           k3      D           *      D                  E           ,      E           &      E           ,      (E           ,      5E           &      BE           p      PE           W       ^E                 kE                 xE                 E           zx      E           @      E                 E                 E           xh      E           EI      E           X      E           t      E           E      E           :2      F           G8      F           ~
      &F           ;o      3F           8      CF           Xz      SF           F      `F           i      mF                 {F           =T      F           u9      F           s      F           %      F           F9      F           !M      F           io      F                 G           ,      G           &      !G           }      /G           pX      =G                 KG           2      YG           }G      gG           <      uG           d      G                 G           &      G           E/      G           '#      G           xC      G           /4      G           S      G           (      G           h      H           9      H           kq      H                 +H           K      9H           8;      GH           s      UH           41      cH           ;      qH                 H           BZ      H                 H           o      H           {(      H           F      H           e      H                 H           R	      
I                 I           #      $I           @      1I           E      >I                 LI           _      ^I           Vy      dI           mx      jI           LF      pI                 wI           g      I                 I           T+      I           E,      I           Py      I           f      I           .      I           f      I           c      J           o      J           ^^      J           *      (J                 5J           D      BJ           o      OJ           !      \J           }      iJ                 vJ           ;o      J           `!      J           >      J           M      J           G      J           W      J           H      J           Ao      J                 J                 J           f      K           )      K           7      K           n      ,K            5      9K           ,      FK           <&      SK           ;      `K           X      mK                 zK           4      K           6      K           W3      K           Z      K                 K                 K           \K      K                 K                  K           bC      L           _      9L           '      ZL           X      fL           ~t      L           V      L           9      L           j/      L                 L           ;o      L           LV      L           yt      M                 M           A
      $M                 1M           ^      >M                 LM           *+      YM           *      fM           ]      sM           a      M           =      M           Yv      M           }$      M           M/      M                 M           p      M           ]      M           AL      M           -      M                 N           s      N                 N           l      *N           ]      7N           \      DN           I      QN                 ^N           2      kN                 xN           )      N           {      N           qp      N                 N           w      N           T      N           Lr      N           6      N           V(      N           u      N           -      O           ^      O           ;U      !O           p      .O           8      ;O           a      HO           O      UO           N      bO           X'      oO           Dw      }O                   O           0      O           o      O                 O           Y      O           :      O           p      O           :      O            S      O                 P           OO      P           m      P           E,      +P           A      9P           t.      \P           A      gP           )      tP           a      P           w      P           ?      P                 P           +      P           E,      P           48      P           t.      P           48      P           3      P           n      
Q           \      Q           X      $Q                 1Q           5      >Q           ~6      KQ           8      XQ           ;o      eQ           #      rQ           D6      Q           fM      Q           .g      Q           fV      Q           z      Q           9      Q           q      Q           #'       R           ]      R           69      R           m      R           A_      R           O      )R           s      4R           9K      uR           C      R           5      R           !       R           |      R           -      R           _      R           +^      R           .      R           X      S           de      S           E      S           N      (S           N      5S           r0      BS           C      VS           R      wS           '[      S                 S           i      S           =      S           S~      S           `      S           .      S           $"      S           =      S           a      
T           +      T           y      $T           h7      1T           d2      >T           _      KT           7%      XT           j6      eT           V@      rT           
      T           Xl      T           H      T           kj      T                 T           p      T                 T           3      T           T      T           P=      T           |P       U           2>      U           {I      *U           J      6U           Q      BU           e      NU           }      ZU           Bl      eU           $      pU           [      |U           "=      U           3J      U           c      U           n      U           U      U           %      U                 U           o^      U           ;o      U           N      V           .      :V           "      FV           X      RV           E      jV           7
      uV           	      V           qn      V           y}      V                 V           3{      V           r      V                 V                 V                 V           h      V           D      V           c      V           wf      W           U      W                 W           W      5W           ]      @W           
      LW           ;o      XW           ;      dW           ">      pW           66      |W                 OX                 `X           [      fX           I      lX           |      rX           ,      xX           L      ~X           <      X           At      X           #|      X           {      X           @      X           lw      X           U      X           Z      X           D      X                 X           "(      X           {N      X           T      X           >      X                 X           g      X           #      X           vE      X           6B      X           4      X                 X           P      Y           a      Y                 Y           k      Y           |l      Y           /e       Y           7      &Y           3?      ,Y           ]      2Y           2      8Y           yr      >Y           A      DY           b      JY                 PY           O      VY           p_      \Y           P      bY           	      hY                 nY           &      tY           S      zY           2      Y           /      Y           g      Y           (      Y                 Y                 Y           G      Y                  Y                 Y           m      Y           @      Y           {2      Y           @      Z                 Z           ,      Z           Z      *Z           "      6Z           L      BZ           P{      NZ           e&      ZZ           $      fZ           4      rZ           F      ~Z           i      Z           >      Z           =      Z           -      Z           7E      Z                 Z           h7      Z           6h      Z           +      Z           66      [           ;      [           iL      '[           [-      3[           |      ?[           y      K[           tD      W[                 c[           r      o[           s(      {[           E      [           f      [           i      [           :t      [           b      [           +      [           $7      [                 [           H(      [           hE      
\           rm      \                 9\           u      E\           nD      i\           ~>      u\           h      \           1%      \                 \           J      \           Wu      \           1      \                 \           c      \           '      \           z      \           X      ]           D      ]           I      (]           )k      5]           	      K]           a      ^]           t      i]                 u]           i=      ]                 ]                 ]           I      ]                 ]           7      ^                 ^           L      '^           
2      4^           J:      @^                 L^           t      ^                 ^           9      ^                 ^           c      ^                 ^           Y      ^           ;o      ^           4      ^           }q      _           Vj      _           p,      $_                 0_           l      =_           7]      J_           I      V_           ;W      b_           E,      n_                 _           f      _           d      _           ;o      _           u      _                 _           mu      _           (u      
`           h      `           @      #`           La      /`           '      ;`           N      G`           H      S`           [o      _`                  k`           /:      w`           %      `           2i      `           "      `           \      `                 `           d]      `                 `           9      `           Tk      a           rq      a                 a           @      da           
;      }a           h      a           P      a           I      a           _      a           1      a           \      a           d      a                 a           8<      a                 ab           %      yb           W      b           d      b           i      b           @      b           N      b           /:      b           "      b           :      c           l      c           S      c           &]      c           e      c           ZO      c           B      c                 c           $1      c           ,      c           &I      c           @      &d                 <d           `H      Hd                 Td           u      ad           v      md                 yd           v      d           ,      d           W      d           n      d                 d           U      d           E,      d           =Z      d           \      e                 !e           )      0e           7      ?e           !      Ne                 ]e           n
      e           g@      e                 e           h      e                 e                  e           %      e           2i      2f           [X      >f           d=      Jf           .      f           ?      f           ]G      f           =Z      f           N      f           \	      f           3;      f           \      f           o      g                 g           [X      g           L      *g                 6g           X      g           F      g           o      g           @      g           w      g                 h           B      h           G&      &h                 2h           Xf      h           1      h           6      h           e*      h           T      h           I      h           V      h                  i           ;o      $i           E      Pi           {z      \i                 ti           ]      i           `!      i           ;o      i           R!      i           <      j           1      j           %i      6j           r      Zj           D      j           d|      j           1      j           w      j           #      j           u      j           ~      j           .      j           gS      j           4      j           JY      j                 
k           a4      k           q       "k           K      .k           N$      :k           h)      Fk           ;m      Qk           h      ]k                  jk                 vk           3;      k           t      k           1      k           g      k           *      k                 k           d=      k           .      k           -      k           K      l           E      l           |      l           K      l           :8      l                  l           ~      l           ![      l                 l           ;o      m           E,      m                  m           Py      3m           m      >m           
      Im           W      Um           Cb      am           w      mm                 zm           &      m           ![      m           -      m           O+      m           d=      m           !V      m           {      m                 m                 m           r]      n           F      n           ?g      n                 )n           q      4n           9X      @n           @      Mn           q      Xn           8)      en           @(      rn           nf      n           t      n                 n           K      n           E      n           8      n           D      n                 n            M      n                 n           k      o           #%      o           J%      o           G      (o                 5o           u@      Bo           2      Oo           Q      \o           l      io           b      vo                 o           %.      o                 o           E,      o           3;      o           i      o           B      o           i      p           ~      !p           A      .p           Tq      ;p           \      Ip           y      Wp           fp      ep           }      sp           /\      p           a+      p           y      p           ?      p           K      p           RX      p           M      p                 p                 p           v      q           F      q           |i      )q           ?      7q           f      Eq                 Sq           q1      aq           e      rq                 q           J      q           Lg      q           	K      q           xs      q                 q           ?v      q           @      q           	p      q           "H      q           -      q           F      q           H      r           )2      r           \I      -r                 ;r           h7      Hr           {      Ur           &      ir           7      xr           p%      r           ]      r           k	      r           U;      r           }      r           /      r           -      r           \      r           ~      s           3      s                 #s           U      0s           <      >s           F      Ks           I      [s           ^      ks           v"      xs           ~      s           ?      s           r:      s           B      s           C      s                 s           -v      s                 s           b:      s           ]      
t           E      t           L      *t           o      :t           BK      Jt           ~      Zt           >F      jt           ;O      wt           U      t           }      t           _r      t           ~      t           $      t           M      t                 t                 t           BW      t                 u                 u           U      #u                 0u           4      <u           ~      Hu           T      Tu           4      `u           bJ      lu           $      xu           )      u           `      u           E      u           e      u           #      u                 u           ;W      u           #      v           1      v           A      &v           .      Jv           Y      Wv                 dv           <      pv           .      |v           6F      v           y      v           xB      v           b      v           8      v           b      v           R      v           u      v                 v           %      v           bm      w           %\      w           J      w                 *w           ,      6w           p4      Bw           Xf      Nw           6      Zw           
      fw           4T      rw           s      ~w                 w           t      w                 w           #n      w                 w           U      w                 w           d=      w           .      1x           EP      =x                 Ux           f#      ax           %      mx           1I      yx           N      x           ld      x           6      x           
      x           4T      x           t      x                 x           f      /y           #n      ?y           [.      Jy           nK      Wy                 dy           f      qy           Xf      ~y           83      y                 y           N|      y                 y           B      y           K      y           yt      y           _f      z           Tq      'z           &      2z           ?      ?z                 Lz           f#      Yz           |      fz                 sz           \      z           .X      z           83      z           G      z           '      z           t      z                 z           S      z           X       {           h      {                 {           d=      '{           .      {           P      {           [Y      O|           a      \|                 i|                 w|                 |           R      |           4      |           q7      |                 |           B      |           =      |           c      |           _      |           r      }           E,      }           Py      }                 &}           O+      2}           .      >}           3;      J}           K      V}           yt      i}           q1      t}           3      }           d      }           o      }                 }           Y      }           O+      }           \J      }                 }           I      ~           .      ~           g      2~           f      X~           -      d~                 v~                 ~                 ~           >      ~           @i      ~           j.      ~           a      ~           U      ~           `      ~           -u                                  3                  U      -           |W      :           lz      G           W      T           mv      a           x      n           >#      {           P`                 3                 n                                   y5                 7                 m                 ',                                  T                 u                                  8      +           @      8           sg      E                 S           R,      `           @      m           "j      z                                             i                 NZ                 }                 3(                 #h                 XH                 =                 3                 lJ      "           t      0           %*      >           Wi      c           <      p           na      |           4                 y                 M                 Qt                 Nf                 *                 s                 C                 R                                   y                  h}                 j      '           q      4                 A           D[      N           w      [           Y      h           0      u                            >                                  -                 "
                 	                 9                 -                 U                                  5                 =                 :                 Z      ,           g      9           Y      F           %      S                 `           ^      m           0      {           /                                  m                 I                                  e                                  !                                  m*      	           l                 (`      %           (      3                 A           BD      O           `      ]           _      k           m      z           )                 
                 D                 iL                 f!                       2           %      ?                 L           N      X           g      e           &_      q           sT      }                            E,                 z                 5                 D                 I                 '                 S                 wP                       G           T2      S                 _           "=      k           h      x           /                 2                 H                 a                 {g                                   "                 2.                 Iu                 p      
           vS                 K                 (      (           X      4           _      @           z<      M           '~      Y           }e      e           @i      q           U                 @                 r                 0                 nl                 l                 9                 @                                                   +=                       
           +                 |F      "           S      .           j      :           W      F                 R           J      `           q      l           5C      x                            U:                 ^$                                  `q                 u                 Y                                  Ae                 W
                                                   +                 O                  O      -           kt      9           5C      E                 Q           U:      ]           }      j           L      v           `q                 !                 u                 W
                                  Ae                 t                                                   +                 O                 O                 !      )                 7           q      D           R      Q           p      ^           6S      k           C      y           dc                 8                                  ]                 j                 %X                 q                 t                 =                 *                 J                 f1      %           QS      1                 >                 O           4$      U           <q      [           4=      b           	                 ?                 "                 B                 	d                 C                 9                 "                 g                 _d                       	                            0      !           Uh      -           o      :           n      F           s      R           d      ^                 j           QS      v           J                 f1                 ?S                 s~                 u                                  Y                 #                 8                 @k                 :                 ?                 c?                 `                  x      &           .      ,           .      2                 8           Ke      ?           K      M           <x      Y           I                 O                 K                 C                 t                                  N^                 00                 #                 XW                 L#      A           @      N           A      [           4k      h           
      u           |                 0                 *                 Y                                  )                 qM                 =      )           k      6           )K      C           v      P                 ]           n      j           u      w           N                 G                 p                 L                 tw                                  $                 <                 h                 y                 $                 ?                 J      !           z      .           "      ;           =      H           `/      U           /_      b           Ey      o            5      |           9                 I                 ;o                 4                                  %^                 E      +           #&      8           5u      E           _      R           k\      _           I      l           A      y           P                 x                 r                 6                 J                                   F=                 u                 #F                 0-                 y                 Mc                 4Y      "           ?.      /                 <           d      I           3      v           ^                 9                 B                 H                 I      	           I                 !                 2      0           7      ;           v      F           d      Z           ^M      f           *      |           v                 #                 O                 :_                 s                 ]                 3;                 f#                 N                 I                 R      )           (      8           6      E           r      R           E      _           Yb      l           (      y           	F                 84                 N                  f                 \                 rq                                  )4                 @                 s                                  `                 mc      "           Q9      /           e      <           a      I           1      V           C      c           s=      p                 }           ;'                 6                 v                 'N                 R                 i                 (U                                                    Y                                  #      -           %      :           [F      G           ?"      T           J      a           s      n           J      {           c                 Z0                 H                                                                    @                 bL                                   ![                 h      ,           hT      9           {      F           )      S           t      j           &      v           >                                                   $                 "                 U                 D                 Y      
           =C                 v      $           l      1           [|      >           }      K           +5      X           i2                 b                 ^]                 f#      (           N      5                 @           t      L           f#      Y           }D      m           N       z           ^]                 km                 w+                 x                 .                                  m                 ?                 l                 M      &           =      2           H      L           |Y      R           l#      X           F      ^           =      d                 k           X      y           I                 ;                                  $D                 %}                                                                    h                 f#                 O+                 G      *           5      7           B      D           _,      Q                 ^           E      k           CO      x           ~                                                   p8                 D                 A                 WL                 !                 ,                 7                 p                                   =      (           9      5           >      B           Tk      O           oF      \                 i           Qx      v           ^                 h                 C)                                  7P                                  6                 4s                 \                 V      *           W_      >           8l      }           s                       0           H|      <           _      H           }                 H                                  #Y                                  wU      Y           P      e           -      q           <      }           )h                 h                 
                 h;                 6*                 |                                  C]                 <w                 S                 v4                 O\      1           r      <           b      G           (      `           k"      f           |      l           Y>      r           Wa      x                 ~                            *                 5                 I                 	|                 `                 C                                  /                 "                 yt                 *                                  q      %           "      1           5      D           $      O           `      u           \                 r                 _h                 '!                 %                 $q                 ~                 :                 VZ                                  =-                 	                 #                                  5d                 e      $           7y      0           F      F           e      R           L      h           ;      t           h_                 0                 w                 X                 B                 h                 	                 D                 x                 "                                  F      $           c      4           %      D           h      T           6V      d           >      t           2i                 i                 E                 (d                 2L                 d2                 G                 m$                 @:                 q                 n      $           )      4                 D           V      T                 d           ?      t           H                 _                 a                 gC                                   %L                 M                 ,                 Nl                 S      !                 1           c      B           %y      a           )m      n           P                 L                                  2f                 W                 6                       	           Qo                 v                  =       ,                 8           v      c           n      u           P                 O+                 q                 y                 $                 f                 n                 sT                 I                                  (                 ;o      )           a)      5           "      Y           l      r                            e                 h                 yt                 (                 kg                 }                       #           ,r      /           	      G           9g      h           	      t           KU                                  o                                  9                 ;o                                  [                 )$                 u                 N@                 Zc      #           |      8           e      D           E      P                 |           =                 ^]                 ,                 7y                                  B                 c0                                  ]                 '3                                  )      (           +)      6           c      D           N@      S           kW      a           Kb      o           S      }           p                 I4      &           z      ,           }      2                 8           4      >           a5      E           =      r           t                 B                 >                 _                 x$                 dD                 ]                 M                 ;6                 W)                 b      &           uZ      3           r`      @           ^      [           ;      f           !{      s           N                 ?                 @                                  G&                 yt                 ;o                 `                 2                 z]                 )9                 Fs      _           6                 }:                 +                 !                 [                                  5j                 i                 5~                 z                 s                 B      )           ;o      5           Z      N           S      g           &      s           }                                  0                 i                 2                 f                 @3                                  o                       	           -                 ,!      W           F!      b           j      m           }      x           ak                 gB                 dn                 ,@                 M                 O                 )p                 2                 sT                 N                 B                 5      ,           -      8           &      \           ]e      o           j                                  9^                 C                 uv                 	                 6                 =h                 7                                  l                 6                 d                 A                 j9                 o                 &      t           	y      z           2H                                   3                 j[                 E}                 [                                  R                  l                                  X                                  W                 4      $           T      +           Ax      7           w      b           @      m                 x           =                 i                                  |                 F                 O+                 K                  x                                                                      ?                 K                 /      !           -      ,           V      =           G      C           "8      I           7      O           n      U            '      [           	X      a           v      g           B      m           8      s           W      y           "                 
                 J                 Y                 ]\                 s                 	                 Xp                 x                 R              G                      WV                                  G      <           .      H                   a           $      m                   v           H3                                    U`                                    !                                                                                                               `                                                      ,                         ,           
>      W           5      a                   x           3                 I                  W                 l                                    ,                  r                 ^                 X       :                  I                  X                  ]                 h           R      s           x                                   8                                   .                 Q                 P                  w                                   t                       &                 +                  9           }p      C           d      \           5      ~                                                               &                                                                                               )           |      9           X      G           ai      K           ai      R           a;      V           a;      ]           WN      a           WN      h           ^      l           ^      s           <      w           <      ~           A%                 A%                 Z                 Z      D	                   ~	                                                           T                    X                                                    8                                       X                                                                                     D                   H           d                   T                                                                &                   .                   I                    Q                   l                    t                                                  0                   X                   w                   X                   w                   X                   p                  8                  O       .           8       6           O       Q           8       Y           D       t                  |                                                                                                                                                                                             d      &                  .                                                                                                                    (            $       0            (       8                   @                   H                   `            @       h            P       p            T       x                                                  |                                    <                                                                                                                t                                             .symtab .strtab .shstrtab .rela.text .rela.init.text .rela.rodata .rodata.str1.1 .rela.data .rela.initcall3.init .bss .comment .note.GNU-stack .rela.debug_aranges .rela.debug_info .debug_abbrev .rela.debug_line .rela.debug_frame .debug_str .rela.debug_loc .rela.debug_ranges                                                                                           @       t                                   @               h     `                          +                                                         &      @               hk                               ;                                                         6      @                m     `                           C      2                                                 W                                                         R      @               `m                               b                                                         ]      @               (o               
                 r                                                         w      0                     2                                                                                                                    @                                    @               @o     H                                                                                          @               o     x#                                                     i                                                          	                                   @                     0                                                       X                                   @               0     P                                0               @      	                                                  IZ     I                                   @                                                                   \                                        @                    p                                                ]     h         B                 	                       e                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  cmd_drivers/net/wireless/bcmdhd/dhd_linux_wq.o := /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/aarch64-linux-gnu-gcc -Wp,-MD,drivers/net/wireless/bcmdhd/.dhd_linux_wq.o.d  -nostdinc -isystem /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/bin/../lib/gcc/aarch64-linux-gnu/7.3.1/include -I../arch/arm64/include -Iarch/arm64/include/generated  -I../include -Iinclude -I../arch/arm64/include/uapi -Iarch/arm64/include/generated/uapi -I../include/uapi -Iinclude/generated/uapi -include ../include/linux/kconfig.h   -I../drivers/net/wireless/bcmdhd -Idrivers/net/wireless/bcmdhd -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -mgeneral-regs-only -fno-pic -fstack-usage -mpc-relative-literal-loads -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -fno-PIE -Os -Wno-maybe-uninitialized -fno-store-merging -Wno-misleading-indentation -Wno-duplicate-decl-specifier -Wno-logical-not-parentheses --param=allow-store-data-races=0 -Werror=frame-larger-than=1 -Wframe-larger-than=1400 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -DCC_HAVE_ASM_GOTO   -I/include   -I/home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out  -I../../drivers/misc/mediatek/include/ -I../drivers/misc/mediatek/include/ -Wall -w -Wstrict-prototypes -Dlinux -DLINUX -DBCMDRIVER -DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DBCMFILEIMAGE -DDHDTHREAD -DSHOW_EVENTS -DBCMDBG -DWLP2P -DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT -DKEEP_ALIVE -DCSCAN -DPKT_FILTER_SUPPORT -DEMBEDDED_PLATFORM -DPNO_SUPPORT -DSHOW_LOGTRACE -DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT -DCUSTOMER_HW2 -DGET_CUSTOM_MAC_ENABLE -DWL_CFG80211 -DBCMASSERT_LOG -DCUSTOM_KEEP_ALIVE_SETTING=28000 -DVSDB -DWL_SCB_TIMEOUT=10 -DWLTDLS -DWLTDLS_AUTO_ENABLE -DCUSTOM_TDLS_IDLE_MODE_SETTING=40000 -DCUSTOM_TDLS_RSSI_THRESHOLD_HIGH=-60 -DCUSTOM_TDLS_RSSI_THRESHOLD_LOW=-70 -DROAM_AP_ENV_DETECTION -DROAM_ENABLE -DROAM_API -DENABLE_FW_ROAM_SUSPEND -DCUSTOM_ROAM_TRIGGER_SETTING=-75 -DCUSTOM_ROAM_DELTA_SETTING=10 -DSUPPORT_PM2_ONLY -DCUSTOM_PNO_EVENT_LOCK_xTIME=10 -DMIRACAST_AMPDU_SIZE=8 -DGSCAN_SUPPORT -DWL_VENDOR_EXT_SUPPORT -DLINKSTAT_SUPPORT -DDHD_USE_EARLYSUSPEND -DESCAN_RESULT_PATCH -DWL_SCHED_SCAN -DDHD_OF_SUPPORT -DIOCTL_RESP_TIMEOUT=5000 -DWAIT_DEQUEUE -DCONFIG_CONTROL_PM -DDHD_USE_IDLECOUNT -DDHDENABLE_TAILPAD -DCUSTOM_SUSPEND_BCN_LI_DTIM=2 -DMAX_DTIM_ALLOWED_INTERVAL=600 -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST -DWL_CFG80211_STA_EVENT -DWL_IFACE_COMB_NUM_CHANNELS -DWL_ENABLE_P2P_IF -DWL_CFG80211_ACL -DDISABLE_11H_SOFTAP -DSET_RANDOM_MAC_SOFTAP -DCUSTOM_FORCE_NODFS_FLAG -DCUSTOM_SET_SHORT_DWELL_TIME -DUSE_WL_TXBF -DUSE_WL_FRAMEBURST -DCUSTOM_DPC_CPUCORE=0 -DMAX_AP_CLIENT_CNT=10 -DMAX_GO_CLIENT_CNT=5 -DCONFIG_DTS -DWL11U -DMFP -DDHD_ENABLE_LPC -DCUSTOM_COUNTRY_CODE -DDHD_WAKE_STATUS -DDHD_WAKE_RX_STATUS -DDHD_WAKE_EVENT_STATUS -DRTT_SUPPORT -DRTT_DEBUG -DBDC -DOOB_INTR_ONLY -DHW_OOB -DDHD_BCMEVENTS -DMMC_SDIO_ABORT -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR -DCUSTOM_AMPDU_MPDU=16 -DCUSTOM_AMPDU_BA_WSIZE=64 -DCUSTOM_GLOM_SETTING=8 -DCUSTOM_RXCHAIN=1 -DUSE_DYNAMIC_F2_BLKSIZE -DDYNAMIC_F2_BLKSIZE_FOR_NONLEGACY=256 -DBCMSDIOH_TXGLOM -DCUSTOM_TXGLOM=1 -DBCMSDIOH_TXGLOM_HIGHSPEED -DDHDTCPACK_SUPPRESS -DRXFRAME_THREAD -DREPEAT_READFRAME -DCUSTOM_MAX_TXGLOM_SIZE=64 -DMAX_HDR_READ=128 -DDHD_FIRSTREAD=128 -DCUSTOM_SDIO_F2_BLKSIZE=256 -DDHD_TXBOUND=64 -DDHD_RXBOUND=64 -DCUSTOM_BCN_TIMEOUT_SETTING=5 -DWLFC_STATE_PREALLOC -DDHD_8021X_DUMP -DEAPOL_PKT_PRIO -DENABLE_INSMOD_NO_FW_LOAD -DUSE_LATE_INITCALL_SYNC -DDHD_DEBUG -DSRCBASE=\"drivers/net/wireless/bcmdhd\"  -I../drivers/net/wireless/bcmdhd/include/ -Idrivers/net/wireless/bcmdhd/include/  -I../drivers/net/wireless/bcmdhd/ -Idrivers/net/wireless/bcmdhd/    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(dhd_linux_wq)"  -D"KBUILD_MODNAME=KBUILD_STR(bcmdhd)" -c -o drivers/net/wireless/bcmdhd/dhd_linux_wq.o ../drivers/net/wireless/bcmdhd/dhd_linux_wq.c

source_drivers/net/wireless/bcmdhd/dhd_linux_wq.o := ../drivers/net/wireless/bcmdhd/dhd_linux_wq.c

deps_drivers/net/wireless/bcmdhd/dhd_linux_wq.o := \
  ../include/linux/init.h \
    $(wildcard include/config/broken/rodata.h) \
    $(wildcard include/config/lto.h) \
    $(wildcard include/config/modules.h) \
  ../include/linux/compiler.h \
    $(wildcard include/config/sparse/rcu/pointer.h) \
    $(wildcard include/config/trace/branch/profiling.h) \
    $(wildcard include/config/profile/all/branches.h) \
    $(wildcard include/config/64bit.h) \
    $(wildcard include/config/enable/must/check.h) \
    $(wildcard include/config/enable/warn/deprecated.h) \
    $(wildcard include/config/kprobes.h) \
  ../include/linux/compiler-gcc.h \
    $(wildcard include/config/arch/supports/optimized/inlining.h) \
    $(wildcard include/config/optimize/inlining.h) \
    $(wildcard include/config/gcov/kernel.h) \
    $(wildcard include/config/arch/use/builtin/bswap.h) \
  ../include/uapi/linux/types.h \
  arch/arm64/include/generated/asm/types.h \
  ../include/uapi/asm-generic/types.h \
  ../include/asm-generic/int-ll64.h \
  ../include/uapi/asm-generic/int-ll64.h \
  ../arch/arm64/include/uapi/asm/bitsperlong.h \
  ../include/asm-generic/bitsperlong.h \
  ../include/uapi/asm-generic/bitsperlong.h \
  ../include/uapi/linux/posix_types.h \
  ../include/linux/stddef.h \
  ../include/uapi/linux/stddef.h \
  ../arch/arm64/include/uapi/asm/posix_types.h \
  ../include/uapi/asm-generic/posix_types.h \
  ../include/linux/types.h \
    $(wildcard include/config/uid16.h) \
    $(wildcard include/config/lbdaf.h) \
    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
    $(wildcard include/config/phys/addr/t/64bit.h) \
  ../include/linux/kernel.h \
    $(wildcard include/config/preempt/voluntary.h) \
    $(wildcard include/config/debug/atomic/sleep.h) \
    $(wildcard include/config/mmu.h) \
    $(wildcard include/config/prove/locking.h) \
    $(wildcard include/config/panic/timeout.h) \
    $(wildcard include/config/ring/buffer.h) \
    $(wildcard include/config/tracing.h) \
    $(wildcard include/config/ftrace/mcount/record.h) \
  /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/toolchain/lib/gcc/aarch64-linux-gnu/7.3.1/include/stdarg.h \
  ../include/linux/linkage.h \
  ../include/linux/stringify.h \
  ../include/linux/export.h \
    $(wildcard include/config/have/underscore/symbol/prefix.h) \
    $(wildcard include/config/modversions.h) \
    $(wildcard include/config/unused/symbols.h) \
  ../arch/arm64/include/asm/linkage.h \
  ../include/linux/bitops.h \
  ../arch/arm64/include/asm/bitops.h \
  ../arch/arm64/include/asm/barrier.h \
    $(wildcard include/config/smp.h) \
  ../include/asm-generic/bitops/builtin-__ffs.h \
  ../include/asm-generic/bitops/builtin-ffs.h \
  ../include/asm-generic/bitops/builtin-__fls.h \
  ../include/asm-generic/bitops/builtin-fls.h \
  ../include/asm-generic/bitops/ffz.h \
  ../include/asm-generic/bitops/fls64.h \
  ../include/asm-generic/bitops/find.h \
    $(wildcard include/config/generic/find/first/bit.h) \
  ../include/asm-generic/bitops/sched.h \
  ../include/asm-generic/bitops/hweight.h \
  ../include/asm-generic/bitops/arch_hweight.h \
  ../include/asm-generic/bitops/const_hweight.h \
  ../include/asm-generic/bitops/lock.h \
  ../include/asm-generic/bitops/non-atomic.h \
  ../include/asm-generic/bitops/le.h \
  ../arch/arm64/include/uapi/asm/byteorder.h \
  ../include/linux/byteorder/little_endian.h \
  ../include/uapi/linux/byteorder/little_endian.h \
  ../include/linux/swab.h \
  ../include/uapi/linux/swab.h \
  arch/arm64/include/generated/asm/swab.h \
  ../include/uapi/asm-generic/swab.h \
  ../include/linux/byteorder/generic.h \
  ../include/linux/log2.h \
    $(wildcard include/config/arch/has/ilog2/u32.h) \
    $(wildcard include/config/arch/has/ilog2/u64.h) \
  ../include/linux/typecheck.h \
  ../include/linux/printk.h \
    $(wildcard include/config/mt/printk/uart/console.h) \
    $(wildcard include/config/mtk/aee/feature.h) \
    $(wildcard include/config/printk/mt/prefix.h) \
    $(wildcard include/config/mt/eng/build.h) \
    $(wildcard include/config/log/too/much/warning.h) \
    $(wildcard include/config/message/loglevel/default.h) \
    $(wildcard include/config/early/printk.h) \
    $(wildcard include/config/printk.h) \
    $(wildcard include/config/dynamic/debug.h) \
  ../include/linux/kern_levels.h \
  ../include/linux/cache.h \
    $(wildcard include/config/arch/has/cache/line/size.h) \
  ../include/uapi/linux/kernel.h \
  ../include/uapi/linux/sysinfo.h \
  ../arch/arm64/include/asm/cache.h \
  ../arch/arm64/include/asm/cachetype.h \
  ../arch/arm64/include/asm/cputype.h \
  ../include/linux/dynamic_debug.h \
  ../include/linux/string.h \
    $(wildcard include/config/binary/printf.h) \
  ../include/uapi/linux/string.h \
  ../arch/arm64/include/asm/string.h \
  ../include/linux/errno.h \
  ../include/uapi/linux/errno.h \
  arch/arm64/include/generated/asm/errno.h \
  ../include/uapi/asm-generic/errno.h \
  ../include/uapi/asm-generic/errno-base.h \
  ../include/linux/spinlock.h \
    $(wildcard include/config/debug/spinlock.h) \
    $(wildcard include/config/generic/lockbreak.h) \
    $(wildcard include/config/preempt.h) \
    $(wildcard include/config/debug/lock/alloc.h) \
  ../include/linux/preempt.h \
    $(wildcard include/config/debug/preempt.h) \
    $(wildcard include/config/preempt/tracer.h) \
    $(wildcard include/config/preempt/count.h) \
    $(wildcard include/config/context/tracking.h) \
    $(wildcard include/config/preempt/notifiers.h) \
  ../include/linux/list.h \
    $(wildcard include/config/debug/list.h) \
  ../include/linux/poison.h \
    $(wildcard include/config/illegal/pointer/value.h) \
  ../include/uapi/linux/const.h \
  arch/arm64/include/generated/asm/preempt.h \
  ../include/asm-generic/preempt.h \
  ../include/linux/thread_info.h \
    $(wildcard include/config/compat.h) \
    $(wildcard include/config/debug/stack/usage.h) \
  ../include/linux/bug.h \
    $(wildcard include/config/generic/bug.h) \
  arch/arm64/include/generated/asm/bug.h \
  ../include/asm-generic/bug.h \
    $(wildcard include/config/bug.h) \
    $(wildcard include/config/generic/bug/relative/pointers.h) \
    $(wildcard include/config/debug/bugverbose.h) \
  ../arch/arm64/include/asm/memory.h \
    $(wildcard include/config/arm64/va/bits.h) \
  arch/arm64/include/generated/asm/sizes.h \
  ../include/asm-generic/sizes.h \
  ../include/linux/sizes.h \
  ../include/asm-generic/memory_model.h \
    $(wildcard include/config/flatmem.h) \
    $(wildcard include/config/discontigmem.h) \
    $(wildcard include/config/sparsemem/vmemmap.h) \
    $(wildcard include/config/sparsemem.h) \
  ../arch/arm64/include/asm/thread_info.h \
    $(wildcard include/config/arm64/64k/pages.h) \
  ../include/linux/irqflags.h \
    $(wildcard include/config/trace/irqflags.h) \
    $(wildcard include/config/preempt/monitor.h) \
    $(wildcard include/config/mtprof.h) \
    $(wildcard include/config/irqsoff/tracer.h) \
    $(wildcard include/config/trace/irqflags/support.h) \
  ../arch/arm64/include/asm/irqflags.h \
  ../arch/arm64/include/asm/ptrace.h \
    $(wildcard include/config/cpu/big/endian.h) \
  ../arch/arm64/include/uapi/asm/ptrace.h \
  ../arch/arm64/include/asm/hwcap.h \
  ../arch/arm64/include/uapi/asm/hwcap.h \
  ../include/linux/bottom_half.h \
  ../include/linux/preempt_mask.h \
  ../include/linux/spinlock_types.h \
  ../arch/arm64/include/asm/spinlock_types.h \
  ../include/linux/lockdep.h \
    $(wildcard include/config/lockdep.h) \
    $(wildcard include/config/lock/stat.h) \
    $(wildcard include/config/prove/rcu.h) \
  ../include/linux/rwlock_types.h \
  ../arch/arm64/include/asm/spinlock.h \
  ../arch/arm64/include/asm/processor.h \
  ../arch/arm64/include/asm/fpsimd.h \
  ../arch/arm64/include/asm/hw_breakpoint.h \
    $(wildcard include/config/have/hw/breakpoint.h) \
  ../include/linux/rwlock.h \
  ../include/linux/spinlock_api_smp.h \
    $(wildcard include/config/inline/spin/lock.h) \
    $(wildcard include/config/inline/spin/lock/bh.h) \
    $(wildcard include/config/inline/spin/lock/irq.h) \
    $(wildcard include/config/inline/spin/lock/irqsave.h) \
    $(wildcard include/config/inline/spin/trylock.h) \
    $(wildcard include/config/inline/spin/trylock/bh.h) \
    $(wildcard include/config/uninline/spin/unlock.h) \
    $(wildcard include/config/inline/spin/unlock/bh.h) \
    $(wildcard include/config/inline/spin/unlock/irq.h) \
    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
  ../include/linux/rwlock_api_smp.h \
    $(wildcard include/config/inline/read/lock.h) \
    $(wildcard include/config/inline/write/lock.h) \
    $(wildcard include/config/inline/read/lock/bh.h) \
    $(wildcard include/config/inline/write/lock/bh.h) \
    $(wildcard include/config/inline/read/lock/irq.h) \
    $(wildcard include/config/inline/write/lock/irq.h) \
    $(wildcard include/config/inline/read/lock/irqsave.h) \
    $(wildcard include/config/inline/write/lock/irqsave.h) \
    $(wildcard include/config/inline/read/trylock.h) \
    $(wildcard include/config/inline/write/trylock.h) \
    $(wildcard include/config/inline/read/unlock.h) \
    $(wildcard include/config/inline/write/unlock.h) \
    $(wildcard include/config/inline/read/unlock/bh.h) \
    $(wildcard include/config/inline/write/unlock/bh.h) \
    $(wildcard include/config/inline/read/unlock/irq.h) \
    $(wildcard include/config/inline/write/unlock/irq.h) \
    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
  ../include/linux/atomic.h \
    $(wildcard include/config/arch/has/atomic/or.h) \
    $(wildcard include/config/generic/atomic64.h) \
  ../arch/arm64/include/asm/atomic.h \
  ../arch/arm64/include/asm/cmpxchg.h \
  ../include/asm-generic/atomic-long.h \
  ../include/linux/fcntl.h \
  ../include/uapi/linux/fcntl.h \
  ../arch/arm64/include/uapi/asm/fcntl.h \
  ../include/uapi/asm-generic/fcntl.h \
  ../include/linux/fs.h \
    $(wildcard include/config/sysfs.h) \
    $(wildcard include/config/fs/posix/acl.h) \
    $(wildcard include/config/security.h) \
    $(wildcard include/config/ima.h) \
    $(wildcard include/config/quota.h) \
    $(wildcard include/config/fsnotify.h) \
    $(wildcard include/config/epoll.h) \
    $(wildcard include/config/file/locking.h) \
    $(wildcard include/config/auditsyscall.h) \
    $(wildcard include/config/block.h) \
    $(wildcard include/config/fs/xip.h) \
    $(wildcard include/config/migration.h) \
  ../include/linux/wait.h \
  arch/arm64/include/generated/asm/current.h \
  ../include/asm-generic/current.h \
  ../include/uapi/linux/wait.h \
  ../include/linux/kdev_t.h \
  ../include/uapi/linux/kdev_t.h \
  ../include/linux/dcache.h \
  ../include/linux/rculist.h \
  ../include/linux/rcupdate.h \
    $(wildcard include/config/tree/rcu.h) \
    $(wildcard include/config/tree/preempt/rcu.h) \
    $(wildcard include/config/rcu/trace.h) \
    $(wildcard include/config/preempt/rcu.h) \
    $(wildcard include/config/rcu/stall/common.h) \
    $(wildcard include/config/rcu/user/qs.h) \
    $(wildcard include/config/rcu/nocb/cpu.h) \
    $(wildcard include/config/tasks/rcu.h) \
    $(wildcard include/config/tiny/rcu.h) \
    $(wildcard include/config/debug/objects/rcu/head.h) \
    $(wildcard include/config/hotplug/cpu.h) \
    $(wildcard include/config/rcu/boost.h) \
    $(wildcard include/config/rcu/nocb/cpu/all.h) \
    $(wildcard include/config/no/hz/full/sysidle.h) \
  ../include/linux/threads.h \
    $(wildcard include/config/nr/cpus.h) \
    $(wildcard include/config/base/small.h) \
  ../include/linux/cpumask.h \
    $(wildcard include/config/cpumask/offstack.h) \
    $(wildcard include/config/debug/per/cpu/maps.h) \
    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
  ../include/linux/bitmap.h \
  ../include/linux/seqlock.h \
  ../include/linux/completion.h \
  ../include/linux/debugobjects.h \
    $(wildcard include/config/debug/objects.h) \
    $(wildcard include/config/debug/objects/free.h) \
  ../include/linux/rcutree.h \
  ../include/linux/rculist_bl.h \
  ../include/linux/list_bl.h \
  ../include/linux/bit_spinlock.h \
  ../include/linux/lockref.h \
    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
  include/generated/bounds.h \
  ../include/linux/path.h \
  ../include/linux/stat.h \
  ../arch/arm64/include/asm/stat.h \
  ../arch/arm64/include/uapi/asm/stat.h \
  ../include/uapi/asm-generic/stat.h \
  ../arch/arm64/include/asm/compat.h \
  ../include/linux/sched.h \
    $(wildcard include/config/sched/debug.h) \
    $(wildcard include/config/no/hz/common.h) \
    $(wildcard include/config/lockup/detector.h) \
    $(wildcard include/config/detect/hung/task.h) \
    $(wildcard include/config/core/dump/default/elf/headers.h) \
    $(wildcard include/config/sched/autogroup.h) \
    $(wildcard include/config/virt/cpu/accounting/native.h) \
    $(wildcard include/config/bsd/process/acct.h) \
    $(wildcard include/config/taskstats.h) \
    $(wildcard include/config/audit.h) \
    $(wildcard include/config/cgroups.h) \
    $(wildcard include/config/inotify/user.h) \
    $(wildcard include/config/fanotify.h) \
    $(wildcard include/config/posix/mqueue.h) \
    $(wildcard include/config/keys.h) \
    $(wildcard include/config/perf/events.h) \
    $(wildcard include/config/schedstats.h) \
    $(wildcard include/config/task/delay/acct.h) \
    $(wildcard include/config/mtk/sched/cmp/tgs.h) \
    $(wildcard include/config/sched/smt.h) \
    $(wildcard include/config/disable/cpu/sched/domain/balance.h) \
    $(wildcard include/config/sched/mc.h) \
    $(wildcard include/config/numa.h) \
    $(wildcard include/config/mtk/sched/cmp.h) \
    $(wildcard include/config/sched/hmp.h) \
    $(wildcard include/config/sched/hmp/prio/filter.h) \
    $(wildcard include/config/hmp/tracer.h) \
    $(wildcard include/config/mtprof/cputime.h) \
    $(wildcard include/config/fair/group/sched.h) \
    $(wildcard include/config/mt/rt/throttle/mon.h) \
    $(wildcard include/config/rt/group/sched.h) \
    $(wildcard include/config/mt/sched/trace.h) \
    $(wildcard include/config/mt/sched/debug.h) \
    $(wildcard include/config/cgroup/sched.h) \
    $(wildcard include/config/blk/dev/io/trace.h) \
    $(wildcard include/config/compat/brk.h) \
    $(wildcard include/config/cc/stackprotector.h) \
    $(wildcard include/config/virt/cpu/accounting/gen.h) \
    $(wildcard include/config/swap.h) \
    $(wildcard include/config/sysvipc.h) \
    $(wildcard include/config/rt/mutexes.h) \
    $(wildcard include/config/debug/mutexes.h) \
    $(wildcard include/config/task/xacct.h) \
    $(wildcard include/config/cpusets.h) \
    $(wildcard include/config/futex.h) \
    $(wildcard include/config/numa/balancing.h) \
    $(wildcard include/config/fault/injection.h) \
    $(wildcard include/config/latencytop.h) \
    $(wildcard include/config/function/graph/tracer.h) \
    $(wildcard include/config/memcg.h) \
    $(wildcard include/config/uprobes.h) \
    $(wildcard include/config/bcache.h) \
    $(wildcard include/config/have/unstable/sched/clock.h) \
    $(wildcard include/config/irq/time/accounting.h) \
    $(wildcard include/config/no/hz/full.h) \
    $(wildcard include/config/proc/fs.h) \
    $(wildcard include/config/stack/growsup.h) \
  ../include/uapi/linux/sched.h \
  ../include/linux/sched/prio.h \
  ../arch/arm64/include/uapi/asm/param.h \
  ../include/asm-generic/param.h \
    $(wildcard include/config/hz.h) \
  ../include/uapi/asm-generic/param.h \
  ../include/linux/capability.h \
  ../include/uapi/linux/capability.h \
  ../include/linux/timex.h \
  ../include/uapi/linux/timex.h \
  ../include/linux/time.h \
    $(wildcard include/config/arch/uses/gettimeoffset.h) \
  ../include/linux/math64.h \
    $(wildcard include/config/arch/supports/int128.h) \
  arch/arm64/include/generated/asm/div64.h \
  ../include/asm-generic/div64.h \
  ../include/linux/time64.h \
  ../include/uapi/linux/time.h \
  ../include/uapi/linux/param.h \
  ../arch/arm64/include/asm/timex.h \
  ../arch/arm64/include/asm/arch_timer.h \
  ../include/clocksource/arm_arch_timer.h \
    $(wildcard include/config/arm/arch/timer.h) \
  ../include/linux/clocksource.h \
    $(wildcard include/config/arch/clocksource/data.h) \
    $(wildcard include/config/clocksource/watchdog.h) \
    $(wildcard include/config/clksrc/of.h) \
  ../include/linux/timer.h \
    $(wildcard include/config/timer/stats.h) \
    $(wildcard include/config/debug/objects/timers.h) \
  ../include/linux/ktime.h \
  ../include/linux/jiffies.h \
  ../include/linux/timekeeping.h \
  ../arch/arm64/include/asm/io.h \
  ../include/linux/blk_types.h \
    $(wildcard include/config/blk/cgroup.h) \
    $(wildcard include/config/blk/dev/integrity.h) \
  ../arch/arm64/include/asm/pgtable.h \
    $(wildcard include/config/transparent/hugepage.h) \
    $(wildcard include/config/have/rcu/table/free.h) \
    $(wildcard include/config/arm64/pgtable/levels.h) \
  ../arch/arm64/include/asm/proc-fns.h \
  ../arch/arm64/include/asm/page.h \
    $(wildcard include/config/have/arch/pfn/valid.h) \
  ../arch/arm64/include/asm/pgtable-types.h \
  ../include/asm-generic/pgtable-nopud.h \
  ../include/asm-generic/getorder.h \
  ../arch/arm64/include/asm/pgtable-hwdef.h \
  ../include/asm-generic/pgtable.h \
    $(wildcard include/config/have/arch/soft/dirty.h) \
  ../include/linux/mm_types.h \
    $(wildcard include/config/split/ptlock/cpus.h) \
    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
    $(wildcard include/config/have/cmpxchg/double.h) \
    $(wildcard include/config/have/aligned/struct/page.h) \
    $(wildcard include/config/want/page/debug/flags.h) \
    $(wildcard include/config/kmemcheck.h) \
    $(wildcard include/config/aio.h) \
    $(wildcard include/config/mmu/notifier.h) \
    $(wildcard include/config/compaction.h) \
  ../include/linux/auxvec.h \
  ../include/uapi/linux/auxvec.h \
  ../arch/arm64/include/uapi/asm/auxvec.h \
  ../include/linux/rbtree.h \
  ../include/linux/rwsem.h \
    $(wildcard include/config/rwsem/spin/on/owner.h) \
    $(wildcard include/config/rwsem/generic/spinlock.h) \
  ../include/linux/osq_lock.h \
  arch/arm64/include/generated/asm/rwsem.h \
  ../include/asm-generic/rwsem.h \
  ../include/linux/page-debug-flags.h \
    $(wildcard include/config/page/poisoning.h) \
    $(wildcard include/config/page/guard.h) \
    $(wildcard include/config/page/debug/something/else.h) \
  ../include/linux/uprobes.h \
  ../include/linux/page-flags-layout.h \
  ../include/linux/numa.h \
    $(wildcard include/config/nodes/shift.h) \
  ../arch/arm64/include/asm/sparsemem.h \
  ../arch/arm64/include/asm/mmu.h \
  arch/arm64/include/generated/asm/early_ioremap.h \
  ../include/asm-generic/early_ioremap.h \
    $(wildcard include/config/generic/early/ioremap.h) \
  ../arch/arm64/include/asm/alternative.h \
  ../arch/arm64/include/asm/cpufeature.h \
  ../include/xen/xen.h \
    $(wildcard include/config/xen.h) \
    $(wildcard include/config/xen/dom0.h) \
    $(wildcard include/config/xen/pvh.h) \
  ../include/asm-generic/iomap.h \
    $(wildcard include/config/has/ioport/map.h) \
    $(wildcard include/config/pci.h) \
    $(wildcard include/config/generic/iomap.h) \
  ../include/asm-generic/pci_iomap.h \
    $(wildcard include/config/no/generic/pci/ioport/map.h) \
    $(wildcard include/config/generic/pci/iomap.h) \
  ../include/asm-generic/timex.h \
  ../include/linux/plist.h \
    $(wildcard include/config/debug/pi/list.h) \
  ../include/linux/nodemask.h \
    $(wildcard include/config/highmem.h) \
    $(wildcard include/config/movable/node.h) \
  ../include/linux/cputime.h \
  arch/arm64/include/generated/asm/cputime.h \
  ../include/asm-generic/cputime.h \
    $(wildcard include/config/virt/cpu/accounting.h) \
  ../include/asm-generic/cputime_jiffies.h \
  ../include/linux/smp.h \
    $(wildcard include/config/profile/cpu.h) \
    $(wildcard include/config/mtk/cpu/hotplug/debug/3.h) \
    $(wildcard include/config/mtk/ram/console.h) \
  ../include/linux/llist.h \
    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
  ../arch/arm64/include/asm/smp.h \
  ../include/linux/sem.h \
  ../include/uapi/linux/sem.h \
  ../include/linux/ipc.h \
  ../include/linux/uidgid.h \
    $(wildcard include/config/user/ns.h) \
  ../include/linux/highuid.h \
  ../include/uapi/linux/ipc.h \
  arch/arm64/include/generated/asm/ipcbuf.h \
  ../include/uapi/asm-generic/ipcbuf.h \
  arch/arm64/include/generated/asm/sembuf.h \
  ../include/uapi/asm-generic/sembuf.h \
  ../include/linux/shm.h \
  ../include/uapi/linux/shm.h \
  arch/arm64/include/generated/asm/shmbuf.h \
  ../include/uapi/asm-generic/shmbuf.h \
  ../arch/arm64/include/asm/shmparam.h \
  ../include/uapi/asm-generic/shmparam.h \
  ../include/linux/signal.h \
    $(wildcard include/config/old/sigaction.h) \
  ../include/uapi/linux/signal.h \
  ../arch/arm64/include/uapi/asm/signal.h \
  ../include/asm-generic/signal.h \
  ../include/uapi/asm-generic/signal.h \
  ../include/uapi/asm-generic/signal-defs.h \
  ../arch/arm64/include/uapi/asm/sigcontext.h \
  ../arch/arm64/include/uapi/asm/siginfo.h \
  ../include/asm-generic/siginfo.h \
  ../include/uapi/asm-generic/siginfo.h \
  ../include/linux/pid.h \
  ../include/linux/percpu.h \
    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
    $(wildcard include/config/have/setup/per/cpu/area.h) \
  ../include/linux/mmdebug.h \
    $(wildcard include/config/debug/vm.h) \
    $(wildcard include/config/debug/virtual.h) \
  ../include/linux/pfn.h \
  ../arch/arm64/include/asm/percpu.h \
  ../include/asm-generic/percpu.h \
  ../include/linux/percpu-defs.h \
    $(wildcard include/config/debug/force/weak/per/cpu.h) \
  ../include/linux/topology.h \
    $(wildcard include/config/use/percpu/numa/node/id.h) \
    $(wildcard include/config/have/memoryless/nodes.h) \
  ../include/linux/mmzone.h \
    $(wildcard include/config/force/max/zoneorder.h) \
    $(wildcard include/config/cma.h) \
    $(wildcard include/config/memory/isolation.h) \
    $(wildcard include/config/zone/dma.h) \
    $(wildcard include/config/zone/dma32.h) \
    $(wildcard include/config/memory/hotplug.h) \
    $(wildcard include/config/have/memblock/node/map.h) \
    $(wildcard include/config/mtk/memcfg.h) \
    $(wildcard include/config/flat/node/mem/map.h) \
    $(wildcard include/config/page/extension.h) \
    $(wildcard include/config/no/bootmem.h) \
    $(wildcard include/config/have/memory/present.h) \
    $(wildcard include/config/need/node/memmap/size.h) \
    $(wildcard include/config/need/multiple/nodes.h) \
    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
    $(wildcard include/config/sparsemem/extreme.h) \
    $(wildcard include/config/nodes/span/other/nodes.h) \
    $(wildcard include/config/holes/in/zone.h) \
    $(wildcard include/config/arch/has/holes/memorymodel.h) \
  ../include/linux/pageblock-flags.h \
    $(wildcard include/config/hugetlb/page.h) \
    $(wildcard include/config/hugetlb/page/size/variable.h) \
  ../include/linux/memory_hotplug.h \
    $(wildcard include/config/memory/hotremove.h) \
    $(wildcard include/config/have/arch/nodedata/extension.h) \
    $(wildcard include/config/have/bootmem/info/node.h) \
  ../include/linux/notifier.h \
  ../include/linux/mutex.h \
    $(wildcard include/config/mutex/spin/on/owner.h) \
  ../include/linux/srcu.h \
  ../include/linux/workqueue.h \
    $(wildcard include/config/debug/objects/work.h) \
    $(wildcard include/config/freezer.h) \
  ../arch/arm64/include/asm/topology.h \
    $(wildcard include/config/arm/cpu/topology.h) \
    $(wildcard include/config/mtk/cpu/topology.h) \
  ../include/asm-generic/topology.h \
  ../include/linux/proportions.h \
  ../include/linux/percpu_counter.h \
  ../include/linux/gfp.h \
    $(wildcard include/config/dmauser/pages.h) \
    $(wildcard include/config/zone/movable/cma.h) \
    $(wildcard include/config/pm/sleep.h) \
  ../include/linux/seccomp.h \
    $(wildcard include/config/seccomp.h) \
    $(wildcard include/config/have/arch/seccomp/filter.h) \
    $(wildcard include/config/seccomp/filter.h) \
  ../include/uapi/linux/seccomp.h \
  ../arch/arm64/include/asm/seccomp.h \
  ../arch/arm64/include/asm/unistd.h \
  ../arch/arm64/include/uapi/asm/unistd.h \
  ../include/asm-generic/unistd.h \
  ../include/uapi/asm-generic/unistd.h \
  ../include/asm-generic/seccomp.h \
  ../include/uapi/linux/unistd.h \
  ../include/linux/rtmutex.h \
    $(wildcard include/config/debug/rt/mutexes.h) \
  ../include/linux/resource.h \
  ../include/uapi/linux/resource.h \
  arch/arm64/include/generated/asm/resource.h \
  ../include/asm-generic/resource.h \
  ../include/uapi/asm-generic/resource.h \
  ../include/linux/hrtimer.h \
    $(wildcard include/config/high/res/timers.h) \
    $(wildcard include/config/timerfd.h) \
  ../include/linux/timerqueue.h \
  ../include/linux/task_io_accounting.h \
    $(wildcard include/config/task/io/accounting.h) \
  ../include/linux/latencytop.h \
  ../include/linux/cred.h \
    $(wildcard include/config/debug/credentials.h) \
  ../include/linux/key.h \
    $(wildcard include/config/sysctl.h) \
  ../include/linux/sysctl.h \
  ../include/uapi/linux/sysctl.h \
  ../include/linux/assoc_array.h \
    $(wildcard include/config/associative/array.h) \
  ../include/linux/selinux.h \
    $(wildcard include/config/security/selinux.h) \
  ../include/uapi/linux/magic.h \
  ../include/linux/ptrace.h \
  ../include/linux/err.h \
  ../include/linux/pid_namespace.h \
    $(wildcard include/config/pid/ns.h) \
  ../include/linux/mm.h \
    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
    $(wildcard include/config/mem/soft/dirty.h) \
    $(wildcard include/config/x86.h) \
    $(wildcard include/config/ppc.h) \
    $(wildcard include/config/parisc.h) \
    $(wildcard include/config/metag.h) \
    $(wildcard include/config/ia64.h) \
    $(wildcard include/config/ksm.h) \
    $(wildcard include/config/shmem.h) \
    $(wildcard include/config/debug/vm/rb.h) \
    $(wildcard include/config/debug/pagealloc.h) \
    $(wildcard include/config/hibernation.h) \
    $(wildcard include/config/hugetlbfs.h) \
  ../include/linux/debug_locks.h \
    $(wildcard include/config/debug/locking/api/selftests.h) \
  ../include/linux/range.h \
  ../include/linux/shrinker.h \
  ../include/linux/page_ext.h \
    $(wildcard include/config/page/owner.h) \
  ../include/linux/stacktrace.h \
    $(wildcard include/config/stacktrace.h) \
    $(wildcard include/config/user/stacktrace/support.h) \
  ../include/linux/page-flags.h \
    $(wildcard include/config/pageflags/extended.h) \
    $(wildcard include/config/arch/uses/pg/uncached.h) \
    $(wildcard include/config/memory/failure.h) \
    $(wildcard include/config/toi/incremental.h) \
  ../include/linux/huge_mm.h \
  ../include/linux/vmstat.h \
    $(wildcard include/config/vm/event/counters.h) \
    $(wildcard include/config/debug/tlbflush.h) \
    $(wildcard include/config/debug/vm/vmacache.h) \
  ../include/linux/vm_event_item.h \
    $(wildcard include/config/memory/balloon.h) \
    $(wildcard include/config/balloon/compaction.h) \
  ../include/linux/nsproxy.h \
  ../include/linux/kref.h \
  ../include/uapi/linux/ptrace.h \
  ../include/uapi/linux/stat.h \
  ../include/linux/list_lru.h \
  ../include/linux/radix-tree.h \
  ../include/linux/semaphore.h \
  ../include/uapi/linux/fiemap.h \
  ../include/linux/migrate_mode.h \
  ../include/linux/percpu-rwsem.h \
  ../include/uapi/linux/fs.h \
  ../include/uapi/linux/limits.h \
  ../include/uapi/linux/ioctl.h \
  arch/arm64/include/generated/asm/ioctl.h \
  ../include/asm-generic/ioctl.h \
  ../include/uapi/asm-generic/ioctl.h \
  ../include/linux/quota.h \
    $(wildcard include/config/quota/netlink/interface.h) \
  ../include/uapi/linux/dqblk_xfs.h \
  ../include/linux/dqblk_v1.h \
  ../include/linux/dqblk_v2.h \
  ../include/linux/dqblk_qtree.h \
  ../include/linux/projid.h \
  ../include/uapi/linux/quota.h \
  ../include/linux/nfs_fs_i.h \
  ../include/linux/ip.h \
  ../include/linux/skbuff.h \
    $(wildcard include/config/nf/conntrack.h) \
    $(wildcard include/config/bridge/netfilter.h) \
    $(wildcard include/config/xfrm.h) \
    $(wildcard include/config/ipv6/ndisc/nodetype.h) \
    $(wildcard include/config/net/sched.h) \
    $(wildcard include/config/net/cls/act.h) \
    $(wildcard include/config/net/rx/busy/poll.h) \
    $(wildcard include/config/network/secmark.h) \
    $(wildcard include/config/network/phy/timestamping.h) \
    $(wildcard include/config/netfilter/xt/target/trace.h) \
    $(wildcard include/config/nf/tables.h) \
    $(wildcard include/config/ip/vs.h) \
  ../include/linux/kmemcheck.h \
  ../include/linux/net.h \
  ../include/linux/random.h \
    $(wildcard include/config/arch/random.h) \
  ../include/uapi/linux/random.h \
  ../include/linux/irqnr.h \
  ../include/uapi/linux/irqnr.h \
  ../include/linux/jump_label.h \
    $(wildcard include/config/jump/label.h) \
  ../include/uapi/linux/net.h \
  ../include/linux/socket.h \
  arch/arm64/include/generated/asm/socket.h \
  ../include/uapi/asm-generic/socket.h \
  arch/arm64/include/generated/asm/sockios.h \
  ../include/uapi/asm-generic/sockios.h \
  ../include/uapi/linux/sockios.h \
  ../include/linux/uio.h \
  ../include/uapi/linux/uio.h \
  ../include/uapi/linux/socket.h \
  ../include/linux/textsearch.h \
  ../include/linux/slab.h \
    $(wildcard include/config/slab/debug.h) \
    $(wildcard include/config/failslab.h) \
    $(wildcard include/config/memcg/kmem.h) \
    $(wildcard include/config/slab.h) \
    $(wildcard include/config/slub.h) \
    $(wildcard include/config/slob.h) \
  ../include/linux/kmemleak.h \
    $(wildcard include/config/debug/kmemleak.h) \
  ../include/net/checksum.h \
  ../arch/arm64/include/asm/uaccess.h \
  ../arch/arm64/include/asm/sysreg.h \
  ../arch/arm64/include/asm/compiler.h \
  arch/arm64/include/generated/asm/checksum.h \
  ../include/asm-generic/checksum.h \
  ../include/linux/dma-mapping.h \
    $(wildcard include/config/has/dma.h) \
    $(wildcard include/config/arch/has/dma/set/coherent/mask.h) \
    $(wildcard include/config/have/dma/attrs.h) \
    $(wildcard include/config/need/dma/map/state.h) \
  ../include/linux/device.h \
    $(wildcard include/config/debug/devres.h) \
    $(wildcard include/config/acpi.h) \
    $(wildcard include/config/pinctrl.h) \
    $(wildcard include/config/dma/cma.h) \
    $(wildcard include/config/devtmpfs.h) \
    $(wildcard include/config/sysfs/deprecated.h) \
  ../include/linux/ioport.h \
  ../include/linux/kobject.h \
    $(wildcard include/config/uevent/helper.h) \
    $(wildcard include/config/debug/kobject/release.h) \
  ../include/linux/sysfs.h \
  ../include/linux/kernfs.h \
    $(wildcard include/config/kernfs.h) \
  ../include/linux/idr.h \
  ../include/linux/kobject_ns.h \
  ../include/linux/klist.h \
  ../include/linux/pinctrl/devinfo.h \
    $(wildcard include/config/pm.h) \
  ../include/linux/pinctrl/consumer.h \
  ../include/linux/seq_file.h \
  ../include/linux/pinctrl/pinctrl-state.h \
  ../include/linux/pm.h \
    $(wildcard include/config/vt/console/sleep.h) \
    $(wildcard include/config/pm/runtime.h) \
    $(wildcard include/config/pm/clk.h) \
    $(wildcard include/config/pm/generic/domains.h) \
  ../include/linux/ratelimit.h \
  ../arch/arm64/include/asm/device.h \
    $(wildcard include/config/iommu/api.h) \
  ../include/linux/pm_wakeup.h \
  ../include/linux/dma-attrs.h \
  ../include/linux/dma-direction.h \
  ../include/linux/scatterlist.h \
    $(wildcard include/config/debug/sg.h) \
    $(wildcard include/config/arch/has/sg/chain.h) \
  arch/arm64/include/generated/asm/scatterlist.h \
  ../include/asm-generic/scatterlist.h \
    $(wildcard include/config/need/sg/dma/length.h) \
  ../arch/arm64/include/asm/dma-mapping.h \
  ../include/linux/vmalloc.h \
  ../include/asm-generic/dma-coherent.h \
    $(wildcard include/config/have/generic/dma/coherent.h) \
  ../arch/arm64/include/asm/xen/hypervisor.h \
  ../arch/arm64/include/../../arm/include/asm/xen/hypervisor.h \
  ../include/asm-generic/dma-mapping-common.h \
  ../include/linux/dma-debug.h \
    $(wildcard include/config/dma/api/debug.h) \
  ../include/linux/netdev_features.h \
  ../include/net/flow_keys.h \
  ../include/uapi/linux/ip.h \
  ../include/linux/kfifo.h \
  ../drivers/net/wireless/bcmdhd/include/linuxver.h \
    $(wildcard include/config/net/radio.h) \
    $(wildcard include/config/wireless/ext.h) \
    $(wildcard include/config/rfkill.h) \
  ../drivers/net/wireless/bcmdhd/include/typedefs.h \
  include/generated/uapi/linux/version.h \
  ../drivers/net/wireless/bcmdhd/include/bcmdefs.h \
  ../include/linux/module.h \
    $(wildcard include/config/module/sig.h) \
    $(wildcard include/config/kallsyms.h) \
    $(wildcard include/config/tracepoints.h) \
    $(wildcard include/config/event/tracing.h) \
    $(wildcard include/config/module/unload.h) \
    $(wildcard include/config/constructors.h) \
    $(wildcard include/config/debug/set/module/ronx.h) \
  ../include/linux/kmod.h \
  ../include/linux/elf.h \
  ../arch/arm64/include/asm/elf.h \
  arch/arm64/include/generated/asm/user.h \
  ../include/asm-generic/user.h \
  ../include/uapi/linux/elf.h \
  ../include/uapi/linux/elf-em.h \
  ../include/linux/moduleparam.h \
    $(wildcard include/config/alpha.h) \
    $(wildcard include/config/ppc64.h) \
  ../arch/arm64/include/asm/module.h \
  ../include/asm-generic/module.h \
    $(wildcard include/config/have/mod/arch/specific.h) \
    $(wildcard include/config/modules/use/elf/rel.h) \
    $(wildcard include/config/modules/use/elf/rela.h) \
  ../include/linux/pci.h \
    $(wildcard include/config/pci/iov.h) \
    $(wildcard include/config/pcieaspm.h) \
    $(wildcard include/config/pci/msi.h) \
    $(wildcard include/config/pci/ats.h) \
    $(wildcard include/config/pci/domains/generic.h) \
    $(wildcard include/config/pcieportbus.h) \
    $(wildcard include/config/pcieaer.h) \
    $(wildcard include/config/pcie/ecrc.h) \
    $(wildcard include/config/ht/irq.h) \
    $(wildcard include/config/pci/domains.h) \
    $(wildcard include/config/pci/quirks.h) \
    $(wildcard include/config/hibernate/callbacks.h) \
    $(wildcard include/config/pci/mmconfig.h) \
    $(wildcard include/config/hotplug/pci.h) \
    $(wildcard include/config/of.h) \
    $(wildcard include/config/eeh.h) \
  ../include/linux/mod_devicetable.h \
  ../include/linux/uuid.h \
  ../include/uapi/linux/uuid.h \
  ../include/linux/io.h \
  ../include/uapi/linux/pci.h \
  ../include/uapi/linux/pci_regs.h \
  ../include/linux/pci_ids.h \
  ../arch/arm64/include/asm/pci.h \
  ../include/asm-generic/pci-bridge.h \
  ../include/asm-generic/pci-dma-compat.h \
  ../include/linux/interrupt.h \
    $(wildcard include/config/irq/forced/threading.h) \
    $(wildcard include/config/generic/irq/probe.h) \
  ../include/linux/irqreturn.h \
  ../include/linux/hardirq.h \
  ../include/linux/ftrace_irq.h \
    $(wildcard include/config/ftrace/nmi/enter.h) \
  ../include/linux/vtime.h \
  ../include/linux/context_tracking_state.h \
  ../include/linux/static_key.h \
  ../arch/arm64/include/asm/hardirq.h \
  ../arch/arm64/include/asm/irq.h \
  ../include/asm-generic/irq.h \
  ../include/linux/irq_cpustat.h \
  ../include/linux/kthread.h \
  ../include/linux/netdevice.h \
    $(wildcard include/config/dcb.h) \
    $(wildcard include/config/wlan.h) \
    $(wildcard include/config/ax25.h) \
    $(wildcard include/config/mac80211/mesh.h) \
    $(wildcard include/config/net/ipip.h) \
    $(wildcard include/config/net/ipgre.h) \
    $(wildcard include/config/ipv6/sit.h) \
    $(wildcard include/config/ipv6/tunnel.h) \
    $(wildcard include/config/rps.h) \
    $(wildcard include/config/netpoll.h) \
    $(wildcard include/config/xps.h) \
    $(wildcard include/config/bql.h) \
    $(wildcard include/config/rfs/accel.h) \
    $(wildcard include/config/fcoe.h) \
    $(wildcard include/config/net/poll/controller.h) \
    $(wildcard include/config/libfcoe.h) \
    $(wildcard include/config/vlan/8021q.h) \
    $(wildcard include/config/net/dsa.h) \
    $(wildcard include/config/tipc.h) \
    $(wildcard include/config/net/ns.h) \
    $(wildcard include/config/cgroup/net/prio.h) \
    $(wildcard include/config/net/flow/limit.h) \
  ../include/linux/pm_qos.h \
  ../include/linux/miscdevice.h \
  ../include/uapi/linux/major.h \
  ../include/linux/delay.h \
  arch/arm64/include/generated/asm/delay.h \
  ../include/asm-generic/delay.h \
  ../include/linux/prefetch.h \
  ../include/linux/dmaengine.h \
    $(wildcard include/config/async/tx/enable/channel/switch.h) \
    $(wildcard include/config/dma/engine.h) \
    $(wildcard include/config/rapidio/dma/engine.h) \
    $(wildcard include/config/async/tx/dma.h) \
  ../include/linux/dynamic_queue_limits.h \
  ../include/linux/ethtool.h \
  ../include/linux/compat.h \
    $(wildcard include/config/compat/old/sigaction.h) \
    $(wildcard include/config/odd/rt/sigaction.h) \
  ../include/uapi/linux/if.h \
  ../include/uapi/linux/hdlc/ioctl.h \
  ../include/uapi/linux/aio_abi.h \
  ../include/uapi/linux/ethtool.h \
  ../include/linux/if_ether.h \
  ../include/uapi/linux/if_ether.h \
  ../include/net/net_namespace.h \
    $(wildcard include/config/ipv6.h) \
    $(wildcard include/config/ieee802154/6lowpan.h) \
    $(wildcard include/config/ip/sctp.h) \
    $(wildcard include/config/ip/dccp.h) \
    $(wildcard include/config/netfilter.h) \
    $(wildcard include/config/nf/defrag/ipv6.h) \
    $(wildcard include/config/wext/core.h) \
  ../include/net/flow.h \
  ../include/linux/in6.h \
  ../include/uapi/linux/in6.h \
  ../include/uapi/linux/libc-compat.h \
  ../include/net/netns/core.h \
  ../include/net/netns/mib.h \
    $(wildcard include/config/xfrm/statistics.h) \
  ../include/net/snmp.h \
  ../include/uapi/linux/snmp.h \
  ../include/linux/u64_stats_sync.h \
  ../include/net/netns/unix.h \
  ../include/net/netns/packet.h \
  ../include/net/netns/ipv4.h \
    $(wildcard include/config/ip/multiple/tables.h) \
    $(wildcard include/config/ip/route/classid.h) \
    $(wildcard include/config/ip/mroute.h) \
    $(wildcard include/config/ip/mroute/multiple/tables.h) \
  ../include/net/inet_frag.h \
  ../include/net/netns/ipv6.h \
    $(wildcard include/config/ipv6/multiple/tables.h) \
    $(wildcard include/config/ipv6/mroute.h) \
    $(wildcard include/config/ipv6/mroute/multiple/tables.h) \
  ../include/net/dst_ops.h \
  ../include/net/netns/ieee802154_6lowpan.h \
  ../include/net/netns/sctp.h \
  ../include/net/netns/dccp.h \
  ../include/net/netns/netfilter.h \
  ../include/linux/proc_fs.h \
  ../include/linux/netfilter.h \
    $(wildcard include/config/nf/nat/needed.h) \
  ../include/linux/in.h \
  ../include/uapi/linux/in.h \
  ../include/uapi/linux/netfilter.h \
  ../include/net/netns/x_tables.h \
    $(wildcard include/config/bridge/nf/ebtables.h) \
  ../include/net/netns/conntrack.h \
    $(wildcard include/config/nf/conntrack/proc/compat.h) \
    $(wildcard include/config/nf/conntrack/events.h) \
    $(wildcard include/config/nf/conntrack/labels.h) \
  ../include/linux/list_nulls.h \
  ../include/linux/netfilter/nf_conntrack_tcp.h \
  ../include/uapi/linux/netfilter/nf_conntrack_tcp.h \
  ../include/net/netns/nftables.h \
  ../include/net/netns/xfrm.h \
  ../include/uapi/linux/xfrm.h \
  ../include/net/flowcache.h \
  ../include/linux/seq_file_net.h \
  ../include/net/dsa.h \
  ../include/linux/of.h \
    $(wildcard include/config/sparc.h) \
    $(wildcard include/config/of/dynamic.h) \
    $(wildcard include/config/attach/node.h) \
    $(wildcard include/config/detach/node.h) \
    $(wildcard include/config/add/property.h) \
    $(wildcard include/config/remove/property.h) \
    $(wildcard include/config/update/property.h) \
    $(wildcard include/config/of/resolve.h) \
  ../include/linux/property.h \
  ../include/linux/phy.h \
  ../include/linux/mii.h \
  ../include/uapi/linux/mii.h \
  ../include/linux/phy_fixed.h \
    $(wildcard include/config/fixed/phy.h) \
  ../include/net/netprio_cgroup.h \
  ../include/linux/cgroup.h \
  ../include/uapi/linux/cgroupstats.h \
  ../include/uapi/linux/taskstats.h \
  ../include/linux/percpu-refcount.h \
  ../include/linux/cgroup_subsys.h \
    $(wildcard include/config/cgroup/cpuacct.h) \
    $(wildcard include/config/cgroup/device.h) \
    $(wildcard include/config/cgroup/freezer.h) \
    $(wildcard include/config/cgroup/net/classid.h) \
    $(wildcard include/config/cgroup/bfqio.h) \
    $(wildcard include/config/cgroup/perf.h) \
    $(wildcard include/config/cgroup/hugetlb.h) \
    $(wildcard include/config/cgroup/debug.h) \
  ../include/uapi/linux/neighbour.h \
  ../include/linux/netlink.h \
  ../include/net/scm.h \
    $(wildcard include/config/security/network.h) \
  ../include/linux/security.h \
    $(wildcard include/config/fw/loader/user/helper.h) \
    $(wildcard include/config/security/path.h) \
    $(wildcard include/config/security/network/xfrm.h) \
    $(wildcard include/config/securityfs.h) \
    $(wildcard include/config/security/yama.h) \
    $(wildcard include/config/mtk/root/trace.h) \
  ../include/uapi/linux/netlink.h \
  ../include/uapi/linux/netdevice.h \
  ../include/uapi/linux/if_packet.h \
  ../include/linux/if_link.h \
  ../include/uapi/linux/if_link.h \
  ../include/linux/sched/rt.h \
  ../include/net/lib80211.h \
  ../include/linux/ieee80211.h \
    $(wildcard include/config/timeout.h) \
  ../drivers/net/wireless/bcmdhd/include/osl.h \
  ../drivers/net/wireless/bcmdhd/include/osl_decl.h \
  ../drivers/net/wireless/bcmdhd/include/linux_osl.h \
    $(wildcard include/config/mmc/msm7x00a.h) \
    $(wildcard include/config/dhd/use/static/buf.h) \
    $(wildcard include/config/nf/conntrack/mark.h) \
  ../drivers/net/wireless/bcmdhd/include/bcmsdh.h \
  ../drivers/net/wireless/bcmdhd/include/bcmutils.h \
  ../drivers/net/wireless/bcmdhd/include/hnd_pktq.h \
  ../drivers/net/wireless/bcmdhd/include/hnd_pktpool.h \
  ../drivers/net/wireless/bcmdhd/include/packed_section_start.h \
  ../drivers/net/wireless/bcmdhd/include/packed_section_end.h \
  ../drivers/net/wireless/bcmdhd/include/bcmendian.h \
  ../drivers/net/wireless/bcmdhd/include/bcmdevs.h \
  ../drivers/net/wireless/bcmdhd/dngl_stats.h \
  ../drivers/net/wireless/bcmdhd/dhd.h \
    $(wildcard include/config/has/wakelock.h) \
  ../include/linux/etherdevice.h \
    $(wildcard include/config/have/efficient/unaligned/access.h) \
  arch/arm64/include/generated/asm/unaligned.h \
  ../include/asm-generic/unaligned.h \
  ../include/linux/unaligned/access_ok.h \
  ../include/linux/unaligned/generic.h \
  ../drivers/net/wireless/bcmdhd/include/wlioctl.h \
    $(wildcard include/config/params/version.h) \
    $(wildcard include/config/usbrndis/retail.h) \
    $(wildcard include/config/item.h) \
    $(wildcard include/config/version.h) \
    $(wildcard include/config/ver/0.h) \
  ../drivers/net/wireless/bcmdhd/include/proto/ethernet.h \
  ../drivers/net/wireless/bcmdhd/include/proto/bcmip.h \
  ../drivers/net/wireless/bcmdhd/include/proto/bcmeth.h \
  ../drivers/net/wireless/bcmdhd/include/proto/bcmevent.h \
  ../drivers/net/wireless/bcmdhd/include/proto/dnglevent.h \
  ../drivers/net/wireless/bcmdhd/include/proto/802.11.h \
  ../drivers/net/wireless/bcmdhd/include/proto/wpa.h \
  ../drivers/net/wireless/bcmdhd/include/proto/802.1d.h \
  ../drivers/net/wireless/bcmdhd/bcmwifi_channels.h \
  ../drivers/net/wireless/bcmdhd/bcmwifi_rates.h \
  ../drivers/net/wireless/bcmdhd/include/devctrl_if/wlioctl_defs.h \
  ../drivers/net/wireless/bcmdhd/include/bcm_mpool_pub.h \
  ../drivers/net/wireless/bcmdhd/include/bcmcdc.h \
  ../drivers/net/wireless/bcmdhd/include/wlfc_proto.h \
  ../drivers/net/wireless/bcmdhd/dhd_dbg.h \
  ../drivers/net/wireless/bcmdhd/include/dhdioctl.h \
  ../drivers/net/wireless/bcmdhd/dhd_linux_wq.h \

drivers/net/wireless/bcmdhd/dhd_linux_wq.o: $(deps_drivers/net/wireless/bcmdhd/dhd_linux_wq.o)

$(deps_drivers/net/wireless/bcmdhd/dhd_linux_wq.o):
                                                                                                                                                                                                                                                                    INDX( 	                 (               f                 e    ` L         w31+H91+H98nH9                        v x 2 2 2                       53|X+H9|X+H9HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                       y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                 ` N         53Q23HnH9                        y m  p c i                     53Q23HnH9                        y m f p c i                 53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                 ` N         53Q23HnH9                        y m f p c i                 ` N         53Q23HnH9                        y m f p c i                    53Q23HnH9                        y m f p c i                 ` N         53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                 53Q23 HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                     53Q23HnH9                        y m f p c i                 b    ` N         53Q23HnH9                       y m f p c i                 ` N         53Q23HnH9                        y m f p c i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF                              pD          @     @   {* S       # *[xacc9 6@) T Ruc!@  B     #@SA  R[BcC{_   Ru a
    |@	T RB!|? T4}c    |B     48 { S[cw  kx y  s` Ro @9`  4\ A T 9`KSA[BcCkDsE{_pq T@9@ 4   T\  4q T( Tq Tq` T  4 Q! ? q T
   4" @9C Qc  qh T#   T SB   !   | qIT` 8q Tq!T`R  @R` 9s 
 R RRu  4qa T
@93     *3@7@9    6 { { 9{S { *o@  4@9pq` Th T q  Tz 9@9s `8 q  TqT`R   R` 9{ S[c ksE @ `@9  q      9  c           RRRR TS    qs`SA[BcCkDsE{_ R@8  4`t8  
  ` 5F 47 *)+)#))   7@N)+O)#P)S)H 
 H 4 i
 T& Q q TK`8a      R
 7$ 8` 9  RRRR@RI 4 ) Tn q  Trq  T qA T4R  R$ 8t 9
  
 4  T  5$ 8l 9 4  T~Sw 9  ` 9C
    `
 9t 9 s  4  TD@w 9d 9 k`8`
 9 kt8` 9  t 9 s `     
                                                                                                                                                                                        .%03lld %lld%s %s B kB MB GB TB PB EB ZB YB KiB MiB GiB TiB PiB EiB ZiB YiB                                      int     M   ;       F       R           e               R                  u8 e   u64    R   	   	     	             4       G   F                  6       l       o       3  9  
-   D  (  P       E      E      E      E  F          |             R       >             (4   M            	
      	      	       	-   -          	_      	-       	-       	-       <      	6A          
R     q  -        
|  b      
-       
-       
-       
-       
-       
-       
-       
       R   
  	     	    	    	    	         
      
      
      
3   l   N   C      N      R   |  	     	     ^      -                   src ;       isz       dst       osz           R       esc ;       out        p               ret -   P    c e   d                                                        %      1        g                    x                         8       F        !        8                      '          0         N  B  8  !        0       Z     =                   a  V  M  !               l    "               #    n-   !  $c ne   $dst n  $osz n!  %out p      #    \-   g  $c \e   $dst \  $osz \!  %out ^    #    I-     $c Ie   $dst I  $osz I!  %out K    #    *-     $c *e   $dst *  $osz *!  %out ,   %to -e    #    -   =  $c e   $dst   $osz !  %out    %to e    &    -   x  'c e   'dst   'osz !  (out     )    -           $      :	  *src        *dst        +          +    R       ,out        -
                !
  
      ,
  5
    .	          h         	  	  !        h       	  	      	  .                 n     /                 r     -:	                U	  J	      `	  i	    /s	          P       	  	  !        P       	  0	  d	  	      "          "             &       s	  'src   'dst   (p    (q     &    |   	  'src |  'dst |  (p ~   (q ~   1    -   (num     &    i   
  'src i  'dst i  (p k   (q k   (num l    &    M   ?
  'src M  'dst M  (p O   (q O    )    -                   +           +    |      *buf        *len -       2      	        2    !  	        2    %  	        2    )  	        ,i --       ,j --       1    .   1    .   3tmp /  x4    N  1    5  1    5   5j  1    ?  1    ?   "          "           A     64   	       64      A     Y     64      F     64    &    A-     'c AM    7        8        
8        
 %  $ >  $ >   I  & I   :;I   :;I  >I:;  	(   
 'I   '  I  !   4 :;I?<   <  4 :;I?<  'I   I  >I:;  >I:;  .?:;'I@B   :;I   :;I  4 :;I  4 :;I  4 :;I  U  1RUXY   1  4 1  4 1   1XY  !  " 1  #.:;'I   $ :;I  %4 :;I  &.:;'I   ' :;I  (4 :;I  ).?:;'I@B  * :;I  + :;I  ,4 :;I  -1RUXY  .1XY  /1XY  04 1  14 :;I  24 :;I  34 :;I  4U  5  6! I/  7. ?<n:;  8. ?<n:;   ,      h       Ph             h             h                ,             QP      x       Q             Q             Q                ,      /       RL             R                ,             S             e                ,             T             T                ,      X       UX             k             k                X      /       UL             U                |             c             c                             Q             QP      x       Q             Q             Q                |             P             P             P             P             P                             P              P              P                             P              P                             d      D       d`      t       d             d                      @       P@      d       d|             d      ,       d                      |       Q|      ,       f                      T       RT      t       lt      |       R|      $       l$      (       R(      ,       l                             S              S      ,       S                      d       c|      ,       c                H             Q             Q      ,       Q                H      t       k|             k             k      ,       k                                P       t        c              c                        0        Q                                R              h                        ,        S,       p        i              i                L       |        e              e                L       t        d               d              d                ,                                                                                                                 (      L      T      p                      L      T                        ,                      h      x      |                                                    h      l      |                        T      `      d                            l      p                  T                                                                                              #   ,        ../lib ../include/linux ../include/uapi/asm-generic ../include/asm-generic ../arch/arm64/include/asm  string_helpers.c   ctype.h   int-ll64.h   int-ll64.h   posix_types.h   types.h   init.h   cachetype.h   printk.h   kernel.h   string_helpers.h   string.h   stddef.h     	         j <j.<j.  "; dt$ "/!!-  6M!"""Z x..=Dx  $p .$o  ..#e . .0"~ ~ + ?/Q./ g!H3!Z.Jw. %  .14< 1K1/'"!+! .. f>XJ+#%.!!   <     n.       2 ( ( 	  & M    ! ^    r >.%/2    J/~ 1v $!"q<11w..~ 1k1&/ .~ 1#/.~ 2!/!!!  . 3!!!/<##. escape_null units_str unescape_special size_t uint64_t isodigit hex_asc_upper linux_banner panic_on_unrecovered_nmi long long unsigned int SYSTEM_RESTART panic_blink SYSTEM_HALT string_escape_mem GNU C89 7.3.1 20180522 -mlittle-endian -mgeneral-regs-only -mpc-relative-literal-loads -mabi=lp64 -g -Os -std=gnu90 -fno-strict-aliasing -fno-common -fstack-usage -fno-delete-null-pointer-checks -fno-PIE -fno-store-merging -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -fno-strict-overflow -fstack-check=no -fconserve-stack --param allow-store-data-races=0 long long int signed char __security_initcall_end saved_command_line digit SYSTEM_BOOTING sf_cap long int __kernel_ulong_t kptr_restrict linux_proc_banner _ctype initcall_t file_operations printk_disable_uart ../lib/string_helpers.c escape_special root_mountflags long unsigned int __u32 atomic_notifier_head strchr console_printk string_get_size SYSTEM_RUNNING size short unsigned int bool dmesg_restrict __con_initcall_end __base STRING_UNITS_10 escape_space string_unescape sysctl_panic_on_stackoverflow reset_devices system_state unescape_hex STRING_UNITS_2 panic_timeout __security_initcall_start /home/rafael/android/MiPad/_cappu-082018/_cappu-mt8176/android_kernel_xiaomi_cappu/out panic_notifier_list kmsg_fops string_size_units _Bool unsigned char system_states __kernel_size_t initcall_debug short int false units escape_octal escape_hex remainder units_10 uint32_t SYSTEM_POWER_OFF divisor __u64 unescape_octal oops_in_progress char unsigned int panic_on_oops units_2 boot_command_line printk_delay_msec early_boot_irqs_disabled panic_on_io_nmi hex_to_bin is_dict snprintf mach_panic_string __rem mt_need_uart_console __icache_flags hex_asc flags __con_initcall_start late_time_init escape_passthrough true unescape_space  GCC: (Linaro GCC 7.3-2018.05~dev) 7.3.1 20180522      x D                     A`BA
	DET
 A     L               $      ApAAB
	BCCO
 A  L                     AABBC
	e
 A                                                                                                                                                                                                      %                   4             P       B     p       P                                                        
                                                                                                                                                                                                 O                   _                      h           $      x                           ,                                                                               string_helpers.c $x $d divisor.2905 units_str.2904 units_10.2902 units_2.2903 string_get_size snprintf string_unescape hex_to_bin string_escape_mem hex_asc _ctype strchr                                            `                   d                   h                                                                                                                      h                   l                   p                   |                                                         ,                                                   p                           (                   0                   8                   @                   H                    P            #       X            &       `            )       p                   x            ,                   0                   4                   8                   <                   @                   D                   H                                                          3                                            )                    7            j      I                  U                  a            p      h            I      t                  {                              |                  b                                    t                                                                                           e                                   C                 '                                   .       )                 Q                 \                 g                 r           |                 5                                  ]                                  u                                  N                                                                                      G      '                 2                 =                 G           '      S                 X                 r                                                                                [                  r                 ?                 Z                 Y                 W                                                                                                        k                        ,           @       8                 T                 _           1      p                 v                                              ,                                    I                                                                                        G                                        "                 <                  Q           h      Y                 t                            l                 p                 p                                  k                                                                                           "                 7           #      @           Y      K           $      r           $                                                   0                       (                 h                              K                 "      >                 y           /                                                                                     G                                                                                     @                  @                        <                 V           H      d                                             L                                                     t                 t      	                 	                 +	                 ;	                  t	           x      	                 	                 
           $      @
                 J
                   a
                 k
                 p
                 z
           6      
           Y      
                 
                 
                   
           -      
           p       
                  
                  
                 
                  
                                                                    /                   8                 C                 T                 _                 k           l       x                             7                                                          	                                                                                           9                                                           \                    `                                                  ,       .symtab .strtab .shstrtab .rela.text .data .bss .rela.rodata .rodata.str1.1 .rela.debug_info .debug_abbrev .debug_loc .rela.debug_aranges .debug_ranges .rela.debug_line .debug_str .comment .note.GNU-stack .rela.debug_frame                                                                                       @                                          @               .                                &                                                          ,                                                          6                                                         1      @               @0                                >      2                     L                             R                                                         M      @                2                                ^                                                         l                            W                             |                      [      0                              w      @               B      0                                                                                                                 '                                   @               B                                       0               "      3                                  0               )      2                                                   *                                                           *                                          @                C                                                       +                                	                      -                                                          C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    x|tTwfB j	J1		2!	-TWM&H2DIAe*b_	K.oM*moWVJl@^@sNNz>o{SUR

h(
JX%~SR0VD6I3(p
>.dhtO[b2t#_3[=>ldfP |s*Ut&#C'%)!,s$b<j=[#12|#%WT C>9ZPj([`,r+>w}y>Z's[/p9._g];_OW$k$w|*> .$@<A_/VoN0	^_7	2	_II$xK$wO&7'OLL)tt4P7dJ1~@m	OR ".p5>e7OyJQo"?O!m*e[~QwF<&QEh'B&!u_"	([7x= ?P oR:7.W<tuTQQ]Qkp1jC@;TtQAO5^+<:#\e'*B:|!^Vzw]?`cX]+j>n@;4J"u=R]zj|E!]	)17z8V<j
!Auj{Yv3 uE_q7j,.3Y=kX=t {,tc%PQvjkY\A^u7UX!^TQ]WM5{T)L*[Ma5obEw6pa3CU673~Hr!w?6OoYOvsy{w|p2;~y==wVZB}SG/w?6M/M9SS;IT_OVa]w-4\/'!Nxo)%=
<x,GK;>V$)AbCn	K	j	x	/J	O\dYY+U_2(OoM-O_lkSE'ROl&\+N8h3rfZMx>O1	m&:2E&a]&\=
%A+M^i2^~	o4q:no&S9m&|	dyVn^a	g+Mya	.'ppau	#	ic&\'|gMpctb4UC~ ?zcH!~)_j?x)4 ^S'2w"nX/"~)A|)sL_ )k5@)qW WcwB|),3?E|)oW'?NS{M2#+U07;zF_Ck\q9*h	^@26)x	GJd\<egQ|tDlt=^7zs^+^P6<4W(iQOZmel'H-@:+-Y_9zOZ)3
K%m+ajl]S5Y,^}|p&~v9b5;+?!Y#Y5Xt:"ZgDXz:
+{^]\V:3rgQiQD1c9q}FMki)%*(rtSS%h
2]EZBOs]403",$EZdG=OV0dW;Y]ejRCkq[EXyFhjZVFW7%<fIRWM4x\FK*]nZ7{J?o0U}s76^TGo"sucyK\Ho><| 0p_m\H!6r08\[fx\6syV	s/p31}iBs$yLow~xIox|do[/OO}u8q+%<N:3hN/cFqGBX? =\0lm1q[B"9#ErN2V{xE2-SmVdOdfv,)<n?oG_!M924lN/ NO+#KG|\|X\ 
;J\wSm#'mvU&iFg\d]2Xw9~9t ~kfdq$4yTNsY~]Qdb|C(?JSk=|+Ri.Y6&K^Q1&u1Y_
/Ko?00},x~C6Nu#;>LG}KQv	{ce|~f/t1X1E.|Nb.>-gZ;&QD]Xf~Xq
]}b[c-lT7s>l7ESsYSKv~}tv;id}
W6X6q9%J=nLD e<&@Zf2s TZlkM.1~!H]c=k:;xz<a~(8$\f:0og>9o!dA^6=vW)m)/alWKtW%lrwh<gla*L~gXrc?Wh=?B}sX:WJ-=Aq'NO\=mWO$b<:m%M5s\EmV 9Q4`6sQsIS8pP=y~w(TD>Ewu%{}W#?E2`2qdSd+'o9"97mQ\OwL!	~D9MmTz>]A	
Y<6lDz>C9)v<^EAl~<s}zk*4Av5A^!ZW'__=J{9{ y x'RsN<mWiMbM5Q1<6'>J*85;&u'c>N=*<+)hGGMGh)B||/t
|Emm}.tvT*BZG*gY !
DL`({u1X4?l0Ou{&}(pNvtf
;/\fifBv8Z2T
0^MGk]6#iG8z:+lt};Gt(~.#&AGa]?J=v%~2*iYq>=g<e{;ag-0?CVlZn{hco]F,dGs?"NaGtgo%ei,g'uk0w3#;b'}Y>y:0FK&W!.czT0Ge^@V@Mea?\V+la+y<#0`H{3h.no*u_jz8>1><|qqED:w/~	mu1MQ9u85q?|zemO_F^+PbabWZ?B{:CxJ1.CJ]}L
gh&z'gGQJ}{?>_	q?dPZ;J'-@s[~U	0VtV>6W93"')ciN;( T:kNnh%X3~QQ"nTMOsl+3m
'SOd0 9NfC.o)!Zh`%V:a-
{;upwOne30%{  ~zE
yE/3ri11v%|D>$=hMD^C![y2g?k/~9~ |5o%1d>su 4<
O}=;K3C.!w2st.f509}(x]8cF;1}yG^
}/A%htL}(~ul.c3{7>s}{0C3"Y(G9Hks?wg2F?g^[~!hXPy]=
af/'s?oOz3y>}"8rkl'Mv}di,CuuW'<Seg,cg7 vxcy>nlGf`,w9Ko|_cQ`aL7sT|g?kht#7#OUI>0,Ci{-~Ssr:.4w1a{[0]acL|4wrcy9Xw}U0n9b}q'kMz~6s=2qa=@|e`YSMF;h`W=50^^030+0<xnyXXTru$gyu,00?I>f6zA!it}$|(;q/T{cV'%_Jn2Ccv40AV"~#?@p^2?eC>:_-X{~XA]{U0Gt!>-0V0ebP7P	sY%Sqy~;3VWeZ;l8}h.Y`7}EekN=tQnHzt]#v*N|/qJ=E[{>>zwae9k6qcn t!O,<nQZe e.g-^:A^{X6Xm2V|rDA}Z!@M7?r	>>	PA^3yrfkBh# vym9a}}!gw1|q!p}S/9&-u&u>rw=>{[z6[zqFpFgqFgqFt8#  Gi< J'
s_(/9|Vk4Jz*#61_crO03=vaW;Wt-%cJRU>=m	2q)lyzj) `"_tYy]"Rgm;HS<NO:bCl8Y\Y;g.DOglcOh5u`\_~af26 Bi\_w!3yX?tP	I= iY8X#?8!/y~
@oP.W>kU~_!_qH72_w'$BBVGipC^_W(JdQJ'zAoOo^kXQwo5<Ajuy]4F?>p	L_Rw!4!$
B] a zJwX^BhPUh!(5]3P"iG{B!d]N-{q}kKJ&;X
U*6}8/7\z	]JE*BL_W{UkIF\\jjOwz#3jp/6vOS'.7|$-T(]B^:jf"F/Qq4*.pPAM
}wPZCC!??p7j(sYS`U5m\O43tJS9?gm3=8-_mJtB8!	t4M[*Nxv4P35"e8tX5?s)k@z;}G@v2?/n7og~`~Fz;eA?a^,L8w?_o	.-Neg)pL^(7@0r0)BoI4=|/ .p]W&Wg["x9KI'WfYo8iX4m+!(_IG4C|v!D	~O@(aUvar`Cx}EJ8V"T67#lG!_	HHHHH@t] ; /{/{g/{'/{.{.{g.{-y_*` cwc^8/%k=~p@?\ ?2~*E~{}4?s-OXv',<@zD/MyI	.Ck~?N]?,w8?XrU&U\yw;k8*JKN[[-`-yG.M8S-<n-+(+VUg~FF]KRP+7Vj[row1A/FMvO1\_69WW3R[l7Pr9g^M07.R\L%G%FN.~v	~Wtr= 6i[M'_;prQU*?\T4Ty*|2?0d# ]p2U31cdNpXdmCEPQ[2/gPexa&K;(5	%t2.=OP'9Mvy4Ol"RQGew8?}"DJ@{<9dXyN6/Q~aGRddsb.;*V)8_Dx1O>'$\F=dHe~G-*
Hp;_SJe~.wQje~	D*E+01~['qbc+G/m"u.CCH8:_(A8lDbB7*w                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ELF                      @                @ 8  @         @       @      @                                                     \     \                                                                                                                        8       8              Ptd   (     (     (     4      4             Qtd                                                   Rtd                                              Android             GNU UiEMq                                              :                      L                      Y                                                                                                                                                         '                     -                     3                     D                     V                     \                     r                                                                                    	                     	                     	                     	                     '
                     ?
                     p
                     
                     
                     
                     
                                          !                     )                     6                     C                     K                     S                     `                     k                     r                     y                                          %                                                                                    0                     R                     s                                                                                                         	                                                                                                           t                                                                                                                                                                        %                     <                     N                     Y                                                                                     C                     {                                                                                                                                                                                                                    "                      L                      m                                                                                        b&                     &                     &                     &                     &                     \*                     d*                     ?                     @                     @                     (@                     3@                     B@                     I@                     N@                     S@                     Y@                     a@                     g@                     u@                     @                     @                     @                     @                     @                     @                     @                     @                     @                     @                     @                     @                     @                     A                     DD                     .F                     =F                     EF                     PF                     \F                     dF                     kF                     sF                     F                     F                     G                     LG                     G                     G                     G                     CT                     U                     lW                     W                     W                     W                     W                     _                     _                       !  P             '    v     (      W    p     H      k*    5               x(            E  !              =C                5$    |g           D    0     <      '    P_            hB                zL                >                	\    P      h      B    L            =    4            K                B_  "  P2            )    tX            X[    t     `       8                ?         D                       *                    `     `           (            9    |                0            6    !     <       yH                H                 \    H     d       ^  "  @.     X       Y    d'            r\         P                 P       x  "  p>            
         @       =2                8    |     |       _    l&     ,         "  M            %    HO     X       9  "  0@             _'    |Z            @  "  |     P      M         |       [    `     \       E    p     \         "  =     `       +    t     8       yU                V    x     P       J    /            B                `    )           a    6           d    :            
e    `>           B                  "  L            Q               6    %            C                R         t       ,    8     4       <X         \       Qb    9     X       Xf    TG           O,         p      C    |*             "  <     ,       aX    D)     <       W
    O     <       ?    (     H           <6     <      #    HX     ,       2         0       N>                  )W    p     H      5e    =            ,     l            *               gA    T     <       Q               f                bS    	            J         H       |^  "  X4               x(            #    R            0    x     4       )    c           ^  "  \1            5                <                O                I#    Q            [         \                          "  M            ^(    [            ?    8     <       {Z    .            X!    tr     <      4          t       &	    `     `       <                yQ    x            /)    U            _3         `       \         \           ,      \      1         @       ,    X               /     4       U  "  d=            \J    H            `    D,                p     (           `      X       TZ    !     h      ]  "  0     ,       
?          @       q$    ^            +         0       7    8     x       r4         <           X     l      7               dI                     &            Q         ,         "  @.     X       /         X	      %    O     <       V    H           V    '     @       ]         @       "    T            W/                N                -         4       9A         d       8         t       T    l     $       f:  "              (    (     0       ~,    l           8               M                f                     p4           (    u     H      O;  "       d       }F    d            CS         t       #    8S     L       D                     <            	R                e    ;            &<    T<            Q                Y    $'     @       -#    d            a    9     X       S         $       U         0       \         \                (       $    DW     ,       I                C    @     $       D         $       a7         $         !  p             %/    L     X      P<                >    H            V    (     H       $  "  x-     $       Z    .           6    x8               H           +                 2               B    l            `  !       X       f6    \           ce    \<     4      C    H            Q  "              X    $'     @       ,         0       5N                E         $       8  !                              m    '     @       C                H    t     $       "    e           0    H     0       c  "   B     H         "  -     \       )    i     <      &8         t       OR                }d  "  C     `                X       <                    t     $           \            	%    \            ^+    X     P       =    R            U         \      R)    T            -    h     ,       b    \3     $           p                B     L       A    x            E         \       T         P       Y    $'     @         !  0     @        O               X    T     X       a    9     X           R            	T    0            wa    @            *d  "  B     `       B                {[     #           7    |            A                 K         p      V    (     H       '0    L     `           ;     l       +3                 "    d              "  d?            0L    `                           3    (     @       XU         <       #'    $a            C    <            P    <           :a    ?            O\         h      K  "  8     `       3    L            *         |      a2         @                       9  "  T     (       'B                #    LY     ,       7    :     8      4    h     <       6         |      T    D     P       H               U]  "   1     \           l$            ]0    ,                 %              "  =            F                 KW    @     (                        `  "  x-     $       !    @     $       /f    D           P    h            \  "  t5             >	         x       B               G         L       y         (       i    L1     p      $    PZ     ,       S    t
            U         l                       z    X0            D                
    p               B     L       ]O                X    (     h       9  "  |     H       X    %            &T    0                \N            G1         0       E                !    ^     X                         !  P     X       &    PR     d       7    |            4                    3            ,-    8     0       -    x            3         @           \            ^    (     (       YH                   3     `       )    pV            E         d       kY    d'            Z    x(                t     $         !       P       ++         X       EB                9"    \]     P       /5    X           A  "  0@             $  "  -     \       $    ]     X       2?    `     @       gD         D       f                 :  "       t       FY    '            e`                pb  "  |D     L                       \    D     P       I               bC    H                                           6               qc  "  pC                dG     @      %  "  -     H       !    T[     ,       3         <       U                f          @       V	         p       I                [         \       ^  "  ,3     ,          d4            T    <            8    X     P           X0            .    L     d      nK    (           1                         T       ,Z                tE    \     (      a%    O           7    B           0&    0Q     \       J         P          0"           tR    D            R    t
            .         0       m5         @       ,\         h        "  -     H       X    k           "    h           5    D     @       G8         $           \                (     (       	"    R     t       !,               R    	            u    D            &S    D           w  !  `             x               X         (       >    X     P       D*         @       7U         <       (                 A    d     l       Y    '            2    0            EE    ,     D       b    L:     `       '    ,`                `(            /         `       3=         <       )    xY            A         |       Z    /                             !        P       :%    X\     l       .H    0     D           '     P         !       P       I                T    4            V         $         "  .              "              n	         p                8       `  "  .            %    HO     X                8       C    T            :4                .               `    8-            [                e    #                !     l       I&    0Q     \       '    @            c  "  D     t           9            H                   "       H       t                `    |     8       L    0     l       lP               eT    @                <     <       *(    b            h8    |     |       ,R               I         @           E     |      P                S    D           E`    &                \            R?  !               .6    <             M    8            	         T       }    p     (       2    /            *    pW            ;  "  (     `       4[         X      ,D    X     P       b  "  hB     H       f#    _     D       1!     L           !    S     p      i.    <     0       ZV         @       q=                }>  !  P     X       2b    9     X       e  !  @     X         "              "a    h     @       #    HV     (       8Q    8     @        __cxa_finalize LIBC libc.so libstagefright_foundation.so __register_atfork __cxa_atexit _ZN7android10VectorImpl13finish_vectorEv _ZN7android10VectorImpl16editItemLocationEm _ZN7android10VectorImpl4pushEPKv _ZN7android10VectorImplC2Emj _ZN7android10VectorImplD2Ev _ZN7android7AStringC1EPKc _ZN7android7AStringC1ERKS0_ _ZN7android7AStringD1Ev _ZN7android9AAtomizer4HashEPKc _ZN7android9AAtomizer7AtomizeEPKc _ZN7android9AAtomizer7atomizeEPKc _ZN7android9AAtomizer9gAtomizerE _ZN7android9AAtomizerC1Ev _ZN7android9AAtomizerC2Ev _ZNK7android6VectorINS_4ListINS_7AStringEEEE10do_destroyEPvm _ZNK7android6VectorINS_4ListINS_7AStringEEEE12do_constructEPvm _ZNK7android6VectorINS_4ListINS_7AStringEEEE15do_move_forwardEPvPKvm _ZNK7android6VectorINS_4ListINS_7AStringEEEE16do_move_backwardEPvPKvm _ZNK7android6VectorINS_4ListINS_7AStringEEEE7do_copyEPvPKvm _ZNK7android6VectorINS_4ListINS_7AStringEEEE8do_splatEPvPKvm _ZNK7android7AString5c_strEv _ZNK7android7AStringeqERKS0_ _ZTVN7android4ListINS_7AStringEEE _ZTVN7android6VectorINS_4ListINS_7AStringEEEEE _ZdaPv _ZdlPv _Znam _Znwm __stack_chk_fail __stack_chk_guard abort pthread_mutex_destroy pthread_mutex_init pthread_mutex_lock pthread_mutex_unlock _ZN7android10ABitReader13fillReservoirEv _ZN7android10ABitReader15getBitsGracefulEmPj _ZN7android10ABitReader19getBitsWithFallbackEmj _ZN7android10ABitReader7getBitsEm _ZN7android10ABitReader7putBitsEjm _ZN7android10ABitReader8skipBitsEm _ZN7android10ABitReaderC1EPKhm _ZN7android10ABitReaderC2EPKhm _ZN7android10ABitReaderD0Ev _ZN7android10ABitReaderD1Ev _ZN7android10ABitReaderD2Ev _ZN7android12NALBitReader13fillReservoirEv _ZN7android12NALBitReaderC1EPKhm _ZN7android12NALBitReaderC2EPKhm _ZN7android7AString6appendEPKc _ZN7android7AString6appendERKS0_ _ZN7android7AString6appendEj _ZN7android7AString6appendEm _ZN7android7AStringC1Ev _ZNK7android10ABitReader11numBitsLeftEv _ZNK7android10ABitReader4dataEv _ZNK7android12NALBitReader18atLeastNumBitsLeftEm _ZNK7android7AString5emptyEv _ZTVN7android10ABitReaderE _ZTVN7android12NALBitReaderE __android_log_assert _ZN7android7ABuffer12CreateAsCopyEPKvm _ZN7android7ABuffer18getMediaBufferBaseEv _ZN7android7ABuffer18setMediaBufferBaseEPNS_15MediaBufferBaseE _ZN7android7ABuffer4metaEv _ZN7android7ABuffer8setRangeEmm _ZN7android7ABufferC1EPvm _ZN7android7ABufferC1Em _ZN7android7ABufferC2EPvm _ZN7android7ABufferC2Em _ZN7android7ABufferD0Ev _ZN7android7ABufferD1Ev _ZN7android7ABufferD2Ev _ZN7android7RefBase10onFirstRefEv _ZN7android7RefBase13onLastWeakRefEPKv _ZN7android7RefBase15onLastStrongRefEPKv _ZN7android7RefBase20onIncStrongAttemptedEjPKv _ZN7android7RefBaseC2Ev _ZN7android7RefBaseD2Ev _ZN7android8AMessageC1Ev _ZNK7android7RefBase9decStrongEPKv _ZNK7android7RefBase9incStrongEPKv _ZTVN7android7ABufferE free malloc memcpy _ZN7android12AStringUtils11MatchesGlobEPKcmS2_mb _ZN7android6ADebug12GetDebugNameEPKc _ZN7android6ADebug17getExperimentFlagEbPKcmmmm _ZN7android6ADebug20GetLevelFromPropertyEPKcS2_l _ZN7android6ADebug25GetDebugLevelFromPropertyEPKcS2_NS0_5LevelE _ZN7android6ADebug26GetLevelFromSettingsStringEPKcS2_l __android_log_print __errno __strchr_chk __strlen_chk isspace memmove property_get strcasestr strdup strtol _ZN7android16SortedVectorImpl3addEPKv _ZN7android8AHandler14deliverMessageERKNS_2spINS_8AMessageEEE _ZNK7android16SortedVectorImpl7indexOfEPKv _ZNK7android8AMessage4whatEv _ZN7android10VectorImpl3popEv _ZN7android25AHierarchicalStateMachine11changeStateERKNS_2spINS_6AStateEEE _ZN7android25AHierarchicalStateMachine13handleMessageERKNS_2spINS_8AMessageEEE _ZN7android25AHierarchicalStateMachineC1Ev _ZN7android25AHierarchicalStateMachineC2Ev _ZN7android25AHierarchicalStateMachineD0Ev _ZN7android25AHierarchicalStateMachineD1Ev _ZN7android25AHierarchicalStateMachineD2Ev _ZN7android6AState11parentStateEv _ZN7android6AState11stateExitedEv _ZN7android6AState12stateEnteredEv _ZN7android6AStateC2ERKNS_2spIS0_EE _ZN7android6AStateD0Ev _ZN7android6AStateD1Ev _ZN7android6AStateD2Ev _ZN7android7RefBase10renameRefsEmRKNS_16ReferenceRenamerE _ZN7android7RefBase11renameRefIdEPS0_PKvS3_ _ZNK7android6VectorINS_2spINS_6AStateEEEE10do_destroyEPvm _ZNK7android6VectorINS_2spINS_6AStateEEEE12do_constructEPvm _ZNK7android6VectorINS_2spINS_6AStateEEEE15do_move_forwardEPvPKvm _ZNK7android6VectorINS_2spINS_6AStateEEEE16do_move_backwardEPvPKvm _ZNK7android6VectorINS_2spINS_6AStateEEEE7do_copyEPvPKvm _ZNK7android6VectorINS_2spINS_6AStateEEEE8do_splatEPvPKvm _ZNK7android8AMessage11debugStringEi _ZTVN7android25AHierarchicalStateMachineE _ZTVN7android6AStateE _ZTVN7android6VectorINS_2spINS_6AStateEEEEE __cxa_pure_virtual _ZN7android11AReplyToken8setReplyERKNS_2spINS_8AMessageEEE _ZN7android13ALooperRoster15registerHandlerENS_2spINS_7ALooperEEERKNS1_INS_8AHandlerEEE _ZN7android13ALooperRoster17unregisterHandlerEi _ZN7android13ALooperRoster23unregisterStaleHandlersEv _ZN7android13ALooperRosterC1Ev _ZN7android13gLooperRosterE _ZN7android16SortedVectorImplD2Ev _ZN7android6Thread10readyToRunEv _ZN7android6Thread11requestExitEv _ZN7android6Thread18requestExitAndWaitEv _ZN7android6Thread3runEPKcim _ZN7android6ThreadC2Eb _ZN7android6ThreadD0Ev _ZN7android6ThreadD1Ev _ZN7android6ThreadD2Ev _ZN7android7ALooper13awaitResponseERKNS_2spINS_11AReplyTokenEEEPNS1_INS_8AMessageEEE _ZN7android7ALooper15registerHandlerERKNS_2spINS_8AHandlerEEE _ZN7android7ALooper16createReplyTokenEv _ZN7android7ALooper17unregisterHandlerEi _ZN7android7ALooper4loopEv _ZN7android7ALooper4postERKNS_2spINS_8AMessageEEEl _ZN7android7ALooper4stopEv _ZN7android7ALooper5startEbbi _ZN7android7ALooper7setNameEPKc _ZN7android7ALooper8GetNowUsEv _ZN7android7ALooper9postReplyERKNS_2spINS_11AReplyTokenEEERKNS1_INS_8AMessageEEE _ZN7android7ALooperC1Ev _ZN7android7ALooperC2Ev _ZN7android7ALooperD0Ev _ZN7android7ALooperD1Ev _ZN7android7ALooperD2Ev _ZN7android7AStringaSERKS0_ _ZN7android7RefBase12weakref_type7decWeakEPKv _ZN7android7RefBase12weakref_type7incWeakEPKv _ZN7android8AMessage7deliverEv _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE10do_compareEPKvS7_ _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE10do_destroyEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE12do_constructEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE15do_move_forwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE16do_move_backwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE7do_copyEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEE8do_splatEPvPKvm _ZNK7android7RefBase10createWeakEPKv _ZTCN7android7ALooper12LooperThreadE0_NS_6ThreadE _ZTTN7android7ALooper12LooperThreadE _ZTVN7android11AReplyTokenE _ZTVN7android12SortedVectorINS_16key_value_pair_tIiNS_13ALooperRoster11HandlerInfoEEEEE _ZTVN7android4ListINS_7ALooper5EventEEE _ZTVN7android7ALooper12LooperThreadE _ZTVN7android7ALooperE _ZTv0_n24_N7android6ThreadD0Ev _ZTv0_n24_N7android6ThreadD1Ev androidGetThreadId clock_gettime pthread_cond_broadcast pthread_cond_destroy pthread_cond_init pthread_cond_signal pthread_cond_timedwait pthread_cond_wait systemTime _ZN7android10VectorImpl13removeItemsAtEmm _ZN7android10VectorImpl3addEPKv _ZN7android10VectorImpl5clearEv _ZN7android13ALooperRoster4dumpEiRKNS_6VectorINS_8String16EEE _ZN7android13ALooperRosterC2Ev _ZN7android16SortedVectorImplC2Emj _ZN7android7RefBase12weakref_type16attemptIncStrongEPKv _ZN7android7String812appendFormatEPKcz _ZN7android7String86appendEPKc _ZN7android7String8C1Ev _ZN7android7String8D1Ev _ZN7android8String16C1EPKc _ZN7android8String16D1Ev _ZNK7android6VectorINS_2spINS_7ALooperEEEE10do_destroyEPvm _ZNK7android6VectorINS_2spINS_7ALooperEEEE12do_constructEPvm _ZNK7android6VectorINS_2spINS_7ALooperEEEE15do_move_forwardEPvPKvm _ZNK7android6VectorINS_2spINS_7ALooperEEEE16do_move_backwardEPvPKvm _ZNK7android6VectorINS_2spINS_7ALooperEEEE7do_copyEPvPKvm _ZNK7android6VectorINS_2spINS_7ALooperEEEE8do_splatEPvPKvm _ZNK7android7String86lengthEv _ZNK7android8String164sizeEv _ZTVN7android6VectorINS_2spINS_7ALooperEEEEE __sprintf_chk __write_chk LIBC_N strzcmp16 _ZN7android13AStringPrintfEPKcz _ZN7android6Parcel10writeFloatEf _ZN7android6Parcel10writeInt32Ei _ZN7android6Parcel10writeInt64El _ZN7android6Parcel11writeDoubleEd _ZN7android6Parcel12writeCStringEPKc _ZN7android7AString6appendEPKcm _ZN7android7AStringC1EPKcm _ZN7android7hexdumpEPKvmmPNS_7AStringE _ZN7android8AMessage10FromParcelERKNS_6ParcelEm _ZN7android8AMessage10setMessageEPKcRKNS_2spIS0_EE _ZN7android8AMessage10setPointerEPKcPv _ZN7android8AMessage12allocateItemEPKc _ZN7android8AMessage13freeItemValueEPNS0_4ItemE _ZN7android8AMessage17setObjectInternalEPKcRKNS_2spINS_7RefBaseEEENS0_4TypeE _ZN7android8AMessage20postAndAwaitResponseEPNS_2spIS0_EE _ZN7android8AMessage20senderAwaitsResponseEPNS_2spINS_11AReplyTokenEEE _ZN7android8AMessage4Item7setNameEPKcm _ZN7android8AMessage4postEl _ZN7android8AMessage5clearEv _ZN7android8AMessage7setRectEPKciiii _ZN7android8AMessage7setSizeEPKcm _ZN7android8AMessage7setWhatEj _ZN7android8AMessage8setFloatEPKcf _ZN7android8AMessage8setInt32EPKci _ZN7android8AMessage8setInt64EPKcl _ZN7android8AMessage9postReplyERKNS_2spINS_11AReplyTokenEEE _ZN7android8AMessage9setBufferEPKcRKNS_2spINS_7ABufferEEE _ZN7android8AMessage9setDoubleEPKcd _ZN7android8AMessage9setObjectEPKcRKNS_2spINS_7RefBaseEEE _ZN7android8AMessage9setStringEPKcRKNS_7AStringE _ZN7android8AMessage9setStringEPKcS2_l _ZN7android8AMessage9setTargetERKNS_2spIKNS_8AHandlerEEE _ZN7android8AMessageC1EjRKNS_2spIKNS_8AHandlerEEE _ZN7android8AMessageC2EjRKNS_2spIKNS_8AHandlerEEE _ZN7android8AMessageC2Ev _ZN7android8AMessageD0Ev _ZN7android8AMessageD1Ev _ZN7android8AMessageD2Ev _ZNK7android6Parcel10readDoubleEv _ZNK7android6Parcel11readCStringEv _ZNK7android6Parcel9readFloatEv _ZNK7android6Parcel9readInt32Ev _ZNK7android6Parcel9readInt64Ev _ZNK7android7AString4sizeEv _ZNK7android8AMessage10findBufferEPKcPNS_2spINS_7ABufferEEE _ZNK7android8AMessage10findDoubleEPKcPd _ZNK7android8AMessage10findObjectEPKcPNS_2spINS_7RefBaseEEE _ZNK7android8AMessage10findStringEPKcPNS_7AStringE _ZNK7android8AMessage11changesFromERKNS_2spIKS0_EEb _ZNK7android8AMessage11findMessageEPKcPNS_2spIS0_EE _ZNK7android8AMessage11findPointerEPKcPPv _ZNK7android8AMessage12countEntriesEv _ZNK7android8AMessage13writeToParcelEPNS_6ParcelE _ZNK7android8AMessage14getEntryNameAtEmPNS0_4TypeE _ZNK7android8AMessage3dupEv _ZNK7android8AMessage8containsEPKc _ZNK7android8AMessage8findItemEPKcNS0_4TypeE _ZNK7android8AMessage8findRectEPKcPiS3_S3_S3_ _ZNK7android8AMessage8findSizeEPKcPm _ZNK7android8AMessage9findFloatEPKcPf _ZNK7android8AMessage9findInt32EPKcPi _ZNK7android8AMessage9findInt64EPKcPl _ZTVN7android8AMessageE isprint memcmp _ZN7android13ParsedMessage5ParseEPKcmbPm _ZN7android15ANetworkSession10threadLoopEv _ZN7android15ANetworkSession11sendRequestEiPKvlbl _ZN7android15ANetworkSession13NetworkThread10threadLoopEv _ZN7android15ANetworkSession13NetworkThreadC1EPS0_ _ZN7android15ANetworkSession13NetworkThreadC2EPS0_ _ZN7android15ANetworkSession13NetworkThreadD0Ev _ZN7android15ANetworkSession13NetworkThreadD1Ev _ZN7android15ANetworkSession13NetworkThreadD2Ev _ZN7android15ANetworkSession13getRTPRecvNumEi _ZN7android15ANetworkSession14destroySessionEi _ZN7android15ANetworkSession15mtkRTPRecvPauseEi _ZN7android15ANetworkSession15resetRTPRecvNumEi _ZN7android15ANetworkSession16createRTSPClientEPKcjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession16createRTSPServerERK7in_addrjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession16createUDPSessionEjPKcjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession16createUDPSessionEjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession16createUIBCClientEPKcjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession16createUIBCServerERK7in_addrjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession16mtkRTPRecvResumeEi _ZN7android15ANetworkSession17connectUDPSessionEiPKcj _ZN7android15ANetworkSession17findListeningSockEi _ZN7android15ANetworkSession17sendDirectRequestEiPKvl _ZN7android15ANetworkSession18MakeSocketBlockingEi _ZN7android15ANetworkSession20createClientOrServerENS0_4ModeEPK7in_addrjPKcjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession21MakeSocketNonBlockingEi _ZN7android15ANetworkSession21switchToWebSocketModeEi _ZN7android15ANetworkSession24createTCPDatagramSessionERK7in_addrjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession24createTCPDatagramSessionEjPKcjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession24createTCPTextDataSessionERK7in_addrjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession25setNetworkSessionTestModeEv _ZN7android15ANetworkSession32createTCPBinaryDataSessionActiveEjPKcjRKNS_2spINS_8AMessageEEEPi _ZN7android15ANetworkSession4stopEv _ZN7android15ANetworkSession5startEv _ZN7android15ANetworkSession7Session11closeSocketEv _ZN7android15ANetworkSession7Session11notifyErrorEbiPKc _ZN7android15ANetworkSession7Session11sendRequestEPKvlbl _ZN7android15ANetworkSession7Session11wantsToReadEv _ZN7android15ANetworkSession7Session12wantsToWriteEv _ZN7android15ANetworkSession7Session13getRTPRecvNumEv _ZN7android15ANetworkSession7Session15mtkRTPRecvPauseEv _ZN7android15ANetworkSession7Session15resetRTPRecvNumEv _ZN7android15ANetworkSession7Session15setSharedSocketEb _ZN7android15ANetworkSession7Session16mtkRTPRecvResumeEv _ZN7android15ANetworkSession7Session17dumpFragmentStatsERKNS1_8FragmentE _ZN7android15ANetworkSession7Session18setClientConnectedEb _ZN7android15ANetworkSession7Session18writeDirectRequestEPKvl _ZN7android15ANetworkSession7Session20setTCPConnectionTypeEi _ZN7android15ANetworkSession7Session21switchToWebSocketModeEv _ZN7android15ANetworkSession7Session6notifyENS0_18NotificationReasonE _ZN7android15ANetworkSession7Session7setModeENS1_4ModeE _ZN7android15ANetworkSession7Session8readMoreEv _ZN7android15ANetworkSession7Session9writeMoreEv _ZN7android15ANetworkSession7SessionC1EiNS1_5StateEiRKNS_2spINS_8AMessageEEE _ZN7android15ANetworkSession7SessionC2EiNS1_5StateEiRKNS_2spINS_8AMessageEEE _ZN7android15ANetworkSession7SessionD0Ev _ZN7android15ANetworkSession7SessionD1Ev _ZN7android15ANetworkSession7SessionD2Ev _ZN7android15ANetworkSession9interruptEv _ZN7android15ANetworkSessionC1Ev _ZN7android15ANetworkSessionC2Ev _ZN7android15ANetworkSessionD0Ev _ZN7android15ANetworkSessionD1Ev _ZN7android15ANetworkSessionD2Ev _ZN7android7AString5clearEv _ZN7android7AString5eraseEmm _ZN7android7AString6appendEi _ZN7android7AString6appendEl _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE10do_compareEPKvS9_ _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE10do_destroyEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE12do_constructEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE15do_move_forwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE16do_move_backwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE7do_copyEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEE8do_splatEPvPKvm _ZNK7android13ParsedMessage10getContentEv _ZNK7android15ANetworkSession7Session11isTCPServerEv _ZNK7android15ANetworkSession7Session12isRTSPServerEv _ZNK7android15ANetworkSession7Session17isClientConnectedEv _ZNK7android15ANetworkSession7Session19isTCPDatagramServerEv _ZNK7android15ANetworkSession7Session20getTCPConnectionTypeEv _ZNK7android15ANetworkSession7Session22getNotificationMessageEv _ZNK7android15ANetworkSession7Session6socketEv _ZNK7android15ANetworkSession7Session9sessionIDEv _ZTCN7android15ANetworkSession13NetworkThreadE0_NS_6ThreadE _ZTTN7android15ANetworkSession13NetworkThreadE _ZTVN7android12SortedVectorINS_16key_value_pair_tIiNS_2spINS_15ANetworkSession7SessionEEEEEEE _ZTVN7android15ANetworkSession13NetworkThreadE _ZTVN7android15ANetworkSession7SessionE _ZTVN7android15ANetworkSessionE _ZTVN7android4ListINS_15ANetworkSession7Session8FragmentEEE _ZTv0_n24_N7android15ANetworkSession13NetworkThreadD0Ev _ZTv0_n24_N7android15ANetworkSession13NetworkThreadD1Ev __FD_ISSET_chk __FD_SET_chk __get_h_errno __read_chk __recvfrom_chk accept atoi bind close connect fcntl gethostbyname getpeername getsockname getsockopt inet_ntoa ioctl listen pipe select send setsockopt socket strcmp strerror usleep _ZN7android10Compare_LEImmEENS_7AStringERKT_RKT0_ _ZN7android6Parcel5writeEPKvm _ZN7android7AString10FromParcelERKNS_6ParcelE _ZN7android7AString11makeMutableEv _ZN7android7AString12kEmptyStringE _ZN7android7AString4trimEv _ZN7android7AString5setToEPKc _ZN7android7AString5setToEPKcm _ZN7android7AString5setToERKS0_mm _ZN7android7AString6appendEPv _ZN7android7AString6appendERKS0_mm _ZN7android7AString6appendEd _ZN7android7AString6appendEf _ZN7android7AString6appendEx _ZN7android7AString6appendEy _ZN7android7AString6insertEPKcmm _ZN7android7AString6insertERKS0_m _ZN7android7AString7tolowerEv _ZN7android7AStringC1ERKNS_7String8E _ZN7android7AStringC1ERKS0_mm _ZN7android7AStringC2EPKc _ZN7android7AStringC2EPKcm _ZN7android7AStringC2ERKNS_7String8E _ZN7android7AStringC2ERKS0_ _ZN7android7AStringC2ERKS0_mm _ZN7android7AStringC2Ev _ZN7android7AStringD2Ev _ZNK7android6Parcel11readInplaceEm _ZNK7android7AString10startsWithEPKc _ZNK7android7AString13writeToParcelEPNS_6ParcelE _ZNK7android7AString16equalsIgnoreCaseERKS0_ _ZNK7android7AString17compareIgnoreCaseERKS0_ _ZNK7android7AString18endsWithIgnoreCaseEPKc _ZNK7android7AString20startsWithIgnoreCaseEPKc _ZNK7android7AString4findEPKcm _ZNK7android7AString4hashEv _ZNK7android7AString7compareERKS0_ _ZNK7android7AString8endsWithEPKc _ZNK7android7AStringgtERKS0_ _ZNK7android7AStringltERKS0_ __snprintf_chk realloc strcasecmp strncasecmp strncmp strstr tolower vasprintf _ZN7android12AStringUtils7CompareEPKcS2_mb _ZN7android10IInterface8asBinderERKNS_2spIS0_EE _ZN7android13IPowerManager11asInterfaceERKNS_2spINS_7IBinderEEE _ZN7android14IPCThreadState20clearCallingIdentityEv _ZN7android14IPCThreadState22restoreCallingIdentityEl _ZN7android14IPCThreadState4selfEv _ZN7android21defaultServiceManagerEv _ZN7android7BBinderC1Ev _ZN7android9AWakeLock16PMDeathRecipient10binderDiedERKNS_2wpINS_7IBinderEEE _ZN7android9AWakeLock17clearPowerManagerEv _ZN7android9AWakeLock7acquireEv _ZN7android9AWakeLock7releaseEb _ZN7android9AWakeLockC1Ev _ZN7android9AWakeLockC2Ev _ZN7android9AWakeLockD0Ev _ZN7android9AWakeLockD1Ev _ZN7android9AWakeLockD2Ev _ZTCN7android9AWakeLock16PMDeathRecipientE0_NS_7IBinder14DeathRecipientE _ZTTN7android9AWakeLock16PMDeathRecipientE _ZTVN7android9AWakeLock16PMDeathRecipientE _ZTVN7android9AWakeLockE _ZN7android10ColorUtils15copyColorConfigERKNS_2spINS_8AMessageEEERS3_ _ZN7android10ColorUtils20convertDataSpaceToV0ER17android_dataspace _ZN7android10ColorUtils24getColorConfigFromFormatERKNS_2spINS_8AMessageEEEPiS6_S6_ _ZN7android10ColorUtils25getColorAspectsFromFormatERKNS_2spINS_8AMessageEEERNS_12ColorAspectsE _ZN7android10ColorUtils25setColorAspectsIntoFormatERKNS_12ColorAspectsERNS_2spINS_8AMessageEEEb _ZN7android10ColorUtils26getHDRStaticInfoFromFormatERKNS_2spINS_8AMessageEEEPNS_13HDRStaticInfoE _ZN7android10ColorUtils26setHDRStaticInfoIntoFormatERKNS_13HDRStaticInfoERNS_2spINS_8AMessageEEE _ZN7android10ColorUtils27getDataSpaceForColorAspectsERNS_12ColorAspectsEb _ZN7android10ColorUtils30wrapColorAspectsIntoColorRangeENS_12ColorAspects5RangeE _ZN7android10ColorUtils32unwrapColorAspectsFromColorRangeEiPNS_12ColorAspects5RangeE _ZN7android10ColorUtils33wrapColorAspectsIntoColorStandardENS_12ColorAspects9PrimariesENS1_12MatrixCoeffsE _ZN7android10ColorUtils33wrapColorAspectsIntoColorTransferENS_12ColorAspects8TransferE _ZN7android10ColorUtils35setDefaultCodecColorAspectsIfNeededERNS_12ColorAspectsEii _ZN7android10ColorUtils35unwrapColorAspectsFromColorStandardEiPNS_12ColorAspects9PrimariesEPNS1_12MatrixCoeffsE _ZN7android10ColorUtils35unwrapColorAspectsFromColorTransferEiPNS_12ColorAspects8TransferE _ZN7android10ColorUtils36convertCodecColorAspectsToIsoAspectsERKNS_12ColorAspectsEPiS4_S4_Pb _ZN7android10ColorUtils36convertIsoColorAspectsToCodecAspectsEiiibRNS_12ColorAspectsE _ZN7android10ColorUtils37checkIfAspectsChangedAndUnspecifyThemERNS_12ColorAspectsERKS1_b _ZN7android10ColorUtils41convertCodecColorAspectsToPlatformAspectsERKNS_12ColorAspectsEPiS4_S4_ _ZN7android10ColorUtils41convertPlatformColorAspectsToCodecAspectsEiiiRNS_12ColorAspectsE _ZN7android18sStandardFallbacksE _ZN7android27sStandardPrimariesFallbacksE _ZN7android11MediaBuffer10nextBufferEv _ZN7android11MediaBuffer11setObserverEPNS_19MediaBufferObserverE _ZN7android11MediaBuffer13setNextBufferEPS0_ _ZN7android11MediaBuffer5claimEv _ZN7android11MediaBuffer5cloneEv _ZN7android11MediaBuffer5resetEv _ZN7android11MediaBuffer7add_refEv _ZN7android11MediaBuffer7releaseEv _ZN7android11MediaBuffer9meta_dataEv _ZN7android11MediaBuffer9set_rangeEmm _ZN7android11MediaBufferC1EPvm _ZN7android11MediaBufferC1ERKNS_2spINS_13GraphicBufferEEE _ZN7android11MediaBufferC1ERKNS_2spINS_7ABufferEEE _ZN7android11MediaBufferC1Em _ZN7android11MediaBufferC2EPvm _ZN7android11MediaBufferC2ERKNS_2spINS_13GraphicBufferEEE _ZN7android11MediaBufferC2ERKNS_2spINS_7ABufferEEE _ZN7android11MediaBufferC2Em _ZN7android11MediaBufferD0Ev _ZN7android11MediaBufferD1Ev _ZN7android11MediaBufferD2Ev _ZN7android12MemoryDealerC1EmPKcj _ZN7android8MetaData5clearEv _ZN7android8MetaDataC1ERKS0_ _ZN7android8MetaDataC1Ev _ZNK7android11MediaBuffer12range_lengthEv _ZNK7android11MediaBuffer12range_offsetEv _ZNK7android11MediaBuffer13graphicBufferEv _ZNK7android11MediaBuffer4dataEv _ZNK7android11MediaBuffer4sizeEv _ZNK7android11MediaBuffer8refcountEv _ZNK7android7IMemory7pointerEv _ZTVN7android11MediaBufferE _ZN7android16MediaBufferGroup10add_bufferEPNS_11MediaBufferE _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferEbm _ZN7android16MediaBufferGroup20signalBufferReturnedEPNS_11MediaBufferE _ZN7android16MediaBufferGroupC1Ev _ZN7android16MediaBufferGroupC2Ev _ZN7android16MediaBufferGroupD0Ev _ZN7android16MediaBufferGroupD1Ev _ZN7android16MediaBufferGroupD2Ev _ZTVN7android16MediaBufferGroupE _ZN7android10VectorImplC2ERKS0_ _ZN7android6Parcel11writeUint32Ej _ZN7android6Parcel14writeByteArrayEmPKh _ZN7android7String85setToERKS0_ _ZN7android7String86formatEPKcz _ZN7android8MetaData10setCStringEjPKc _ZN7android8MetaData10setPointerEjPv _ZN7android8MetaData10typed_data11freeStorageEv _ZN7android8MetaData10typed_data15allocateStorageEm _ZN7android8MetaData10typed_data5clearEv _ZN7android8MetaData10typed_data7setDataEjPKvm _ZN7android8MetaData10typed_dataC1ERKS1_ _ZN7android8MetaData10typed_dataC1Ev _ZN7android8MetaData10typed_dataC2ERKS1_ _ZN7android8MetaData10typed_dataC2Ev _ZN7android8MetaData10typed_dataD1Ev _ZN7android8MetaData10typed_dataD2Ev _ZN7android8MetaData10typed_dataaSERKS1_ _ZN7android8MetaData11findCStringEjPPKc _ZN7android8MetaData11findPointerEjPPv _ZN7android8MetaData13writeToParcelERNS_6ParcelE _ZN7android8MetaData16createFromParcelERKNS_6ParcelE _ZN7android8MetaData16updateFromParcelERKNS_6ParcelE _ZN7android8MetaData6removeEj _ZN7android8MetaData7setDataEjjPKvm _ZN7android8MetaData7setRectEjiiii _ZN7android8MetaData8findRectEjPiS1_S1_S1_ _ZN7android8MetaData8setFloatEjf _ZN7android8MetaData8setInt32Eji _ZN7android8MetaData8setInt64Ejl _ZN7android8MetaData9findFloatEjPf _ZN7android8MetaData9findInt32EjPi _ZN7android8MetaData9findInt64EjPl _ZN7android8MetaDataC2ERKS0_ _ZN7android8MetaDataC2Ev _ZN7android8MetaDataD0Ev _ZN7android8MetaDataD1Ev _ZN7android8MetaDataD2Ev _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE10do_compareEPKvS7_ _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE10do_destroyEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE12do_constructEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE15do_move_forwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE16do_move_backwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE7do_copyEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEE8do_splatEPvPKvm _ZNK7android6Parcel10readUint32EPj _ZNK7android6Parcel9readInt32EPi _ZNK7android8MetaData10typed_data7getDataEPjPPKvPm _ZNK7android8MetaData10typed_data8asStringEb _ZNK7android8MetaData7hasDataEj _ZNK7android8MetaData8findDataEjPjPPKvPm _ZNK7android8MetaData8toStringEv _ZNK7android8MetaData9dumpToLogEv _ZTVN7android12SortedVectorINS_16key_value_pair_tIjNS_8MetaData10typed_dataEEEEE _ZTVN7android8MetaDataE _ZN7android13ParsedMessage12GetAttributeEPKcS2_PNS_7AStringE _ZN7android13ParsedMessage17GetInt32AttributeEPKcS2_Pi _ZN7android13ParsedMessage5parseEPKcmb _ZN7android13ParsedMessageC1Ev _ZN7android13ParsedMessageC2Ev _ZN7android13ParsedMessageD0Ev _ZN7android13ParsedMessageD1Ev _ZN7android13ParsedMessageD2Ev _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE10do_compareEPKvS6_ _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE10do_destroyEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE12do_constructEPvm _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE15do_move_forwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE16do_move_backwardEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE7do_copyEPvPKvm _ZNK7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEE8do_splatEPvPKvm _ZNK7android13ParsedMessage10findStringEPKcPNS_7AStringE _ZNK7android13ParsedMessage11debugStringEv _ZNK7android13ParsedMessage13getStatusCodeEPi _ZNK7android13ParsedMessage15getRequestFieldEmPNS_7AStringE _ZNK7android13ParsedMessage9findInt32EPKcPi _ZTVN7android12SortedVectorINS_16key_value_pair_tINS_7AStringES2_EEEE _ZTVN7android13ParsedMessageE _ZN7android12decodeBase64ERKNS_7AStringE _ZN7android12encodeBase64EPKvmPNS_7AStringE _edata __bss_start _end libbinder.so libutils.so libcutils.so liblog.so libpowermanager.so libc++.so libdl.so libm.so            @      %1!C   PA      D( DX\h@    ! B P  DF      0 H!   @P    E@Xb\2   $ X 2 @#K'RHD 5 B5x   @     ( A( @  X      @   @ @ "(8, 	LP !  	Q"0  @2 EH B`Hh
!Z1  ;P@,!    `@$1P") HX0D(@A
  B@1  (H@ CX$BZH      Bb   (!2  ,  "  D	 ,  		! !<8  (	&`
b`1"  U@Z  @                                                                                                                                                                           	  
                                                 "  $  %  '  (  )  *  ,  /  3  4  6  9  :  <  >  A  C  D  F  G  L      N      P  T  U      V  W  X  Y  [  \      ]  a      c  d  g  i  k  p          s  t      w  z  ~                                                                                                                                                                                 
                                   "  $  %  &  )  ,  0  1  5  6  8      ;  =          >      @      A  B  F  H  J  M  N  O  R  S  W  Y  Z  [  a  c  d  e  h  l  m  n  #OCHV+,5FBVO$#k
8{g#Na
*W=k/s"./c-C?3p$HE=4#D. wHkZP*j"0<[@?6,v96Q;Q"$}'dI7<P`2rsmH_fQ)(~C4lR-+L5Da[TP
14RjE|fA0'Hd"b;"<DR6'|#l'<!PCHhz7r~F4y {].	c=K
D*o4".ptIv}otiMGfcjLxmmG?YP{jsG'?<GJ9#<UP-D; dJ0 ;`b{skY(5Gi[N."weoG8R^ZI]J%J'{)jM"B3fF L6~CE"[0eM?+'=J7bVA<tPMFW,:{.S;sK?9k3I0g8#tLbv;N;'zaePa,taJCA#L9r)U''[
=*,_X!\MPd 2uGCu6/ij4OG:qbE-2_Dd}`B(1I`,QGK~1vZJW/0+Kpg16u*dyQ?N.AQjCmkjs#w{20DHOtKoWC\1~+[aXm:+ZEfn> d?FDk>8P!TkRu?MI>_ .og#qdB[3DC\\`;{><uG^?nG1/2!3|@vHRx-k	u7J:Ww2pDHx.1?B=t"~^vC$X*__(V\/HqX*W?C"v	HM>!%d<_+RF8!=?D[3HlcC~=.>9mU(/HWQ}`+KQQyJz&N5R(Z05f0,,D$1:	WoT`P!9#/2k2iI@kH2DHGk7<iksEN
\:>p-L`I-WTA|5BD@?g1:l{\X`udbd L.@l$l%bJ)bPhpswss	zRRh!"c2\-""SNvuI@9RFDky[tLDTOFwZBR|3	ap;{#Qg	K`:"/l?>8JK>:\"C-Ja9NG4w+S/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Q                          c          >i              APS2 4 }	
 	 {4 \p  4 08( <  8b	 C\p4(	 ~   ( ~ (0o

 ~4"4 {<<} he    k    k    k    luxxyyzy 	j 	 ' 	uxthp|uun}vhsy!! !x""l"x#$q%p&&'	'v((	(t  (n((	)n  )e)*a*	+ * +d+,,l,--e-./y00g1{11}234o45j55w5k66~788m99u9;g;;<q<<j<==r>>	>r  ?n? 	  t(     x    w o |     i  	  d   r  } 	   a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x                                                                                                                                                                        6                 N                                                    "                 ]                                                                                                                                          (       
           0       	           8       ,          @                 H       H          P       l          X       W          `                  h       6          p                  x                                           8                                                    t                                                                                                                                                                                                                                      7                                                                (                  0                  8       !           @       "           H       $           P       )           X       #           `                 h       &           p                 x       (                  '                  %                                     ~                 +                  *                                   ,                  -                  .                  ^                                   W                 l                 /                                                                       L                                   d          (                 0       9          8       5          @       0           H       F           P       B           X                 `                 h       A           p       C           x       @                  >                  3                                   ;                                  S                                   5                  ?                  D                  E                                   ;                                   9                  :                   8                  1                  u                 s                             (                  0                 8                 @                  H                 P                 X       4           `       2           h       7           p       6           x       =                  <                  J                  K                  G                  H                  P                  S                  V                  Q                  N                  M                  L                  T                  I                  R                  U                   O                                                                                 (                  0                  8                 @                  H       b           P       e          X                 `       D          h                 p       N          x       F                                                   %                 a                                    d                                  _                  `                  ^                  \                  ]                  X                  [                  Y                  W                   Z                  m                 C                                              (       d           0       v           8       c           @       f           H       {           P       h           X       m           `       k           h                 p       T          x                        p                                    o                  e                 n                 .                 <                 i                                                     g                                   
                 B                 B                                   z                  ,                                                     9          (                 0       "          8       w           @       q           H                  P       s           X                  `                  h       |           p                  x                         u                                   y                  x                  n                  l                  j                  e                  r                  t                  Q                                                                                                                            F                                                              (       1          0       _          8       )          @                 H                  P       R          X                  `                  h                  p                  x                                                                                                ~                  }                                                                                                                                                                                                      `                                  L                                             (                 0                 8                  @                  H       M          P                 X       x          `       Q          h       7          p       >          x       :                                   o                                                                                                       4                 g                                   `                                                                                                                                                M                 @                             (                 0                 8                  @                  H                 P                  X                 `                  h                 p                 x       v                 _                 8                                                     U                                                                     $                 c                 b                                  h                                  E                           { B     B  B  B"  BB  Bb  B  B  B  B  B  B"  BB  Bb  B  B  B  B  C  C"  
CB  Cb  C  C  C  C  "C  &C"  *CB  .Cb  2C  6C  :C  >C  BC  FC"  JCB  NCb  RC  VC  ZC  ^C  bC  fC"  jCB  nCb  rC  vC  zC  ~C  C  C"  CB  Cb  C  C  C  C  C  C"  CB  Cb  C  C  C  C  C  C"  CB  Cb  C  C  C  C  C  C"  CB  Cb  C  C  C  C  D   D"   
DB   Db   D   D   D   D   "D!  &D"!  *DB!  .Db!  2D!  6D!  :D!  >D!  BD"  FD""  JDB"  NDb"  RD"  VD"  ZD"  ^D"  bD#  fD"#  jDB#  nDb#  rD#  vD#  zD#  ~D#  D$  D"$  DB$  Db$  D$  D$  D$  D$  D%  D"%  DB%  Db%  D%  D%  D%  D%  D&  D"&  DB&  Db&  D&  D&  D&  D&  D'  D"'  DB'  Db'  D'  D'  D'  D'  E(  E"(  
EB(  Eb(  E(  E(  E(  E(  "E)  &E")  *EB)  .Eb)  2E)  6E)  :E)  >E)  BE*  FE"*  JEB*  NEb*  RE*  VE*  ZE*  ^E*  bE+  fE"+  jEB+  nEb+  rE+  vE+  zE+  ~E+  E,  E",  EB,  Eb,  E,  E,  E,  E,  E-  E"-  EB-  Eb-  E-  E-  E-  E-  E.  E".  EB.  Eb.  E.  E.  E.  E.  E/  E"/  EB/  Eb/  E/  E/  E/  E/  F0  F"0  
FB0  Fb0  F0  F0  F0  F0  "F1  &F"1  *FB1  .Fb1  2F1  6F1  :F1  >F1  BF2  FF"2   JFB2   NFb2   RF2   VF2   ZF2   ^F2   bF3   fF"3   jFB3   nFb3   rF3   vF3   zF3   ~F3   F4   F"4   FB4   Fb4   F4   F4   F4   F4   F5   F"5   FB5   Fb5   F5   F5   F5   F5   F6   F"6   FB6   Fb6   F6   F6   F6   F6   F7   F"7   FB7   Fb7   F7   F7   F7   F7   G8   G"8   
GB8   Gb8   G8   G8   G8   G8   "G9   &G"9   *GB9   .Gb9   2G9   6G9   :G9   >G9   BG:   FG":   JGB:   NGb:   RG:   VG:   ZG:   ^G:   bG;   fG";   jGB;   nGb;   rG;   vG;   zG;   ~G;   G<   G"<   GB<   Gb<   G<   G<   G<   G<   G=   G"=   GB=   Gb=   G=   G=   G=   G=   G>   G">   GB>   Gb>   G>   G>   G>   G>   G?   G"?   GB?   Gb?   G?   G?   G?   G? O{C   s"B  B,B{A     4OO{C   sVBs  B,B{A     =Oog_WO{C2 ! `      ( \   ( s.B`   2  A
@		@@ 
  
!@	 	@ @
  
AB	 	-@ 9@
@
E@	, 	@8 C
D 
%@	 	Q@]@
$ 
i@	P 	AE\ 1@
h 
u@F	@!`	0    ) 
t `   ) T2~  !    \     ( 
	 `   ( = 	Rg   I  !  2  5	 ) T  	    (    `   ( 2G  	   	  		   	)i	$ I	( ' 	0  	8 i)	< )R		 	, IR!  	   (  	4 `   (  
R !@` 
 W     ( 	  
$ `   ( R  !
@		@@  
  
!@	 	@ @
  
AB	 	-@ 9@
@
E@	, 	@8 C
D 
%@	 	Q@]@
$ 
i@	P 	AE\ 1@
h 
F	@	u@0 !B

@=@	t 	   ) 
 < `   )  R  !B 	 
 *        ( 	 
 `   ( 2((@  (  (@ h  HH   H!@	 (   $ ) {EODWC_BgAh  og{      ^{_{  @ `  T@  ?{_{     1    @L {_{        @@@B {_O{C   B A 8:{AO:     B9_WO{   &B @ 0 kf	 Th@@9 4* *l{K! Tk	+ TI@8	5*  *	A`  @@  @@ T     x6  # 
@ R#   @#  @  @ @ @(  {COBWA__
_WO{    &B @  *2     B))BA 7A   R   # @ @` T@  @T @ @@    TT@  {COBWA__WO{    h@))B)A i @ T@  h@T   h@ `@  {BOAW{BOAW_ 	@9 4*  *K{j
J T@	+  T	@8	5_*_{ O{C   B A h H{AOHO{C   B A h ;={AOWO{    )BA s  T R j B  {BOAW_QO{C 3 s C T A@ ?3{AO_?g_WO{   )BA s  T R =  @W@   R @  @TB B {DOCWB_Ag_g_WO{   )BA s  T R   @W@   R @  @TB {DOCWB_Ag_g_WO{   ))Bh|V 8 9A s c T RB   _V@   R @  @T@@ ?s{DOCWB_Ag_g_WO{s   )BA s  T R   @W@   R @  @TA@ ?B S{DOCWB_Ag_~WO{    h@))B)A i @ T@  Yh@T   h@ `@@  {{BOAWr  1B   A    9_h@h 	@* + i_8  ]3	  TJ  B T_   Tk 	*h2H}! TH}2 H T}@(!  2*_* 2	 9*_{ $WO{    T @*2  @	@ ? 6@	 T@!  Ts  TJ}@"%U	*  *{BOA*W_        ;Bp;c|;+_WO{   i  T*$   @*2  @	@ ?  6@	# T@!  T # TJ}@"%V	*  * 2v   *{COBWA___WO{ *  i  T*"   @*2  @	@ ? 6@	 T@! c T  TJ}@"%V	*  *  **{COBWA__WO{    T@22  @	@ ? 6@		 T@+}@	J! C T	  Ts  T T @2  @	@ ? 6@		 T@+}@	J!  Ts	 c T 2  *  *{BOAW_@WO{   &B *@h@9H 5 p c T o  !> o 2p r  ( 6 
h@  i
 	b T? C T!   Th i@) i I T2)Tj@~@)}@"J%I	*i Th ]   {BOAW_  !=# #  E#    Bp;%@2	}	  T	@} 	B  T_{ @   T	@ H_{   9    5B, A   _{ @2	}	! T	@
}J	 T_  T*{_) 	 T?  T ,@
@N@9 q qn  4*  k 1 T
l  7)! f T # T? k  TJ ? {_@ ,@* @ q@9 qo  4*  k 1 T
,   7@9J -]3  T*   # T _ H  T2H}! TH}2 H T}@(!  2*_* 2	 9*_{ `_O{C    9B 2 A B ~ 9  " {AO_WO{    9B~NNA 9B  {BOAW__WO{ C   &B  	R@    9B 2 A B ~ 9  "   ~@@H 	@ 	z@ h    `   v@   {COBWA__O{C    hA9)9B)A i   4`@`  c `@   @@ ?  A@  T{AOXO{C  `@   @@ ?t {AO_O{C    hA9)9B)A i   4`@`  9 `@   @@ ?  A@  *0{AO_WO{   &B  @ @b T   !> @     6 vb T @i T   !> @    ( 6 _N@H  {COBWA__  !>  e  !( # E#  # T   Bp;YWO{  A  HR; @`   u {BOAWO{C  `@   @@ ?`@  {AO_og_WO{CC   %B @ 	  R    @@85 AR   BR @ @9*  4@85 @( 5 T  T`  T@9( 5  @85  h       [ # T k{8@5     2@  6  @)%B)@(h C{EODWC_BgAo_WO{   &B @3 d  43 c ]   {BOAW_WO{   &B *@3 D  43 C  ]ij?  R@   {BOAW_{_WO{ 1    {w  ( t @ T_8 q  T@9( 4 q  T  u@9 q5 h   T " T #T{COBWA__=WO{   &B *  @ 3   43 2   T*  *        I))    $!B2
]   {BOAW_WO{ C   &B @ h@@ ?h.@ 1b Ti@9h. 	 4@s  *   (@ 1 T    2 # )@   {BOAW_O{C  7  =BA h@`   {AO4{AO_O{C   =B A h  A@  -{AO1O{C   =B A h  A@  #{AO @  `  
_  ABA | _  )AB )A 	  @`  _O{C   AB A h  @@  {AOWO{   &B @@ `  @ @   @       @  @!@ ? 7@@	! T@@    @`  @@  @@ @*# # 3     !B R # @`  @`   ]  {BOAW_         l!Bp;cU_WO{   &B @h@@?  T2*  FBB # `@    k  @# 	@ @    ]@@ a# 2*B  @   M@`   Q   @  #  @  @    9@  =# +@h @) '@@Hi	_)_	 T@  `@`  #t +@   @ @@ ?s  T+@T@s s # T# t  @ @@ ?B #  W# Y@`   # NP\  {COBWA__vyO{C   EB A h 8{AO8O{C   EB A h +-{AOq  B   T? _{ PO{C 3 s C T@`  " 3{AO_>WO{ s s  T@ `  " " {BOAW_'WO{ S s  T@ `  " {BOAW_WO{    &B2@h~  Tb}  A  W  @   {BOAW_@)}	@ @A	O{C   IB A {AO{  2thj|H	G H{_O{C  *  MB`B A h ` `  QB2A hB `F   `rJ b9`   TB{AOWO{   MB A 	`f(I  	@)^ 	  hF@)QB)A iB @ T@  @@  hF@T  
 hF@ `F@@  `Y` `B ={BOAW_WO{ C   &B tB @  1 kF	 TI @ ^@  	@ )^ 	 wbB9hJ@  	@)^ 	 b93@  5`        @@ ?` htr k T`e 5@I@c `  T@c@  	@ )^ 	*@  {COBWA__	WO{    h@)QB)A i @ T@  @@  mh@T  
 h@ `@  {BOAW {BOAW_O{C  '{AOO{C    &B @   @  C {AO_O{C C   &B@  `   "   TB @ *   @  *C {AO_   TBg_WO{ B ***j kwT 6( 5J@h  bB9 4R  ( 5Ih  J  bB9 4F   2b9p  7*>   R\ b  YB !   ]B	a  N J@  	@)^ 	J @	@    6  !  < * ? *U 4@( 	@)^ 	   *-*{DOCWB_Ag_)(_WO{    &B B @   k TJ@h  bB9 4F@(@	  T@ 24thj|H	G(H Tf T	}R}	}I TUsRc *@r\%}h@~H
ZHH( T@J )
& T  ?
  T)f T   T  c B k  T @ k& T 2$  F@@	@ @# !  5@`  9 F@@&A	 (	    @@  .@  2  *# ! @`  @ * {COBWA__g_WO{   &B B @ d k	 T 2thj|H	G(H k  T TF@	@	  T
@_MT  	 @# !  @`   F@@?  T @2H@  6 v   (@
 (@ 4 @`  @@( {DOCWB_Ag_9<WO{ C   &B 2@        @aBA (   `     9t @`   @   {BOAW_
og_WO{C r k T@ B   @h@9h 4:B  Y@`  ]  @  X? h@9( 5 k TJ@  > kT{2  **{EODWC_BgAo_         !Bp;c WO{  r k T@! *u  5{BOA*W_O{C   IB A h `{AOO{C   IB A h S{AO  (` B   T_{ vO{C  s  T@  @b @  
@"  s{AO_^WO{  s  T@ @ 
@
 h  " @ @ h  b   {BOAW_<WO{  s  T@ @ 
@
 h  " @ @ h  b  {BOAW_og_WO{C Rh~	A 
 U 6 W 	X 
9 	: 
s  Th]h^`^h  Azh_`_h  !s_  `_i^  `^d {EODWC_BgAo__WO{  s  T@ @ 
@  h  # G@ @    a ?@  @c 5@  
@! / {COBWA__H @) @	k?k@K_O{C   YB ! {A`bOO{C   YB ! `b{AOO{C  `J {AO D@O{C  @^   YB! {A`bOO{C  @^   YB! `b{AOuO{C   aB A h  B@  (Ah  `@{AOO{C   aB A h  B@  (Ah  `@{AOIWO{    h@)QB)A i @ T@  @@  4h@T  
 h@ `@@  ,{BOAW#O{C  ` *R  IB 2iR A h {AO_og_WO{C  'B @  k T@@h 5  @ c c P@@ 9# ( @c P  c !  6 @c A   ;@   @  @9wR@ 1F T` S c hR  >  @@    ! W S@Uc   %H@  @@[@  @ @  @@   @c @ *C{EODWC_BgAo_         !8	Bp;cp	wz_WO{    &B  @"  ( @ @ @   
@ @b  h   +@   @@  @@  {COBWA__Ag_WO{  'B* @  k	 Tt C  C   @   @b @  @" h@	R  "	A 	R"	 @C   6@   @  ? [@7c   (@   @v:@  @ p 2@`  C d@( {DOCWB_Ag_g_WO{  &B C 2@*   fBB   k Tt@T u R  Th@  ")@ " 	@#   6(@   @  C #    2x@`  # TB C  iC k@H {DOCWB_Ag_O{C   eB A h Q{AOQog_WO{C  %B   @(B9# 
@
       *fr @C8@9+@ C5 4 *C5 4@##@$'@ #   *# x 4@@#@  
 *8 5  9   2     2	9  T
@T  *    B9#@((*   7  !  k Tu@  !          w R9Zsh ' h@~ ii  h@( `@   6h@   @     h@( `@   6h@    N  @   	iB9   !	 9@-@iB9@? qa T	!@i 	@j}$ij|Sg9	 4|S|Sk9o9s9w9    *g 2c@@ g@{ b T@	!@	T     !|    '@  7  B9#@((*   7@- @  x@`    e@`     TT@ j @ ic i  Z)%B)@(H C{EODWC_BgAo_VYO{C   eB A h {AO^WO{    &B2@h~  Tb}  +A  W  @   {BOAW_!$WO{  h@9( 4    !B@2o2  BH 5 @ y@`  }* 2u h 9{BOAW_         !Bp;c0O{C  W  iB ~A h {AO_WO{ * E  iB  A   {BOAWg_WO{   &B @ @h @ub h @ ` c c +@ #   /   (A  `@$ (B `@ +  c !   h@  `@y@   @c @u @ @   # @  h@  `@v@  @# @ {DOCWB_Ag_oO{C   iB A h (Bh  `@(Ah  `@{AO_WO{  hEh RNDB @  a  NY@	 Q?	 q T) q@ T q T@T "L  @`   B ThE#T{COBWA__#O{C   iB A h >(Bh  `@(Ah  `@{AO" _ @_O{C ) @ * Q_	 q T?) q` T? q T3 @ {AO
  @  {AOd{AO_WO{  T  B T
 {BOAWK_WO{   |wE  RN)@  TN %@  4  TcT TRN(Y@5 	 Q?	 q T) q T q T@s      T  ThRN )  TRNu `& {COBWA__@     b     !Bp;cg_WO{  *E  RR)@  TR %@  4 b TcT TRR	Y@ ?k   {DOCWB_Ag_J_WO{   E  RR)@  TR %@Z  4 B TcT{COBWA'__%O{C *L    {AO_g_WO{  E  RR)@  TR %@)  4  TcT  TRRY@  4*  *  RR9@ 2h {DOCWB_Ag_O{C  2    {AO_g_WO{  E  RR)@  TR %@  4 " TcT TRRY@ q! TRR@ 2h   *  *{DOCWB_Ag_O{C 2    {AO_g_WO{  >E  RR)@  TR %@  4 " TcT TRRY@	 q! TRR@ 2h   *  *{DOCWB_Ag_d#m{C N 2    {A#l_g_WO{  E  RR)@  TR %@g  4 " TcT TRRY@ q! TRR9@ 2h   *  *{DOCWB_Ag_##m{C NJ2    {A#l_g_WO{  E  RR)@  TR %@&  4 " TcT TRRY@ q! TRR@ 2h   *  *{DOCWB_Ag_O{C 	 R    {AO_g_WO{  {E  RR)@  TR %@  4 " TcT TRRY@ q! TRR@ 2h   *  *{DOCWB_Ag_WO{  22"    @  {BOAW__WO{  t   22" `     {COBWA__WO{ *  v" @  @` {BOAW_WO{  q  2h" @  @  h {BOAW_WO{ C   &B @ H @    N HR" @  @   @`   @   {BOAW_WO{  / 2h" @  l@  h {BOAW_WO{ ****(RT )L)  {BOAW_g_WO{  E  RR)@  TR %@  4 B TcT TRRY@ qA TRR@ 2  *  *{DOCWB_Ag_g_WO{  PE  RR)@  TR %@  4 " TcT TRRY@ q! TRR@  `@`   2t   *  *{DOCWB_Ag_ng_WO{  E  RR)@  TR %@|  4 " TcT TRRY@) q! TRR@  `@`   2t   *  *{DOCWB_Ag_0g_WO{  E  RR)@  TR %@>  4 " TcT TRRY@! q! TRR@  s`@`  w 2t   *  *{DOCWB_Ag_og_WO{C  E  RH[)@  TH[ %@  4Z " T_cT_b TRH[	Y@?% q T 	@ 2 @	RI[	 (A@ (E@h   *  *{EODWC_BgAo_WO{    &B @  h@ `@C l  6t@   @ #  # @` #   c@a  b  !B RS@`  C @   {BOAW_~WO{    &B @  @ @C 5  6@   @ #  # @`  # *	  @a  b  !Bp R{2@`  C @  * {BOAW_CWO{    &B @  @ @   6@   @ c f@@ C  a  !I  2" @ @  @a  b  !Bp R{2&  a  b  !Bp2s   @`  C u@   # g# /@`  # g@c / *@`  c ^@`   Z@  * {BOAW_WO{    &B @ u@u  
@H @C  6
@ 
  a  b  !B R{2  @5    # "# @ * #    a  b  !B Rm{2@`  C @  * {BOAW_WO{ C   &Ba  !@     6@  `@`  u @    a  !  2" @  @  *   h@ @`   @  * {BOAW_Tog_WO{C   )%B  HR)@ 0x@ h@ H `@#     6v@   @   iBC  A    C   C @`  # hE@(hEH   	R9?		h	@D	V *)  T ; R& oh	Y@Z Y@ Q q T({ @` @]  2@ u   @ @` @N@   R  =`=	R B ThET  @)%B)@(H C{EODWC_BgAo_og_WO{C  )%B*a  )@ !T@   4>S 4^S` 4~S@  4)|S`  "\S#<S$  #	*##
  @`   r@ 4`   da  !E(  1~@}@   w  x  w 
 1R{? w/  >   @[ @ [@ H@I@	h H@ THW%@`  c ,cc./@( 5[@	@
C@ 
@ 7@  a  !hx  HW%@`   p|u[@@   HW	Y@?) q Ti{ ) IW!%@@`  C 4cC\C  IW!%@@`   tWPv  IW!%@@`   KDj  IW @!%@`  c " >c7c]  IW!%@ @`   02+Q  IW!%@@`   l&E  IW @6%@ `  C CC6  IW!%@@`   *  IW6%@@ \@ B	 T9 	 TCC `   C  IW@)!%@$H)`      t*.  Z b TE_CT*  a  !hZ  Z)%B)@( C{EODWC_BgAo__a  b  !BT\WO{   &B*  @~@Fqc T a  !>  !
R    6 $  !`]  {BOAW_a  !0"# #  x# a  b   !Bp;Wog_WO{C  {'B  {@ j * HR m  iB  A ~  j@ V@	|@	@E Ta  b  !B2@2	@E     Rs ' a  8b * Y   qh Thz b6  + 2  + .  #|@ )  & %  & !  & Z 2   @  
 @H 5@ @ @@ @`    Eb  )  Tb %   T@Ec T  a  b  2!B I@ a  b  !B82<@@@    a  b  !B2/@ @`   @h C{EODWC_BgAo_a  b  !BLO_WO{  h@*a:JhE(   R"N'@[@[@! q( Tz	  @  @   @   @
   @    @ " ThET{COBWA__s  sb  B2b  BX5#mog_WO{C   ' J%B J@@)  HR  I  iB A ~ ? F@I@
@?
k  T?@	 @@@@ @ T?@7 I@)    6H@7    z6 YI	I9 {FOEWD_CgBoA#l7@;@`  7@`  HE2 '@CR r(  yk3E@ _ <TE  j)@  Tj %@  4 / TcT  Tj	Y@ ?k  #@( q(. T  (y8 	 @  @k) T@?@@    E @  @ ( T@?@@} 2  @  @& T@?@@r2     @@  !@% T@?@@!@#e 2      W  @@  a`# T f   @@A T    @@  ! 7@?@@@  @  @ @  T@?@@ `   9  2# @  v@   @	 oY	 w @3   g3@Y# ` a    2 4@?@@@ hkUH)v`(R  X )T)   @3 ` G3@  @+  C?+@ 3@@@_  T@@
@@ 	A	J  7 ` 4@?@@W  w  @H @?@@'  2# '@  '@ '@  #  w  @
 @?@@/  HR# Y  Y Y`  /@  c=  @@?@c!@2    d  @@?@@ R    [   @
  T  3 # '  + 3@@?@@   HR" Y  Y   Y`  +@  C3@ ,  # '@ CC#@`  +@E @?@@[ 2" @ @  h@   +@`  C3@`  Y`  {  THE@CT?@@  ( J%BJ@YH {FOEWD_CgBoA#l_s  sb  B 2b  B - E_E  TR( 	Y@I   %@__  _WO{ "  2 7@ @^j(F {BOAW_O{C  B.  mB 2!    qB	a  {AO_!  9O{C   mB ! 1{A`BO)O{C  @^   mB! "{A`BOO{C   mB ! `B{AOO{C  @^   mB! `B{AO{  D@ 2{_og_WO{C  )%B )@c?y( ) TA Tc?y( ) TA TF@c2F@B - k' T2@( .@@U@7	A9I 5	@	 4c2*@k	A9) 5	@) 4? q`  T? qa T9@	@?  Tc2*k " T2@CT 1! Tcc *6( 47F@c2 4F@  2 2 @ qT  @a  b   !$B0 R q T k&& T2	  2@   @ q # T @  @a  b   !$B2* a  b   2!$B**  q T9 c T.@@U@7c2*m  5c2*h`  4 qF Tc2*a@ 4@@ q T 2(!R	
H 42# *3 ] *7* 2*[  q22*U6C @k T 4kF TDa  b   2!$B*`*Fs  O@@ya  b  
	Z)	ZC}SD]SE=S	Z'}S2!$B L RnB@  1 TB @ -@ `    2 **%  @`   @@|  $@b  B	 q( @@ 2@!@b   2B,*2x ;@    @ 	 @       @  @a  b   2!$B*   * 4k Ta  b   2!$B**c2* 4@ *4kT
@?` T v  x  B
$! o @   c t
@(@		 (    @`  s@@# ; `  b #@`  c@2@@`  c Y
@?T  Z)%B)@(( C{EODWC_BgAo_o_WO{  'B**@* !  uB 2uR)^
)A   9f y 9B yi~) ~h w @`. `  ab9  9)yBRhf  R(A h6 `:  `a  b  !$BD$2**wJ Yh@ qa T27 `V@c H * t6 *Ea  !>  *>    6 \2 `V@S 6 * t6 *+a  !>  *$   ( 6 BZt  '		Z!}S"]S#=S	Z Y		Z!}S"]S#=S	Zc `.@# @b@a  !'@a  !'2@ (a   !( Zx@a  !0(	Z}S@c a   !`( Yx@a  !(	Z}S@@`  # c  `   (   4  *  CRa  b  !$B)2c [ {DOCWB_Ao_a  !$  a  !&c c  5c a  b   !$Bp;WO{    c@uBa  b  !$A BT)2h `V@ 1  Tx hV `  h:@)yB)A i6 @ T@  A@  *h:@T   h:@ `:@@   E@  {BOAWWO{    h@)yB)A i @ T@  A@   h@T   h@ `@  {BOAW{BOAW_O{C  R{AO T@_ _@ q  T@  4*_*_*2	 *_ ,@  `  _@	 q_@ q_ @9_(   9_(   9_A9h  4*_@ q_A9h  4*_@ 4 q T8@	@?_ 2_ q  T8@	@?_*_#mog_WO{  %B @h@ q* TcMa@? q@ Tca  !>cLc 2cO   6c    @)@y  z  {  |  t  29-Z_-{--
$ 	RR _ S_@* @ B`V@ Uu @ q T_@`V@* B
@A	 U  h@9 4* 92  *  @k& T*  	@9@9h2@963	  4}S k@ T;2K	}@j )}
)`)*}I}I%LR2 k Tb  BL+*c* R   hf y 2h 9  b  B,*W hf y_@ux_@ 	wW@a  !,vW@`  h@_@ TcgO@a  *! ->O@ c  [S@a   2! -2S@`  Rrr Th _@7#IG@a  *!H- G@ #  C>K@a   2!H-K@`  C`.@
C@b@a  !'	C@a  2!'XC@		Z!}S"]S#=S	Zy  XxC@	Z}SC@C@h@ i Th hR&i ThR h"@`&   Fh TR	Hr	 Ttij`R@}I	G	 !^ (" ! )b   "2B.h&@R h"   thj|H	Gb  `" #H2B-C@`  L**_@`  F q@  T4. 1T 4hf@ 4 q` Ta  b  !$B/2Rcf * `V@*BBRCBR 4O @ q`T @k T   T`h@ q T`   0cR  4a  !0c 5a  b  !$B0 2Z*
  R*hf  c  *cD/ h@ q T$ 5v  w  x  y  {  u''-9G2{,  C _ @9 qA T O TV@9	@9	x/ /@ R T #N T`.@C +@b@ +@ R+@=@9a  !$2 	R./@ ##' '@	@@<)/@  '@ 	#@#@`  +@#+@/@ J T'@`  #+@ q 8  c*
@HC `.@ @b@@ 2C `   \ @`   \@@  "R 5/@_O C Thz85 q T/@ B Thz8) q  T/@	 A T/ /@@`   6@`   24 ` qh: Ti  )(y	 u #9 Tv  w  x  y  ,''9- @9@9xz  6 T 	R |co  o@	@@< yo@ 	x3@x3@`  `.@Ec@b@Ec@2Ac@cic@Bjc@`  o@`  c Ts ca@? q@ TcA  !>cc2c  (1 6c-u6 o * Tz   2ZK4@9@ T Tb C) T
@9@92x  Y( #( T
@9@9@9@9@9h)p(*@9khp"@9Jx
*&@9	*}`x{
XR@9  2 h 7*   9 ($ T	@9
@9	@9@9)SI3i39*+ h" T' C& T! T 	R   V@	@@ S 4{ 	b# T
@
# T@ji8Jq}*'l@k@)
JIi(8 ! TT`.@c @b@a  !'@a  2!'@a   !-@@9@ T@`  c  @`    hT  `.@clo@b@a  !'ko@a  !'2fo@va   !- `o@a  a  b  !$B0 2Hu  Tv  w  x  z  {  
$0C1Z'{-  22\ @9@9@9@9 2'@9@9x  # T 	RA 6co o@	@@9< `.@c@b@a  !'c@"Rc@c0c@	1c@`  o@`  cS (T:   	R
u J co o@	@@6 : v`.@c@b@a  !'c@a  !' Rc@a  !-cc@c@`  _o@`  c[4 4c  *ct4* 2h9  Y)%B)@( *{FOEWD_CgBoA#l_a  b  *!$B1 2a  !)  a  !2cA  B   !$Bp;_WO{ C   &B  @** .@j@@A  !'i@A  *!'d@a   !_@a  !0*Z@a  !@ X@Y@`   @   {COBWA__sO{C    &B@   == @    A @`  @  C {AO_V_WO{   &B @ h@ 4 qA Th:@@$ T A 
@`V@*	@
	C!
V@6 @ qT @k&" T 4   q T@9 6==
@   @`  h:@@A	 (    A@  )h:@@!TR*hf   2 `V@ 22s c % * >t 4 *A  !> > * A   6  +@? q@ T 2A  !> * 2+ -   6 @ 4k TC  *c< 2h9@k T   a@? q@ T A  !>   2 
   6  h:@@ TB 
@`V@*	@
	C!
  F @ qTm    T
@@ T@ T
@@ @9 6==
@   @`   h:@@A	 (    A@  h:@@!T5u *M   2 2h *F    . 1 Th:@	@? T`V@!R h:@ *	@?` Tc  T)@?T  hf@ 4 q TA  B  !$B82Rcf *   C  c7    *#@A  B  !$B62-*   @k TU 4c  c  2* 2Gt9  *@( * {COBWA__ @  A  B  C   4!$Bp;c5NA  !8  A  ! ;  A  !8=   Y A  B   !$Bp;8@  A  B  C   4!$Bp;c>/WO{ C   &B  *@ `.@@b@A  !'@A  !'*@@`   L@   {BOAW_g_WO{  9'B *9@ h@ q`  T qa T  b W  h@ q Th@	 q@	 T q T` q TH 5c B@k Tc A  !>c c ? 2]c   ( 6c { 	R} 
 & Tp @`   @	@H 
i)8@	@@( 9@	@@( 	 }   	R_ T @`   @	@  	l  22(B@IR 	R:G Ab T: @`   @	@*R 
i)8@	@@( 9@B@	@@(	@9 T) 2	 9@X	@@(	 9@	@@( 9@	@@( 9@	@@( 9@	@@(
 9@P	@@(
 9@H	@@(
! 9@	@@(% 9   T)2	 9@H	@@(
	 9@	@@( 9  )*	 9@	@@( f    6 2  @c A  U@`  Y v:@ R< `=5u  Ev @h @  @`  C@`   ?@(H *{DOCWB_Ag_`  A  B  c    !$Bp;ca  !  c  A  B   !$Bp;og_WO{C  &B @ h@ q T q T* q  T`  A  B  c   !$Bp;c8 t A  !>  *<    6 Z`V@!R#  5i(v)V?}kA T@ k TAq  TA  b  !$B(
 R%LhJ@  ) R	r		 Tm T`.@ @b@A  !'@A  !' 2@a  !
q@vJ @`   `V@*PRW  x    2r\R
$
R~@}	b	H 52*k T RNy @ q  T @- q  T @q T`V@*&  1TA  b  !$B
2     @kFT 4h@ q@ T  &B q@ TC  c7 2*    &B*@  c  c  2*  &B@ 2 2h i9@H *C{EODWC_BgAo_a  !# #  # A  B   !$Bp;O{C    }B`B A h  2`B*2 hB j  B	 i)9A h* {AO_O{C   }B A h   BA T(C  	@)^ 	`B Q{AOWO{  C`  @@ ?u  `J@ 2 2g @ qT  @A  B   !$B R%@@  	@)^ 	 `F@`J@* hB  {BOAW_O{C  }{AOQWO{  Ch  B  `q  4 h) @k' T% R B  mB 2! y  qB	a  h@  	@)^ 	 @A  !\	@o2 ? * 4@  	@)^ 	o `F@`J@ h)  *{BOA*W_O{C t   `J@ 2 2 | @ qT  @{AA  B   !$B RO{AO_*2**
	og_WO{C  %B B @*** kD TA  B  !$B 2* ; i q 2*2 *	7 2 _ q  T Q	 q  T
 q` T 5A  B   2!$B 2 2o M 222*@*7A  B  !$Bl 2 2 > 2R 2*2 2 2*# 2 4
 q T 22 2c2*[  &72* 2S2*W @6&  @kf9 TA  B  !$B2*  &B@ 2 2 2*k c Zg@A  B  !$B2 222*y  7 2 22*r 7 2 2*?g@A  B  !$B@2R* 2s2*_ \`6 @k1 TA  B  !$B 2 R 22s2*_ I`6 @k. TA  B  !$B 2* 2*  q22* 6 @k+ TX 52x" qH T 2!2R	
 4& @@@)	Z)}S@x    qH T 2!	R	
 4hZ}Sx" q T 2!2R	
 4YYxA  B  
	Z)	ZD}SE]SF=S	Z(}S!$B2* o2* * x7 *`A  !>  *Y   ! 6 w* @q
 TW  2*A  B   *!$B2GX	 5 Q	 q T_ q` T w 4 *7A  !>  *0   ( 6 NY @2 y)	Z(}SC  y@ @2*@@   %  @hZ}SxYxA  B   	Z}S!$B2A  B  !$B 22* *7 Q! q Ti  )9h'   @k TA  B  !$B2**  ;@&B@   Uw 4 *A  !> U * X  h 6 2 RB@ ( 1 T@**B d;@`  h
 Q;  q T  i  &B)(y@	  2 !     A  B  !$B, 2 2 2  A  B  !$B, 222   A  B  !$B, 2 2 2;@ 2 	 ;@@ 6! # ;   'B #@`  (v  J@ 2 2G @ qT  @JA  B   !$B Rg;@*@ `  Z *C{EODWC_BgAo_  &B@A  !h  A  !0 \   kA  B   !$Bp;A  !X* 2**
	**
**	****
*	_WO{ **A  B  C   !$Bp;c2*{COBWA2*_m* 2**
	a**2**
	T_WO{    &B B @*  kF	 TB#  #  @   # fV.@ @   # V@  {2%   W@ 7 W  2u  J@ 2 2o @ qT  @rA  B   !$B R@`  # 7*@( * {COBWA__O{C  `V@ 7] hV {AO_O{C * 2 *M  q22*G ** 63 @k  T{AO_O{C * 2 *5  qy2*/ ** 6 @k  T{AO_tO{C *A  B   !$B, 2*4 {AO_g_WO{   'B B @** . kf TB#  #  @   !# .@  @ @2U@
Z}S  y y @# 2*@@  7*	  {2     @k T@`   @H *{DOCWB_Ag_og_WO{C   Z'B B Z@**  k TB#  #  @   a# `Y.@ @   # P@  {2!   Bu  J@ 2 2m @ qT  @pA  B   !$B R@`  # 5*@Hh *C{EODWC_BgAo__WO{    &B B @* y k TB#  #  i@   " U.@ @   # @  {2  @ q  T@  4    2 @*`  # l@( * {COBWA__ehog_WO{C   )%B *)@ 2@ U  V  2
$v 2R.@#  @U@ * 1 T@y	Z}Sk T@@ q( Th#
  4  29  T2@?T      A  B  !$B 2**  )%B)@@(h *C{EODWC_BgAo_@ Q	 q'_O{C  c@A  B  !$B 2`@{AO__WO{    &B B@#   #  @   # YV.@ @   # I@  {2  A@ *  # C@ * {COBWA__* R**
	* 2**
	*2**
	_WO{    &B B @* i kf TB#  #  Y@   " U.@ @   # @  {2  A  B  !$B 28 2 9@`  # *_@( * {COBWA__X[O{C A  B   !$B 2 2h 9{A*O__WO{    &B B @*  kF TB#  #  @   " U.@ @   # @  {2  A  B  !$Bd 2 9@`  # *@( * {COBWA__O{C A  B   !$Bd 2 9{A*O__WO{    &B B @*  kF TB#  #  @   " OU.@ @   # ?@    @A  B  !$B 2@@`  # 6@(  {COBWA__O{C  c@A  B  !$B 2q`@{AO__WO{    &B B @* n kF TB#  #  ^@   " U.@ @   # @  {2  A  B  !$B 2= @`  # *e@( * {COBWA__^aO{C A  B   !$B 2 {A*O_O{C A  B   !$B 2 2h9{A*O_O{C   B A h {AOUO{C   B A h J{AO:  (  B   T_{ O{C S 4  s C T@`  B 3{AO_WO{  5  s  T@@ `  eB B {BOAW_WO{  5  s  T@@ `  LB {BOAW__WO{  v|" s  T_( _ `  / _`  3B B {COBWA__WO{ s T  5  s c T_@ `  @`  B B 3{BOAW_WO{    h@)yB)A i @ T@  A@  h@T   h@ `@@  {BOAW  B 2@| 	 _WO{   2 ~ 
   @B @  	  T @ 2~ 
 {BOAWWO{     @B @  	  T @ 2~ 
 {BOAW|   )B 2 )@	|  zWO{    @B@     T @~  2
 {BOAW_WO{   2~ h
 4 @  h@B @  	  Tj @ 2i~ h
 {BOAW> 2|  #@_WO{  ` T  @B@     TD @ 2~ 
 @@5     T8 @~  2
 {COBWA_@  "  C   Bp;c @_ 2|  MO{C    `@B@     T @h~  2h
 {AO_O{C  ?   T#@/{AO_  @_@ _WO{    `@B@ a  T+` h@	 T)  Tj
@?
i TH T}  T{a
 `   h@  h@ Ti@h ?i(8{BOAW_I@  "  C   @$Bp;c$}	@I  2} T @ij8{" TJ   T_	T  _{ (@(@_ A T{   @! @G  q{_*_WO{    `@B@ a  T` h@   @9@ 4 B Tt@" Th@ iu8 5t@    T C Th@ it8 5 T`@ h@t i48{BOAW_O{C    `@B@ a  T` {AO_g_WO{C  'B  9B @ 2' (@ @H TD  *, 22g| q T  q T 2\ C  7  >2S C @D  *, 22K| q T  qM T 2@ C  @
 @  (@ `  T   T #  4@( @ @     T @ h@   T- h @) T" T +@ Ti@h ?i(8'@ {DOCWB_Ag_R@  "  C   &Bp;c,S  s"AR (@  2C  @C @  8S  sB!R (@  2  @ }@"  Bp;W(@tWO{    &B  B@ 2 @ h  @@  TD  *,# 22| q T  q T# 2 # M5  >2 D@D  *,# 22| qH T  q T# 2 # 1@  {BOAW_@  "  C   &Bp;c,O{C   l{A O( @O{C    &B*D   @*%# 22* T< q( T  q T# 2I # @ C {AO_@  "  C   &Bp;c&O{C    &B*D   @*# 22* '< q( T  q T# 2 # @ C {AO_@  "  C   &Bp;c(\O{C    &BD   @**# 22| q( T  q T# 2 # ^ C {AO_@  "  C   &Bp;c*h/O{C    &BD   @*,# 22| q( T  q T# 2 # j^ C {AO_@  "  C   &Bp;c,;O{C    &BD   @*.# 22| q( T  q T# 2 # =^ C {AO_@  "  C   &Bp;c.O{C    &BD   @*0# 22s| q( T  q T# 2h # ^ C {AO_@  "  C   &Bp;c0O{C    &BD    "@*2# 22 G< q( T  q T# 2< # @ C {AO_@  "  C   &Bp;c2|O{C    &BD   *@2# 22 < q( T  q T# 2 # @ C {AO_@  "  C   &Bp;c4QO{C    &BD   @*|6# 22| q( T  q T# 2 # ^ C {AO_@  "  C   &Bp;c6]$WO{ C  &B @  @  @H @    B@ `  T @]   
 @	(  {BOAW_S  sv8R   B  2# @  =@# 9@"  Bp;($@
	g_WO{  'B " @c    s@(   @9B(@     T-(@ @   Tj @ T b T
@	I T( T}  T{
 J   T@)C T"  T  U@ @ T @ {DOCWB_Ag_yS  s9R "  B  2 @  @ @"  Bp;a@  "  C   @$Bp;c;{   @! @T |S{_  @! @N{   @! @I  q{_  @! @{   @! @  q{_O{C    `@B@ a  T` h@(   @9h@ 2  9h@" Th@ it8h@ i48 T{AO_O{C  @  {A  qO_O{C   @ b  T*  @(    q{AO_O{C  @  {A  qO_O{C   @ b  T*  @(    q{AO_WO{  |@   B 2 @  {BOAWWO{   &B " { 2@c   Q@ @    B@ `  T @  4]h  {BOAW_
@]H  {BOAWPS  s<AR !  B  2 @  @ @"  Bp;`WO{  
  O &BC cc2@ #C  +:)3<!@ C	<[    B  2@h~ i
 [@   {BOAW_"C  6og_WO{C* V jx8 q  T "
 TCTH Tt  6  @ 5" Th  T Tj{8? q  T{  TCTy T7  T 7( Tt  6    4 B TcT  cT     7) T*{EODWC_BgAo_ t  6    qWO{    B2t " A ~h  B   B	a N 
 u {BOAW_WO{    &B  B @A  h A  	@c )^ 	 c \@  	@c )^ 	@h@@7@   	@# )^ 	 *# ?@  @# @  	@ )^ 	 28h
@  	@)^ 	 (B  	@)^ 	(A  	@)^ 	@  	@)^ 	@   {COBWA__/O{C  2 	hA  	@)^ 	 {AO_O{C  {AO)_WO{ C  &B @h"@  4 1 Th"  2  A A	  @A  ! @@  ? @  	@ )^ 	[#@  @  	@)^ 	O@h
 #@ h@@8@   	@ )^ 	9*  ?@ 	@ )^ 	5  A  B  !H?B R#@  	@)^ 	'@	  R @ c ^@!   !H?@C @qA  !# m* 2c C #  ? *# oC m@5 4  @c ^*    @^@  	@)^ 	h"@v  1 Th" @	@c )^ 	b*\   {COBWA__[V   !  "  #   >!H?Bp;cp?WO{  h"@h 4a  6 2h"  qC Th"  5A i
@) 14h
@ **	@)@ ?&,h@  	@)^ 	 {BOAW_@  !  "  C   !H?Bp;cDRO{C @  2hA  	@)^ 	 {AO_   O{C  `" {{AO @^  ! rO{C  @^ `" j{AO @ dO{C  `B ^{AO @^  A UO{C  @^ `B M{AO  @` 	@?   T*! J *J})
	 _  @ 	@? ` T*1 kUJ  J}J2I%	 _  )a(%@	@ T
@_ k  T
	@_k` T1 ?T(  *qb T q T? qh T 1B T**}I		  *_ @	  @@1 T*)xI  T 	+B  T_{ ~  )a(%@	  T
@_ k T1 ?aT@@q22 22,R2)h? kl T_ k- T
 	k& TI*((  I  _ 2)  I  _
@)**  I  _{ P{   )(%@	  T
@_ k T! ?aTq  T qi T @@1B T{_*{_ @{_@  A  "  C   !,Bp;cXh+  )(%@	  T
@_ k  T! ?aT\A@q  T@@q' T{  2(  _@*(  _  )(%@	  T
@_ k  T! ?aTq( T  qc Ttq  T @@1 T  *_ @_  1B  T_{   )(%@	  T
@_ k T! ?aT@@q, R22R rJ 2_ kL T k T	 
k  T{ 	@**)  _{   )(%@	  T
@_ k T! ?aT\A@q  T	@@q  T 2  	@*  i  JaI)@?
  T+@k T)1 _	aT?@@q22 22-R2I?k, Tk  T, 	kF T*j
   2k   *@)*j k   kj-@_  TL@k TJ! 
aT_@@q. R22R r 2k Tk  TJ kg  TrJ@*? q) q j {_h{   	)@ @?
  T+@k T)! _	aTq  T	 qI TA@1  TS*  (@(    a	@
-@@_@ TL@	k  TL	@k` TJ1 
T
	*_qb T? q T qh T)1" T*
}H	  *  H@	  )A@1 T*xHa T(+" TH    	)@@?
  T+@k  T)! _	aTq( T! qc T	u?q  TA@1 T  *  (@   1 Th  $@)(A)(*
**q3{_@  A  "  C   !,Bp;cX0{   )!
@(%@_q@ T	 Tl@
k Tk! ?aT	  T
@ 4! ?T@  A  "  C   !,Bp;ch@  )(  
@(%@_q@ T	 Tl@
k Tk! ?aT	  T
@ 4! ?T@  A  "  C   4	!,Bp;c<
h@  )H  
@(%@_q@ T	 Tl@
k Tk! ?aT	  T
@ 4! ?T@  A  "  C   x!,Bp;c|h@h   @ q  9{_  )!(%@	  T
@_ k  T! ?aT   @   )(%@	  T
@_k  T! ?aT   @   )(%@	  T
@_k  T! ?aT   @   r 2  _2 R?;qL T_;q TRH|!r	  T2 R   ?@q  THQq  T 2 2  )Q 2?}q  T_Dq 2+ T_Dq?Dq_q?qJ
i	
I	* 22? qi
 @j  52
  
@J  5	 	@I  5 @h  5 2 _  A	)@ @?
@ T+@k  T)! _	aT  (@  Er_ @  4) @	k  T*  *   2  	@	 4*@?
k  T B  6  2	@	 4*@?
k  T B  6  2	@  4*@?
k`  T 2 *_O{C  c@) 4  4h@  4h
@H 5  *fA)A  B  !,B R  )(%@	  Tj@@
k  T! ?aT2   @  )(%@	  Tj
@@
k  T! ?aT 2  @  ai@
-@h@_@ TL@	k  TL	@k  TJ1 
Tk  kBj-@_@ TL@	k  TL	@k` TJ1 
Tj  JBK1@ 2 2 Tm@	k  Tk! aT 2  A@  a@ q@  )A(%@*<SJY*Tm *	  T
@_k  T! ?aT  @u{A*O_WO{  @!  !ph  H  7 @!  !`  H  7 @!  !X  H  7 {BOAW_WO{ C u  &B !  @!p  @A  6`@@!  !p@!  ! 6  6`@@!  !@!  ! +  6`@@!  !@   {BOAW_WO{  u  &B !  @!pS  @  H  7 @!  !C   H  7 @!  !3 `  6@  * B)` 4 q  Th  =yc  $  $ q  Th  >ye  &   q  Th  A?yg  (  !  "  !,B R @   {BOAW_WO{  u  &B*S @C 3  ) @B  5  6`@!  !pt@B  5  6`@!  !m@B  5  6`@!  !f@   {BOAW_WO{ C v  &B  	R@ l!R a  @@9!  !	@@ (
 9@9	 9
@9		 9@9	 9@9	 9@9	 9@9	 9@9	 9"@9	! 9&@9	% 9*@9	) 9.@9	- 92@9	1 96@9	5 9:@9	9 9>@9	= 9B@9	A 9F@9	E 9J@9	I 9N@9	M 9R@9	Q 9V@9	U 9Z@9	Y 9^@9	] 9b@9	a 9`@:@`   @   {BOAW_1O{C C t  &B!  !@     @6@ 6@@d  T	@@(@9c 4!  "  !,B R*=  *;  !  "  !,BX R*3   9	@9
	@9I]3i x	@9
@9I]3i2 x	@9
@9I]3iR x	@9
!@9I]3ir x	%@9
)@9I]3i x	-@9
1@9I]3i x	5@9
9@9I]3i x	=@9
A@9I]3i x	E@9
I@9I]3ix	M@9
Q@9I]3i2x	U@9
Y@9I]3iRx	]@9a@9	]3irx 2@`   D@  *C {AO_WO{ h  B 2 A  a

tbB9~h  u. ~{BOAW__WO{  w  &Bh  B @A 2 h~  2R 
 R~hB9ub| v. P  ` 5  2k"  *B\ C  @ @	@#  ?@  	@)^ 	@    `   !  "  !\B R#`   !  "  !\B2@`  C @   {COBWA__CWO{   2h h h  B   A h    @`" `  a2& B9tb ?u. ~{BOAW_WO{ h  B   A h ( @	@@(h ( @@hh  @`& `  a"q2B9tb u. g~{BOAW_O{C t  &B @h@h ib (_
 q*5 T`@  @	@^H C {AO@  a@A 4 !  !>  *    6  h@@ ?   qm T^ C {AO_h@@^  C {AO  !  !# #  # !  "   !\Bp;   !  "  #   @!\Bp;cO{C t  &B @h@  a@? q@ T E!  !>   2>    6 \ ^ C {AO_   !  "  #    !\Bp;c\!  !# ?#  # N!  "   !\Bp;R` 	_) 	
5_ @h   @_{    !  "  #   p!\Bp;cu @h   @_{    !  "  #   p!\Bp;c f @_ @_WO{  h"@h  Te@i T!  "  !\B "2h"@  h@  TuR{BOAW_   !  "  #   "!\Bp;c#8  @  `  g_O{C  `.@h@"{AO_O{C  i  h@)B)A i  hBA9  4`@  h6@h  V `2@   @@ ?2 (F  	@)^ 	D E@  @ D@  <`D  {AO6{AO_   !  "  #   %!\Bp;c,&O{C  {AOa  @h   _{    !    #   '!\Bp;cl( _ @_ @_g_WO{ h"@h	 2xj  h&BJB 2JA     b B9& f . ~v^C@h  T@? T!  "  !\B "2+@  @? T2^Ga.@ .@`  . h@@ ?2 {DOCWB_Ag_   !    #   p!\Bp;cH*s6   !    #   "!\Bp;c#iO{C h  B `" A h *` K~{AO__WO{ x  'B h  @ t2@BA h    >F G * @W 4 * A * D  ( 6 5@@ ?` `" @  {COBWA__!  !+# #  '# !     !-Bp;O{C  {AOWO{  "  k T6@    2 6 {BOAWog_WO{C " *s k T  2@ @ 5  T 32  w   7 kTuU2     T 2TA2V 2@A  T2 6@A  T6    @@ ?@@ ?* :*{EODWC_BgAo_O{C  "  k  T g{AO#&O{C  h  B*2A hh  BA h {AO_O{C  th  BaB A mh  BA  {AO_O{C h  B A h  BA  {AOg @ O{C h  B A h  BA  P{AOWO{  v  &B@ @  #   @    T@`  1   2 2~  *@  * {BOAW_WO{ *  H B T*{BOAbnRBrWg_WO{ y  9'B@ 9@*  )#   K@    T@`   x  2	   #     *A 
@   T@`   
 
  h  Tb    ` !  "  !/B62@
   @(( *{DOCWB_Ag_:O{C C s  s&B 2s@  -RBfr@h     C {AO_#O{C C s  s&B 2s@  -Rr}@h     C {AO_O{C C s  s&BR"r s@2  f@h     C {AO_O{C C s  s&B 2s@  RDrO@h     C {AO_O{C  s  s&Bs@ )LR)nr# 27@h     C {AO_WO{  v  &B B @  #   @    T@`  & @
	@		@a _ I  T@jnRJr?
k  T 2h   *  *@   {BOAW__WO{  x  'B B @  #   M@    T@`   @		@ 		@ 		@a ? I  T@ 2h   *@   {COBWA__[WO{ v  &B B @ c #  @    T@`   @	4	@(	@5a  I  T@-RIfr	ka Tc o ` Tc n  !>c nc 2gc q  h 6c 	@ 2h   *  *]   {BOAW_!  !-  c Z !     !/Bp;9WO{ v  &B B @ c #  @    T@`  a @	4	@(	@5a  I  T@-Rr	ka Tc " ` Tc   !>c c 2c   h 6c @ 2h   *  *]   {BOAW_!  !/  c   !     !/Bp;WO{ v  &B B @ c #  f@    T@`   @	4	@(	@5a  I  T@R)r	ka Tc  ` Tc   !>c c 2c   h 6c U@ 2h   *  *]   {BOAW_]!  !D1 9 c  H!     !/Bp;WO{ v  &B B @ c #  @    T@`   @	4	@(	@5a  I  T@R	Dr	ka Tc a" ` Tc `  !>c `c 2Yc c  h 6c @ 2h   *  *]   {BOAW_!  !2  c L !     !/Bp;+g_WO{y  9'B B 9@  c #  @    T@`  N x@	7	@(	@8a  I  T@LRnr	k! Tc B ` Tc   !>c c 2c   h 6c @ 2 @ @ @h   *  *@( {DOCWB_Ag_!  !|4 x c  !     !/Bp;WO{  v  &B @ ( @ @ @    T@#  a      A 2	  !  "  !/B62+ # 3@    T@`   @   {BOAW_MWO{  @*   T
@`  
    h  TB   
 ` !  "  !/B62
@   {BOAW{BOAW_ @(  @h  	@@ ? I  T@H  _O{C  t  &B @ @ #   @    T@`  x ^   C {AO_   _O{C  h@   T`
@`  `
   {AO_WO{ h@   t@  h  TB   9
  !  "  !/B62
@ @ hAi_{B? a2OAW+{BOAW_O{C  t  h  T`B   `
 @ !  "  !/B62j`
@ {AO_WO{   Th@   T`
@`  
   @h @u  h  T`B   `
  !  "  !/B62A`
@   A_? 2{BOAW_O{C  h@   T`
@`  
  {AO__WO{ w  &B @*0@B _ I  T@@-Rhr? k TRCr? kl T-Rr? k` TRr? k T    6,x  hnRHr? k` TR(r? k T-RHfr? k! T@    7a  RDr? k TLRnr? k T
@)A)    7 r s M  @    P7 g h B      6#\#]#7  @    7 Q R ,      48c Gc Hc V 6@  T @   !     @    7  "% & \   {COBWA___WO{  w  &B @ h"@ qF T5  6  887h@	@* 	@_ 9	}S
}S}S[ 9# O 9S 9W 9@O l# ~  4b qTs@   {COBWA__m_WO{  v  &B @ h"@ q T4  5  /8w7h@~@ 2 	@_ 9	}S
}S}S[ 9# O 9S 9W 9@2O # C qT<@   {COBWA__6g_WO{ t@* h@@	@	@a  I  T@*9 B T?cT{DOCWB_A*g__WO{  w  &B S @ {  4!  "  !/B8 R2%  @ 4C p *3 h *# d * 5A)@@ **@ B T@T*  *  *@  {COBWA__WO{  2 h  B*2A th  B A  @{BOAW*O{C h  B A h a{AOO{C h  B A h T{AO  (@ B   T_{ wO{C  4` s  T_   T@`    {AO_`og_WO{Cs 6  7  /6s c TH@h H@ h X@x  h  T`c   ` @ 2