exist)
{
	u8 h2c_parameter[1] = {0};

	coex_sta->c2h_bt_info_req_sent = true;

	h2c_parameter[0] |= BIT0;	/* trigger */

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex], Query Bt Info, FW write 0x61 = 0x%x\n",
		  h2c_parameter[0]);

	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
}

static void halbtc8192e2ant_update_btlink_info(struct btc_coexist *btcoexist)
{
	struct btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
	bool bt_hson = false;

	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hson);

	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
	bt_link_info->sco_exist = coex_sta->sco_exist;
	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
	bt_link_info->pan_exist = coex_sta->pan_exist;
	bt_link_info->hid_exist = coex_sta->hid_exist;

	/* work around for HS mode. */
	if (bt_hson) {
		bt_link_info->pan_exist = true;
		bt_link_info->bt_link_exist = true;
	}

	/* check if Sco only */
	if (bt_link_info->sco_exist &&
	    !bt_link_info->a2dp_exist &&
	    !bt_link_info->pan_exist &&
	    !bt_link_info->hid_exist)
		bt_link_info->sco_only = true;
	else
		bt_link_info->sco_only = false;

	/* check if A2dp only */
	if (!bt_link_info->sco_exist &&
	    bt_link_info->a2dp_exist &&
	    !bt_link_info->pan_exist &&
	    !bt_link_info->hid_exist)
		bt_link_info->a2dp_only = true;
	else
		bt_link_info->a2dp_only = false;

	/* check if Pan only */
	if (!bt_link_info->sco_exist &&
	    !bt_link_info->a2dp_exist &&
	    bt_link_info->pan_exist &&
	    !bt_link_info->hid_exist)
		bt_link_info->pan_only = true;
	else
		bt_link_info->pan_only = false;

	/* check if Hid only */
	if (!bt_link_info->sco_exist &&
	    !bt_link_info->a2dp_exist &&
	    !bt_link_info->pan_exist &&
	    bt_link_info->hid_exist)
		bt_link_info->hid_only = true;
	else
		bt_link_info->hid_only = false;
}

static u8 halbtc8192e2ant_action_algorithm(struct btc_coexist *btcoexist)
{
	struct btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
	struct btc_stack_info *stack_info = &btcoexist->stack_info;
	bool bt_hson = false;
	u8 algorithm = BT_8192E_2ANT_COEX_ALGO_UNDEFINED;
	u8 numdiffprofile = 0;

	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hson);

	if (!bt_link_info->bt_link_exist) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "No BT link exists!!!\n");
		return algorithm;
	}

	if (bt_link_info->sco_exist)
		numdiffprofile++;
	if (bt_link_info->hid_exist)
		numdiffprofile++;
	if (bt_link_info->pan_exist)
		numdiffprofile++;
	if (bt_link_info->a2dp_exist)
		numdiffprofile++;

	if (numdiffprofile == 1) {
		if (bt_link_info->sco_exist) {
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "SCO only\n");
			algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
		} else {
			if (bt_link_info->hid_exist) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "HID only\n");
				algorithm = BT_8192E_2ANT_COEX_ALGO_HID;
			} else if (bt_link_info->a2dp_exist) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "A2DP only\n");
				algorithm = BT_8192E_2ANT_COEX_ALGO_A2DP;
			} else if (bt_link_info->pan_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "PAN(HS) only\n");
					algorithm =
						BT_8192E_2ANT_COEX_ALGO_PANHS;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "PAN(EDR) only\n");
					algorithm =
						BT_8192E_2ANT_COEX_ALGO_PANEDR;
				}
			}
		}
	} else if (numdiffprofile == 2) {
		if (bt_link_info->sco_exist) {
			if (bt_link_info->hid_exist) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "SCO + HID\n");
				algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
			} else if (bt_link_info->a2dp_exist) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "SCO + A2DP ==> SCO\n");
				algorithm = BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
			} else if (bt_link_info->pan_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO + PAN(HS)\n");
					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO + PAN(EDR)\n");
					algorithm =
						BT_8192E_2ANT_COEX_ALGO_SCO_PAN;
				}
			}
		} else {
			if (bt_link_info->hid_exist &&
			    bt_link_info->a2dp_exist) {
				if (stack_info->num_of_hid >= 2) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "HID*2 + A2DP\n");
					algorithm =
					BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "HID + A2DP\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_HID_A2DP;
				}
			} else if (bt_link_info->hid_exist &&
				   bt_link_info->pan_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "HID + PAN(HS)\n");
					algorithm = BT_8192E_2ANT_COEX_ALGO_HID;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "HID + PAN(EDR)\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
				}
			} else if (bt_link_info->pan_exist &&
				   bt_link_info->a2dp_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "A2DP + PAN(HS)\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "A2DP + PAN(EDR)\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP;
				}
			}
		}
	} else if (numdiffprofile == 3) {
		if (bt_link_info->sco_exist) {
			if (bt_link_info->hid_exist &&
			    bt_link_info->a2dp_exist) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "SCO + HID + A2DP ==> HID\n");
				algorithm = BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
			} else if (bt_link_info->hid_exist &&
				   bt_link_info->pan_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO + HID + PAN(HS)\n");
					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO + HID + PAN(EDR)\n");
					algorithm =
						BT_8192E_2ANT_COEX_ALGO_SCO_PAN;
				}
			} else if (bt_link_info->pan_exist &&
				   bt_link_info->a2dp_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO + A2DP + PAN(HS)\n");
					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO + A2DP + PAN(EDR)\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
				}
			}
		} else {
			if (bt_link_info->hid_exist &&
			    bt_link_info->pan_exist &&
			    bt_link_info->a2dp_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "HID + A2DP + PAN(HS)\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_HID_A2DP;
				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "HID + A2DP + PAN(EDR)\n");
					algorithm =
					BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
				}
			}
		}
	} else if (numdiffprofile >= 3) {
		if (bt_link_info->sco_exist) {
			if (bt_link_info->hid_exist &&
			    bt_link_info->pan_exist &&
			    bt_link_info->a2dp_exist) {
				if (bt_hson) {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "ErrorSCO+HID+A2DP+PAN(HS)\n");

				} else {
					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
						  "SCO+HID+A2DP+PAN(EDR)\n");
					algorithm =
					    BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
				}
			}
		}
	}

	return algorithm;
}

static void halbtc8192e2ant_setfw_dac_swinglevel(struct btc_coexist *btcoexist,
						 u8 dac_swinglvl)
{
	u8 h2c_parameter[1] = {0};

	/* There are several type of dacswing
	 * 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6
	 */
	h2c_parameter[0] = dac_swinglvl;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex], Set Dac Swing Level = 0x%x\n", dac_swinglvl);
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex], FW write 0x64 = 0x%x\n", h2c_parameter[0]);

	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
}

static void halbtc8192e2ant_set_fwdec_btpwr(struct btc_coexist *btcoexist,
					    u8 dec_btpwr_lvl)
{
	u8 h2c_parameter[1] = {0};

	h2c_parameter[0] = dec_btpwr_lvl;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex] decrease Bt Power level = %d, FW write 0x62 = 0x%x\n",
		  dec_btpwr_lvl, h2c_parameter[0]);

	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
}

static void halbtc8192e2ant_dec_btpwr(struct btc_coexist *btcoexist,
				      bool force_exec, u8 dec_btpwr_lvl)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW,
		  "[BTCoex], %s Dec BT power level = %d\n",
		  (force_exec ? "force to" : ""), dec_btpwr_lvl);
	coex_dm->cur_dec_bt_pwr = dec_btpwr_lvl;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], preBtDecPwrLvl=%d, curBtDecPwrLvl=%d\n",
			  coex_dm->pre_dec_bt_pwr, coex_dm->cur_dec_bt_pwr);
	}
	halbtc8192e2ant_set_fwdec_btpwr(btcoexist, coex_dm->cur_dec_bt_pwr);

	coex_dm->pre_dec_bt_pwr = coex_dm->cur_dec_bt_pwr;
}

static void halbtc8192e2ant_set_bt_autoreport(struct btc_coexist *btcoexist,
					      bool enable_autoreport)
{
	u8 h2c_parameter[1] = {0};

	h2c_parameter[0] = 0;

	if (enable_autoreport)
		h2c_parameter[0] |= BIT0;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex], BT FW auto report : %s, FW write 0x68 = 0x%x\n",
		  (enable_autoreport ? "Enabled!!" : "Disabled!!"),
		  h2c_parameter[0]);

	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
}

static void halbtc8192e2ant_bt_autoreport(struct btc_coexist *btcoexist,
					  bool force_exec,
					  bool enable_autoreport)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW,
		  "[BTCoex], %s BT Auto report = %s\n",
		  (force_exec ? "force to" : ""),
		  ((enable_autoreport) ? "Enabled" : "Disabled"));
	coex_dm->cur_bt_auto_report = enable_autoreport;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex] bPreBtAutoReport=%d, bCurBtAutoReport=%d\n",
			  coex_dm->pre_bt_auto_report,
			  coex_dm->cur_bt_auto_report);

		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
			return;
	}
	halbtc8192e2ant_set_bt_autoreport(btcoexist,
					  coex_dm->cur_bt_auto_report);

	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
}

static void halbtc8192e2ant_fw_dac_swinglvl(struct btc_coexist *btcoexist,
					    bool force_exec, u8 fw_dac_swinglvl)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW,
		  "[BTCoex], %s set FW Dac Swing level = %d\n",
		  (force_exec ? "force to" : ""), fw_dac_swinglvl);
	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swinglvl;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex] preFwDacSwingLvl=%d, curFwDacSwingLvl=%d\n",
			  coex_dm->pre_fw_dac_swing_lvl,
			  coex_dm->cur_fw_dac_swing_lvl);

		if (coex_dm->pre_fw_dac_swing_lvl ==
		    coex_dm->cur_fw_dac_swing_lvl)
			return;
	}

	halbtc8192e2ant_setfw_dac_swinglevel(btcoexist,
					     coex_dm->cur_fw_dac_swing_lvl);

	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
}

static void btc8192e2ant_set_sw_rf_rx_lpf_corner(struct btc_coexist *btcoexist,
						 bool rx_rf_shrink_on)
{
	if (rx_rf_shrink_on) {
		/* Shrink RF Rx LPF corner */
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
			  "[BTCoex], Shrink RF Rx LPF corner!!\n");
		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
					  0xfffff, 0xffffc);
	} else {
		/* Resume RF Rx LPF corner
		 * After initialized, we can use coex_dm->btRf0x1eBackup
		 */
		if (btcoexist->initilized) {
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
				  "[BTCoex], Resume RF Rx LPF corner!!\n");
			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
						  0xfffff,
						  coex_dm->bt_rf0x1e_backup);
		}
	}
}

static void halbtc8192e2ant_rf_shrink(struct btc_coexist *btcoexist,
				      bool force_exec, bool rx_rf_shrink_on)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW,
		  "[BTCoex], %s turn Rx RF Shrink = %s\n",
		  (force_exec ? "force to" : ""),
		  ((rx_rf_shrink_on) ? "ON" : "OFF"));
	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "[BTCoex]bPreRfRxLpfShrink=%d,bCurRfRxLpfShrink=%d\n",
			  coex_dm->pre_rf_rx_lpf_shrink,
			  coex_dm->cur_rf_rx_lpf_shrink);

		if (coex_dm->pre_rf_rx_lpf_shrink ==
		    coex_dm->cur_rf_rx_lpf_shrink)
			return;
	}
	btc8192e2ant_set_sw_rf_rx_lpf_corner(btcoexist,
					     coex_dm->cur_rf_rx_lpf_shrink);

	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
}

static void halbtc8192e2ant_set_dac_swingreg(struct btc_coexist *btcoexist,
					     u32 level)
{
	u8 val = (u8)level;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
		  "[BTCoex], Write SwDacSwing = 0x%x\n", level);
	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x883, 0x3e, val);
}

static void btc8192e2ant_setsw_full_swing(struct btc_coexist *btcoexist,
					  bool sw_dac_swingon,
					  u32 sw_dac_swinglvl)
{
	if (sw_dac_swingon)
		halbtc8192e2ant_set_dac_swingreg(btcoexist, sw_dac_swinglvl);
	else
		halbtc8192e2ant_set_dac_swingreg(btcoexist, 0x18);
}

static void halbtc8192e2ant_DacSwing(struct btc_coexist *btcoexist,
				     bool force_exec, bool dac_swingon,
				     u32 dac_swinglvl)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW,
		  "[BTCoex], %s turn DacSwing=%s, dac_swinglvl = 0x%x\n",
		  (force_exec ? "force to" : ""),
		  ((dac_swingon) ? "ON" : "OFF"), dac_swinglvl);
	coex_dm->cur_dac_swing_on = dac_swingon;
	coex_dm->cur_dac_swing_lvl = dac_swinglvl;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "[BTCoex], bPreDacSwingOn=%d, preDacSwingLvl = 0x%x, ",
			  coex_dm->pre_dac_swing_on,
			  coex_dm->pre_dac_swing_lvl);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "bCurDacSwingOn=%d, curDacSwingLvl = 0x%x\n",
			  coex_dm->cur_dac_swing_on,
			  coex_dm->cur_dac_swing_lvl);

		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
		    (coex_dm->pre_dac_swing_lvl == coex_dm->cur_dac_swing_lvl))
			return;
	}
	mdelay(30);
	btc8192e2ant_setsw_full_swing(btcoexist, dac_swingon, dac_swinglvl);

	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
}

static void halbtc8192e2ant_set_agc_table(struct btc_coexist *btcoexist,
					  bool agc_table_en)
{
	/* BB AGC Gain Table */
	if (agc_table_en) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
			  "[BTCoex], BB Agc Table On!\n");
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x0a1A0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x091B0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x081C0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x071D0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x061E0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x051F0001);
	} else {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
			  "[BTCoex], BB Agc Table Off!\n");
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
	}
}

static void halbtc8192e2ant_AgcTable(struct btc_coexist *btcoexist,
				     bool force_exec, bool agc_table_en)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW,
		  "[BTCoex], %s %s Agc Table\n",
		  (force_exec ? "force to" : ""),
		  ((agc_table_en) ? "Enable" : "Disable"));
	coex_dm->cur_agc_table_en = agc_table_en;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "[BTCoex], bPreAgcTableEn=%d, bCurAgcTableEn=%d\n",
			  coex_dm->pre_agc_table_en, coex_dm->cur_agc_table_en);

		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
			return;
	}
	halbtc8192e2ant_set_agc_table(btcoexist, agc_table_en);

	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
}

static void halbtc8192e2ant_set_coex_table(struct btc_coexist *btcoexist,
					   u32 val0x6c0, u32 val0x6c4,
					   u32 val0x6c8, u8 val0x6cc)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
		  "[BTCoex], set coex table, set 0x6c0 = 0x%x\n", val0x6c0);
	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
		  "[BTCoex], set coex table, set 0x6c4 = 0x%x\n", val0x6c4);
	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
		  "[BTCoex], set coex table, set 0x6c8 = 0x%x\n", val0x6c8);
	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC,
		  "[BTCoex], set coex table, set 0x6cc = 0x%x\n", val0x6cc);
	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
}

static void halbtc8192e2ant_coex_table(struct btc_coexist *btcoexist,
				       bool force_exec,
				       u32 val0x6c0, u32 val0x6c4,
				       u32 val0x6c8, u8 val0x6cc)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW,
		  "[BTCoex], %s write Coex Table 0x6c0 = 0x%x, ",
		  (force_exec ? "force to" : ""), val0x6c0);
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW,
		  "0x6c4 = 0x%x, 0x6c8 = 0x%x, 0x6cc = 0x%x\n",
		  val0x6c4, val0x6c8, val0x6cc);
	coex_dm->cur_val0x6c0 = val0x6c0;
	coex_dm->cur_val0x6c4 = val0x6c4;
	coex_dm->cur_val0x6c8 = val0x6c8;
	coex_dm->cur_val0x6cc = val0x6cc;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "[BTCoex], preVal0x6c0 = 0x%x, preVal0x6c4 = 0x%x, ",
			  coex_dm->pre_val0x6c0, coex_dm->pre_val0x6c4);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "preVal0x6c8 = 0x%x, preVal0x6cc = 0x%x !!\n",
			  coex_dm->pre_val0x6c8, coex_dm->pre_val0x6cc);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "[BTCoex], curVal0x6c0 = 0x%x, curVal0x6c4 = 0x%x,\n",
			  coex_dm->cur_val0x6c0, coex_dm->cur_val0x6c4);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL,
			  "curVal0x6c8 = 0x%x, curVal0x6cc = 0x%x !!\n",
			  coex_dm->cur_val0x6c8, coex_dm->cur_val0x6cc);

		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
			return;
	}
	halbtc8192e2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4,
				       val0x6c8, val0x6cc);

	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
}

static void btc8192e2ant_coex_tbl_w_type(struct btc_coexist *btcoexist,
					 bool force_exec, u8 type)
{
	switch (type) {
	case 0:
		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55555555,
					   0x5a5a5a5a, 0xffffff, 0x3);
		break;
	case 1:
		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x5a5a5a5a,
					   0x5a5a5a5a, 0xffffff, 0x3);
		break;
	case 2:
		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0x55555555,
					   0x5ffb5ffb, 0xffffff, 0x3);
		break;
	case 3:
		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0xdfffdfff,
					   0x5fdb5fdb, 0xffffff, 0x3);
		break;
	case 4:
		halbtc8192e2ant_coex_table(btcoexist, force_exec, 0xdfffdfff,
					   0x5ffb5ffb, 0xffffff, 0x3);
		break;
	default:
		break;
	}
}

static void halbtc8192e2ant_set_fw_ignore_wlanact(struct btc_coexist *btcoexist,
						  bool enable)
{
	u8 h2c_parameter[1] = {0};

	if (enable)
		h2c_parameter[0] |= BIT0; /* function enable */

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex]set FW for BT Ignore Wlan_Act, FW write 0x63 = 0x%x\n",
		  h2c_parameter[0]);

	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
}

static void halbtc8192e2ant_IgnoreWlanAct(struct btc_coexist *btcoexist,
					  bool force_exec, bool enable)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW,
		  "[BTCoex], %s turn Ignore WlanAct %s\n",
		  (force_exec ? "force to" : ""), (enable ? "ON" : "OFF"));
	coex_dm->cur_ignore_wlan_act = enable;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], bPreIgnoreWlanAct = %d ",
			  coex_dm->pre_ignore_wlan_act);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "bCurIgnoreWlanAct = %d!!\n",
			  coex_dm->cur_ignore_wlan_act);

		if (coex_dm->pre_ignore_wlan_act ==
		    coex_dm->cur_ignore_wlan_act)
			return;
	}
	halbtc8192e2ant_set_fw_ignore_wlanact(btcoexist, enable);

	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
}

static void halbtc8192e2ant_SetFwPstdma(struct btc_coexist *btcoexist, u8 byte1,
					u8 byte2, u8 byte3, u8 byte4, u8 byte5)
{
	u8 h2c_parameter[5] = {0};

	h2c_parameter[0] = byte1;
	h2c_parameter[1] = byte2;
	h2c_parameter[2] = byte3;
	h2c_parameter[3] = byte4;
	h2c_parameter[4] = byte5;

	coex_dm->ps_tdma_para[0] = byte1;
	coex_dm->ps_tdma_para[1] = byte2;
	coex_dm->ps_tdma_para[2] = byte3;
	coex_dm->ps_tdma_para[3] = byte4;
	coex_dm->ps_tdma_para[4] = byte5;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex], FW write 0x60(5bytes) = 0x%x%08x\n",
		  h2c_parameter[0],
		  h2c_parameter[1] << 24 | h2c_parameter[2] << 16 |
		  h2c_parameter[3] << 8 | h2c_parameter[4]);

	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
}

static void btc8192e2ant_sw_mec1(struct btc_coexist *btcoexist,
				 bool shrink_rx_lpf, bool low_penalty_ra,
				 bool limited_dig, bool btlan_constrain)
{
	halbtc8192e2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf);
}

static void btc8192e2ant_sw_mec2(struct btc_coexist *btcoexist,
				 bool agc_table_shift, bool adc_backoff,
				 bool sw_dac_swing, u32 dac_swinglvl)
{
	halbtc8192e2ant_AgcTable(btcoexist, NORMAL_EXEC, agc_table_shift);
	halbtc8192e2ant_DacSwing(btcoexist, NORMAL_EXEC, sw_dac_swing,
				 dac_swinglvl);
}

static void halbtc8192e2ant_ps_tdma(struct btc_coexist *btcoexist,
				    bool force_exec, bool turn_on, u8 type)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW,
		  "[BTCoex], %s turn %s PS TDMA, type=%d\n",
		  (force_exec ? "force to" : ""),
		  (turn_on ? "ON" : "OFF"), type);
	coex_dm->cur_ps_tdma_on = turn_on;
	coex_dm->cur_ps_tdma = type;

	if (!force_exec) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], bPrePsTdmaOn = %d, bCurPsTdmaOn = %d!!\n",
			  coex_dm->pre_ps_tdma_on, coex_dm->cur_ps_tdma_on);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], prePsTdma = %d, curPsTdma = %d!!\n",
			  coex_dm->pre_ps_tdma, coex_dm->cur_ps_tdma);

		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
			return;
	}
	if (turn_on) {
		switch (type) {
		case 1:
		default:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1a,
						    0x1a, 0xe1, 0x90);
			break;
		case 2:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x12,
						    0x12, 0xe1, 0x90);
			break;
		case 3:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1c,
						    0x3, 0xf1, 0x90);
			break;
		case 4:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x10,
						    0x3, 0xf1, 0x90);
			break;
		case 5:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1a,
						    0x1a, 0x60, 0x90);
			break;
		case 6:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x12,
						    0x12, 0x60, 0x90);
			break;
		case 7:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1c,
						    0x3, 0x70, 0x90);
			break;
		case 8:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xa3, 0x10,
						    0x3, 0x70, 0x90);
			break;
		case 9:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1a,
						    0x1a, 0xe1, 0x10);
			break;
		case 10:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x12,
						    0x12, 0xe1, 0x10);
			break;
		case 11:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1c,
						    0x3, 0xf1, 0x10);
			break;
		case 12:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x10,
						    0x3, 0xf1, 0x10);
			break;
		case 13:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1a,
						    0x1a, 0xe0, 0x10);
			break;
		case 14:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x12,
						    0x12, 0xe0, 0x10);
			break;
		case 15:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1c,
						    0x3, 0xf0, 0x10);
			break;
		case 16:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x12,
						    0x3, 0xf0, 0x10);
			break;
		case 17:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0x61, 0x20,
						    0x03, 0x10, 0x10);
			break;
		case 18:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x5,
						    0x5, 0xe1, 0x90);
			break;
		case 19:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x25,
						    0x25, 0xe1, 0x90);
			break;
		case 20:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x25,
						    0x25, 0x60, 0x90);
			break;
		case 21:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x15,
						    0x03, 0x70, 0x90);
			break;
		case 71:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0xe3, 0x1a,
						    0x1a, 0xe1, 0x90);
			break;
		}
	} else {
		/* disable PS tdma */
		switch (type) {
		default:
		case 0:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0x8, 0x0, 0x0,
						    0x0, 0x0);
			btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
			break;
		case 1:
			halbtc8192e2ant_SetFwPstdma(btcoexist, 0x0, 0x0, 0x0,
						    0x8, 0x0);
			mdelay(5);
			btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x20);
			break;
		}
	}

	/* update pre state */
	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
}

static void halbtc8192e2ant_set_switch_sstype(struct btc_coexist *btcoexist,
					      u8 sstype)
{
	u8 mimops = BTC_MIMO_PS_DYNAMIC;
	u32 disra_mask = 0x0;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
		  "[BTCoex], REAL set SS Type = %d\n", sstype);

	disra_mask = halbtc8192e2ant_decidera_mask(btcoexist, sstype,
						   coex_dm->curra_masktype);
	halbtc8192e2ant_Updatera_mask(btcoexist, FORCE_EXEC, disra_mask);

	if (sstype == 1) {
		halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
		/* switch ofdm path */
		btcoexist->btc_write_1byte(btcoexist, 0xc04, 0x11);
		btcoexist->btc_write_1byte(btcoexist, 0xd04, 0x1);
		btcoexist->btc_write_4byte(btcoexist, 0x90c, 0x81111111);
		/* switch cck patch */
		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xe77, 0x4, 0x1);
		btcoexist->btc_write_1byte(btcoexist, 0xa07, 0x81);
		mimops = BTC_MIMO_PS_STATIC;
	} else if (sstype == 2) {
		halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
		btcoexist->btc_write_1byte(btcoexist, 0xc04, 0x33);
		btcoexist->btc_write_1byte(btcoexist, 0xd04, 0x3);
		btcoexist->btc_write_4byte(btcoexist, 0x90c, 0x81121313);
		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xe77, 0x4, 0x0);
		btcoexist->btc_write_1byte(btcoexist, 0xa07, 0x41);
		mimops = BTC_MIMO_PS_DYNAMIC;
	}
	/* set rx 1ss or 2ss */
	btcoexist->btc_set(btcoexist, BTC_SET_ACT_SEND_MIMO_PS, &mimops);
}

static void halbtc8192e2ant_switch_sstype(struct btc_coexist *btcoexist,
					  bool force_exec, u8 new_sstype)
{
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
		  "[BTCoex], %s Switch SS Type = %d\n",
		  (force_exec ? "force to" : ""), new_sstype);
	coex_dm->cur_sstype = new_sstype;

	if (!force_exec) {
		if (coex_dm->pre_sstype == coex_dm->cur_sstype)
			return;
	}
	halbtc8192e2ant_set_switch_sstype(btcoexist, coex_dm->cur_sstype);

	coex_dm->pre_sstype = coex_dm->cur_sstype;
}

static void halbtc8192e2ant_coex_alloff(struct btc_coexist *btcoexist)
{
	/* fw all off */
	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);
	halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);

	/* sw all off */
	btc8192e2ant_sw_mec1(btcoexist, false, false, false, false);
	btc8192e2ant_sw_mec2(btcoexist, false, false, false, 0x18);

	/* hw all off */
	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 0);
}

static void halbtc8192e2ant_init_coex_dm(struct btc_coexist *btcoexist)
{
	/* force to reset coex mechanism */

	halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, FORCE_EXEC, 6);
	halbtc8192e2ant_dec_btpwr(btcoexist, FORCE_EXEC, 0);

	btc8192e2ant_coex_tbl_w_type(btcoexist, FORCE_EXEC, 0);
	halbtc8192e2ant_switch_sstype(btcoexist, FORCE_EXEC, 2);

	btc8192e2ant_sw_mec1(btcoexist, false, false, false, false);
	btc8192e2ant_sw_mec2(btcoexist, false, false, false, 0x18);
}

static void halbtc8192e2ant_action_bt_inquiry(struct btc_coexist *btcoexist)
{
	bool low_pwr_disable = true;

	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
			   &low_pwr_disable);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 2);
	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);
	halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);

	btc8192e2ant_sw_mec1(btcoexist, false, false, false, false);
	btc8192e2ant_sw_mec2(btcoexist, false, false, false, 0x18);
}

static bool halbtc8192e2ant_is_common_action(struct btc_coexist *btcoexist)
{
	struct btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
	bool common = false, wifi_connected = false, wifi_busy = false;
	bool bt_hson = false, low_pwr_disable = false;

	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hson);
	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
			   &wifi_connected);
	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);

	if (bt_link_info->sco_exist || bt_link_info->hid_exist)
		halbtc8192e2ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 0, 0, 0);
	else
		halbtc8192e2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);

	if (!wifi_connected) {
		low_pwr_disable = false;
		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
				   &low_pwr_disable);

		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], Wifi non-connected idle!!\n");

		if ((BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
		     coex_dm->bt_status) ||
		    (BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE ==
		     coex_dm->bt_status)) {
			halbtc8192e2ant_switch_sstype(btcoexist,
						      NORMAL_EXEC, 2);
			btc8192e2ant_coex_tbl_w_type(btcoexist,
						     NORMAL_EXEC, 1);
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						false, 0);
		} else {
			halbtc8192e2ant_switch_sstype(btcoexist,
						      NORMAL_EXEC, 1);
			btc8192e2ant_coex_tbl_w_type(btcoexist,
						     NORMAL_EXEC, 0);
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						false, 1);
		}

		halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);

		btc8192e2ant_sw_mec1(btcoexist, false, false, false, false);
		btc8192e2ant_sw_mec2(btcoexist, false, false, false, 0x18);

		common = true;
	} else {
		if (BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
		    coex_dm->bt_status) {
			low_pwr_disable = false;
			btcoexist->btc_set(btcoexist,
					   BTC_SET_ACT_DISABLE_LOW_POWER,
					   &low_pwr_disable);

			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Wifi connected + BT non connected-idle!!\n");

			halbtc8192e2ant_switch_sstype(btcoexist,
						      NORMAL_EXEC, 2);
			btc8192e2ant_coex_tbl_w_type(btcoexist,
						     NORMAL_EXEC, 1);
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						false, 0);
			halbtc8192e2ant_fw_dac_swinglvl(btcoexist,
							NORMAL_EXEC, 6);
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);

			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);

			common = true;
		} else if (BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE ==
			   coex_dm->bt_status) {
			low_pwr_disable = true;
			btcoexist->btc_set(btcoexist,
					   BTC_SET_ACT_DISABLE_LOW_POWER,
					   &low_pwr_disable);

			if (bt_hson)
				return false;
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Wifi connected + BT connected-idle!!\n");

			halbtc8192e2ant_switch_sstype(btcoexist,
						      NORMAL_EXEC, 2);
			btc8192e2ant_coex_tbl_w_type(btcoexist,
						     NORMAL_EXEC, 1);
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						false, 0);
			halbtc8192e2ant_fw_dac_swinglvl(btcoexist,
							NORMAL_EXEC, 6);
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);

			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);

			common = true;
		} else {
			low_pwr_disable = true;
			btcoexist->btc_set(btcoexist,
					   BTC_SET_ACT_DISABLE_LOW_POWER,
					   &low_pwr_disable);

			if (wifi_busy) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "Wifi Connected-Busy + BT Busy!!\n");
				common = false;
			} else {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "Wifi Connected-Idle + BT Busy!!\n");

				halbtc8192e2ant_switch_sstype(btcoexist,
							      NORMAL_EXEC, 1);
				btc8192e2ant_coex_tbl_w_type(btcoexist,
							     NORMAL_EXEC, 2);
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 21);
				halbtc8192e2ant_fw_dac_swinglvl(btcoexist,
								NORMAL_EXEC, 6);
				halbtc8192e2ant_dec_btpwr(btcoexist,
							  NORMAL_EXEC, 0);
				btc8192e2ant_sw_mec1(btcoexist, false,
						     false, false, false);
				btc8192e2ant_sw_mec2(btcoexist, false,
						     false, false, 0x18);
				common = true;
			}
		}
	}
	return common;
}

static void btc8192e_int1(struct btc_coexist *btcoexist, bool tx_pause,
			  int result)
{
	if (tx_pause) {
		BTC_PRINT(BTC_MSG_ALGORITHM,
			  ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], TxPause = 1\n");

		if (coex_dm->cur_ps_tdma == 71) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 5);
			coex_dm->tdma_adj_type = 5;
		} else if (coex_dm->cur_ps_tdma == 1) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 5);
			coex_dm->tdma_adj_type = 5;
		} else if (coex_dm->cur_ps_tdma == 2) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 6);
			coex_dm->tdma_adj_type = 6;
		} else if (coex_dm->cur_ps_tdma == 3) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 7);
			coex_dm->tdma_adj_type = 7;
		} else if (coex_dm->cur_ps_tdma == 4) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 8);
			coex_dm->tdma_adj_type = 8;
		}
		if (coex_dm->cur_ps_tdma == 9) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 13);
			coex_dm->tdma_adj_type = 13;
		} else if (coex_dm->cur_ps_tdma == 10) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 14);
			coex_dm->tdma_adj_type = 14;
		} else if (coex_dm->cur_ps_tdma == 11) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 15);
			coex_dm->tdma_adj_type = 15;
		} else if (coex_dm->cur_ps_tdma == 12) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 16);
			coex_dm->tdma_adj_type = 16;
		}

		if (result == -1) {
			if (coex_dm->cur_ps_tdma == 5) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 6);
				coex_dm->tdma_adj_type = 6;
			} else if (coex_dm->cur_ps_tdma == 6) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 7) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 8);
				coex_dm->tdma_adj_type = 8;
			} else if (coex_dm->cur_ps_tdma == 13) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 14);
				coex_dm->tdma_adj_type = 14;
			} else if (coex_dm->cur_ps_tdma == 14) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 15) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 16);
				coex_dm->tdma_adj_type = 16;
			}
		} else if (result == 1) {
			if (coex_dm->cur_ps_tdma == 8) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 7) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 6);
				coex_dm->tdma_adj_type = 6;
			} else if (coex_dm->cur_ps_tdma == 6) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 5);
				coex_dm->tdma_adj_type = 5;
			} else if (coex_dm->cur_ps_tdma == 16) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 15) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 14);
				coex_dm->tdma_adj_type = 14;
			} else if (coex_dm->cur_ps_tdma == 14) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 13);
				coex_dm->tdma_adj_type = 13;
			}
		}
	} else {
		BTC_PRINT(BTC_MSG_ALGORITHM,
			  ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], TxPause = 0\n");
		if (coex_dm->cur_ps_tdma == 5) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 71);
			coex_dm->tdma_adj_type = 71;
		} else if (coex_dm->cur_ps_tdma == 6) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 2);
			coex_dm->tdma_adj_type = 2;
		} else if (coex_dm->cur_ps_tdma == 7) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 3);
			coex_dm->tdma_adj_type = 3;
		} else if (coex_dm->cur_ps_tdma == 8) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 4);
			coex_dm->tdma_adj_type = 4;
		}
		if (coex_dm->cur_ps_tdma == 13) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 9);
			coex_dm->tdma_adj_type = 9;
		} else if (coex_dm->cur_ps_tdma == 14) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 10);
			coex_dm->tdma_adj_type = 10;
		} else if (coex_dm->cur_ps_tdma == 15) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 11);
			coex_dm->tdma_adj_type = 11;
		} else if (coex_dm->cur_ps_tdma == 16) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 12);
			coex_dm->tdma_adj_type = 12;
		}

		if (result == -1) {
			if (coex_dm->cur_ps_tdma == 71) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 1);
				coex_dm->tdma_adj_type = 1;
			} else if (coex_dm->cur_ps_tdma == 1) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 2);
				coex_dm->tdma_adj_type = 2;
			} else if (coex_dm->cur_ps_tdma == 2) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 3) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 4);
				coex_dm->tdma_adj_type = 4;
			} else if (coex_dm->cur_ps_tdma == 9) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 10);
				coex_dm->tdma_adj_type = 10;
			} else if (coex_dm->cur_ps_tdma == 10) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 11) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 12);
				coex_dm->tdma_adj_type = 12;
			}
		} else if (result == 1) {
			if (coex_dm->cur_ps_tdma == 4) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 3) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 2);
				coex_dm->tdma_adj_type = 2;
			} else if (coex_dm->cur_ps_tdma == 2) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 1);
				coex_dm->tdma_adj_type = 1;
			} else if (coex_dm->cur_ps_tdma == 1) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 71);
				coex_dm->tdma_adj_type = 71;
			} else if (coex_dm->cur_ps_tdma == 12) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 11) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 10);
				coex_dm->tdma_adj_type = 10;
			} else if (coex_dm->cur_ps_tdma == 10) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 9);
				coex_dm->tdma_adj_type = 9;
			}
		}
	}
}

static void btc8192e_int2(struct btc_coexist *btcoexist, bool tx_pause,
			  int result)
{
	if (tx_pause) {
		BTC_PRINT(BTC_MSG_ALGORITHM,
			  ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], TxPause = 1\n");
		if (coex_dm->cur_ps_tdma == 1) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 6);
			coex_dm->tdma_adj_type = 6;
		} else if (coex_dm->cur_ps_tdma == 2) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 6);
			coex_dm->tdma_adj_type = 6;
		} else if (coex_dm->cur_ps_tdma == 3) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 7);
			coex_dm->tdma_adj_type = 7;
		} else if (coex_dm->cur_ps_tdma == 4) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 8);
			coex_dm->tdma_adj_type = 8;
		}
		if (coex_dm->cur_ps_tdma == 9) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 14);
			coex_dm->tdma_adj_type = 14;
		} else if (coex_dm->cur_ps_tdma == 10) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 14);
			coex_dm->tdma_adj_type = 14;
		} else if (coex_dm->cur_ps_tdma == 11) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 15);
			coex_dm->tdma_adj_type = 15;
		} else if (coex_dm->cur_ps_tdma == 12) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 16);
			coex_dm->tdma_adj_type = 16;
		}
		if (result == -1) {
			if (coex_dm->cur_ps_tdma == 5) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 6);
				coex_dm->tdma_adj_type = 6;
			} else if (coex_dm->cur_ps_tdma == 6) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 7) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 8);
				coex_dm->tdma_adj_type = 8;
			} else if (coex_dm->cur_ps_tdma == 13) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 14);
				coex_dm->tdma_adj_type = 14;
			} else if (coex_dm->cur_ps_tdma == 14) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 15) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 16);
				coex_dm->tdma_adj_type = 16;
			}
		} else if (result == 1) {
			if (coex_dm->cur_ps_tdma == 8) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 7) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 6);
				coex_dm->tdma_adj_type = 6;
			} else if (coex_dm->cur_ps_tdma == 6) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 6);
				coex_dm->tdma_adj_type = 6;
			} else if (coex_dm->cur_ps_tdma == 16) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 15) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 14);
				coex_dm->tdma_adj_type = 14;
			} else if (coex_dm->cur_ps_tdma == 14) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 14);
				coex_dm->tdma_adj_type = 14;
			}
		}
	} else {
		BTC_PRINT(BTC_MSG_ALGORITHM,
			  ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], TxPause = 0\n");
		if (coex_dm->cur_ps_tdma == 5) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 2);
			coex_dm->tdma_adj_type = 2;
		} else if (coex_dm->cur_ps_tdma == 6) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 2);
			coex_dm->tdma_adj_type = 2;
		} else if (coex_dm->cur_ps_tdma == 7) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 3);
			coex_dm->tdma_adj_type = 3;
		} else if (coex_dm->cur_ps_tdma == 8) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 4);
			coex_dm->tdma_adj_type = 4;
		}
		if (coex_dm->cur_ps_tdma == 13) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 10);
			coex_dm->tdma_adj_type = 10;
		} else if (coex_dm->cur_ps_tdma == 14) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 10);
			coex_dm->tdma_adj_type = 10;
		} else if (coex_dm->cur_ps_tdma == 15) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 11);
			coex_dm->tdma_adj_type = 11;
		} else if (coex_dm->cur_ps_tdma == 16) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 12);
			coex_dm->tdma_adj_type = 12;
		}
		if (result == -1) {
			if (coex_dm->cur_ps_tdma == 1) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 2);
				coex_dm->tdma_adj_type = 2;
			} else if (coex_dm->cur_ps_tdma == 2) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 3) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 4);
				coex_dm->tdma_adj_type = 4;
			} else if (coex_dm->cur_ps_tdma == 9) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 10);
				coex_dm->tdma_adj_type = 10;
			} else if (coex_dm->cur_ps_tdma == 10) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 11) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 12);
				coex_dm->tdma_adj_type = 12;
			}
		} else if (result == 1) {
			if (coex_dm->cur_ps_tdma == 4) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 3) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 2);
				coex_dm->tdma_adj_type = 2;
			} else if (coex_dm->cur_ps_tdma == 2) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 2);
				coex_dm->tdma_adj_type = 2;
			} else if (coex_dm->cur_ps_tdma == 12) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 11) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 10);
				coex_dm->tdma_adj_type = 10;
			} else if (coex_dm->cur_ps_tdma == 10) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 10);
				coex_dm->tdma_adj_type = 10;
			}
		}
	}
}

static void btc8192e_int3(struct btc_coexist *btcoexist, bool tx_pause,
			  int result)
{
	if (tx_pause) {
		BTC_PRINT(BTC_MSG_ALGORITHM,
			  ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], TxPause = 1\n");
		if (coex_dm->cur_ps_tdma == 1) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 7);
			coex_dm->tdma_adj_type = 7;
		} else if (coex_dm->cur_ps_tdma == 2) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 7);
			coex_dm->tdma_adj_type = 7;
		} else if (coex_dm->cur_ps_tdma == 3) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 7);
			coex_dm->tdma_adj_type = 7;
		} else if (coex_dm->cur_ps_tdma == 4) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 8);
			coex_dm->tdma_adj_type = 8;
		}
		if (coex_dm->cur_ps_tdma == 9) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 15);
			coex_dm->tdma_adj_type = 15;
		} else if (coex_dm->cur_ps_tdma == 10) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 15);
			coex_dm->tdma_adj_type = 15;
		} else if (coex_dm->cur_ps_tdma == 11) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 15);
			coex_dm->tdma_adj_type = 15;
		} else if (coex_dm->cur_ps_tdma == 12) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 16);
			coex_dm->tdma_adj_type = 16;
		}
		if (result == -1) {
			if (coex_dm->cur_ps_tdma == 5) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 6) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 7) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 8);
				coex_dm->tdma_adj_type = 8;
			} else if (coex_dm->cur_ps_tdma == 13) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 14) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 15) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 16);
				coex_dm->tdma_adj_type = 16;
			}
		} else if (result == 1) {
			if (coex_dm->cur_ps_tdma == 8) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 7) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 6) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 7);
				coex_dm->tdma_adj_type = 7;
			} else if (coex_dm->cur_ps_tdma == 16) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 15) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			} else if (coex_dm->cur_ps_tdma == 14) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 15);
				coex_dm->tdma_adj_type = 15;
			}
		}
	} else {
		BTC_PRINT(BTC_MSG_ALGORITHM,
			  ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], TxPause = 0\n");
		if (coex_dm->cur_ps_tdma == 5) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 3);
			coex_dm->tdma_adj_type = 3;
		} else if (coex_dm->cur_ps_tdma == 6) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 3);
			coex_dm->tdma_adj_type = 3;
		} else if (coex_dm->cur_ps_tdma == 7) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 3);
			coex_dm->tdma_adj_type = 3;
		} else if (coex_dm->cur_ps_tdma == 8) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 4);
			coex_dm->tdma_adj_type = 4;
		}
		if (coex_dm->cur_ps_tdma == 13) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 11);
			coex_dm->tdma_adj_type = 11;
		} else if (coex_dm->cur_ps_tdma == 14) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 11);
			coex_dm->tdma_adj_type = 11;
		} else if (coex_dm->cur_ps_tdma == 15) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 11);
			coex_dm->tdma_adj_type = 11;
		} else if (coex_dm->cur_ps_tdma == 16) {
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 12);
			coex_dm->tdma_adj_type = 12;
		}
		if (result == -1) {
			if (coex_dm->cur_ps_tdma == 1) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 2) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 3) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 4);
				coex_dm->tdma_adj_type = 4;
			} else if (coex_dm->cur_ps_tdma == 9) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 10) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 11) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 12);
				coex_dm->tdma_adj_type = 12;
			}
		} else if (result == 1) {
			if (coex_dm->cur_ps_tdma == 4) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 3) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 2) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 3);
				coex_dm->tdma_adj_type = 3;
			} else if (coex_dm->cur_ps_tdma == 12) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 11) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			} else if (coex_dm->cur_ps_tdma == 10) {
				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
							true, 11);
				coex_dm->tdma_adj_type = 11;
			}
		}
	}
}

static void halbtc8192e2ant_tdma_duration_adjust(struct btc_coexist *btcoexist,
						 bool sco_hid, bool tx_pause,
						 u8 max_interval)
{
	static int up, dn, m, n, wait_cnt;
	/* 0: no change, +1: increase WiFi duration,
	 * -1: decrease WiFi duration
	 */
	int result;
	u8 retry_cnt = 0;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW,
		  "[BTCoex], TdmaDurationAdjust()\n");

	if (!coex_dm->auto_tdma_adjust) {
		coex_dm->auto_tdma_adjust = true;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], first run TdmaDurationAdjust()!!\n");
		if (sco_hid) {
			if (tx_pause) {
				if (max_interval == 1) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 13);
					coex_dm->tdma_adj_type = 13;
				} else if (max_interval == 2) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 14);
					coex_dm->tdma_adj_type = 14;
				} else if (max_interval == 3) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 15);
					coex_dm->tdma_adj_type = 15;
				} else {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 15);
					coex_dm->tdma_adj_type = 15;
				}
			} else {
				if (max_interval == 1) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 9);
					coex_dm->tdma_adj_type = 9;
				} else if (max_interval == 2) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 10);
					coex_dm->tdma_adj_type = 10;
				} else if (max_interval == 3) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 11);
					coex_dm->tdma_adj_type = 11;
				} else {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 11);
					coex_dm->tdma_adj_type = 11;
				}
			}
		} else {
			if (tx_pause) {
				if (max_interval == 1) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 5);
					coex_dm->tdma_adj_type = 5;
				} else if (max_interval == 2) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 6);
					coex_dm->tdma_adj_type = 6;
				} else if (max_interval == 3) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 7);
					coex_dm->tdma_adj_type = 7;
				} else {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 7);
					coex_dm->tdma_adj_type = 7;
				}
			} else {
				if (max_interval == 1) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 1);
					coex_dm->tdma_adj_type = 1;
				} else if (max_interval == 2) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 2);
					coex_dm->tdma_adj_type = 2;
				} else if (max_interval == 3) {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 3);
					coex_dm->tdma_adj_type = 3;
				} else {
					halbtc8192e2ant_ps_tdma(btcoexist,
								NORMAL_EXEC,
								true, 3);
					coex_dm->tdma_adj_type = 3;
				}
			}
		}

		up = 0;
		dn = 0;
		m = 1;
		n = 3;
		result = 0;
		wait_cnt = 0;
	} else {
		/* accquire the BT TRx retry count from BT_Info byte2 */
		retry_cnt = coex_sta->bt_retry_cnt;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], retry_cnt = %d\n", retry_cnt);
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], up=%d, dn=%d, m=%d, n=%d, wait_cnt=%d\n",
			  up, dn, m, n, wait_cnt);
		result = 0;
		wait_cnt++;
		/* no retry in the last 2-second duration */
		if (retry_cnt == 0) {
			up++;
			dn--;

			if (dn <= 0)
				dn = 0;

			if (up >= n) {
				wait_cnt = 0;
				n = 3;
				up = 0;
				dn = 0;
				result = 1;
				BTC_PRINT(BTC_MSG_ALGORITHM,
					  ALGO_TRACE_FW_DETAIL,
					  "[BTCoex]Increase wifi duration!!\n");
			}
		} else if (retry_cnt <= 3) {
			up--;
			dn++;

			if (up <= 0)
				up = 0;

			if (dn == 2) {
				if (wait_cnt <= 2)
					m++;
				else
					m = 1;

				if (m >= 20)
					m = 20;

				n = 3 * m;
				up = 0;
				dn = 0;
				wait_cnt = 0;
				result = -1;
				BTC_PRINT(BTC_MSG_ALGORITHM,
					  ALGO_TRACE_FW_DETAIL,
					  "Reduce wifi duration for retry<3\n");
			}
		} else {
			if (wait_cnt == 1)
				m++;
			else
				m = 1;

			if (m >= 20)
				m = 20;

			n = 3*m;
			up = 0;
			dn = 0;
			wait_cnt = 0;
			result = -1;
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
				  "Decrease wifi duration for retryCounter>3!!\n");
		}

		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], max Interval = %d\n", max_interval);
		if (max_interval == 1)
			btc8192e_int1(btcoexist, tx_pause, result);
		else if (max_interval == 2)
			btc8192e_int2(btcoexist, tx_pause, result);
		else if (max_interval == 3)
			btc8192e_int3(btcoexist, tx_pause, result);
	}

	/* if current PsTdma not match with
	 * the recorded one (when scan, dhcp...),
	 * then we have to adjust it back to the previous record one.
	 */
	if (coex_dm->cur_ps_tdma != coex_dm->tdma_adj_type) {
		bool scan = false, link = false, roam = false;

		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "[BTCoex], PsTdma type dismatch!!!, ");
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL,
			  "curPsTdma=%d, recordPsTdma=%d\n",
			  coex_dm->cur_ps_tdma, coex_dm->tdma_adj_type);

		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);

		if (!scan && !link && !roam)
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true,
						coex_dm->tdma_adj_type);
		else
			BTC_PRINT(BTC_MSG_ALGORITHM,
				  ALGO_TRACE_FW_DETAIL,
				  "[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
	}
}

/* SCO only or SCO+PAN(HS) */
static void halbtc8192e2ant_action_sco(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_STAY_LOW;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 4);

	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
	}

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	/* sw mechanism */
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x6);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x6);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x6);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x6);
		}
	}
}

static void halbtc8192e2ant_action_sco_pan(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_STAY_LOW;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 4);

	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
	}

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	/* sw mechanism */
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x6);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x6);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x6);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x6);
		}
	}
}

static void halbtc8192e2ant_action_hid(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 3);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
	}

	/* sw mechanism */
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
static void halbtc8192e2ant_action_a2dp(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;
	bool long_dist = false;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	if ((btrssi_state == BTC_RSSI_STATE_LOW ||
	     btrssi_state == BTC_RSSI_STATE_STAY_LOW) &&
	    (wifirssi_state == BTC_RSSI_STATE_LOW ||
	     wifirssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], A2dp, wifi/bt rssi both LOW!!\n");
		long_dist = true;
	}
	if (long_dist) {
		halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
					   0x4);
	} else {
		halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
		halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
					   0x8);
	}

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	if (long_dist)
		btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 0);
	else
		btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 2);

	if (long_dist) {
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 17);
		coex_dm->auto_tdma_adjust = false;
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
	} else {
		if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
		    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
			halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
							     true, 1);
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
			   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
			halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
							     false, 1);
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
			   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
							     false, 1);
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		}
	}

	/* sw mechanism */
	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

static void halbtc8192e2ant_action_a2dp_pan_hs(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);
	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 2);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, true, 2);
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
						     false, 2);
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
						     false, 2);
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
	}

	/* sw mechanism */
	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     true, 0x6);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     true, 0x6);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     true, 0x6);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     true, 0x6);
		}
	}
}

static void halbtc8192e2ant_action_pan_edr(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 2);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
	}

	/* sw mechanism */
	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

/* PAN(HS) only */
static void halbtc8192e2ant_action_pan_hs(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 2);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
	}
	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

/* PAN(EDR)+A2DP */
static void halbtc8192e2ant_action_pan_edr_a2dp(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 2);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, true, 3);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
						     false, 3);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
						     false, 3);
	}

	/* sw mechanism	*/
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, false,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

static void halbtc8192e2ant_action_pan_edr_hid(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 3);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 10);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
						true, 10);
	}

	/* sw mechanism */
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

/* HID+A2DP+PAN(EDR) */
static void btc8192e2ant_action_hid_a2dp_pan_edr(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	halbtc8192e2ant_fw_dac_swinglvl(btcoexist, NORMAL_EXEC, 6);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 3);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, true, 3);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 3);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 3);
	}

	/* sw mechanism */
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

static void halbtc8192e2ant_action_hid_a2dp(struct btc_coexist *btcoexist)
{
	u8 wifirssi_state, btrssi_state = BTC_RSSI_STATE_HIGH;
	u32 wifi_bw;

	wifirssi_state = halbtc8192e2ant_wifirssi_state(btcoexist, 0, 2, 15, 0);
	btrssi_state = halbtc8192e2ant_btrssi_state(3, 34, 42);

	halbtc8192e2ant_switch_sstype(btcoexist, NORMAL_EXEC, 1);
	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);

	btc8192e2ant_coex_tbl_w_type(btcoexist, NORMAL_EXEC, 3);

	if ((btrssi_state == BTC_RSSI_STATE_LOW) ||
	    (btrssi_state == BTC_RSSI_STATE_STAY_LOW)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 0);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, true, 2);
	} else if ((btrssi_state == BTC_RSSI_STATE_MEDIUM) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_MEDIUM))	{
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 2);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 2);
	} else if ((btrssi_state == BTC_RSSI_STATE_HIGH) ||
		   (btrssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
		halbtc8192e2ant_dec_btpwr(btcoexist, NORMAL_EXEC, 4);
		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 2);
	}

	/* sw mechanism */
	if (BTC_WIFI_BW_HT40 == wifi_bw) {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, true, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	} else {
		if ((wifirssi_state == BTC_RSSI_STATE_HIGH) ||
		    (wifirssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, true, false,
					     false, 0x18);
		} else {
			btc8192e2ant_sw_mec1(btcoexist, false, true,
					     false, false);
			btc8192e2ant_sw_mec2(btcoexist, false, false,
					     false, 0x18);
		}
	}
}

static void halbtc8192e2ant_run_coexist_mechanism(struct btc_coexist *btcoexist)
{
	u8 algorithm = 0;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
		  "[BTCoex], RunCoexistMechanism()===>\n");

	if (btcoexist->manual_control) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], return for Manual CTRL <===\n");
		return;
	}

	if (coex_sta->under_ips) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], wifi is under IPS !!!\n");
		return;
	}

	algorithm = halbtc8192e2ant_action_algorithm(btcoexist);
	if (coex_sta->c2h_bt_inquiry_page &&
	    (BT_8192E_2ANT_COEX_ALGO_PANHS != algorithm)) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], BT is under inquiry/page scan !!\n");
		halbtc8192e2ant_action_bt_inquiry(btcoexist);
		return;
	}

	coex_dm->cur_algorithm = algorithm;
	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
		  "[BTCoex], Algorithm = %d\n", coex_dm->cur_algorithm);

	if (halbtc8192e2ant_is_common_action(btcoexist)) {
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], Action 2-Ant common.\n");
		coex_dm->auto_tdma_adjust = false;
	} else {
		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "[BTCoex] preAlgorithm=%d, curAlgorithm=%d\n",
				  coex_dm->pre_algorithm,
				  coex_dm->cur_algorithm);
			coex_dm->auto_tdma_adjust = false;
		}
		switch (coex_dm->cur_algorithm) {
		case BT_8192E_2ANT_COEX_ALGO_SCO:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = SCO.\n");
			halbtc8192e2ant_action_sco(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_SCO_PAN:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = SCO+PAN(EDR).\n");
			halbtc8192e2ant_action_sco_pan(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_HID:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = HID.\n");
			halbtc8192e2ant_action_hid(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_A2DP:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = A2DP.\n");
			halbtc8192e2ant_action_a2dp(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
			halbtc8192e2ant_action_a2dp_pan_hs(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_PANEDR:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = PAN(EDR).\n");
			halbtc8192e2ant_action_pan_edr(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_PANHS:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = HS mode.\n");
			halbtc8192e2ant_action_pan_hs(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = PAN+A2DP.\n");
			halbtc8192e2ant_action_pan_edr_a2dp(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_PANEDR_HID:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
			halbtc8192e2ant_action_pan_edr_hid(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
			btc8192e2ant_action_hid_a2dp_pan_edr(btcoexist);
			break;
		case BT_8192E_2ANT_COEX_ALGO_HID_A2DP:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = HID+A2DP.\n");
			halbtc8192e2ant_action_hid_a2dp(btcoexist);
			break;
		default:
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "Action 2-Ant, algorithm = unknown!!\n");
			/* halbtc8192e2ant_coex_alloff(btcoexist); */
			break;
		}
		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
	}
}

static void halbtc8192e2ant_init_hwconfig(struct btc_coexist *btcoexist,
					  bool backup)
{
	u16 u16tmp = 0;
	u8 u8tmp = 0;

	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
		  "[BTCoex], 2Ant Init HW Config!!\n");

	if (backup) {
		/* backup rf 0x1e value */
		coex_dm->bt_rf0x1e_backup =
			btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A,
						  0x1e, 0xfffff);

		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
								      0x430);
		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
								     0x434);
		coex_dm->backup_retrylimit = btcoexist->btc_read_2byte(
								    btcoexist,
								    0x42a);
		coex_dm->backup_ampdu_maxtime = btcoexist->btc_read_1byte(
								    btcoexist,
								    0x456);
	}

	/* antenna sw ctrl to bt */
	btcoexist->btc_write_1byte(btcoexist, 0x4f, 0x6);
	btcoexist->btc_write_1byte(btcoexist, 0x944, 0x24);
	btcoexist->btc_write_4byte(btcoexist, 0x930, 0x700700);
	btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x20);
	if (btcoexist->chip_interface == BTC_INTF_USB)
		btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
	else
		btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);

	btc8192e2ant_coex_tbl_w_type(btcoexist, FORCE_EXEC, 0);

	/* antenna switch control parameter */
	btcoexist->btc_write_4byte(btcoexist, 0x858, 0x55555555);

	/* coex parameters */
	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
	/* 0x790[5:0] = 0x5 */
	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
	u8tmp &= 0xc0;
	u8tmp |= 0x5;
	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);

	/* enable counter statistics */
	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);

	/* enable PTA */
	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
	/* enable mailbox interface */
	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x40);
	u16tmp |= BIT9;
	btcoexist->btc_write_2byte(btcoexist, 0x40, u16tmp);

	/* enable PTA I2C mailbox  */
	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x101);
	u8tmp |= BIT4;
	btcoexist->btc_write_1byte(btcoexist, 0x101, u8tmp);

	/* enable bt clock when wifi is disabled. */
	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x93);
	u8tmp |= BIT0;
	btcoexist->btc_write_1byte(btcoexist, 0x93, u8tmp);
	/* enable bt clock when suspend. */
	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
	u8tmp |= BIT0;
	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
}

/*************************************************************
 *   work around function start with wa_halbtc8192e2ant_
 *************************************************************/

/************************************************************
 *   extern function start with EXhalbtc8192e2ant_
 ************************************************************/

void ex_halbtc8192e2ant_init_hwconfig(struct btc_coexist *btcoexist)
{
	halbtc8192e2ant_init_hwconfig(btcoexist, true);
}

void ex_halbtc8192e2ant_init_coex_dm(struct btc_coexist *btcoexist)
{
	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
		  "[BTCoex], Coex Mechanism Init!!\n");
	halbtc8192e2ant_init_coex_dm(btcoexist);
}

void ex_halbtc8192e2ant_display_coex_info(struct btc_coexist *btcoexist)
{
	struct btc_board_info *board_info = &btcoexist->board_info;
	struct btc_stack_info *stack_info = &btcoexist->stack_info;
	struct rtl_priv *rtlpriv = btcoexist->adapter;
	u8 u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
	u16 u16tmp[4];
	u32 u32tmp[4];
	bool roam = false, scan = false, link = false, wifi_under_5g = false;
	bool bt_hson = false, wifi_busy = false;
	int wifirssi = 0, bt_hs_rssi = 0;
	u32 wifi_bw, wifi_traffic_dir;
	u8 wifi_dot11_chnl, wifi_hs_chnl;
	u32 fw_ver = 0, bt_patch_ver = 0;

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		   "\r\n ============[BT Coexist info]============");

	if (btcoexist->manual_control) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
			   "\r\n ===========[Under Manual Control]===========");
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
			   "\r\n ==========================================");
	}

	if (!board_info->bt_exist) {
		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n BT not exists !!!");
		return;
	}

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		   "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:",
		   board_info->pg_ant_num, board_info->btdm_ant_num);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %s / %d",
		   "BT stack/ hci ext ver",
		   ((stack_info->profile_notified) ? "Yes" : "No"),
		   stack_info->hci_version);

	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
		   "CoexVer/ FwVer/ PatchVer",
		   glcoex_ver_date_8192e_2ant, glcoex_ver_8192e_2ant,
		   fw_ver, bt_patch_ver, bt_patch_ver);

	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hson);
	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_DOT11_CHNL,
			   &wifi_dot11_chnl);
	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifi_hs_chnl);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d / %d(%d)",
		   "Dot11 channel / HsMode(HsChnl)",
		   wifi_dot11_chnl, bt_hson, wifi_hs_chnl);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %02x %02x %02x ",
		   "H2C Wifi inform bt chnl Info", coex_dm->wifi_chnl_info[0],
		   coex_dm->wifi_chnl_info[1], coex_dm->wifi_chnl_info[2]);

	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifirssi);
	btcoexist->btc_get(btcoexist, BTC_GET_S4_HS_RSSI, &bt_hs_rssi);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d",
		   "Wifi rssi/ HS rssi", wifirssi, bt_hs_rssi);

	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d/ %d ",
		   "Wifi link/ roam/ scan", link, roam, scan);

	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,
			   &wifi_traffic_dir);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %s / %s/ %s ",
		   "Wifi status", (wifi_under_5g ? "5G" : "2.4G"),
		   ((BTC_WIFI_BW_LEGACY == wifi_bw) ? "Legacy" :
			(((BTC_WIFI_BW_HT40 == wifi_bw) ? "HT40" : "HT20"))),
		   ((!wifi_busy) ? "idle" :
			((BTC_WIFI_TRAFFIC_TX == wifi_traffic_dir) ?
				"uplink" : "downlink")));

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = [%s/ %d/ %d] ",
		   "BT [status/ rssi/ retryCnt]",
		   ((btcoexist->bt_info.bt_disabled) ? ("disabled") :
		    ((coex_sta->c2h_bt_inquiry_page) ?
		     ("inquiry/page scan") :
		      ((BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
			coex_dm->bt_status) ? "non-connected idle" :
			 ((BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE ==
			   coex_dm->bt_status) ? "connected-idle" : "busy")))),
		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d / %d / %d / %d",
		   "SCO/HID/PAN/A2DP", stack_info->sco_exist,
		   stack_info->hid_exist, stack_info->pan_exist,
		   stack_info->a2dp_exist);
	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);

	bt_info_ext = coex_sta->bt_info_ext;
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %s",
		   "BT Info A2DP rate",
		   (bt_info_ext&BIT0) ? "Basic rate" : "EDR rate");

	for (i = 0; i < BT_INFO_SRC_8192E_2ANT_MAX; i++) {
		if (coex_sta->bt_info_c2h_cnt[i]) {
			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
				   "\r\n %-35s = %02x %02x %02x %02x ",
				   GLBtInfoSrc8192e2Ant[i],
				   coex_sta->bt_info_c2h[i][0],
				   coex_sta->bt_info_c2h[i][1],
				   coex_sta->bt_info_c2h[i][2],
				   coex_sta->bt_info_c2h[i][3]);
			RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
				   "%02x %02x %02x(%d)",
				   coex_sta->bt_info_c2h[i][4],
				   coex_sta->bt_info_c2h[i][5],
				   coex_sta->bt_info_c2h[i][6],
				   coex_sta->bt_info_c2h_cnt[i]);
		}
	}

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %s/%s",
		   "PS state, IPS/LPS",
		   ((coex_sta->under_ips ? "IPS ON" : "IPS OFF")),
		   ((coex_sta->under_lps ? "LPS ON" : "LPS OFF")));
	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x ", "SS Type",
		   coex_dm->cur_sstype);

	/* Sw mechanism	*/
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s",
		   "============[Sw mechanism]============");
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d/ %d ",
		   "SM1[ShRf/ LpRA/ LimDig]", coex_dm->cur_rf_rx_lpf_shrink,
		   coex_dm->cur_low_penalty_ra, coex_dm->limited_dig);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x ", "Rate Mask",
		   btcoexist->bt_info.ra_mask);

	/* Fw mechanism	*/
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s",
		   "============[Fw mechanism]============");

	ps_tdma_case = coex_dm->cur_ps_tdma;
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
		   "PS TDMA", coex_dm->ps_tdma_para[0],
		   coex_dm->ps_tdma_para[1], coex_dm->ps_tdma_para[2],
		   coex_dm->ps_tdma_para[3], coex_dm->ps_tdma_para[4],
		   ps_tdma_case, coex_dm->auto_tdma_adjust);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d ",
		   "DecBtPwr/ IgnWlanAct",
		   coex_dm->cur_dec_bt_pwr, coex_dm->cur_ignore_wlan_act);

	/* Hw setting */
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s",
		   "============[Hw setting]============");

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x",
		   "RF-A, 0x1e initVal", coex_dm->bt_rf0x1e_backup);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
		   "backup ARFR1/ARFR2/RL/AMaxTime", coex_dm->backup_arfr_cnt1,
		   coex_dm->backup_arfr_cnt2, coex_dm->backup_retrylimit,
		   coex_dm->backup_ampdu_maxtime);

	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
		   "0x430/0x434/0x42a/0x456",
		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);

	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc04);
	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xd04);
	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x90c);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
		   "0xc04/ 0xd04/ 0x90c", u32tmp[0], u32tmp[1], u32tmp[2]);

	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x", "0x778",
		   u8tmp[0]);

	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x92c);
	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x930);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x/ 0x%x",
		   "0x92c/ 0x930", (u8tmp[0]), u32tmp[0]);

	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x4f);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x/ 0x%x",
		   "0x40/ 0x4f", u8tmp[0], u8tmp[1]);

	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x/ 0x%x",
		   "0x550(bcn ctrl)/0x522", u32tmp[0], u8tmp[0]);

	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = 0x%x", "0xc50(dig)",
		   u32tmp[0]);

	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,
		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);

	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d",
		   "0x770(hp rx[31:16]/tx[15:0])",
		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
	RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "\r\n %-35s = %d/ %d",
		   "0x774(lp rx[31:16]/tx[15:0])",
		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 1)
	halbtc8192e2ant_monitor_bt_ctr(btcoexist);
#endif
	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
}

void ex_halbtc8192e2ant_ips_notify(struct btc_coexist *btcoexist, u8 type)
{
	if (BTC_IPS_ENTER == type) {
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], IPS ENTER notify\n");
		coex_sta->under_ips = true;
		halbtc8192e2ant_coex_alloff(btcoexist);
	} else if (BTC_IPS_LEAVE == type) {
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], IPS LEAVE notify\n");
		coex_sta->under_ips = false;
	}
}

void ex_halbtc8192e2ant_lps_notify(struct btc_coexist *btcoexist, u8 type)
{
	if (BTC_LPS_ENABLE == type) {
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], LPS ENABLE notify\n");
		coex_sta->under_lps = true;
	} else if (BTC_LPS_DISABLE == type) {
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], LPS DISABLE notify\n");
		coex_sta->under_lps = false;
	}
}

void ex_halbtc8192e2ant_scan_notify(struct btc_coexist *btcoexist, u8 type)
{
	if (BTC_SCAN_START == type)
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], SCAN START notify\n");
	else if (BTC_SCAN_FINISH == type)
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], SCAN FINISH notify\n");
}

void ex_halbtc8192e2ant_connect_notify(struct btc_coexist *btcoexist, u8 type)
{
	if (BTC_ASSOCIATE_START == type)
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], CONNECT START notify\n");
	else if (BTC_ASSOCIATE_FINISH == type)
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], CONNECT FINISH notify\n");
}

void ex_halbtc8192e2ant_media_status_notify(struct btc_coexist *btcoexist,
					    u8 type)
{
	u8 h2c_parameter[3] = {0};
	u32 wifi_bw;
	u8 wifi_center_chnl;

	if (btcoexist->manual_control ||
	    btcoexist->stop_coex_dm ||
	    btcoexist->bt_info.bt_disabled)
		return;

	if (BTC_MEDIA_CONNECT == type)
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], MEDIA connect notify\n");
	else
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], MEDIA disconnect notify\n");

	/* only 2.4G we need to inform bt the chnl mask */
	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
			   &wifi_center_chnl);
	if ((BTC_MEDIA_CONNECT == type) &&
	    (wifi_center_chnl <= 14)) {
		h2c_parameter[0] = 0x1;
		h2c_parameter[1] = wifi_center_chnl;
		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
		if (BTC_WIFI_BW_HT40 == wifi_bw)
			h2c_parameter[2] = 0x30;
		else
			h2c_parameter[2] = 0x20;
	}

	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC,
		  "[BTCoex], FW write 0x66 = 0x%x\n",
		  h2c_parameter[0] << 16 | h2c_parameter[1] << 8 |
		  h2c_parameter[2]);

	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
}

void ex_halbtc8192e2ant_special_packet_notify(struct btc_coexist *btcoexist,
					      u8 type)
{
	if (type == BTC_PACKET_DHCP)
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
			  "[BTCoex], DHCP Packet notify\n");
}

void ex_halbtc8192e2ant_bt_info_notify(struct btc_coexist *btcoexist,
				       u8 *tmp_buf, u8 length)
{
	u8 bt_info = 0;
	u8 i, rsp_source = 0;
	bool bt_busy = false, limited_dig = false;
	bool wifi_connected = false;

	coex_sta->c2h_bt_info_req_sent = false;

	rsp_source = tmp_buf[0] & 0xf;
	if (rsp_source >= BT_INFO_SRC_8192E_2ANT_MAX)
		rsp_source = BT_INFO_SRC_8192E_2ANT_WIFI_FW;
	coex_sta->bt_info_c2h_cnt[rsp_source]++;

	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
		  "[BTCoex], Bt info[%d], length=%d, hex data = [",
		  rsp_source, length);
	for (i = 0; i < length; i++) {
		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
		if (i == 1)
			bt_info = tmp_buf[i];
		if (i == length-1)
			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
				  "0x%02x]\n", tmp_buf[i]);
		else
			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY,
				  "0x%02x, ", tmp_buf[i]);
	}

	if (BT_INFO_SRC_8192E_2ANT_WIFI_FW != rsp_source) {
		coex_sta->bt_retry_cnt =	/* [3:0] */
			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;

		coex_sta->bt_rssi =
			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;

		coex_sta->bt_info_ext =
			coex_sta->bt_info_c2h[rsp_source][4];

		/* Here we need to resend some wifi info to BT
		 * because bt is reset and loss of the info.
		 */
		if ((coex_sta->bt_info_ext & BIT1)) {
			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
				  "bit1, send wifi BW&Chnl to BT!!\n");
			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
					   &wifi_connected);
			if (wifi_connected)
				ex_halbtc8192e2ant_media_status_notify(
							btcoexist,
							BTC_MEDIA_CONNECT);
			else
				ex_halbtc8192e2ant_media_status_notify(
							btcoexist,
							BTC_MEDIA_DISCONNECT);
		}

		if ((coex_sta->bt_info_ext & BIT3)) {
			if (!btcoexist->manual_control &&
			    !btcoexist->stop_coex_dm) {
				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
					  "bit3, BT NOT ignore Wlan active!\n");
				halbtc8192e2ant_IgnoreWlanAct(btcoexist,
							      FORCE_EXEC,
							      false);
			}
		} else {
			/* BT already NOT ignore Wlan active,
			 * do nothing here.
			 */
		}

#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 0)
		if ((coex_sta->bt_info_ext & BIT4)) {
			/* BT auto report already enabled, do nothing */
		} else {
			halbtc8192e2ant_bt_autoreport(btcoexist, FORCE_EXEC,
						      true);
		}
#endif
	}

	/* check BIT2 first ==> check if bt is under inquiry or page scan */
	if (bt_info & BT_INFO_8192E_2ANT_B_INQ_PAGE)
		coex_sta->c2h_bt_inquiry_page = true;
	else
		coex_sta->c2h_bt_inquiry_page = false;

	/* set link exist status */
	if (!(bt_info&BT_INFO_8192E_2ANT_B_CONNECTION)) {
		coex_sta->bt_link_exist = false;
		coex_sta->pan_exist = false;
		coex_sta->a2dp_exist = false;
		coex_sta->hid_exist = false;
		coex_sta->sco_exist = false;
	} else {/* connection exists */
		coex_sta->bt_link_exist = true;
		if (bt_info & BT_INFO_8192E_2ANT_B_FTP)
			coex_sta->pan_exist = true;
		else
			coex_sta->pan_exist = false;
		if (bt_info & BT_INFO_8192E_2ANT_B_A2DP)
			coex_sta->a2dp_exist = true;
		else
			coex_sta->a2dp_exist = false;
		if (bt_info & BT_INFO_8192E_2ANT_B_HID)
			coex_sta->hid_exist = true;
		else
			coex_sta->hid_exist = false;
		if (bt_info & BT_INFO_8192E_2ANT_B_SCO_ESCO)
			coex_sta->sco_exist = true;
		else
			coex_sta->sco_exist = false;
	}

	halbtc8192e2ant_update_btlink_info(btcoexist);

	if (!(bt_info&BT_INFO_8192E_2ANT_B_CONNECTION)) {
		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], BT Non-Connected idle!!!\n");
	} else if (bt_info == BT_INFO_8192E_2ANT_B_CONNECTION) {
		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], bt_infoNotify(), BT Connected-idle!!!\n");
	} else if ((bt_info&BT_INFO_8192E_2ANT_B_SCO_ESCO) ||
		   (bt_info&BT_INFO_8192E_2ANT_B_SCO_BUSY)) {
		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_SCO_BUSY;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], bt_infoNotify(), BT SCO busy!!!\n");
	} else if (bt_info&BT_INFO_8192E_2ANT_B_ACL_BUSY) {
		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_ACL_BUSY;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex], bt_infoNotify(), BT ACL busy!!!\n");
	} else {
		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_MAX;
		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
			  "[BTCoex]bt_infoNotify(), BT Non-Defined state!!!\n");
	}

	if ((BT_8192E_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
	    (BT_8192E_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
	    (BT_8192E_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
		bt_busy = true;
		limited_dig = true;
	} else {
		bt_busy = false;
		limited_dig = false;
	}

	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);

	coex_dm->limited_dig = limited_dig;
	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);

	halbtc8192e2ant_run_coexist_mechanism(btcoexist);
}

void ex_halbtc8192e2ant_stack_operation_notify(struct btc_coexist *btcoexist,
					       u8 type)
{
}

void ex_halbtc8192e2ant_halt_notify(struct btc_coexist *btcoexist)
{
	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, "[BTCoex], Halt notify\n");

	halbtc8192e2ant_IgnoreWlanAct(btcoexist, FORCE_EXEC, true);
	ex_halbtc8192e2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
}

void ex_halbtc8192e2ant_periodical(struct btc_coexist *btcoexist)
{
	static u8 dis_ver_info_cnt;
	u32 fw_ver = 0, bt_patch_ver = 0;
	struct btc_board_info *board_info = &btcoexist->board_info;
	struct btc_stack_info *stack_info = &btcoexist->stack_info;

	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE,
		  "=======================Periodical=======================\n");
	if (dis_ver_info_cnt <= 5) {
		dis_ver_info_cnt += 1;
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
			  "************************************************\n");
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
			  "Ant PG Num/ Ant Mech/ Ant Pos = %d/ %d/ %d\n",
			  board_info->pg_ant_num, board_info->btdm_ant_num,
			  board_info->btdm_ant_pos);
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
			  "BT stack/ hci ext ver = %s / %d\n",
			  ((stack_info->profile_notified) ? "Yes" : "No"),
			  stack_info->hci_version);
		btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER,
				   &bt_patch_ver);
		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
			  "CoexVer/ FwVer/ PatchVer = %d_%x/ 0x%x/ 0x%x(%d)\n",
			  glcoex_ver_date_8192e_2ant, glcoex_ver_8192e_2ant,
			  fw_ver, bt_patch_ver, bt_patch_ver);
		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT,
			  "************************************************\n");
	}

#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 0)
	halbtc8192e2ant_querybt_info(btcoexist);
	halbtc8192e2ant_monitor_bt_ctr(btcoexist);
	btc8192e2ant_monitor_bt_enable_dis(btcoexist);
#else
	if (halbtc8192e2ant_iswifi_status_changed(btcoexist) ||
	    coex_dm->auto_tdma_adjust)
		halbtc8192e2ant_run_coexist_mechanism(btcoexist);
#endif
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Sonics Silicon Backplane
 * Broadcom EXTIF core driver
 *
 * Copyright 2005, Broadcom Corporation
 * Copyright 2006, 2007, Michael Buesch <m@bues.ch>
 * Copyright 2006, 2007, Felix Fietkau <nbd@openwrt.org>
 * Copyright 2007, Aurelien Jarno <aurelien@aurel32.net>
 *
 * Licensed under the GNU/GPL. See COPYING for details.
 */

#include <linux/serial.h>
#include <linux/serial_core.h>
#include <linux/serial_reg.h>

#include "ssb_private.h"


static inline u32 extif_read32(struct ssb_extif *extif, u16 offset)
{
	return ssb_read32(extif->dev, offset);
}

static inline void extif_write32(struct ssb_extif *extif, u16 offset, u32 value)
{
	ssb_write32(extif->dev, offset, value);
}

static inline u32 extif_write32_masked(struct ssb_extif *extif, u16 offset,
				       u32 mask, u32 value)
{
	value &= mask;
	value |= extif_read32(extif, offset) & ~mask;
	extif_write32(extif, offset, value);

	return value;
}

#ifdef CONFIG_SSB_SERIAL
static bool serial_exists(u8 *regs)
{
	u8 save_mcr, msr = 0;

	if (regs) {
		save_mcr = regs[UART_MCR];
		regs[UART_MCR] = (UART_MCR_LOOP | UART_MCR_OUT2 | UART_MCR_RTS);
		msr = regs[UART_MSR] & (UART_MSR_DCD | UART_MSR_RI
					| UART_MSR_CTS | UART_MSR_DSR);
		regs[UART_MCR] = save_mcr;
	}
	return (msr == (UART_MSR_DCD | UART_MSR_CTS));
}

int ssb_extif_serial_init(struct ssb_extif *extif, struct ssb_serial_port *ports)
{
	u32 i, nr_ports = 0;

	/* Disable GPIO interrupt initially */
	extif_write32(extif, SSB_EXTIF_GPIO_INTPOL, 0);
	extif_write32(extif, SSB_EXTIF_GPIO_INTMASK, 0);

	for (i = 0; i < 2; i++) {
		void __iomem *uart_regs;

		uart_regs = ioremap_nocache(SSB_EUART, 16);
		if (uart_regs) {
			uart_regs += (i * 8);

			if (serial_exists(uart_regs) && ports) {
				extif_write32(extif, SSB_EXTIF_GPIO_INTMASK, 2);

				nr_ports++;
				ports[i].regs = uart_regs;
				ports[i].irq = 2;
				ports[i].baud_base = 13500000;
				ports[i].reg_shift = 0;
			}
			iounmap(uart_regs);
		}
	}
	return nr_ports;
}
#endif /* CONFIG_SSB_SERIAL */

void ssb_extif_timing_init(struct ssb_extif *extif, unsigned long ns)
{
	u32 tmp;

	/* Initialize extif so we can get to the LEDs and external UART */
	extif_write32(extif, SSB_EXTIF_PROG_CFG, SSB_EXTCFG_EN);

	/* Set timing for the flash */
	tmp  = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;
	tmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;
	tmp |= DIV_ROUND_UP(120, ns);
	extif_write32(extif, SSB_EXTIF_PROG_WAITCNT, tmp);

	/* Set programmable interface timing for external uart */
	tmp  = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;
	tmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;
	tmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT;
	tmp |= DIV_ROUND_UP(120, ns);
	extif_write32(extif, SSB_EXTIF_PROG_WAITCNT, tmp);
}

void ssb_extif_get_clockcontrol(struct ssb_extif *extif,
				u32 *pll_type, u32 *n, u32 *m)
{
	*pll_type = SSB_PLLTYPE_1;
	*n = extif_read32(extif, SSB_EXTIF_CLOCK_N);
	*m = extif_read32(extif, SSB_EXTIF_CLOCK_SB);
}

u32 ssb_extif_watchdog_timer_set_wdt(struct bcm47xx_wdt *wdt, u32 ticks)
{
	struct ssb_extif *extif = bcm47xx_wdt_get_drvdata(wdt);

	return ssb_extif_watchdog_timer_set(extif, ticks);
}

u32 ssb_extif_watchdog_timer_set_ms(struct bcm47xx_wdt *wdt, u32 ms)
{
	struct ssb_extif *extif = bcm47xx_wdt_get_drvdata(wdt);
	u32 ticks = (SSB_EXTIF_WATCHDOG_CLK / 1000) * ms;

	ticks = ssb_extif_watchdog_timer_set(extif, ticks);

	return (ticks * 1000) / SSB_EXTIF_WATCHDOG_CLK;
}

u32 ssb_extif_watchdog_timer_set(struct ssb_extif *extif, u32 ticks)
{
	if (ticks > SSB_EXTIF_WATCHDOG_MAX_TIMER)
		ticks = SSB_EXTIF_WATCHDOG_MAX_TIMER;
	extif_write32(extif, SSB_EXTIF_WATCHDOG, ticks);

	return ticks;
}

void ssb_extif_init(struct ssb_extif *extif)
{
	if (!extif->dev)
		return; /* We don't have a Extif core */
	spin_lock_init(&extif->gpio_lock);
}

u32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask)
{
	return extif_read32(extif, SSB_EXTIF_GPIO_IN) & mask;
}

u32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask, u32 value)
{
	unsigned long flags;
	u32 res = 0;

	spin_lock_irqsave(&extif->gpio_lock, flags);
	res = extif_write32_masked(extif, SSB_EXTIF_GPIO_OUT(0),
				   mask, value);
	spin_unlock_irqrestore(&extif->gpio_lock, flags);

	return res;
}

u32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask, u32 value)
{
	unsigned long flags;
	u32 res = 0;

	spin_lock_irqsave(&extif->gpio_lock, flags);
	res = extif_write32_masked(extif, SSB_EXTIF_GPIO_OUTEN(0),
				   mask, value);
	spin_unlock_irqrestore(&extif->gpio_lock, flags);

	return res;
}

u32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask, u32 value)
{
	unsigned long flags;
	u32 res = 0;

	spin_lock_irqsave(&extif->gpio_lock, flags);
	res = extif_write32_masked(extif, SSB_EXTIF_GPIO_INTPOL, mask, value);
	spin_unlock_irqrestore(&extif->gpio_lock, flags);

	return res;
}

u32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask, u32 value)
{
	unsigned long flags;
	u32 res = 0;

	spin_lock_irqsave(&extif->gpio_lock, flags);
	res = extif_write32_masked(extif, SSB_EXTIF_GPIO_INTMASK, mask, value);
	spin_unlock_irqrestore(&extif->gpio_lock, flags);

	return res;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /******************************************************************************
 *
 * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
 *
 * Modifications for inclusion into the Linux staging tree are
 * Copyright(c) 2010 Larry Finger. All rights reserved.
 *
 * Contact information:
 * WLAN FAE <wlanfae@realtek.com>
 * Larry Finger <Larry.Finger@lwfinger.net>
 *
 ******************************************************************************/
#ifndef __RTL8712_GP_BITDEF_H__
#define __RTL8712_GP_BITDEF_H__

/*GPIO_CTRL*/
#define	_GPIO_MOD_MSK			0xFF000000
#define	_GPIO_MOD_SHT			24
#define	_GPIO_IO_SEL_MSK		0x00FF0000
#define	_GPIO_IO_SEL_SHT		16
#define	_GPIO_OUT_MSK			0x0000FF00
#define	_GPIO_OUT_SHT			8
#define	_GPIO_IN_MSK			0x000000FF
#define	_GPIO_IN_SHT			0

/*SYS_PINMUX_CFG*/
#define	_GPIOSEL_MSK			0x0003
#define	_GPIOSEL_SHT			0

/*LED_CFG*/
#define _LED1SV				BIT(7)
#define _LED1CM_MSK			0x0070
#define _LED1CM_SHT			4
#define _LED0SV				BIT(3)
#define _LED0CM_MSK			0x0007
#define _LED0CM_SHT			0

/*PHY_REG*/
#define _HST_RDRDY_SHT			0
#define _HST_RDRDY_MSK			0xFF
#define _HST_RDRDY			BIT(_HST_RDRDY_SHT)
#define _CPU_WTBUSY_SHT			1
#define _CPU_WTBUSY_MSK			0xFF
#define _CPU_WTBUSY			BIT(_CPU_WTBUSY_SHT)

/* 11. General Purpose Registers   (Offset: 0x02E0 - 0x02FF)*/

/*       8192S GPIO Config Setting (offset 0x2F1, 1 byte)*/

/*----------------------------------------------------------------------------*/

#define		GPIOMUX_EN	BIT(3)	/* When this bit is set to "1",
					 * GPIO PINs will switch to MAC
					 * GPIO Function*/
#define		GPIOSEL_GPIO	0	/* UART or JTAG or pure GPIO*/
#define		GPIOSEL_PHYDBG	1	/* PHYDBG*/
#define		GPIOSEL_BT	2	/* BT_coex*/
#define		GPIOSEL_WLANDBG	3	/* WLANDBG*/
#define		GPIOSEL_GPIO_MASK	(~(BIT(0)|BIT(1)))
/* HW Radio OFF switch (GPIO BIT) */
#define		HAL_8192S_HW_GPIO_OFF_BIT	BIT(3)
#define		HAL_8192S_HW_GPIO_OFF_MASK	0xF7
#define		HAL_8192S_HW_GPIO_WPS_BIT	BIT(4)

#endif	/*__RTL8712_GP_BITDEF_H__*/

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Driver for SMSC USB3503 USB 2.0 hub controller driver
 *
 * Copyright (c) 2012-2013 Dongjin Kim (tobetter@gmail.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <linux/clk.h>
#include <linux/i2c.h>
#include <linux/gpio.h>
#include <linux/delay.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/of_gpio.h>
#include <linux/platform_device.h>
#include <linux/platform_data/usb3503.h>
#include <linux/regmap.h>

#define USB3503_VIDL		0x00
#define USB3503_VIDM		0x01
#define USB3503_PIDL		0x02
#define USB3503_PIDM		0x03
#define USB3503_DIDL		0x04
#define USB3503_DIDM		0x05

#define USB3503_CFG1		0x06
#define USB3503_SELF_BUS_PWR	(1 << 7)

#define USB3503_CFG2		0x07
#define USB3503_CFG3		0x08
#define USB3503_NRD		0x09

#define USB3503_PDS		0x0a

#define USB3503_SP_ILOCK	0xe7
#define USB3503_SPILOCK_CONNECT	(1 << 1)
#define USB3503_SPILOCK_CONFIG	(1 << 0)

#define USB3503_CFGP		0xee
#define USB3503_CLKSUSP		(1 << 7)

#define USB3503_RESET		0xff

struct usb3503 {
	enum usb3503_mode	mode;
	struct regmap		*regmap;
	struct device		*dev;
	struct clk		*clk;
	u8	port_off_mask;
	int	gpio_intn;
	int	gpio_reset;
	int	gpio_connect;
	bool	secondary_ref_clk;
};

static int usb3503_reset(struct usb3503 *hub, int state)
{
	if (!state && gpio_is_valid(hub->gpio_connect))
		gpio_set_value_cansleep(hub->gpio_connect, 0);

	if (gpio_is_valid(hub->gpio_reset))
		gpio_set_value_cansleep(hub->gpio_reset, state);

	/* Wait T_HUBINIT == 4ms for hub logic to stabilize */
	if (state)
		usleep_range(4000, 10000);

	return 0;
}

static int usb3503_connect(struct usb3503 *hub)
{
	struct device *dev = hub->dev;
	int err;

	usb3503_reset(hub, 1);

	if (hub->regmap) {
		/* SP_ILOCK: set connect_n, config_n for config */
		err = regmap_write(hub->regmap, USB3503_SP_ILOCK,
			   (USB3503_SPILOCK_CONNECT
				 | USB3503_SPILOCK_CONFIG));
		if (err < 0) {
			dev_err(dev, "SP_ILOCK failed (%d)\n", err);
			return err;
		}

		/* PDS : Set the ports which are disabled in self-powered mode. */
		if (hub->port_off_mask) {
			err = regmap_update_bits(hub->regmap, USB3503_PDS,
					hub->port_off_mask,
					hub->port_off_mask);
			if (err < 0) {
				dev_err(dev, "PDS failed (%d)\n", err);
				return err;
			}
		}

		/* CFG1 : Set SELF_BUS_PWR, this enables self-powered operation. */
		err = regmap_update_bits(hub->regmap, USB3503_CFG1,
					 USB3503_SELF_BUS_PWR,
					 USB3503_SELF_BUS_PWR);
		if (err < 0) {
			dev_err(dev, "CFG1 failed (%d)\n", err);
			return err;
		}

		/* SP_LOCK: clear connect_n, config_n for hub connect */
		err = regmap_update_bits(hub->regmap, USB3503_SP_ILOCK,
					 (USB3503_SPILOCK_CONNECT
					  | USB3503_SPILOCK_CONFIG), 0);
		if (err < 0) {
			dev_err(dev, "SP_ILOCK failed (%d)\n", err);
			return err;
		}
	}

	if (gpio_is_valid(hub->gpio_connect))
		gpio_set_value_cansleep(hub->gpio_connect, 1);

	hub->mode = USB3503_MODE_HUB;
	dev_info(dev, "switched to HUB mode\n");

	return 0;
}

static int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)
{
	struct device *dev = hub->dev;
	int err = 0;

	switch (mode) {
	case USB3503_MODE_HUB:
		err = usb3503_connect(hub);
		break;

	case USB3503_MODE_STANDBY:
		usb3503_reset(hub, 0);
		dev_info(dev, "switched to STANDBY mode\n");
		break;

	default:
		dev_err(dev, "unknown mode is requested\n");
		err = -EINVAL;
		break;
	}

	return err;
}

static const struct regmap_config usb3503_regmap_config = {
	.reg_bits = 8,
	.val_bits = 8,

	.max_register = USB3503_RESET,
};

static int usb3503_probe(struct usb3503 *hub)
{
	struct device *dev = hub->dev;
	struct usb3503_platform_data *pdata = dev_get_platdata(dev);
	struct device_node *np = dev->of_node;
	int err;
	u32 mode = USB3503_MODE_HUB;
	const u32 *property;
	int len;

	if (pdata) {
		hub->port_off_mask	= pdata->port_off_mask;
		hub->gpio_intn		= pdata->gpio_intn;
		hub->gpio_connect	= pdata->gpio_connect;
		hub->gpio_reset		= pdata->gpio_reset;
		hub->mode		= pdata->initial_mode;
	} else if (np) {
		struct clk *clk;
		hub->port_off_mask = 0;

		clk = devm_clk_get(dev, "refclk");
		if (IS_ERR(clk) && PTR_ERR(clk) != -ENOENT) {
			dev_err(dev, "unable to request refclk (%ld)\n",
					PTR_ERR(clk));
			return PTR_ERR(clk);
		}

		if (!IS_ERR(clk)) {
			u32 rate = 0;
			hub->clk = clk;

			if (!of_property_read_u32(np, "refclk-frequency",
						 &rate)) {

				switch (rate) {
				case 38400000:
				case 26000000:
				case 19200000:
				case 12000000:
					hub->secondary_ref_clk = 0;
					break;
				case 24000000:
				case 27000000:
				case 25000000:
				case 50000000:
					hub->secondary_ref_clk = 1;
					break;
				default:
					dev_err(dev,
						"unsupported reference clock rate (%d)\n",
						(int) rate);
					return -EINVAL;
				}
				err = clk_set_rate(hub->clk, rate);
				if (err) {
					dev_err(dev,
						"unable to set reference clock rate to %d\n",
						(int) rate);
					return err;
				}
			}

			err = clk_prepare_enable(hub->clk);
			if (err) {
				dev_err(dev,
					"unable to enable reference clock\n");
				return err;
			}
		}

		property = of_get_property(np, "disabled-ports", &len);
		if (property && (len / sizeof(u32)) > 0) {
			int i;
			for (i = 0; i < len / sizeof(u32); i++) {
				u32 port = be32_to_cpu(property[i]);
				if ((1 <= port) && (port <= 3))
					hub->port_off_mask |= (1 << port);
			}
		}

		hub->gpio_intn	= of_get_named_gpio(np, "intn-gpios", 0);
		if (hub->gpio_intn == -EPROBE_DEFER)
			return -EPROBE_DEFER;
		hub->gpio_connect = of_get_named_gpio(np, "connect-gpios", 0);
		if (hub->gpio_connect == -EPROBE_DEFER)
			return -EPROBE_DEFER;
		hub->gpio_reset = of_get_named_gpio(np, "reset-gpios", 0);
		if (hub->gpio_reset == -EPROBE_DEFER)
			return -EPROBE_DEFER;
		of_property_read_u32(np, "initial-mode", &mode);
		hub->mode = mode;
	}

	if (hub->port_off_mask && !hub->regmap)
		dev_err(dev, "Ports disabled with no control interface\n");

	if (gpio_is_valid(hub->gpio_intn)) {
		int val = hub->secondary_ref_clk ? GPIOF_OUT_INIT_LOW :
						   GPIOF_OUT_INIT_HIGH;
		err = devm_gpio_request_one(dev, hub->gpio_intn, val,
					    "usb3503 intn");
		if (err) {
			dev_err(dev,
				"unable to request GPIO %d as interrupt pin (%d)\n",
				hub->gpio_intn, err);
			return err;
		}
	}

	if (gpio_is_valid(hub->gpio_connect)) {
		err = devm_gpio_request_one(dev, hub->gpio_connect,
				GPIOF_OUT_INIT_LOW, "usb3503 connect");
		if (err) {
			dev_err(dev,
				"unable to request GPIO %d as connect pin (%d)\n",
				hub->gpio_connect, err);
			return err;
		}
	}

	if (gpio_is_valid(hub->gpio_reset)) {
		err = devm_gpio_request_one(dev, hub->gpio_reset,
				GPIOF_OUT_INIT_LOW, "usb3503 reset");
		/* Datasheet defines a hardware reset to be at least 100us */
		usleep_range(100, 10000);
		if (err) {
			dev_err(dev,
				"unable to request GPIO %d as reset pin (%d)\n",
				hub->gpio_reset, err);
			return err;
		}
	}

	usb3503_switch_mode(hub, hub->mode);

	dev_info(dev, "%s: probed in %s mode\n", __func__,
			(hub->mode == USB3503_MODE_HUB) ? "hub" : "standby");

	return 0;
}

static int usb3503_i2c_probe(struct i2c_client *i2c,
			     const struct i2c_device_id *id)
{
	struct usb3503 *hub;
	int err;

	hub = devm_kzalloc(&i2c->dev, sizeof(struct usb3503), GFP_KERNEL);
	if (!hub) {
		dev_err(&i2c->dev, "private data alloc fail\n");
		return -ENOMEM;
	}

	i2c_set_clientdata(i2c, hub);
	hub->regmap = devm_regmap_init_i2c(i2c, &usb3503_regmap_config);
	if (IS_ERR(hub->regmap)) {
		err = PTR_ERR(hub->regmap);
		dev_err(&i2c->dev, "Failed to initialise regmap: %d\n", err);
		return err;
	}
	hub->dev = &i2c->dev;

	return usb3503_probe(hub);
}

static int usb3503_platform_probe(struct platform_device *pdev)
{
	struct usb3503 *hub;

	hub = devm_kzalloc(&pdev->dev, sizeof(struct usb3503), GFP_KERNEL);
	if (!hub) {
		dev_err(&pdev->dev, "private data alloc fail\n");
		return -ENOMEM;
	}
	hub->dev = &pdev->dev;

	return usb3503_probe(hub);
}

#ifdef CONFIG_PM_SLEEP
static int usb3503_i2c_suspend(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct usb3503 *hub = i2c_get_clientdata(client);

	usb3503_switch_mode(hub, USB3503_MODE_STANDBY);

	if (hub->clk)
		clk_disable_unprepare(hub->clk);

	return 0;
}

static int usb3503_i2c_resume(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct usb3503 *hub = i2c_get_clientdata(client);

	if (hub->clk)
		clk_prepare_enable(hub->clk);

	usb3503_switch_mode(hub, hub->mode);

	return 0;
}
#endif

static SIMPLE_DEV_PM_OPS(usb3503_i2c_pm_ops, usb3503_i2c_suspend,
		usb3503_i2c_resume);

static const struct i2c_device_id usb3503_id[] = {
	{ USB3503_I2C_NAME, 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, usb3503_id);

#ifdef CONFIG_OF
static const struct of_device_id usb3503_of_match[] = {
	{ .compatible = "smsc,usb3503", },
	{ .compatible = "smsc,usb3503a", },
	{},
};
MODULE_DEVICE_TABLE(of, usb3503_of_match);
#endif

static struct i2c_driver usb3503_i2c_driver = {
	.driver = {
		.name = USB3503_I2C_NAME,
		.pm = &usb3503_i2c_pm_ops,
		.of_match_table = of_match_ptr(usb3503_of_match),
	},
	.probe		= usb3503_i2c_probe,
	.id_table	= usb3503_id,
};

static struct platform_driver usb3503_platform_driver = {
	.driver = {
		.name = USB3503_I2C_NAME,
		.of_match_table = of_match_ptr(usb3503_of_match),
		.owner = THIS_MODULE,
	},
	.probe		= usb3503_platform_probe,
};

static int __init usb3503_init(void)
{
	int err;

	err = i2c_register_driver(THIS_MODULE, &usb3503_i2c_driver);
	if (err != 0)
		pr_err("usb3503: Failed to register I2C driver: %d\n", err);

	err = platform_driver_register(&usb3503_platform_driver);
	if (err != 0)
		pr_err("usb3503: Failed to register platform driver: %d\n",
		       err);

	return 0;
}
module_init(usb3503_init);

static void __exit usb3503_exit(void)
{
	platform_driver_unregister(&usb3503_platform_driver);
	i2c_del_driver(&usb3503_i2c_driver);
}
module_exit(usb3503_exit);

MODULE_AUTHOR("Dongjin Kim <tobetter@gmail.com>");
MODULE_DESCRIPTION("USB3503 USB HUB driver");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /* -*- mode: c; c-basic-offset: 8; -*-
 * vim: noexpandtab sw=8 ts=8 sts=0:
 *
 * Copyright (C) 2004, 2005 Oracle.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 021110-1307, USA.
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/string.h>
#include <asm/uaccess.h>

#include "masklog.h"

struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);
EXPORT_SYMBOL_GPL(mlog_and_bits);
struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);
EXPORT_SYMBOL_GPL(mlog_not_bits);

static ssize_t mlog_mask_show(u64 mask, char *buf)
{
	char *state;

	if (__mlog_test_u64(mask, mlog_and_bits))
		state = "allow";
	else if (__mlog_test_u64(mask, mlog_not_bits))
		state = "deny";
	else
		state = "off";

	return snprintf(buf, PAGE_SIZE, "%s\n", state);
}

static ssize_t mlog_mask_store(u64 mask, const char *buf, size_t count)
{
	if (!strncasecmp(buf, "allow", 5)) {
		__mlog_set_u64(mask, mlog_and_bits);
		__mlog_clear_u64(mask, mlog_not_bits);
	} else if (!strncasecmp(buf, "deny", 4)) {
		__mlog_set_u64(mask, mlog_not_bits);
		__mlog_clear_u64(mask, mlog_and_bits);
	} else if (!strncasecmp(buf, "off", 3)) {
		__mlog_clear_u64(mask, mlog_not_bits);
		__mlog_clear_u64(mask, mlog_and_bits);
	} else
		return -EINVAL;

	return count;
}

struct mlog_attribute {
	struct attribute attr;
	u64 mask;
};

#define to_mlog_attr(_attr) container_of(_attr, struct mlog_attribute, attr)

#define define_mask(_name) {			\
	.attr = {				\
		.name = #_name,			\
		.mode = S_IRUGO | S_IWUSR,	\
	},					\
	.mask = ML_##_name,			\
}

static struct mlog_attribute mlog_attrs[MLOG_MAX_BITS] = {
	define_mask(TCP),
	define_mask(MSG),
	define_mask(SOCKET),
	define_mask(HEARTBEAT),
	define_mask(HB_BIO),
	define_mask(DLMFS),
	define_mask(DLM),
	define_mask(DLM_DOMAIN),
	define_mask(DLM_THREAD),
	define_mask(DLM_MASTER),
	define_mask(DLM_RECOVERY),
	define_mask(DLM_GLUE),
	define_mask(VOTE),
	define_mask(CONN),
	define_mask(QUORUM),
	define_mask(BASTS),
	define_mask(CLUSTER),
	define_mask(ERROR),
	define_mask(NOTICE),
	define_mask(KTHREAD),
};

static struct attribute *mlog_attr_ptrs[MLOG_MAX_BITS] = {NULL, };

static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,
			 char *buf)
{
	struct mlog_attribute *mlog_attr = to_mlog_attr(attr);

	return mlog_mask_show(mlog_attr->mask, buf);
}

static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,
			  const char *buf, size_t count)
{
	struct mlog_attribute *mlog_attr = to_mlog_attr(attr);

	return mlog_mask_store(mlog_attr->mask, buf, count);
}

static const struct sysfs_ops mlog_attr_ops = {
	.show  = mlog_show,
	.store = mlog_store,
};

static struct kobj_type mlog_ktype = {
	.default_attrs = mlog_attr_ptrs,
	.sysfs_ops     = &mlog_attr_ops,
};

static struct kset mlog_kset = {
	.kobj   = {.ktype = &mlog_ktype},
};

int mlog_sys_init(struct kset *o2cb_kset)
{
	int i = 0;

	while (mlog_attrs[i].attr.mode) {
		mlog_attr_ptrs[i] = &mlog_attrs[i].attr;
		i++;
	}
	mlog_attr_ptrs[i] = NULL;

	kobject_set_name(&mlog_kset.kobj, "logmask");
	mlog_kset.kobj.kset = o2cb_kset;
	return kset_register(&mlog_kset);
}

void mlog_sys_shutdown(void)
{
	kset_unregister(&mlog_kset);
}
                                                                                                                                                                                                 /*
 * These are the public elements of the Linux LAPB module.
 */

#ifndef	LAPB_KERNEL_H
#define	LAPB_KERNEL_H

#define	LAPB_OK			0
#define	LAPB_BADTOKEN		1
#define	LAPB_INVALUE		2
#define	LAPB_CONNECTED		3
#define	LAPB_NOTCONNECTED	4
#define	LAPB_REFUSED		5
#define	LAPB_TIMEDOUT		6
#define	LAPB_NOMEM		7

#define	LAPB_STANDARD		0x00
#define	LAPB_EXTENDED		0x01

#define	LAPB_SLP		0x00
#define	LAPB_MLP		0x02

#define	LAPB_DTE		0x00
#define	LAPB_DCE		0x04

struct lapb_register_struct {
	void (*connect_confirmation)(struct net_device *dev, int reason);
	void (*connect_indication)(struct net_device *dev, int reason);
	void (*disconnect_confirmation)(struct net_device *dev, int reason);
	void (*disconnect_indication)(struct net_device *dev, int reason);
	int  (*data_indication)(struct net_device *dev, struct sk_buff *skb);
	void (*data_transmit)(struct net_device *dev, struct sk_buff *skb);
};

struct lapb_parms_struct {
	unsigned int t1;
	unsigned int t1timer;
	unsigned int t2;
	unsigned int t2timer;
	unsigned int n2;
	unsigned int n2count;
	unsigned int window;
	unsigned int state;
	unsigned int mode;
};

extern int lapb_register(struct net_device *dev,
			 const struct lapb_register_struct *callbacks);
extern int lapb_unregister(struct net_device *dev);
extern int lapb_getparms(struct net_device *dev, struct lapb_parms_struct *parms);
extern int lapb_setparms(struct net_device *dev, struct lapb_parms_struct *parms);
extern int lapb_connect_request(struct net_device *dev);
extern int lapb_disconnect_request(struct net_device *dev);
extern int lapb_data_request(struct net_device *dev, struct sk_buff *skb);
extern int lapb_data_received(struct net_device *dev, struct sk_buff *skb);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 *		INETPEER - A storage for permanent information about peers
 *
 *  Authors:	Andrey V. Savochkin <saw@msu.ru>
 */

#ifndef _NET_INETPEER_H
#define _NET_INETPEER_H

#include <linux/types.h>
#include <linux/init.h>
#include <linux/jiffies.h>
#include <linux/spinlock.h>
#include <linux/rtnetlink.h>
#include <net/ipv6.h>
#include <linux/atomic.h>

struct inetpeer_addr_base {
	union {
		__be32			a4;
		__be32			a6[4];
	};
};

struct inetpeer_addr {
	struct inetpeer_addr_base	addr;
	__u16				family;
};

struct inet_peer {
	/* group together avl_left,avl_right,v4daddr to speedup lookups */
	struct inet_peer __rcu	*avl_left, *avl_right;
	struct inetpeer_addr	daddr;
	__u32			avl_height;

	u32			metrics[RTAX_MAX];
	u32			rate_tokens;	/* rate limiting for ICMP */
	unsigned long		rate_last;
	union {
		struct list_head	gc_list;
		struct rcu_head     gc_rcu;
	};
	/*
	 * Once inet_peer is queued for deletion (refcnt == -1), following field
	 * is not available: rid
	 * We can share memory with rcu_head to help keep inet_peer small.
	 */
	union {
		struct {
			atomic_t			rid;		/* Frag reception counter */
		};
		struct rcu_head         rcu;
		struct inet_peer	*gc_next;
	};

	/* following fields might be frequently dirtied */
	__u32			dtime;	/* the time of last use of not referenced entries */
	atomic_t		refcnt;
};

struct inet_peer_base {
	struct inet_peer __rcu	*root;
	seqlock_t		lock;
	int			total;
};

#define INETPEER_BASE_BIT	0x1UL

static inline struct inet_peer *inetpeer_ptr(unsigned long val)
{
	BUG_ON(val & INETPEER_BASE_BIT);
	return (struct inet_peer *) val;
}

static inline struct inet_peer_base *inetpeer_base_ptr(unsigned long val)
{
	if (!(val & INETPEER_BASE_BIT))
		return NULL;
	val &= ~INETPEER_BASE_BIT;
	return (struct inet_peer_base *) val;
}

static inline bool inetpeer_ptr_is_peer(unsigned long val)
{
	return !(val & INETPEER_BASE_BIT);
}

static inline void __inetpeer_ptr_set_peer(unsigned long *val, struct inet_peer *peer)
{
	/* This implicitly clears INETPEER_BASE_BIT */
	*val = (unsigned long) peer;
}

static inline bool inetpeer_ptr_set_peer(unsigned long *ptr, struct inet_peer *peer)
{
	unsigned long val = (unsigned long) peer;
	unsigned long orig = *ptr;

	if (!(orig & INETPEER_BASE_BIT) ||
	    cmpxchg(ptr, orig, val) != orig)
		return false;
	return true;
}

static inline void inetpeer_init_ptr(unsigned long *ptr, struct inet_peer_base *base)
{
	*ptr = (unsigned long) base | INETPEER_BASE_BIT;
}

static inline void inetpeer_transfer_peer(unsigned long *to, unsigned long *from)
{
	unsigned long val = *from;

	*to = val;
	if (inetpeer_ptr_is_peer(val)) {
		struct inet_peer *peer = inetpeer_ptr(val);
		atomic_inc(&peer->refcnt);
	}
}

void inet_peer_base_init(struct inet_peer_base *);

void inet_initpeers(void) __init;

#define INETPEER_METRICS_NEW	(~(u32) 0)

static inline bool inet_metrics_new(const struct inet_peer *p)
{
	return p->metrics[RTAX_LOCK-1] == INETPEER_METRICS_NEW;
}

/* can be called with or without local BH being disabled */
struct inet_peer *inet_getpeer(struct inet_peer_base *base,
			       const struct inetpeer_addr *daddr,
			       int create);

static inline struct inet_peer *inet_getpeer_v4(struct inet_peer_base *base,
						__be32 v4daddr,
						int create)
{
	struct inetpeer_addr daddr;

	daddr.addr.a4 = v4daddr;
	daddr.family = AF_INET;
	return inet_getpeer(base, &daddr, create);
}

static inline struct inet_peer *inet_getpeer_v6(struct inet_peer_base *base,
						const struct in6_addr *v6daddr,
						int create)
{
	struct inetpeer_addr daddr;

	*(struct in6_addr *)daddr.addr.a6 = *v6daddr;
	daddr.family = AF_INET6;
	return inet_getpeer(base, &daddr, create);
}

/* can be called from BH context or outside */
void inet_putpeer(struct inet_peer *p);
bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout);

void inetpeer_invalidate_tree(struct inet_peer_base *);

/*
 * temporary check to make sure we dont access rid, tcp_ts,
 * tcp_ts_stamp if no refcount is taken on inet_peer
 */
static inline void inet_peer_refcheck(const struct inet_peer *p)
{
	WARN_ON_ONCE(atomic_read(&p->refcnt) <= 0);
}
#endif /* _NET_INETPEER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * kernel/power/autosleep.c
 *
 * Opportunistic sleep support.
 *
 * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>
 */

#include <linux/device.h>
#include <linux/mutex.h>
#include <linux/pm_wakeup.h>

#include "power.h"

#define HIB_AUTOSLEEP_DEBUG 1
#define _TAG_HIB_M "HIB/AUTOSLEEP"
#if (HIB_AUTOSLEEP_DEBUG)
#define hib_autoslp_log(fmt, ...)   pr_warn("[%s][%s]" fmt, _TAG_HIB_M, __func__, ##__VA_ARGS__)
#else
#define hib_autoslp_log(fmt, ...)
#endif
#define hib_autoslp_warn(fmt, ...)   pr_warn("[%s][%s]" fmt, _TAG_HIB_M, __func__, ##__VA_ARGS__)

static suspend_state_t autosleep_state;
static struct workqueue_struct *autosleep_wq;
/*
 * Note: it is only safe to mutex_lock(&autosleep_lock) if a wakeup_source
 * is active, otherwise a deadlock with try_to_suspend() is possible.
 * Alternatively mutex_lock_interruptible() can be used.  This will then fail
 * if an auto_sleep cycle tries to freeze processes.
 */
static DEFINE_MUTEX(autosleep_lock);
static struct wakeup_source *autosleep_ws;

static void try_to_suspend(struct work_struct *work)
{
	unsigned int initial_count, final_count;

	if (!pm_get_wakeup_count(&initial_count, true))
		goto out;

	mutex_lock(&autosleep_lock);

	if (!pm_save_wakeup_count(initial_count) ||
		system_state != SYSTEM_RUNNING) {
		mutex_unlock(&autosleep_lock);
		goto out;
	}

	if (autosleep_state == PM_SUSPEND_ON) {
#ifdef CONFIG_MTK_HIBERNATION
		system_is_hibernating = false;
#endif
		mutex_unlock(&autosleep_lock);
		return;
	}
#ifdef CONFIG_MTK_HIBERNATION
	if (autosleep_state >= PM_SUSPEND_MAX) {
		mtk_hibernate_via_autosleep(&autosleep_state);
	} else {
		hib_autoslp_log("pm_suspend: state(%d)\n", autosleep_state);
		if (!system_is_hibernating) {
			hib_autoslp_warn("calling pm_suspend() state(%d)\n", autosleep_state);
			pm_suspend(autosleep_state);
		} else {
			hib_autoslp_warn("system is hibernating: so changing state(%d->%d)\n",
					 autosleep_state, PM_SUSPEND_MAX);
			autosleep_state = PM_SUSPEND_MAX;
		}
	}
#else /* !CONFIG_MTK_HIBERNATION */
	if (autosleep_state >= PM_SUSPEND_MAX)
		hibernate();
	else
		pm_suspend(autosleep_state);
#endif /* CONFIG_MTK_HIBERNATION */

	mutex_unlock(&autosleep_lock);

	if (!pm_get_wakeup_count(&final_count, false))
		goto out;

	/*
	 * If the wakeup occured for an unknown reason, wait to prevent the
	 * system from trying to suspend and waking up in a tight loop.
	 */
	if (final_count == initial_count)
		schedule_timeout_uninterruptible(HZ / 2);

 out:
	queue_up_suspend_work();
}

static DECLARE_WORK(suspend_work, try_to_suspend);

void queue_up_suspend_work(void)
{
	if (autosleep_state > PM_SUSPEND_ON)
		queue_work(autosleep_wq, &suspend_work);
}

suspend_state_t pm_autosleep_state(void)
{
	return autosleep_state;
}

int pm_autosleep_lock(void)
{
	return mutex_lock_interruptible(&autosleep_lock);
}

void pm_autosleep_unlock(void)
{
	mutex_unlock(&autosleep_lock);
}

int pm_autosleep_set_state(suspend_state_t state)
{

#ifndef CONFIG_HIBERNATION
	if (state >= PM_SUSPEND_MAX)
		return -EINVAL;
#endif

	__pm_stay_awake(autosleep_ws);

	mutex_lock(&autosleep_lock);

	autosleep_state = state;

	__pm_relax(autosleep_ws);

	if (state > PM_SUSPEND_ON) {
		pm_wakep_autosleep_enabled(true);
		queue_up_suspend_work();
	} else {
		pm_wakep_autosleep_enabled(false);
	}

	mutex_unlock(&autosleep_lock);
	return 0;
}

int __init pm_autosleep_init(void)
{
	autosleep_ws = wakeup_source_register("autosleep");
	if (!autosleep_ws)
		return -ENOMEM;

	autosleep_wq = alloc_ordered_workqueue("autosleep", 0);
	if (autosleep_wq)
		return 0;

	wakeup_source_unregister(autosleep_ws);
	return -ENOMEM;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Copyright (c) 2010 Patrick McHardy <kaber@trash.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
#include <linux/module.h>
#include <linux/gfp.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/netfilter_ipv6/ip6_tables.h>
#include <linux/netfilter/x_tables.h>
#include <linux/netfilter/xt_CT.h>
#include <net/netfilter/nf_conntrack.h>
#include <net/netfilter/nf_conntrack_l4proto.h>
#include <net/netfilter/nf_conntrack_helper.h>
#include <net/netfilter/nf_conntrack_ecache.h>
#include <net/netfilter/nf_conntrack_timeout.h>
#include <net/netfilter/nf_conntrack_zones.h>

static inline int xt_ct_target(struct sk_buff *skb, struct nf_conn *ct)
{
	/* Previously seen (loopback)? Ignore. */
	if (skb->nfct != NULL)
		return XT_CONTINUE;

	/* special case the untracked ct : we want the percpu object */
	if (!ct)
		ct = nf_ct_untracked_get();
	atomic_inc(&ct->ct_general.use);
	skb->nfct = &ct->ct_general;
	skb->nfctinfo = IP_CT_NEW;

	return XT_CONTINUE;
}

static unsigned int xt_ct_target_v0(struct sk_buff *skb,
				    const struct xt_action_param *par)
{
	const struct xt_ct_target_info *info = par->targinfo;
	struct nf_conn *ct = info->ct;

	return xt_ct_target(skb, ct);
}

static unsigned int xt_ct_target_v1(struct sk_buff *skb,
				    const struct xt_action_param *par)
{
	const struct xt_ct_target_info_v1 *info = par->targinfo;
	struct nf_conn *ct = info->ct;

	return xt_ct_target(skb, ct);
}

static u8 xt_ct_find_proto(const struct xt_tgchk_param *par)
{
	if (par->family == NFPROTO_IPV4) {
		const struct ipt_entry *e = par->entryinfo;

		if (e->ip.invflags & IPT_INV_PROTO)
			return 0;
		return e->ip.proto;
	} else if (par->family == NFPROTO_IPV6) {
		const struct ip6t_entry *e = par->entryinfo;

		if (e->ipv6.invflags & IP6T_INV_PROTO)
			return 0;
		return e->ipv6.proto;
	} else
		return 0;
}

static int
xt_ct_set_helper(struct nf_conn *ct, const char *helper_name,
		 const struct xt_tgchk_param *par)
{
	struct nf_conntrack_helper *helper;
	struct nf_conn_help *help;
	u8 proto;

	proto = xt_ct_find_proto(par);
	if (!proto) {
		pr_info("You must specify a L4 protocol, and not use "
			"inversions on it.\n");
		return -ENOENT;
	}

	helper = nf_conntrack_helper_try_module_get(helper_name, par->family,
						    proto);
	if (helper == NULL) {
		pr_info("No such helper \"%s\"\n", helper_name);
		return -ENOENT;
	}

	help = nf_ct_helper_ext_add(ct, helper, GFP_KERNEL);
	if (help == NULL) {
		module_put(helper->me);
		return -ENOMEM;
	}

	help->helper = helper;
	return 0;
}

#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
static void __xt_ct_tg_timeout_put(struct ctnl_timeout *timeout)
{
	typeof(nf_ct_timeout_put_hook) timeout_put;

	timeout_put = rcu_dereference(nf_ct_timeout_put_hook);
	if (timeout_put)
		timeout_put(timeout);
}
#endif

static int
xt_ct_set_timeout(struct nf_conn *ct, const struct xt_tgchk_param *par,
		  const char *timeout_name)
{
#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
	typeof(nf_ct_timeout_find_get_hook) timeout_find_get;
	struct ctnl_timeout *timeout;
	struct nf_conn_timeout *timeout_ext;
	struct nf_conntrack_l4proto *l4proto;
	int ret = 0;
	u8 proto;

	rcu_read_lock();
	timeout_find_get = rcu_dereference(nf_ct_timeout_find_get_hook);
	if (timeout_find_get == NULL) {
		ret = -ENOENT;
		pr_info("Timeout policy base is empty\n");
		goto out;
	}

	proto = xt_ct_find_proto(par);
	if (!proto) {
		ret = -EINVAL;
		pr_info("You must specify a L4 protocol, and not use "
			"inversions on it.\n");
		goto out;
	}

	timeout = timeout_find_get(timeout_name);
	if (timeout == NULL) {
		ret = -ENOENT;
		pr_info("No such timeout policy \"%s\"\n", timeout_name);
		goto out;
	}

	if (timeout->l3num != par->family) {
		ret = -EINVAL;
		pr_info("Timeout policy `%s' can only be used by L3 protocol "
			"number %d\n", timeout_name, timeout->l3num);
		goto err_put_timeout;
	}
	/* Make sure the timeout policy matches any existing protocol tracker,
	 * otherwise default to generic.
	 */
	l4proto = __nf_ct_l4proto_find(par->family, proto);
	if (timeout->l4proto->l4proto != l4proto->l4proto) {
		ret = -EINVAL;
		pr_info("Timeout policy `%s' can only be used by L4 protocol "
			"number %d\n",
			timeout_name, timeout->l4proto->l4proto);
		goto err_put_timeout;
	}
	timeout_ext = nf_ct_timeout_ext_add(ct, timeout, GFP_ATOMIC);
	if (timeout_ext == NULL)
		ret = -ENOMEM;

err_put_timeout:
	__xt_ct_tg_timeout_put(timeout);
out:
	rcu_read_unlock();
	return ret;
#else
	return -EOPNOTSUPP;
#endif
}

static int xt_ct_tg_check(const struct xt_tgchk_param *par,
			  struct xt_ct_target_info_v1 *info)
{
	struct nf_conntrack_tuple t;
	struct nf_conn *ct;
	int ret = -EOPNOTSUPP;

	if (info->flags & XT_CT_NOTRACK) {
		ct = NULL;
		goto out;
	}

#ifndef CONFIG_NF_CONNTRACK_ZONES
	if (info->zone)
		goto err1;
#endif

	ret = nf_ct_l3proto_try_module_get(par->family);
	if (ret < 0)
		goto err1;

	memset(&t, 0, sizeof(t));
	ct = nf_conntrack_alloc(par->net, info->zone, &t, &t, GFP_KERNEL);
	ret = PTR_ERR(ct);
	if (IS_ERR(ct))
		goto err2;

	ret = 0;
	if ((info->ct_events || info->exp_events) &&
	    !nf_ct_ecache_ext_add(ct, info->ct_events, info->exp_events,
				  GFP_KERNEL)) {
		ret = -EINVAL;
		goto err3;
	}

	if (info->helper[0]) {
		ret = xt_ct_set_helper(ct, info->helper, par);
		if (ret < 0)
			goto err3;
	}

	if (info->timeout[0]) {
		ret = xt_ct_set_timeout(ct, par, info->timeout);
		if (ret < 0)
			goto err3;
	}

	nf_conntrack_tmpl_insert(par->net, ct);
out:
	info->ct = ct;
	return 0;

err3:
	nf_conntrack_free(ct);
err2:
	nf_ct_l3proto_module_put(par->family);
err1:
	return ret;
}

static int xt_ct_tg_check_v0(const struct xt_tgchk_param *par)
{
	struct xt_ct_target_info *info = par->targinfo;
	struct xt_ct_target_info_v1 info_v1 = {
		.flags 		= info->flags,
		.zone		= info->zone,
		.ct_events	= info->ct_events,
		.exp_events	= info->exp_events,
	};
	int ret;

	if (info->flags & ~XT_CT_NOTRACK)
		return -EINVAL;

	memcpy(info_v1.helper, info->helper, sizeof(info->helper));

	ret = xt_ct_tg_check(par, &info_v1);
	if (ret < 0)
		return ret;

	info->ct = info_v1.ct;

	return ret;
}

static int xt_ct_tg_check_v1(const struct xt_tgchk_param *par)
{
	struct xt_ct_target_info_v1 *info = par->targinfo;

	if (info->flags & ~XT_CT_NOTRACK)
		return -EINVAL;

	return xt_ct_tg_check(par, par->targinfo);
}

static int xt_ct_tg_check_v2(const struct xt_tgchk_param *par)
{
	struct xt_ct_target_info_v1 *info = par->targinfo;

	if (info->flags & ~XT_CT_MASK)
		return -EINVAL;

	return xt_ct_tg_check(par, par->targinfo);
}

static void xt_ct_destroy_timeout(struct nf_conn *ct)
{
#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
	struct nf_conn_timeout *timeout_ext;
	typeof(nf_ct_timeout_put_hook) timeout_put;

	rcu_read_lock();
	timeout_put = rcu_dereference(nf_ct_timeout_put_hook);

	if (timeout_put) {
		timeout_ext = nf_ct_timeout_find(ct);
		if (timeout_ext)
			timeout_put(timeout_ext->timeout);
	}
	rcu_read_unlock();
#endif
}

static void xt_ct_tg_destroy(const struct xt_tgdtor_param *par,
			     struct xt_ct_target_info_v1 *info)
{
	struct nf_conn *ct = info->ct;
	struct nf_conn_help *help;

	if (ct && !nf_ct_is_untracked(ct)) {
		help = nfct_help(ct);
		if (help)
			module_put(help->helper->me);

		nf_ct_l3proto_module_put(par->family);

		xt_ct_destroy_timeout(ct);
		nf_ct_put(info->ct);
	}
}

static void xt_ct_tg_destroy_v0(const struct xt_tgdtor_param *par)
{
	struct xt_ct_target_info *info = par->targinfo;
	struct xt_ct_target_info_v1 info_v1 = {
		.flags 		= info->flags,
		.zone		= info->zone,
		.ct_events	= info->ct_events,
		.exp_events	= info->exp_events,
		.ct		= info->ct,
	};
	memcpy(info_v1.helper, info->helper, sizeof(info->helper));

	xt_ct_tg_destroy(par, &info_v1);
}

static void xt_ct_tg_destroy_v1(const struct xt_tgdtor_param *par)
{
	xt_ct_tg_destroy(par, par->targinfo);
}

static struct xt_target xt_ct_tg_reg[] __read_mostly = {
	{
		.name		= "CT",
		.family		= NFPROTO_UNSPEC,
		.targetsize	= sizeof(struct xt_ct_target_info),
		.checkentry	= xt_ct_tg_check_v0,
		.destroy	= xt_ct_tg_destroy_v0,
		.target		= xt_ct_target_v0,
		.table		= "raw",
		.me		= THIS_MODULE,
	},
	{
		.name		= "CT",
		.family		= NFPROTO_UNSPEC,
		.revision	= 1,
		.targetsize	= sizeof(struct xt_ct_target_info_v1),
		.checkentry	= xt_ct_tg_check_v1,
		.destroy	= xt_ct_tg_destroy_v1,
		.target		= xt_ct_target_v1,
		.table		= "raw",
		.me		= THIS_MODULE,
	},
	{
		.name		= "CT",
		.family		= NFPROTO_UNSPEC,
		.revision	= 2,
		.targetsize	= sizeof(struct xt_ct_target_info_v1),
		.checkentry	= xt_ct_tg_check_v2,
		.destroy	= xt_ct_tg_destroy_v1,
		.target		= xt_ct_target_v1,
		.table		= "raw",
		.me		= THIS_MODULE,
	},
};

static unsigned int
notrack_tg(struct sk_buff *skb, const struct xt_action_param *par)
{
	/* Previously seen (loopback)? Ignore. */
	if (skb->nfct != NULL)
		return XT_CONTINUE;

	skb->nfct = &nf_ct_untracked_get()->ct_general;
	skb->nfctinfo = IP_CT_NEW;
	nf_conntrack_get(skb->nfct);

	return XT_CONTINUE;
}

static int notrack_chk(const struct xt_tgchk_param *par)
{
	if (!par->net->xt.notrack_deprecated_warning) {
		pr_info("netfilter: NOTRACK target is deprecated, "
			"use CT instead or upgrade iptables\n");
		par->net->xt.notrack_deprecated_warning = true;
	}
	return 0;
}

static struct xt_target notrack_tg_reg __read_mostly = {
	.name		= "NOTRACK",
	.revision	= 0,
	.family		= NFPROTO_UNSPEC,
	.checkentry	= notrack_chk,
	.target		= notrack_tg,
	.table		= "raw",
	.me		= THIS_MODULE,
};

static int __init xt_ct_tg_init(void)
{
	int ret;

	ret = xt_register_target(&notrack_tg_reg);
	if (ret < 0)
		return ret;

	ret = xt_register_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));
	if (ret < 0) {
		xt_unregister_target(&notrack_tg_reg);
		return ret;
	}
	return 0;
}

static void __exit xt_ct_tg_exit(void)
{
	xt_unregister_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));
	xt_unregister_target(&notrack_tg_reg);
}

module_init(xt_ct_tg_init);
module_exit(xt_ct_tg_exit);

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Xtables: connection tracking target");
MODULE_ALIAS("ipt_CT");
MODULE_ALIAS("ip6t_CT");
MODULE_ALIAS("ipt_NOTRACK");
MODULE_ALIAS("ip6t_NOTRACK");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * fireworks_proc.c - a part of driver for Fireworks based devices
 *
 * Copyright (c) 2009-2010 Clemens Ladisch
 * Copyright (c) 2013-2014 Takashi Sakamoto
 *
 * Licensed under the terms of the GNU General Public License, version 2.
 */

#include "./fireworks.h"

static inline const char*
get_phys_name(struct snd_efw_phys_grp *grp, bool input)
{
	const char *const ch_type[] = {
		"Analog", "S/PDIF", "ADAT", "S/PDIF or ADAT", "Mirroring",
		"Headphones", "I2S", "Guitar", "Pirzo Guitar", "Guitar String",
	};

	if (grp->type < ARRAY_SIZE(ch_type))
		return ch_type[grp->type];
	else if (input)
		return "Input";
	else
		return "Output";
}

static void
proc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
{
	struct snd_efw *efw = entry->private_data;
	unsigned short i;
	struct snd_efw_hwinfo *hwinfo;

	hwinfo = kmalloc(si