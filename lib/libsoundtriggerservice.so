rs[phm->obj_index])) {
			hpios_locked_mem_free(&phw->instream_host_buffers
				[phm->obj_index]);
			phw->instream_host_buffer_size[phm->obj_index] = 0;
		}
	}
}

static void instream_host_buffer_get_info(struct hpi_adapter_obj *pao,
	struct hpi_message *phm, struct hpi_response *phr)
{
	struct hpi_hw_obj *phw = pao->priv;
	struct bus_master_interface *interface = phw->p_interface_buffer;
	struct hpi_hostbuffer_status *status;
	u8 *p_bbm_data;

	if (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->
				obj_index])) {
		if (hpios_locked_mem_get_virt_addr(&phw->
				instream_host_buffers[phm->obj_index],
				(void *)&p_bbm_data)) {
			phr->error = HPI_ERROR_INVALID_OPERATION;
			return;
		}
		status = &interface->instream_host_buffer_status[phm->
			obj_index];
		hpi_init_response(phr, HPI_OBJ_ISTREAM,
			HPI_ISTREAM_HOSTBUFFER_GET_INFO, 0);
		phr->u.d.u.hostbuffer_info.p_buffer = p_bbm_data;
		phr->u.d.u.hostbuffer_info.p_status = status;
	} else {
		hpi_init_response(phr, HPI_OBJ_ISTREAM,
			HPI_ISTREAM_HOSTBUFFER_GET_INFO,
			HPI_ERROR_INVALID_OPERATION);
	}
}

static void instream_host_buffer_free(struct hpi_adapter_obj *pao,
	struct hpi_message *phm, struct hpi_response *phr)
{
	struct hpi_hw_obj *phw = pao->priv;
	u32 command = phm->u.d.u.buffer.command;

	if (phw->instream_host_buffer_size[phm->obj_index]) {
		if (command == HPI_BUFFER_CMD_EXTERNAL
			|| command == HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER) {
			phw->instream_host_buffer_size[phm->obj_index] = 0;
			hw_message(pao, phm, phr);
		}

		if (command == HPI_BUFFER_CMD_EXTERNAL
			|| command == HPI_BUFFER_CMD_INTERNAL_FREE)
			hpios_locked_mem_free(&phw->instream_host_buffers
				[phm->obj_index]);

	} else {
		/* Should HPI_ERROR_INVALID_OPERATION be returned
		   if no host buffer is allocated? */
		hpi_init_response(phr, HPI_OBJ_ISTREAM,
			HPI_ISTREAM_HOSTBUFFER_FREE, 0);

	}

}

static void instream_start(struct hpi_adapter_obj *pao,
	struct hpi_message *phm, struct hpi_response *phr)
{
	hw_message(pao, phm, phr);
}

static u32 instream_get_bytes_available(struct hpi_hostbuffer_status *status)
{
	return status->dsp_index - status->host_index;
}

static void instream_read(struct hpi_adapter_obj *pao,
	struct hpi_message *phm, struct hpi_response *phr)
{
	struct hpi_hw_obj *phw = pao->priv;
	struct bus_master_interface *interface = phw->p_interface_buffer;
	struct hpi_hostbuffer_status *status;
	u32 data_available;
	u8 *p_bbm_data;
	u32 l_first_read;
	u8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;

	if (!phw->instream_host_buffer_size[phm->obj_index]) {
		hw_message(pao, phm, phr);
		return;
	}
	hpi_init_response(phr, phm->object, phm->function, 0);

	status = &interface->instream_host_buffer_status[phm->obj_index];
	data_available = instream_get_bytes_available(status);
	if (data_available < phm->u.d.u.data.data_size) {
		phr->error = HPI_ERROR_INVALID_DATASIZE;
		return;
	}

	if (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->
				obj_index])) {
		if (hpios_locked_mem_get_virt_addr(&phw->
				instream_host_buffers[phm->obj_index],
				(void *)&p_bbm_data)) {
			phr->error = HPI_ERROR_INVALID_OPERATION;
			return;
		}

		/* either all data,
		   or enough to fit from current to end of BBM buffer */
		l_first_read =
			min(phm->u.d.u.data.data_size,
			status->size_in_bytes -
			(status->host_index & (status->size_in_bytes - 1)));

		memcpy(p_app_data,
			p_bbm_data +
			(status->host_index & (status->size_in_bytes - 1)),
			l_first_read);
		/* remaining data if any */
		memcpy(p_app_data + l_first_read, p_bbm_data,
			phm->u.d.u.data.data_size - l_first_read);
	}
	status->host_index += phm->u.d.u.data.data_size;
}

static void instream_get_info(struct hpi_adapter_obj *pao,
	struct hpi_message *phm, struct hpi_response *phr)
{
	struct hpi_hw_obj *phw = pao->priv;
	struct bus_master_interface *interface = phw->p_interface_buffer;
	struct hpi_hostbuffer_status *status;
	if (!phw->instream_host_buffer_size[phm->obj_index]) {
		hw_message(pao, phm, phr);
		return;
	}

	status = &interface->instream_host_buffer_status[phm->obj_index];

	hpi_init_response(phr, phm->object, phm->function, 0);

	phr->u.d.u.stream_info.state = (u16)status->stream_state;
	phr->u.d.u.stream_info.samples_transferred =
		status->samples_processed;
	phr->u.d.u.stream_info.buffer_size = status->size_in_bytes;
	phr->u.d.u.stream_info.data_available =
		instream_get_bytes_available(status);
	phr->u.d.u.stream_info.auxiliary_data_available =
		status->auxiliary_data_available;
}

/*****************************************************************************/
/* LOW-LEVEL */
#define HPI6205_MAX_FILES_TO_LOAD 2

static u16 adapter_boot_load_dsp(struct hpi_adapter_obj *pao,
	u32 *pos_error_code)
{
	struct hpi_hw_obj *phw = pao->priv;
	struct dsp_code dsp_code;
	u16 boot_code_id[HPI6205_MAX_FILES_TO_LOAD];
	u32 temp;
	int dsp = 0, i = 0;
	u16 err = 0;

	boot_code_id[0] = HPI_ADAPTER_ASI(0x6205);

	boot_code_id[1] = pao->pci.pci_dev->subsystem_device;
	boot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(boot_code_id[1]);

	/* fix up cases where bootcode id[1] != subsys id */
	switch (boot_code_id[1]) {
	case HPI_ADAPTER_FAMILY_ASI(0x5000):
		boot_code_id[0] = boot_code_id[1];
		boot_code_id[1] = 0;
		break;
	case HPI_ADAPTER_FAMILY_ASI(0x5300):
	case HPI_ADAPTER_FAMILY_ASI(0x5400):
	case HPI_ADAPTER_FAMILY_ASI(0x6300):
		boot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x6400);
		break;
	case HPI_ADAPTER_FAMILY_ASI(0x5500):
	case HPI_ADAPTER_FAMILY_ASI(0x5600):
	case HPI_ADAPTER_FAMILY_ASI(0x6500):
		boot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x6600);
		break;
	case HPI_ADAPTER_FAMILY_ASI(0x8800):
		boot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x8900);
		break;
	default:
		break;
	}

	/* reset DSP by writing a 1 to the WARMRESET bit */
	temp = C6205_HDCR_WARMRESET;
	iowrite32(temp, phw->prHDCR);
	hpios_delay_micro_seconds(1000);

	/* check that PCI i/f was configured by EEPROM */
	temp = ioread32(phw->prHSR);
	if ((temp & (C6205_HSR_CFGERR | C6205_HSR_EEREAD)) !=
		C6205_HSR_EEREAD)
		return HPI6205_ERROR_6205_EEPROM;
	temp |= 0x04;
	/* disable PINTA interrupt */
	iowrite32(temp, phw->prHSR);

	/* check control register reports PCI boot mode */
	temp = ioread32(phw->prHDCR);
	if (!(temp & C6205_HDCR_PCIBOOT))
		return HPI6205_ERROR_6205_REG;

	/* try writing a few numbers to the DSP page register */
	/* and reading them back. */
	temp = 3;
	iowrite32(temp, phw->prDSPP);
	if ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))
		return HPI6205_ERROR_6205_DSPPAGE;
	temp = 2;
	iowrite32(temp, phw->prDSPP);
	if ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))
		return HPI6205_ERROR_6205_DSPPAGE;
	temp = 1;
	iowrite32(temp, phw->prDSPP);
	if ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))
		return HPI6205_ERROR_6205_DSPPAGE;
	/* reset DSP page to the correct number */
	temp = 0;
	iowrite32(temp, phw->prDSPP);
	if ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))
		return HPI6205_ERROR_6205_DSPPAGE;
	phw->dsp_page = 0;

	/* release 6713 from reset before 6205 is bootloaded.
	   This ensures that the EMIF is inactive,
	   and the 6713 HPI gets the correct bootmode etc
	 */
	if (boot_code_id[1] != 0) {
		/* DSP 1 is a C6713 */
		/* CLKX0 <- '1' release the C6205 bootmode pulldowns */
		boot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002202);
		hpios_delay_micro_seconds(100);
		/* Reset the 6713 #1 - revB */
		boot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 0);

		/* dummy read every 4 words for 6205 advisory 1.4.4 */
		boot_loader_read_mem32(pao, 0, 0);

		hpios_delay_micro_seconds(100);
		/* Release C6713 from reset - revB */
		boot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 4);
		hpios_delay_micro_seconds(100);
	}

	for (dsp = 0; dsp < HPI6205_MAX_FILES_TO_LOAD; dsp++) {
		/* is there a DSP to load? */
		if (boot_code_id[dsp] == 0)
			continue;

		err = boot_loader_config_emif(pao, dsp);
		if (err)
			return err;

		err = boot_loader_test_internal_memory(pao, dsp);
		if (err)
			return err;

		err = boot_loader_test_external_memory(pao, dsp);
		if (err)
			return err;

		err = boot_loader_test_pld(pao, dsp);
		if (err)
			return err;

		/* write the DSP code down into the DSPs memory */
		err = hpi_dsp_code_open(boot_code_id[dsp], pao->pci.pci_dev,
			&dsp_code, pos_error_code);
		if (err)
			return err;

		while (1) {
			u32 length;
			u32 address;
			u32 type;
			u32 *pcode;

			err = hpi_dsp_code_read_word(&dsp_code, &length);
			if (err)
				break;
			if (length == 0xFFFFFFFF)
				break;	/* end of code */

			err = hpi_dsp_code_read_word(&dsp_code, &address);
			if (err)
				break;
			err = hpi_dsp_code_read_word(&dsp_code, &type);
			if (err)
				break;
			err = hpi_dsp_code_read_block(length, &dsp_code,
				&pcode);
			if (err)
				break;
			for (i = 0; i < (int)length; i++) {
				boot_loader_write_mem32(pao, dsp, address,
					*pcode);
				/* dummy read every 4 words */
				/* for 6205 advisory 1.4.4 */
				if (i % 4 == 0)
					boot_loader_read_mem32(pao, dsp,
						address);
				pcode++;
				address += 4;
			}

		}
		if (err) {
			hpi_dsp_code_close(&dsp_code);
			return err;
		}

		/* verify code */
		hpi_dsp_code_rewind(&dsp_code);
		while (1) {
			u32 length = 0;
			u32 address = 0;
			u32 type = 0;
			u32 *pcode = NULL;
			u32 data = 0;

			hpi_dsp_code_read_word(&dsp_code, &length);
			if (length == 0xFFFFFFFF)
				break;	/* end of code */

			hpi_dsp_code_read_word(&dsp_code, &address);
			hpi_dsp_code_read_word(&dsp_code, &type);
			hpi_dsp_code_read_block(length, &dsp_code, &pcode);

			for (i = 0; i < (int)length; i++) {
				data = boot_loader_read_mem32(pao, dsp,
					address);
				if (data != *pcode) {
					err = 0;
					break;
				}
				pcode++;
				address += 4;
			}
			if (err)
				break;
		}
		hpi_dsp_code_close(&dsp_code);
		if (err)
			return err;
	}

	/* After bootloading all DSPs, start DSP0 running
	 * The DSP0 code will handle starting and synchronizing with its slaves
	 */
	if (phw->p_interface_buffer) {
		/* we need to tell the card the physical PCI address */
		u32 physicalPC_iaddress;
		struct bus_master_interface *interface =
			phw->p_interface_buffer;
		u32 host_mailbox_address_on_dsp;
		u32 physicalPC_iaddress_verify = 0;
		int time_out = 10;
		/* set ack so we know when DSP is ready to go */
		/* (dwDspAck will be changed to HIF_RESET) */
		interface->dsp_ack = H620_HIF_UNKNOWN;
		wmb();	/* ensure ack is written before dsp writes back */

		err = hpios_locked_mem_get_phys_addr(&phw->h_locked_mem,
			&physicalPC_iaddress);

		/* locate the host mailbox on the DSP. */
		host_mailbox_address_on_dsp = 0x80000000;
		while ((physicalPC_iaddress != physicalPC_iaddress_verify)
			&& time_out--) {
			boot_loader_write_mem32(pao, 0,
				host_mailbox_address_on_dsp,
				physicalPC_iaddress);
			physicalPC_iaddress_verify =
				boot_loader_read_mem32(pao, 0,
				host_mailbox_address_on_dsp);
		}
	}
	HPI_DEBUG_LOG(DEBUG, "starting DS_ps running\n");
	/* enable interrupts */
	temp = ioread32(phw->prHSR);
	temp &= ~(u32)C6205_HSR_INTAM;
	iowrite32(temp, phw->prHSR);

	/* start code running... */
	temp = ioread32(phw->prHDCR);
	temp |= (u32)C6205_HDCR_DSPINT;
	iowrite32(temp, phw->prHDCR);

	/* give the DSP 10ms to start up */
	hpios_delay_micro_seconds(10000);
	return err;

}

/*****************************************************************************/
/* Bootloader utility functions */

static u32 boot_loader_read_mem32(struct hpi_adapter_obj *pao, int dsp_index,
	u32 address)
{
	struct hpi_hw_obj *phw = pao->priv;
	u32 data = 0;
	__iomem u32 *p_data;

	if (dsp_index == 0) {
		/* DSP 0 is always C6205 */
		if ((address >= 0x01800000) & (address < 0x02000000)) {
			/* BAR1 register access */
			p_data = pao->pci.ap_mem_base[1] +
				(address & 0x007fffff) /
				sizeof(*pao->pci.ap_mem_base[1]);
			/* HPI_DEBUG_LOG(WARNING,
			   "BAR1 access %08x\n", dwAddress); */
		} else {
			u32 dw4M_page = address >> 22L;
			if (dw4M_page != phw->dsp_page) {
				phw->dsp_page = dw4M_page;
				/* *INDENT OFF* */
				iowrite32(phw->dsp_page, phw->prDSPP);
				/* *INDENT-ON* */
			}
			address &= 0x3fffff;	/* address within 4M page */
			/* BAR0 memory access */
			p_data = pao->pci.ap_mem_base[0] +
				address / sizeof(u32);
		}
		data = ioread32(p_data);
	} else if (dsp_index == 1) {
		/* DSP 1 is a C6713 */
		u32 lsb;
		boot_loader_write_mem32(pao, 0, HPIAL_ADDR, address);
		boot_loader_write_mem32(pao, 0, HPIAH_ADDR, address >> 16);
		lsb = boot_loader_read_mem32(pao, 0, HPIDL_ADDR);
		data = boot_loader_read_mem32(pao, 0, HPIDH_ADDR);
		data = (data << 16) | (lsb & 0xFFFF);
	}
	return data;
}

static void boot_loader_write_mem32(struct hpi_adapter_obj *pao,
	int dsp_index, u32 address, u32 data)
{
	struct hpi_hw_obj *phw = pao->priv;
	__iomem u32 *p_data;
	/*      u32 dwVerifyData=0; */

	if (dsp_index == 0) {
		/* DSP 0 is always C6205 */
		if ((address >= 0x01800000) & (address < 0x02000000)) {
			/* BAR1 - DSP  register access using */
			/* Non-prefetchable PCI access */
			p_data = pao->pci.ap_mem_base[1] +
				(address & 0x007fffff) /
				sizeof(*pao->pci.ap_mem_base[1]);
		} else {
			/* BAR0 access - all of DSP memory using */
			/* pre-fetchable PCI access */
			u32 dw4M_page = address >> 22L;
			if (dw4M_page != phw->dsp_page) {
				phw->dsp_page = dw4M_page;
				/* *INDENT-OFF* */
				iowrite32(phw->dsp_page, phw->prDSPP);
				/* *INDENT-ON* */
			}
			address &= 0x3fffff;	/* address within 4M page */
			p_data = pao->pci.ap_mem_base[0] +
				address / sizeof(u32);
		}
		iowrite32(data, p_data);
	} else if (dsp_index == 1) {
		/* DSP 1 is a C6713 */
		boot_loader_write_mem32(pao, 0, HPIAL_ADDR, address);
		boot_loader_write_mem32(pao, 0, HPIAH_ADDR, address >> 16);

		/* dummy read every 4 words for 6205 advisory 1.4.4 */
		boot_loader_read_mem32(pao, 0, 0);

		boot_loader_write_mem32(pao, 0, HPIDL_ADDR, data);
		boot_loader_write_mem32(pao, 0, HPIDH_ADDR, data >> 16);

		/* dummy read every 4 words for 6205 advisory 1.4.4 */
		boot_loader_read_mem32(pao, 0, 0);
	}
}

static u16 boot_loader_config_emif(struct hpi_adapter_obj *pao, int dsp_index)
{
	if (dsp_index == 0) {
		u32 setting;

		/* DSP 0 is always C6205 */

		/* Set the EMIF */
		/* memory map of C6205 */
		/* 00000000-0000FFFF    16Kx32 internal program */
		/* 00400000-00BFFFFF    CE0     2Mx32 SDRAM running @ 100MHz */

		/* EMIF config */
		/*------------ */
		/* Global EMIF control */
		boot_loader_write_mem32(pao, dsp_index, 0x01800000, 0x3779);
#define WS_OFS 28
#define WST_OFS 22
#define WH_OFS 20
#define RS_OFS 16
#define RST_OFS 8
#define MTYPE_OFS 4
#define RH_OFS 0

		/* EMIF CE0 setup - 2Mx32 Sync DRAM on ASI5000 cards only */
		setting = 0x00000030;
		boot_loader_write_mem32(pao, dsp_index, 0x01800008, setting);
		if (setting != boot_loader_read_mem32(pao, dsp_index,
				0x01800008))
			return HPI6205_ERROR_DSP_EMIF1;

		/* EMIF CE1 setup - 32 bit async. This is 6713 #1 HPI, */
		/* which occupies D15..0. 6713 starts at 27MHz, so need */
		/* plenty of wait states. See dsn8701.rtf, and 6713 errata. */
		/* WST should be 71, but 63  is max possible */
		setting =
			(1L << WS_OFS) | (63L << WST_OFS) | (1L << WH_OFS) |
			(1L << RS_OFS) | (63L << RST_OFS) | (1L << RH_OFS) |
			(2L << MTYPE_OFS);
		boot_loader_write_mem32(pao, dsp_index, 0x01800004, setting);
		if (setting != boot_loader_read_mem32(pao, dsp_index,
				0x01800004))
			return HPI6205_ERROR_DSP_EMIF2;

		/* EMIF CE2 setup - 32 bit async. This is 6713 #2 HPI, */
		/* which occupies D15..0. 6713 starts at 27MHz, so need */
		/* plenty of wait states */
		setting =
			(1L << WS_OFS) | (28L << WST_OFS) | (1L << WH_OFS) |
			(1L << RS_OFS) | (63L << RST_OFS) | (1L << RH_OFS) |
			(2L << MTYPE_OFS);
		boot_loader_write_mem32(pao, dsp_index, 0x01800010, setting);
		if (setting != boot_loader_read_mem32(pao, dsp_index,
				0x01800010))
			return HPI6205_ERROR_DSP_EMIF3;

		/* EMIF CE3 setup - 32 bit async. */
		/* This is the PLD on the ASI5000 cards only */
		setting =
			(1L << WS_OFS) | (10L << WST_OFS) | (1L << WH_OFS) |
			(1L << RS_OFS) | (10L << RST_OFS) | (1L << RH_OFS) |
			(2L << MTYPE_OFS);
		boot_loader_write_mem32(pao, dsp_index, 0x01800014, setting);
		if (setting != boot_loader_read_mem32(pao, dsp_index,
				0x01800014))
			return HPI6205_ERROR_DSP_EMIF4;

		/* set EMIF SDRAM control for 2Mx32 SDRAM (512x32x4 bank) */
		/*  need to use this else DSP code crashes? */
		boot_loader_write_mem32(pao, dsp_index, 0x01800018,
			0x07117000);

		/* EMIF SDRAM Refresh Timing */
		/* EMIF SDRAM timing  (orig = 0x410, emulator = 0x61a) */
		boot_loader_write_mem32(pao, dsp_index, 0x0180001C,
			0x00000410);

	} else if (dsp_index == 1) {
		/* test access to the C6713s HPI registers */
		u32 write_data = 0, read_data = 0, i = 0;

		/* Set up HPIC for little endian, by setiing HPIC:HWOB=1 */
		write_data = 1;
		boot_loader_write_mem32(pao, 0, HPICL_ADDR, write_data);
		boot_loader_write_mem32(pao, 0, HPICH_ADDR, write_data);
		/* C67 HPI is on lower 16bits of 32bit EMIF */
		read_data =
			0xFFF7 & boot_loader_read_mem32(pao, 0, HPICL_ADDR);
		if (write_data != read_data) {
			HPI_DEBUG_LOG(ERROR, "HPICL %x %x\n", write_data,
				read_data);
			return HPI6205_ERROR_C6713_HPIC;
		}
		/* HPIA - walking ones test */
		write_data = 1;
		for (i = 0; i < 32; i++) {
			boot_loader_write_mem32(pao, 0, HPIAL_ADDR,
				write_data);
			boot_loader_write_mem32(pao, 0, HPIAH_ADDR,
				(write_data >> 16));
			read_data =
				0xFFFF & boot_loader_read_mem32(pao, 0,
				HPIAL_ADDR);
			read_data =
				read_data | ((0xFFFF &
					boot_loader_read_mem32(pao, 0,
						HPIAH_ADDR))
				<< 16);
			if (read_data != write_data) {
				HPI_DEBUG_LOG(ERROR, "HPIA %x %x\n",
					write_data, read_data);
				return HPI6205_ERROR_C6713_HPIA;
			}
			write_data = write_data << 1;
		}

		/* setup C67x PLL
		 *  ** C6713 datasheet says we cannot program PLL from HPI,
		 * and indeed if we try to set the PLL multiply from the HPI,
		 * the PLL does not seem to lock, so we enable the PLL and
		 * use the default multiply of x 7, which for a 27MHz clock
		 * gives a DSP speed of 189MHz
		 */
		/* bypass PLL */
		boot_loader_write_mem32(pao, dsp_index, 0x01B7C100, 0x0000);
		hpios_delay_micro_seconds(1000);
		/* EMIF = 189/3=63MHz */
		boot_loader_write_mem32(pao, dsp_index, 0x01B7C120, 0x8002);
		/* peri = 189/2 */
		boot_loader_write_mem32(pao, dsp_index, 0x01B7C11C, 0x8001);
		/* cpu  = 189/1 */
		boot_loader_write_mem32(pao, dsp_index, 0x01B7C118, 0x8000);
		hpios_delay_micro_seconds(1000);
		/* ** SGT test to take GPO3 high when we start the PLL */
		/* and low when the delay is completed */
		/* FSX0 <- '1' (GPO3) */
		boot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002A0A);
		/* PLL not bypassed */
		boot_loader_write_mem32(pao, dsp_index, 0x01B7C100, 0x0001);
		hpios_delay_micro_seconds(1000);
		/* FSX0 <- '0' (GPO3) */
		boot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002A02);

		/* 6205 EMIF CE1 resetup - 32 bit async. */
		/* Now 6713 #1 is running at 189MHz can reduce waitstates */
		boot_loader_write_mem32(pao, 0, 0x01800004,	/* CE1 */
			(1L << WS_OFS) | (8L << WST_OFS) | (1L << WH_OFS) |
			(1L << RS_OFS) | (12L << RST_OFS) | (1L << RH_OFS) |
			(2L << MTYPE_OFS));

		hpios_delay_micro_seconds(1000);

		/* check that we can read one of the PLL registers */
		/* PLL should not be bypassed! */
		if ((boot_loader_read_mem32(pao, dsp_index, 0x01B7C100) & 0xF)
			!= 0x0001) {
			return HPI6205_ERROR_C6713_PLL;
		}
		/* setup C67x EMIF  (note this is the only use of
		   BAR1 via BootLoader_WriteMem32) */
		boot_loader_write_mem32(pao, dsp_index, C6713_EMIF_GCTL,
			0x000034A8);

		/* EMIF CE0 setup - 2Mx32 Sync DRAM
		   31..28       Wr setup
		   27..22       Wr strobe
		   21..20       Wr hold
		   19..16       Rd setup
		   15..14       -
		   13..8        Rd strobe
		   7..4         MTYPE   0011            Sync DRAM 32bits
		   3            Wr hold MSB
		   2..0         Rd hold
		 */
		boot_loader_write_mem32(pao, dsp_index, C6713_EMIF_CE0,
			0x00000030);

		/* EMIF SDRAM Extension
		   0x00
		   31-21        0000b 0000b 000b
		   20           WR2RD = 2cycles-1  = 1b

		   19-18        WR2DEAC = 3cycle-1 = 10b
		   17           WR2WR = 2cycle-1   = 1b
		   16-15        R2WDQM = 4cycle-1  = 11b
		   14-12        RD2WR = 6cycles-1  = 101b

		   11-10        RD2DEAC = 4cycle-1 = 11b
		   9            RD2RD = 2cycle-1   = 1b
		   8-7          THZP = 3cycle-1    = 10b
		   6-5          TWR  = 2cycle-1    = 01b (tWR = 17ns)
		   4            TRRD = 2cycle      = 0b  (tRRD = 14ns)
		   3-1          TRAS = 5cycle-1    = 100b (Tras=42ns)
		   1            CAS latency = 3cyc = 1b
		   (for Micron 2M32-7 operating at 100MHz)
		 */
		boot_loader_write_mem32(pao, dsp_index, C6713_EMIF_SDRAMEXT,
			0x001BDF29);

		/* EMIF SDRAM control - set up for a 2Mx32 SDRAM (512x32x4 bank)
		   31           -       0b       -
		   30           SDBSZ   1b              4 bank
		   29..28       SDRSZ   00b             11 row address pins

		   27..26       SDCSZ   01b             8 column address pins
		   25           RFEN    1b              refersh enabled
		   24           INIT    1b              init SDRAM!

		   23..20       TRCD    0001b                   (Trcd/Tcyc)-1 = (20/10)-1 = 1

		   19..16       TRP     0001b                   (Trp/Tcyc)-1 = (20/10)-1 = 1

		   15..12       TRC     0110b                   (Trc/Tcyc)-1 = (70/10)-1 = 6

		   11..0        -       0000b 0000b 0000b
		 */
		boot_loader_write_mem32(pao, dsp_index, C6713_EMIF_SDRAMCTL,
			0x47116000);

		/* SDRAM refresh timing
		   Need 4,096 refresh cycles every 64ms = 15.625us = 1562cycles of 100MHz = 0x61A
		 */
		boot_loader_write_mem32(pao, dsp_index,
			C6713_EMIF_SDRAMTIMING, 0x00000410);

		hpios_delay_micro_seconds(1000);
	} else if (dsp_index == 2) {
		/* DSP 2 is a C6713 */
	}

	return 0;
}

static u16 boot_loader_test_memory(struct hpi_adapter_obj *pao, int dsp_index,
	u32 start_address, u32 length)
{
	u32 i = 0, j = 0;
	u32 test_addr = 0;
	u32 test_data = 0, data = 0;

	length = 1000;

	/* for 1st word, test each bit in the 32bit word, */
	/* dwLength specifies number of 32bit words to test */
	/*for(i=0; i<dwLength; i++) */
	i = 0;
	{
		test_addr = start_address + i * 4;
		test_data = 0x00000001;
		for (j = 0; j < 32; j++) {
			boot_loader_write_mem32(pao, dsp_index, test_addr,
				test_data);
			data = boot_loader_read_mem32(pao, dsp_index,
				test_addr);
			if (data != test_data) {
				HPI_DEBUG_LOG(VERBOSE,
					"Memtest error details  "
					"%08x %08x %08x %i\n", test_addr,
					test_data, data, dsp_index);
				return 1;	/* error */
			}
			test_data = test_data << 1;
		}	/* for(j) */
	}	/* for(i) */

	/* for the next 100 locations test each location, leaving it as zero */
	/* write a zero to the next word in memory before we read */
	/* the previous write to make sure every memory location is unique */
	for (i = 0; i < 100; i++) {
		test_addr = start_address + i * 4;
		test_data = 0xA5A55A5A;
		boot_loader_write_mem32(pao, dsp_index, test_addr, test_data);
		boot_loader_write_mem32(pao, dsp_index, test_addr + 4, 0);
		data = boot_loader_read_mem32(pao, dsp_index, test_addr);
		if (data != test_data) {
			HPI_DEBUG_LOG(VERBOSE,
				"Memtest error details  "
				"%08x %08x %08x %i\n", test_addr, test_data,
				data, dsp_index);
			return 1;	/* error */
		}
		/* leave location as zero */
		boot_loader_write_mem32(pao, dsp_index, test_addr, 0x0);
	}

	/* zero out entire memory block */
	for (i = 0; i < length; i++) {
		test_addr = start_address + i * 4;
		boot_loader_write_mem32(pao, dsp_index, test_addr, 0x0);
	}
	return 0;
}

static u16 boot_loader_test_internal_memory(struct hpi_adapter_obj *pao,
	int dsp_index)
{
	int err = 0;
	if (dsp_index == 0) {
		/* DSP 0 is a C6205 */
		/* 64K prog mem */
		err = boot_loader_test_memory(pao, dsp_index, 0x00000000,
			0x10000);
		if (!err)
			/* 64K data mem */
			err = boot_loader_test_memory(pao, dsp_index,
				0x80000000, 0x10000);
	} else if (dsp_index == 1) {
		/* DSP 1 is a C6713 */
		/* 192K internal mem */
		err = boot_loader_test_memory(pao, dsp_index, 0x00000000,
			0x30000);
		if (!err)
			/* 64K internal mem / L2 cache */
			err = boot_loader_test_memory(pao, dsp_index,
				0x00030000, 0x10000);
	}

	if (err)
		return HPI6205_ERROR_DSP_INTMEM;
	else
		return 0;
}

static u16 boot_loader_test_external_memory(struct hpi_adapter_obj *pao,
	int dsp_index)
{
	u32 dRAM_start_address = 0;
	u32 dRAM_size = 0;

	if (dsp_index == 0) {
		/* only test for SDRAM if an ASI5000 card */
		if (pao->pci.pci_dev->subsystem_device == 0x5000) {
			/* DSP 0 is always C6205 */
			dRAM_start_address = 0x00400000;
			dRAM_size = 0x200000;
			/*dwDRAMinc=1024; */
		} else
			return 0;
	} else if (dsp_index == 1) {
		/* DSP 1 is a C6713 */
		dRAM_start_address = 0x80000000;
		dRAM_size = 0x200000;
		/*dwDRAMinc=1024; */
	}

	if (boot_loader_test_memory(pao, dsp_index, dRAM_start_address,
			dRAM_size))
		return HPI6205_ERROR_DSP_EXTMEM;
	return 0;
}

static u16 boot_loader_test_pld(struct hpi_adapter_obj *pao, int dsp_index)
{
	u32 data = 0;
	if (dsp_index == 0) {
		/* only test for DSP0 PLD on ASI5000 card */
		if (pao->pci.pci_dev->subsystem_device == 0x5000) {
			/* PLD is located at CE3=0x03000000 */
			data = boot_loader_read_mem32(pao, dsp_index,
				0x03000008);
			if ((data & 0xF) != 0x5)
				return HPI6205_ERROR_DSP_PLD;
			data = boot_loader_read_mem32(pao, dsp_index,
				0x0300000C);
			if ((data & 0xF) != 0xA)
				return HPI6205_ERROR_DSP_PLD;
		}
	} else if (dsp_index == 1) {
		/* DSP 1 is a C6713 */
		if (pao->pci.pci_dev->subsystem_device == 0x8700) {
			/* PLD is located at CE1=0x90000000 */
			data = boot_loader_read_mem32(pao, dsp_index,
				0x90000010);
			if ((data & 0xFF) != 0xAA)
				return HPI6205_ERROR_DSP_PLD;
			/* 8713 - LED on */
			boot_loader_write_mem32(pao, dsp_index, 0x90000000,
				0x02);
		}
	}
	return 0;
}

/** Transfer data to or from DSP
 nOperation = H620_H620_HIF_SEND_DATA or H620_HIF_GET_DATA
*/
static short hpi6205_transfer_data(struct hpi_adapter_obj *pao, u8 *p_data,
	u32 data_size, int operation)
{
	struct hpi_hw_obj *phw = pao->priv;
	u32 data_transferred = 0;
	u16 err = 0;
	u32 temp2;
	struct bus_master_interface *interface = phw->p_interface_buffer;

	if (!p_data)
		return HPI_ERROR_INVALID_DATA_POINTER;

	data_size &= ~3L;	/* round data_size down to nearest 4 bytes */

	/* make sure state is IDLE */
	if (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT))
		return HPI_ERROR_DSP_HARDWARE;

	while (data_transferred < data_size) {
		u32 this_copy = data_size - data_transferred;

		if (this_copy > HPI6205_SIZEOF_DATA)
			this_copy = HPI6205_SIZEOF_DATA;

		if (operation == H620_HIF_SEND_DATA)
			memcpy((void *)&interface->u.b_data[0],
				&p_data[data_transferred], this_copy);

		interface->transfer_size_in_bytes = this_copy;

		/* DSP must change this back to nOperation */
		interface->dsp_ack = H620_HIF_IDLE;
		send_dsp_command(phw, operation);

		temp2 = wait_dsp_ack(phw, operation, HPI6205_TIMEOUT);
		HPI_DEBUG_LOG(DEBUG, "spun %d times for data xfer of %d\n",
			HPI6205_TIMEOUT - temp2, this_copy);

		if (!temp2) {
			/* timed out */
			HPI_DEBUG_LOG(ERROR,
				"Timed out waiting for " "state %d got %d\n",
				operation, interface->dsp_ack);

			break;
		}
		if (operation == H620_HIF_GET_DATA)
			memcpy(&p_data[data_transferred],
				(void *)&interface->u.b_data[0], this_copy);

		data_transferred += this_copy;
	}
	if (interface->dsp_ack != operation)
		HPI_DEBUG_LOG(DEBUG, "interface->dsp_ack=%d, expected %d\n",
			interface->dsp_ack, operation);
	/*                      err=HPI_ERROR_DSP_HARDWARE; */

	send_dsp_command(phw, H620_HIF_IDLE);

	return err;
}

/* wait for up to timeout_us microseconds for the DSP
   to signal state by DMA into dwDspAck
*/
static int wait_dsp_ack(struct hpi_hw_obj *phw, int state, int timeout_us)
{
	struct bus_master_interface *interface = phw->p_interface_buffer;
	int t = timeout_us / 4;

	rmb();	/* ensure interface->dsp_ack is up to date */
	while ((interface->dsp_ack != state) && --t) {
		hpios_delay_micro_seconds(4);
		rmb();	/* DSP changes dsp_ack by DMA */
	}

	/*HPI_DEBUG_LOG(VERBOSE, "Spun %d for %d\n", timeout_us/4-t, state); */
	return t * 4;
}

/* set the busmaster interface to cmd, then interrupt the DSP */
static void send_dsp_command(struct hpi_hw_obj *phw, int cmd)
{
	struct bus_master_interface *interface = phw->p_interface_buffer;
	u32 r;

	interface->host_cmd = cmd;
	wmb();	/* DSP gets state by DMA, make sure it is written to memory */
	/* before we interrupt the DSP */
	r = ioread32(phw->prHDCR);
	r |= (u32)C6205_HDCR_DSPINT;
	iowrite32(r, phw->prHDCR);
	r &= ~(u32)C6205_HDCR_DSPINT;
	iowrite32(r, phw->prHDCR);
}

static unsigned int message_count;

static u16 message_response_sequence(struct hpi_adapter_obj *pao,
	struct hpi_message *phm, struct hpi_response *phr)
{
	u32 time_out, time_out2;
	struct hpi_hw_obj *phw = pao->priv;
	struct bus_master_interface *interface = phw->p_interface_buffer;
	u16 err = 0;

	message_count++;
	if (phm->size > sizeof(interface->u.message_buffer)) {
		phr->error = HPI_ERROR_MESSAGE_BUFFER_TOO_SMALL;
		phr->specific_error = sizeof(interface->u.message_buffer);
		phr->size = sizeof(struct hpi_response_header);
		HPI_DEBUG_LOG(ERROR,
			"message len %d too big for buffer %zd \n", phm->size,
			sizeof(interface->u.message_buffer));
		return 0;
	}

	/* Assume buffer of type struct bus_master_interface
	   is allocated "noncacheable" */

	if (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT)) {
		HPI_DEBUG_LOG(DEBUG, "timeout waiting for idle\n");
		return HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT;
	}

	memcpy(&interface->u.message_buffer, phm, phm->size);
	/* signal we want a response */
	send_dsp_command(phw, H620_HIF_GET_RESP);

	time_out2 = wait_dsp_ack(phw, H620_HIF_GET_RESP, HPI6205_TIMEOUT);

	if (!time_out2) {
		HPI_DEBUG_LOG(ERROR,
			"(%u) Timed out waiting for " "GET_RESP state [%x]\n",
			message_count, interface->dsp_ack);
	} else {
		HPI_DEBUG_LOG(VERBOSE,
			"(%u) transition to GET_RESP after %u\n",
			message_count, HPI6205_TIMEOUT - time_out2);
	}
	/* spin waiting on HIF interrupt flag (end of msg process) */
	time_out = HPI6205_TIMEOUT;

	/* read the result */
	if (time_out) {
		if (interface->u.response_buffer.response.size <= phr->size)
			memcpy(phr, &interface->u.response_buffer,
				interface->u.response_buffer.response.size);
		else {
			HPI_DEBUG_LOG(ERROR,
				"response len %d too big for buffer %d\n",
				interface->u.response_buffer.response.size,
				phr->size);
			memcpy(phr, &interface->u.response_buffer,
				sizeof(struct hpi_response_header));
			phr->error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;
			phr->specific_error =
				interface->u.response_buffer.response.size;
			phr->size = sizeof(struct hpi_response_header);
		}
	}
	/* set interface back to idle */
	send_dsp_command(phw, H620_HIF_IDLE);

	if (!time_out || !time_out2) {
		HPI_DEBUG_LOG(DEBUG, "something timed out!\n");
		return HPI6205_ERROR_MSG_RESP_TIMEOUT;
	}
	/* special case for adapter close - */
	/* wait for the DSP to indicate it is idle */
	if (phm->function == HPI_ADAPTER_CLOSE) {
		if (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT)) {
			HPI_DEBUG_LOG(DEBUG,
				"Timeout waiting for idle "
				"(on adapter_close)\n");
			return HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT;
		}
	}
	err = hpi_validate_response(phm, phr);
	return err;
}

static void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,
	struct hpi_response *phr)
{

	u16 err = 0;

	hpios_dsplock_lock(pao);

	err = message_response_sequence(pao, phm, phr);

	/* maybe an error response */
	if (err) {
		/* something failed in the HPI/DSP interface */
		if (err >= HPI_ERROR_BACKEND_BASE) {
			phr->error = HPI_ERROR_DSP_COMMUNICATION;
			phr->specific_error = err;
		} else {
			phr->error = err;
		}

		pao->dsp_crashed++;

		/* just the header of the response is valid */
		phr->size = sizeof(struct hpi_response_header);
		goto err;
	} else
		pao->dsp_crashed = 0;

	if (phr->error != 0)	/* something failed in the DSP */
		goto err;

	switch (phm->function) {
	case HPI_OSTREAM_WRITE:
	case HPI_ISTREAM_ANC_WRITE:
		err = hpi6205_transfer_data(pao, phm->u.d.u.data.pb_data,
			phm->u.d.u.data.data_size, H620_HIF_SEND_DATA);
		break;

	case HPI_ISTREAM_READ:
	case HPI_OSTREAM_ANC_READ:
		err = hpi6205_transfer_data(pao, phm->u.d.u.data.pb_data,
			phm->u.d.u.data.data_size, H620_HIF_GET_DATA);
		break;

	}
	phr->error = err;

err:
	hpios_dsplock_unlock(pao);

	return;
}
                                                                                                                                                                                                                              /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _LINUX_FCNTL_H
#define _LINUX_FCNTL_H

#include <asm/fcntl.h>

#define F_SETLEASE	(F_LINUX_SPECIFIC_BASE + 0)
#define F_GETLEASE	(F_LINUX_SPECIFIC_BASE + 1)

/*
 * Cancel a blocking posix lock; internal use only until we expose an
 * asynchronous lock api to userspace:
 */
#define F_CANCELLK	(F_LINUX_SPECIFIC_BASE + 5)

/* Create a file descriptor with FD_CLOEXEC set. */
#define F_DUPFD_CLOEXEC	(F_LINUX_SPECIFIC_BASE + 6)

/*
 * Request nofications on a directory.
 * See below for events that may be notified.
 */
#define F_NOTIFY	(F_LINUX_SPECIFIC_BASE+2)

/*
 * Set and get of pipe page size array
 */
#define F_SETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 7)
#define F_GETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 8)

/*
 * Set/Get seals
 */
#define F_ADD_SEALS	(F_LINUX_SPECIFIC_BASE + 9)
#define F_GET_SEALS	(F_LINUX_SPECIFIC_BASE + 10)

/*
 * Types of seals
 */
#define F_SEAL_SEAL	0x0001	/* prevent further seals from being set */
#define F_SEAL_SHRINK	0x0002	/* prevent file from shrinking */
#define F_SEAL_GROW	0x0004	/* prevent file from growing */
#define F_SEAL_WRITE	0x0008	/* prevent writes */
/* (1U << 31) is reserved for signed error codes */

/*
 * Set/Get write life time hints. {GET,SET}_RW_HINT operate on the
 * underlying inode, while {GET,SET}_FILE_RW_HINT operate only on
 * the specific file.
 */
#define F_GET_RW_HINT		(F_LINUX_SPECIFIC_BASE + 11)
#define F_SET_RW_HINT		(F_LINUX_SPECIFIC_BASE + 12)
#define F_GET_FILE_RW_HINT	(F_LINUX_SPECIFIC_BASE + 13)
#define F_SET_FILE_RW_HINT	(F_LINUX_SPECIFIC_BASE + 14)

/*
 * Valid hint values for F_{GET,SET}_RW_HINT. 0 is "not set", or can be
 * used to clear any hints previously set.
 */
#define RWF_WRITE_LIFE_NOT_SET	0
#define RWH_WRITE_LIFE_NONE	1
#define RWH_WRITE_LIFE_SHORT	2
#define RWH_WRITE_LIFE_MEDIUM	3
#define RWH_WRITE_LIFE_LONG	4
#define RWH_WRITE_LIFE_EXTREME	5

/*
 * Types of directory notifications that may be requested.
 */
#define DN_ACCESS	0x00000001	/* File accessed */
#define DN_MODIFY	0x00000002	/* File modified */
#define DN_CREATE	0x00000004	/* File created */
#define DN_DELETE	0x00000008	/* File removed */
#define DN_RENAME	0x00000010	/* File renamed */
#define DN_ATTRIB	0x00000020	/* File changed attibutes */
#define DN_MULTISHOT	0x80000000	/* Don't remove notifier */

#define AT_FDCWD		-100    /* Special value used to indicate
                                           openat should use the current
                                           working directory. */
#define AT_SYMLINK_NOFOLLOW	0x100   /* Do not follow symbolic links.  */
#define AT_REMOVEDIR		0x200   /* Remove directory instead of
                                           unlinking file.  */
#define AT_SYMLINK_FOLLOW	0x400   /* Follow symbolic links.  */
#define AT_NO_AUTOMOUNT		0x800	/* Suppress terminal automount traversal */
#define AT_EMPTY_PATH		0x1000	/* Allow empty relative pathname */

#define AT_STATX_SYNC_TYPE	0x6000	/* Type of synchronisation required from statx() */
#define AT_STATX_SYNC_AS_STAT	0x0000	/* - Do whatever stat() does */
#define AT_STATX_FORCE_SYNC	0x2000	/* - Force the attributes to be sync'd with the server */
#define AT_STATX_DONT_SYNC	0x4000	/* - Don't sync attributes with the server */


#endif /* _LINUX_FCNTL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               INDX( 	                 (   ò   Ë       ‘                    K≥    ` N     E≥    ÙÂnˇ3‘ê∑<¸H9‘ê∑<¸H9‘≥?oëH9‘                        h e l p e r                 E≥    ÓÃnˇ3‘‡† hÍ2‘ˇ€nˇ3‘ÏÃnˇ3‘                         m t 6 5 x x . h                     E≥    ÓÃnˇ3‘‡† hÍ2‘ˇ€nˇ3‘ÏÃnˇ3‘                         m t 6 5 x x . h                     E≥    ÓÃnˇ3‘‡† hÍ2‘ˇ€nˇ3‘ÏÃnˇ3‘                         m t 6 5 x x . h                     E≥    ÓÃnˇ3‘‡† hÍ2 ˇ€nˇ3‘ÏÃnˇ3‘                         m t 6 5 x x . h                     E≥    ÓÃnˇ3‘‡† hÍ2‘ˇ€nˇ3‘ÏÃnˇ3‘                         m t 6 5 x x . h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          ∑                    €         @     @   ‡ ë ƒrí@˘‡™  ±0C˙‰áüöƒ  ¥ ÄR# @9§  4Ä|@ì¿_÷§Ä˝ˇˇa ?¿ q†  T x  8q°  T   ê  π‡™Ûˇˇ?ƒ q`  Tdq°  T   ê! ÄR  π˜ˇˇ » Q   qh˛ˇT!¿ Q   ê¯ˇˇ‡ ë ƒrí@˘‡™  ±0C˙‰áüöƒ  ¥ ÄR$ @9£  4`|@ì¿_÷£Ä˝ˇˇÅ ?¿ q†  T x  8q°  T   ê  π‡™Ûˇˇ?ƒ q`  TdqaˇˇT   ê! ÄR  π˜ˇˇ‡ ë ƒrí@˘‡™  ±0C˙‰áüöƒ  ¥ ÄR$ @9£  4`|@ì¿_÷£Ä˝ˇˇÅ ?¿ q†  T x  8q°  T   ê  π‡™Ûˇˇ?ƒ q`  TdqaˇˇT   ê! ÄR  π˜ˇˇ‡ ë ƒrí@˘‡™  ±0C˙‰áüöƒ  ¥ ÄR$ @9£  4`|@ì¿_÷£Ä˝ˇˇÅ ?¿ q†  T x  8q°  T   ê  π‡™Ûˇˇ?ƒ q`  TdqaˇˇT   ê! ÄR  π˜ˇˇ˝{ø©‡™ Ä“  ê˝ ë!  ë   î˝{¡®¿_÷˝{ø©‡™ Ä“  ê˝ ë!  ë   î˝{¡®¿_÷˝{ø©‡™ Ä“  ê˝ ë!  ë   î˝{¡®¿_÷˝{ø©‡™ Ä“  ê˝ ë!  ë   î˝{¡®¿_÷˝{ø©‡™ Ä“  ê˝ ë!  ë   î˝{¡®¿_÷˝{ø©‡™ Ä“  ê˝ ë!  ë   î˝{¡®¿_÷˝{ø©  ê˝ ë" @π  ê!  ë   î  ÄR˝{¡®¿_÷˝{ø©  ê˝ ë" @π  ê!  ë   î  ÄR˝{¡®¿_÷˝{ø©  ê˝ ë" @π  ê!  ë   î  ÄR˝{¡®¿_÷˝{ø©  ê˝ ë" @π  ê!  ë   î  ÄR˝{¡®¿_÷˝{ø©  ê˝ ë" @π  ê!  ë   î  ÄR˝{¡®¿_÷ˇC—  ê!  ë˝{©˝C ëÛS©Û ™ı[©˜c©  ê˘k© ÄR˚s©   î  êB  ë  ê‡™!  ë   î  ê‡™!  ë   îAÄR‡™   î   ê  ê!  ë @π‡™   î  ê!  ë‡™   î‡ ë   î   ê @˘   ë†? ˘   ê   ë†7 ˘†?@˘ü Î· T‡ ë   îAÄR‡™   î  ÄR˝{A©ÛSB©ı[C©˜cD©˘kE©˚sF©ˇCë¿_÷ñ
@˘    ê   ë†; ˘ÄB ëﬂ Îa  Tî@˘Êˇˇƒ:@˘√2ë§  ¥∆2@˘f  ¥«6@˘G µ°;@˘‚*‡™   îï≤ëõ‚Cy‡™ö"@πôJ@π   îú™Aπ‡™   î‰*„*‚*Â*˘™  ê‡™!  ë   î  ê  ê‡™!  ë   î5A¯{ ë ÄRøÎ° T  ê!  ë‡™   î  ê  ë   îï @˘  êõBëZ ëøÎ· T  ë   î÷@˘ƒˇˇ¿V@π‚*‡ π  ê!  ë¿ä@π‡ π‡™≈R@π   î…ˇˇ§@πZ °7@˘‚*£ë‡™ºfEπ   î¢¶B˘Ç  ¥·™‡™   î•bEπ  ê¢jEπ!  ë£nEπ‡™§rEπ   îü q¡ T  ê!  ë‡™   îÄ@˘D@˘Ç  ¥·™‡™@ ?÷†ÓV9†  6  ê‡™!  ë   îAÄR‡™   îµ@˘∑ˇˇü qÅ  T  ê!  ëÈˇˇ‚*  ê‡™!  ë   îÂˇˇ£≤@y·™§"@π‡™¢R@π¶@˘•"@˘   îµ@˘Øˇˇ˝{ø©F|@ìÂ™' ÄR˝ ëÑ ÄRÄRB ÄR  ê   ê!  ë   ë   î˝{¡®¿_÷˝{∏©˝ ë°ã©°ë† ˘†É ë†á©   ê° ˘°ë° ˘·Ä   ë°; πø? π  ê£ì©!  ë•õ©ß? ˘   î†  4   ê°C ë   ë   î˝{»®¿_÷˝{Ω©D —ü( Ò˝ ëÛS© T‡ ëøC¯ƒríø/ π„™Û™Ñ@˘c ´b0D˙Âáüö≈  µ≥Äí‡™ÛSA©˝{√®¿_÷†ì ë   î ˇˇµ
 Ò® T†ì@9¿ q†  Tx! ?8q°  T   ê°ÄR  πÌˇˇƒ q`  T?dqÅ  T   ê° äR¯ˇˇ  ê!  ë »`8‡ 7   ê°ì ë   ë   î≥Äí‹ˇˇ¢É ë ÄR†ì ë   îÙ *‡  4°ì ë   êì~@ì   ë   î–ˇˇ†#@π†˝ˇ4ÔëR·˛ør j†  T   ê   ë   îÈˇˇêR 
! ÇR_ k 
a T¢# π†#@π" ÇR   *  2 j  Å  ê   π∂ˇˇÄR†r 
_ k@˛ˇTÉ àR 
_ k¿˝ˇTB ÑR  
 k  ü†# πÈˇˇ¿_÷¿_÷˝{æ© Ä“   ê   ë˝ ëÛS©  ê   îÄ ˘† ¥  ês ë‚ ™ Ä“cB ë ÄR   ê   ë   îÇ@˘ Ä“c‚ë ÄR   ê   ë   îÇ@˘ Ä“cÇë ÄR   ê   ë   îÇ@˘ Ä“c"ë ÄR   ê   ë   îÇ@˘ Ä“c¬ë ÄR   ê   ë   îÇ@˘   ê Ä“cbë ÄR   ë   îÛSA©˝{¬®¿_÷˝{æ©˝ ëÛ ˘  êa@˘Å ¥   ê   ë   îa@˘   ê   ë   îa@˘   ê   ë   îa@˘   ê   ë   îa@˘   ê   ë   îa@˘   ê   ë   î   ê Ä“   ë   îÛ@˘˝{¬®¿_÷    Ù  
                       §Ä Ä“   £Ä Ä“   £Ä Ä“   £Ä Ä“                                                                   cifs_vfs_err                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    %d
 0x%x
 Display Internal CIFS Data Structures for Debugging
---------------------------------------------------
 2.05 CIFS Version %s
 Features: Active VFS Requests: %d
 Servers: 
%d) entry for %s not fully displayed
	 
%d) Name: %s  Domain: %s Uses: %d OS: %s
	NOS: %s	Capability: 0x%x
	SMB session status: %d	 TCP status: %d
	Local Users To Server: %d SecMode: 0x%x Req On Wire: %d 
	Shares: 
	%d) %s Mounts: %d  Type: %s  DevInfo: 0x%x Attributes: 0x%x
	PathComponentMax: %d Status: %d  type: DISK   type: CDROM   type: %d  	DISCONNECTED  
	MIDs:
 	State: %d com: %d pid: %d cbdata: %p mid %llu
  7 3[name:cifs&]CIFS VFS: %pV Invalid SecurityFlags: %s
 Unsupported security flags: 0x%x
 fs/cifs DebugData cifsFYI traceSMB LinuxExtensionsEnabled SecurityFlags LookupCacheEnabled x      s                    Ë
          2    -   P-   
-   N   -    `   N   2    Y   2    Pe   e       Å   2        ì   2    ì   Pì       Ø   2        ∆   ∂   2        ÿ   tint ÿ       e       ˙   2          2    @s8 Å   @u8 ì     @u16 ∆   @s32 ÿ   @u32 e   B  @s64 ˙   @u64   ;e   	Ç  	     	     
-   í  -    ù  ÿ        	®  2    P®      	-       	ÿ       	0e       	1e       	G¥      	Hù  
ÿ     -        	W˙       	Xù      	Yù      	Zÿ       	[ÿ   Y       
 ∂       
!∂       
"‰       
#‰       
$      
'∂       
(‰       ‰       ê      ∆       ø      2      “  2                ’      -      6‡      ;Î      E      aà       Ö-       Ü-       ì]      ûe       üe       †e       £]      ®h  ∞ì      ±ÿ         ≤~  µ≥      ∂®        ∑û      ∫„      ªË       ªË   æ  æ      æ      ø,        ¬,      √,       √2     ,      “]      ”]       ‘n   8  n  ]   c      (        æ  J    æ   J    æ  J    æ  J    ÿ   J    ÿ    u    ct      á÷  ‹  Aÿ   Á  v
À  Û  3     äË      äË      ãË      ãË  
Y   *  3     í      ì=      îe       ú·      û«      (-   
`   w  3 l      
w      w      «      ÿ   
ÿ   ≥  3     _®      q‚  fmt rN    va s‚   ¿      œÿ       –ÿ       —ÿ       Ëœê      –å/       —€}      “ˇ}      ”#~      ‘w~       ’w~  (    ÷ë~  0    ◊ë~  8    ÿ±~  @    Ÿˆ~  H    ⁄  P    €  X    ‹/  `    ›I  h    ﬁc  p    ﬂI  x    ‡á  Ä    ·°  à    ‚¿  ê    „ﬂ  ò    ‰Ä  †    Â>/  ®    Ê"Ä  ∞    Áﬂ  ∏    ËKÄ  ¿    ÈtÄ  »    ÍòÄ  –    ÎºÄ  ÿ    ÌzÅ  ‡ 	      6ê  Qe   8¬  	     	    	         ;È      <]       =Á?       Î¬  ®    ÿ        Ï  Ù      §ÿ       •ÿ       ¶ÿ       ßÿ       ®ÿ       ©ÿ       ªÿ       Ω«  E    e   ¿•  	     	    	    	    	         ∆t      ÿw      „w      3=      jh  (1	      1	   val B      B      B      ]      1	    B    p	      !º       "ï	      $¿	      &]       	ï	      
       ®   p	      E¿	      Fa       G7   õ	   )
      *;
       +ÿ       ,ÿ       --       .-        #;
  fd $ÿ        %Ø       &Ø    
  (k
      ‡      '7	      /∆	       0â
  fn û
   !A
   ®  ò
  ò
   k
  â
      (-       h.(      /-        0§
      1      2!      3k
       4ÿ   Pcpu 5ÿ   T    6æ  X    7ÿ   ` #    ∞W      XØ       Yæ      Zì      [e       \e       _Z0       `ÿ   (    a  0    b-   8    c-   @    eÿ   H    gÿ   L    iÿ   P    iÿ   T    iÿ   X    je   \    kÊV  `Fse lkT  h'rt mUU  (    oÒV  p\dl q‹U  x    |e       }ÿ       ~‘       Åÿ   (    Ç∫V  ,    Éæ  0    Ü¸V  @    ê#N  H    ìæ  h    ï◊/  x    ñ4%  †'mm ôÈ%  ∏    ôÈ%  ¿%    õe   »    ûB  Ã    üW  –    °∏.      §ÿ        •ÿ       •ÿ       ¶ÿ       ße       ™e   %    ¨e   %    Æe   %    ±e   %    ≤e       ¥-    'pid ∂±  (    ∑±  ,    ¬  0    √  8    «æ  @    »æ  P    …  `    ’æ  h    ÷æ  x    ŸW  à    ⁄æ  –    €æ  ‡    ›,F      ﬁPD  ¯    ﬂPD       ·O0      ·O0      ·O0      ·O0       ‚O0  (    „  0    ÂJ  8    -   H    -   P    Ò]  X    Ú]  `    Ù-   h    Ù-   p    ˜-   x    ˘-   Ä    ˘-   à    ¸4J  ê    ˝ä:  ®     "W  ÿ    "W  ‡    (W  Ë    	ÿ   ¯    	ÿ   ¸       'fs =W  ∞	    HW  ∏	    ÓF  ¿	    NW  »	    TW  –	    ª3  ÿ	    ª3  ‡	     ª3  Ë	    !V6  	    #-   
    $˙  
    %iW  
    &æ   
    'oW  (
    (]  0
    *zW  8
    ,À2  @
    -e   D
    /ÕA  H
    2B  X
    3B  \
    6]  `
    9&  d
    =l%  h
    >f%  p
    @ÖW  x
    `æ  Ä
    cêW  à
    gõW  ê
    k¶W  ò
    mY  †
    oY  ®
    q-   ∞
    r#Y  ∏
    sHD  ¿
    Å‡Y  ¿
    Éæ  »
    ÜÎY  ÿ
    à&Z  ‡
    äæ  Ë
    ã1Z  ¯
    é7Z       èÑ>      êæ  8    ì-   H'rcu …8  P    ŒWZ  `    –P+  h    ÷ÿ   x    ‹ÿ   |    ›ÿ   Ä    ﬁ-   à    Ë-   ê    È-   ò    ¸-   †    ˛-   ® (        w    M-       4e       4e       7-   )    Já      Ká       L‰        M‰    
ó  ó  -    2    K¿      ,       ,   <    !û  %·      &l         'Ã      ÿ       ÿ   g     û    &      ¿    <       RAH  h    B       @]  ]2    <    LH   ~       ·         i  x!"π      !#á       !$B       !%B   y! ”      !!S  7â   )     !Ù  !π   ,cpu !)e    zpmu     "ÖÙ  )    #2N      #4ÿ        #6ÿ       #7ÿ       #9N      #:N  ê 
^  ^  -    d          h#=  x19 #>-    x20 #?-   x21 #@-   x22 #A-   x23 #B-    x24 #C-   (x25 #D-   0x26 #E-   8x27 #F-   @x28 #G-   Hfp #H-   Psp #I-   Xpc #J-   ` )    ∞#Mh      #Ni       #O-   h    #P”  p    #Q-   ê    #R-   ò    #S  †     $≥      %'ö      %(]       %)æ   <    %+s      &ø      &ƒ    ¶  
-   ‘  -         &¶      &ÿ       &O˚  ø  ı      &P˚      &Q˚      &R˚  -    &±-  
¶  =  -     
4   M  -     =      &‹M  
4   t  -   @-     ^      &
t      '.û      '/e         '3Ö  i'œ      'Ö       ']   {    '©       (      (e        (ö       )1ÿ       *R-       *S-       *`ÿ       +!H      +"m        +%m      +&m       +&s   H  m  K,ú      ,]       ,ÿ    R,∏  h    ,  |y       ,Õ  ]ú    -/Ó      -0B   len -0B   -.  7Õ      -2]       --&  !Ó       -4+     ö       0-<z      -=®       ->®      -?®      -@®      -Az    
®  ä  -        -C1  -Ö¥      -Ü      -á8       ¿-mÉ      -oe        -pû      -qH      -rà      -s       -t   0    -v–  8    -y∏  X    -zè  `    -{#   h    -|-   p    -}æ  x    -æ  Ä    -Äæ  ê    -Åæ  †d_u -àï  ∞ ¥  ¥  #    0       ¶       ∆       À2       Î2      !e       $mt      %mt      (⁄u       )#   (    *…)  0    -æ  8    1-   @!Îs  H    =õ  L    >Ô  P    ?p	  X    @p	  h    Ap	  x    B]  à    C∆   å    De   ê    E1  ò    L-   †    MÑ>  ®    O-   –    Q  ÿ    Ræ  Ë    Sæ  ¯    Tæ  Lt      Y]  (    Zì  0    [ì  4    \ì  8    `‡u  @    aÌv  H    bÁ(  P    fæ   L/t      m‰       p‰       qÓ       tæ  ( é  
ì   ‡  -        Ä@-óä      -ò=        -ô=       -öc       -õí       -ùß        -û∏   (    -ü∏   0    -†Œ   8    -°Ì   @    -¢=!  H    -£W!  P    -§q!  X    -•ç!  ` ‡  ä  #    @@Ø#       ∞æ       ±õ      ≤ì       ≥-       ¥Ô       µ£{  (    ∂¿|  0    ∑∆|  8    ∏Ã|  @    π‹|  H    ∫-   P    ª-   X    ºà  `    Ωû%  h    æÿ   ê    øì  î    ¡æ  ò    √Ï|  †    ≈æ  ®    ∆/  ∏    «æ  ¿    »√$  –    …Y  ÿ     ˝|  ‡    À  Ë    Ãón  ¯    Œàz       –™!  ∞    —}  –    ”æ  ‡    ‘e   Ë    ’R  Ï    ŸB      ﬂÑ>  ¯    Â=       Î=  (    Ïè  0    Òÿ   8    Û1[  @    ˆh  Ä    ˘ÿ   à    ¸c?  ê    ˝Ó  ò    b  @¿    b  @ 'rcu 8      
ÿ     ï  ÿ   =   à  e    )   ÿ   W   W   ]    É    C   ÿ   å   W   W   e   N   å    &  i   ÿ   ß   W    ò   ∏   à   ≠   Œ   à      æ   =  Ì   à  =  ÿ    ‘       !  !  !   Û   !      .8!  mnt .!       .	à   !  ¯   ÿ   W!  à  «   C!     q!  à  e    ]!  á!  á!  !   8!  w!      -Êœ      -’ÿ   
Y   ∫!  -        /ÿ       /ﬁ!  cap /ﬁ!    
‰   Ó!  -        /≈!  Ó!      /+˘!      /,˘!      9"      ÿ        ÿ        0	"      1L]      1M9       1∂-   ^    2%}"      2&R       2)e"      3ÿ       3ƒ«      3≈ÿ       84˛"      4æ       4-       4#      4#       4-   (    4ÿ   0     ˛"  #  -    	#      4$˛"      5V#      5é#       5e       5e    %#      86,é#      6.-    !»(  !í*  !‘*   ]+  0 [#  $    ©√$      ™õ       ´ÿ       ¨       ≠#       ÆÑ>      Øæ  @    ∞æ  P    ±æ  X    ≤ÿ   `    ≥«  d    µæ  h    ∑√$  x    ∏e   Ä    πœs  à    ªe   ê    ºÿ   î    Ω⁄s  ò    æÂs  †    øæ  ®    ∆-   ∏    …ÿ   ¿    ÀÑ>  » î#      7]      7]      7?…$      7O‘$      7S…$      8té#  
Í$  %  =-   ˇ     8ÿ%      8Ÿ%      9#f%      9$-        9%f%      9&f%   4%      9*Ö%      9+f%        :û%      :ì        (;È%      ;®       ;æ      ;&  osq ; Ö%      ;%    Ô%  #    6^Ü(      6_¡-       6`l%      6aB      6c>/      6g-        6h-   (    6i-   0    6j-   8pgd 6kD/  @    6lì  H    6mì  L    6nh  P    6oÿ   X    6q]  \    6rû%  `    6tæ  à    6z-   ò    6{-   †    6}-   ®    6~-   ∞    6-   ∏    6Ä-   ¿    6Å-   »    6Ç-   –    6É-   ÿ    6Ñ-   ‡    6Ñ-   Ë    6Ñ-       6Ñ-   ¯    6Ö-    'brk 6Ö-       6Ö-       6Ü-       6Ü-        6Ü-   (    6Ü-   0    6àJ/  8    6é.  à    6ê_/  †    6í!  ®    6ïº(  ∞    6ó-   ¿    6ôe/  »    6õ]  –    6úp/  ÿ    6≠ä,  ‡    6À«  Ë    6ÕÜ(  È _     <áK=º(  id =e        =&      =æ   <    =é(  60Á(      61…)      68æ   $    ∞è…)      ê        ë˜b      í]      ìì      îl%       ïæ  (    ñÑ>  8    ò-   `    ô-   h    ö-   p    õƒs  x    ú-   Ä    ùY  à    û]  ê    üæ  ò    †æ  ® Á(  6=˘)      6>-       6?æ      6@«   6n/*  &    6oe    &    6pe    &    6qe      6[S*      6lì  7˘)      6sÿ    6Yn*  !/*       6uì   6Kí*      6Ve   7S*      6we    6<ß*  !œ)   !n*   6Ç‘*      6Éé#       6Öÿ       6Üÿ    6|+  .lru 6}æ  7ß*      6ç+      6é8       +  R6óE+      6ò-   Sptl 6£]      6¶J+      6ßé#       E+      6—Å+      6“é#       6‘‰       6’‰    #     ä,  f_u ´w       !              ‡u  (    "]  0    #h  8    $e   @    %R  D    &Ñ>  H    'Ô  p    (Ûv  x    )"W  ò    *Ow  †    ,]  ¿    .æ  »    1æ  –    5æ  ÿ    6æ  Ë    8…)  ¯ Å+  i 6µ,  Frb 64%       6-    } 6Â,  ~    6ê,      6æ      6 N        ∞6˜¡-      6˙-        6˚-       6ˇ¡-      6ˇ¡-      64%       6	-   8    6È%  @    6ı$  H    6-   P    6!µ,  X    6)æ  x    6+Ã-  à    6.M.  ê    61-   ò    63ä,  †    64æ  ® Â,      «-      @> H.      >*]       >*]      >J]      >`]      >J]       >â]  (    >û]  0    >/¬]  8 “-  H.      6>{.      6?       6@{.   S.  $    86C∏.      6Dì       6ES.      6F‹       6S‡.      6Tÿ        6U‡.   
ÿ   .  -        6Y/      6Z/    
h  /  -    -   >/  ä,  -   -   -   -    /  Í$  
-   Z/  -   )     Z/  Å.      k/  é#      ? ƒ      á/  A]      @1¢/  í/      Aã-       Aå-       BQ◊/      BRæ        (BU0      BVÿ        BWæ      BXæ   Cb0      Cbƒ        Cb0      Cc0  
0  C0  -        Cñ30      D-       EAs0      EBs0    Z0      FÑ0  ä0  ï0  æ        F“0      FZ0       Fy0      Fæ      F,       Fe   Ì0  ı  e        G3¯0  ›0      G=1      G>æ        G@˛0      @F?è1      F@]       FA]      FB]      FC]      FD]       FE]  (    FF]  0    FG]  8     FJö1  "1  @FS	2      FTN        FUÿ       FV      FW      FX-        FY-   (    FZ-   0    F[-   8 )    KFR=2  rec F\=2       F^e    K    F_e   K 
†1  N2  =-   +     Fa	2      Fb]      Fce       F˜e       H"ÿ       H#ÿ       HQÿ       HRÿ           I¶2  IÀ2  val IŸ        I∂2  IÎ2  val I‰        I÷2      XÙ†3      ıì       ˆì      ˜ì      ˘ì      ˙ì       h      -        -   (    h  0      8uid À2  H    h  P ˆ2  JWª3  sig JXƒ        JY¶3      Kí      K‹3  ∆3      KÁ      K¯3  ‚3  ^    L!4      Lÿ       L	æ       L
˛3  L9M4      L:ø       L;    L?í4      L@'       LAÿ       LBí4      LC!4      LDÿ    
Y   °4   -    LHŒ4      LIø       LJ       LK!4    LO5      LPø       LQ       LRÿ       LS      LT   LX45      LYæ       L]Ø    LaU5      Lb®   _fd Lcÿ    LgÇ5      Lhæ       Liÿ       Lje    pL5„5      L6„5      L<,4      LEM4  ._rt LL°4      LUŒ4      L^5      Ld45      LkU5   
ÿ   Û5  -        ÄL006      L1ÿ        L2ÿ       L3ÿ       LlÇ5       LmÛ5  
ÿ   K6  -        Mÿ       M{6      Mæ       Mª3       MÒÿ        MÙ√6      Mˆ—3       M˜-       M˝Ì3      Mˇª3        M›6  sa MÜ6        M,J+  *    e   N7  	     	    	    	    	          N4H7  nr N6ÿ    ns N7>8      N8   )    êO>8      Oƒ`       Oa  ,rcu O8      Oÿ       Oe       O       OJ+  (    Oe   0    O >8  8    O"!  @    O#à  H    O$à  P    O)‰H  X    O*Ò>  `    O+Î2  Ä    O,ÿ   Ñ    O-ÿ   à    O.e   å H7  pid PN;ç8      N=ì       N>e       N@ç8  rcu NA8       NBù8  0 
Ó  ù8  -    
7  ≠8  -         NED8      NG›8      NI   pid NJ›8   D8      NeH7  
-   ˛8  -        PÓ8      Q8æ      Q99  4   e   *    e   QNU9  	     	    	    	     
T   e9  -    U9      QUe9      QW+9      RLÿ       hR\∞9      R]∞9       R^-   ` 
æ  ¿9  -         @Rjÿ9  x Rkÿ9    
Y   Á9   -         RÀ:      R‘>        R’>        pRÿ1:      RŸ1:       R⁄Á9  P 
æ  A:  -        RÔe       @R¸ä:      R˝ÿ        R˛ÿ       Rˇÿ       Rä:   
æ  ö:  -        hRœ:  pcp RL:       R  @    Rœ:  A 
  ﬂ:  -     E    e   R
;  	     	    	    	     #    Ä@RG⁄<      RK⁄<       RUÍ<      R_e   0    Ra¥=  8    Rb∫=  @    Rh-   H    R{-   P    R¶-   X    Rß-   `    R®-   h    R™N   p    R∞ÿ   x    R∏-   Ä    Rÿ¿=  à    RŸ-   ê    R⁄-   ò    R‹¿9  @¿    Rﬂ]  ¿    R‚∆=  »    RÂ-   @    RÁ¿9  @Ä    RÏ]  Ä    RÌ:  à    Rh  ¯    R˜-        R˚-       R˝>       Re        Re   $    Rÿ   (    R«  ,    R¿9  @@    R÷=  @ 
-   Í<  -    
®  ˙<  -    #    @@R“¥=      R”c>  @     R‘t>  Ä    R’ÿ   »    RÔ-   –    R-   ÿ    RÒ-   ‡    RÛÿ   Ë    RÙö      Rıö      Rˆ       R¯ÿ   (    R˘ﬂ:  , ˙<  ö:  ö  
ã9  ÷=  -   
 
h  Ê=  -         Rò>      Rô>       Röÿ    
;      HRÆ<>      RØA>       R∞G>       <>  
Ê=  W>  -        R¿é#  M
;  @t>  -    
>  Ñ>  -         (S2œ>      S4ì       S5]      S6æ      S8  osq S;Ö%        T⁄>  ‡>  Î>  Î>   Ò>       Td"?      Teh       Tfæ      Tgœ>       hTq^?      TrÒ>       Ts©"   wq Tvc?  Xcpu Twÿ   `     ^?      Tec?      Tfc?      Tgc?      Thc?      Tic?      Tjc?      Tkc?      2»?  Œ?  ÿ   Á?  Á?  -   æ   Ì?      5@      6Ω?       7Á?      8ÿ        0@E@      Aû%       BÁ?  (     E^@      FÁ?        ¡E@      ÷@      RÑ>      RRÿ       Rˆ      Rã      Rê˙<      R@ÿ@      RM-        RPÿ@   -   
Ô@  Ô@  =-   ˇ ∞@      Rrﬁ@       UVA      U	ÿ        U
ÿ       Uÿ       Ue       U‘      U‘   
A  fA  -        UVA      VöG      (WºA      W&       WR      Wæ      WºA    7      Wÿ       XÚA      Xÿ        X˜A       ÚA      Yÿ       Z*-B      Z+¥       Z,¥        [TB      [	4%       [
}"       [yB      [l%       [yB   -B  *    e   \,ùB  	     	         @\lËB      \m-B       \n}"       \o˝B  (    \ppC  0    \q-   8 B  ˜B  ˜B   ùB  ËB      @\ëpC      \íD       \ìÿ       \îº      \ïTB      \ñ}"       \ó!D  (    \ò}"  0    \ô}"  8 C  8    @\µD      \∂&   cpu \∑e       \∏e       \πe       \ª}"      \ºÿ       \Ωÿ       \æ-        \ø-   (    \¿-   0    \¡}"  8    \√'D  @ vC  A}"  D  
C  7D  -            \I7D  _     ]ÿ   ˙  
-   lD  -        ^%wD  ÿ   öD  öD  ÿ   æ  VD  E   †D      @^iE      ^kN        ^læ      ^mÿ       ^n¶      ^oöD      ^pFE       ^qLE  (    ^ræ  0    ^sæ  8 Ô       ^WFE      ^Xì       ^Yö   lD  E       ^vyE      ^w4%       ^x‘E       H^}‘E  !F       ^à,F      ^âöD       ^äcF  (set ^ãéF  0    ^åπF  8    ^çøF  @ yE  ^ÄF      ^ÅöD       ^Çÿ       ^Éÿ       ^Ñÿ    ^,F  7⁄E  .rcu ^Ü8   ‹      h^õcF      ^úiF       ^ùIG  X    ^ücG  ` 2F      X^ñéF      ^ó‘F   dir ^òîF   iF      P^êπF      ^íyE       ^ìl%  H îF  RE  ÿ   ‘F  éF   ≈F  éF  ÓF  cF  ÓF   ÙF      0_IG      _ì       _∑^      _ ¬^      _!Õ^      _">8       _#≥`  ( ⁄F  ÿ   cG  ‘E  öD   OG      ê` ≤G      `!ì       `"ÿ       `#ÿ       `$≤G      `%¬G  ê 
Î2  ¬G  -    
—G  —G   -    Î2      `BiG      Ä`gﬂH      `hì   uid `pÀ2  gid `qÎ2      `rÀ2      `sÎ2      `tÀ2      `uÎ2      `vÀ2      `wÎ2       `xe   $    `yÓ!  (    `zÓ!  0    `{Ó!  8    `|Ó!  @    `}Ó!  H    `áæ  P    `â†3  X    `ä‰H  `    `ãÍH  hrcu `å8  p ‚G  ¶2  iG  
-   ˚H  3     óH      ¶-       ßÿ       ®-   
Y   7I  -         ·'I      ~      ]      y      y  #    (—∫I      “ì       ”∫I      ‘]      ’ö   
√6   I  -   ?     ‡J      ·O0       ‚O0      „B      ‰B       Ó4J      ÔO0       O0       iJ      O0       O0         $     +†J      ,4J       -ÿ       .&   #    ∞;·M      <ì       =ì      >ÿ       ?æ      Aö       D  8    GV6  @    Jÿ   X    Pÿ   \    Q  `    Tÿ   h    Ue   l    `e   p    ae   p    dÿ   t    eæ  x    hùB  à    i›8  »    j}"  –it q·M  ÿ    wiJ      z4J  (    |ä:  @    ~›8  p    Åÿ   x'tty ÉˆM  Ä    éœ  à    èO0  ê    èO0  ò    èO0  †    èO0  ®    êO0  ∞    ëO0  ∏    ìJ  ¿    ï-   –    ï-   ÿ    ï-   ‡    ï-   Ë    ñ-       ñ-   ¯    ñ-        ñ-       ó-       ó-       ó-        ó-   (    ò-   0    ò-   8    ôHD  @    °  @    ¨¸M  H    µe   H    ∂e   L    ∑N  P    √û%  X    ∆]  Ä    «Ø   Ñ    »Ø   Ü    ÀÑ>  à 
 I  ÒM  -        ÒM  
B  N  -        N      ˆ2       $eN      &-        '      *      +       •ÿ   /ÈìN      Íæ  Brcu Î8   C    (©˜P      ´˜P       ¨˜P      ≠Q      Æ-       Ø-        ∞e   (    ±e   ,    ≤e   0    ≥e   4    ¥e   8    µe   <    ∂e   @    ∑e   D    ∏e   H    ∫ÿ   L    ªÿ   P    ºÿ   T    ø-   X    ¿e   `    ¡e   d    ƒ]  h    ≈-   p    …Q  x     Q  Ñ    ÀQ  ê    ÃQ  ú    ÕQ  ®    ŒQ  ¥    œQ  ¿    –Q  Ã    ”e   ÿ    ‘e   ‹    ’e   ‡    ÿe   ‰    Ÿe   Ë    ⁄e   Ï    ›e       ﬁe   Ù    ﬂe   ¯    ‚e   ¸    „e        ‰e       Á=  LqN      Óe        ˆQ  ( ìN      ˝P  
e   Q  -    
-   'Q   -    -    3Q  9Q  ı  HQ  ÿ    -    ÷      áQ  sd áQ   sg  çQ  sgc !òQ   ˜P  Q      ûQ  ìQ      8$ R      %'Q       &HQ  