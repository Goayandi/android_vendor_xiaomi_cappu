
			    struct dlm_lock_resource *res)
{
	spin_lock(&dlm->spinlock);
	spin_lock(&res->spinlock);

	__dlm_lockres_calc_usage(dlm, res);

	spin_unlock(&res->spinlock);
	spin_unlock(&dlm->spinlock);
}

static void dlm_purge_lockres(struct dlm_ctxt *dlm,
			     struct dlm_lock_resource *res)
{
	int master;
	int ret = 0;

	assert_spin_locked(&dlm->spinlock);
	assert_spin_locked(&res->spinlock);

	master = (res->owner == dlm->node_num);

	mlog(0, "%s: Purging res %.*s, master %d\n", dlm->name,
	     res->lockname.len, res->lockname.name, master);

	if (!master) {
		res->state |= DLM_LOCK_RES_DROPPING_REF;
		/* drop spinlock...  retake below */
		spin_unlock(&res->spinlock);
		spin_unlock(&dlm->spinlock);

		spin_lock(&res->spinlock);
		/* This ensures that clear refmap is sent after the set */
		__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);
		spin_unlock(&res->spinlock);

		/* clear our bit from the master's refmap, ignore errors */
		ret = dlm_drop_lockres_ref(dlm, res);
		if (ret < 0) {
			if (!dlm_is_host_down(ret))
				BUG();
		}
		spin_lock(&dlm->spinlock);
		spin_lock(&res->spinlock);
	}

	if (!list_empty(&res->purge)) {
		mlog(0, "%s: Removing res %.*s from purgelist, master %d\n",
		     dlm->name, res->lockname.len, res->lockname.name, master);
		list_del_init(&res->purge);
		dlm_lockres_put(res);
		dlm->purge_count--;
	}

	if (!__dlm_lockres_unused(res)) {
		mlog(ML_ERROR, "%s: res %.*s in use after deref\n",
		     dlm->name, res->lockname.len, res->lockname.name);
		__dlm_print_one_lock_resource(res);
		BUG();
	}

	__dlm_unhash_lockres(dlm, res);

	/* lockres is not in the hash now.  drop the flag and wake up
	 * any processes waiting in dlm_get_lock_resource. */
	if (!master) {
		res->state &= ~DLM_LOCK_RES_DROPPING_REF;
		spin_unlock(&res->spinlock);
		wake_up(&res->wq);
	} else
		spin_unlock(&res->spinlock);
}

static void dlm_run_purge_list(struct dlm_ctxt *dlm,
			       int purge_now)
{
	unsigned int run_max, unused;
	unsigned long purge_jiffies;
	struct dlm_lock_resource *lockres;

	spin_lock(&dlm->spinlock);
	run_max = dlm->purge_count;

	while(run_max && !list_empty(&dlm->purge_list)) {
		run_max--;

		lockres = list_entry(dlm->purge_list.next,
				     struct dlm_lock_resource, purge);

		spin_lock(&lockres->spinlock);

		purge_jiffies = lockres->last_used +
			msecs_to_jiffies(DLM_PURGE_INTERVAL_MS);

		/* Make sure that we want to be processing this guy at
		 * this time. */
		if (!purge_now && time_after(purge_jiffies, jiffies)) {
			/* Since resources are added to the purge list
			 * in tail order, we can stop at the first
			 * unpurgable resource -- anyone added after
			 * him will have a greater last_used value */
			spin_unlock(&lockres->spinlock);
			break;
		}

		/* Status of the lockres *might* change so double
		 * check. If the lockres is unused, holding the dlm
		 * spinlock will prevent people from getting and more
		 * refs on it. */
		unused = __dlm_lockres_unused(lockres);
		if (!unused ||
		    (lockres->state & DLM_LOCK_RES_MIGRATING) ||
		    (lockres->inflight_assert_workers != 0)) {
			mlog(0, "%s: res %.*s is in use or being remastered, "
			     "used %d, state %d, assert master workers %u\n",
			     dlm->name, lockres->lockname.len,
			     lockres->lockname.name,
			     !unused, lockres->state,
			     lockres->inflight_assert_workers);
			list_move_tail(&lockres->purge, &dlm->purge_list);
			spin_unlock(&lockres->spinlock);
			continue;
		}

		dlm_lockres_get(lockres);

		dlm_purge_lockres(dlm, lockres);

		dlm_lockres_put(lockres);

		/* Avoid adding any scheduling latencies */
		cond_resched_lock(&dlm->spinlock);
	}

	spin_unlock(&dlm->spinlock);
}

static void dlm_shuffle_lists(struct dlm_ctxt *dlm,
			      struct dlm_lock_resource *res)
{
	struct dlm_lock *lock, *target;
	int can_grant = 1;

	/*
	 * Because this function is called with the lockres
	 * spinlock, and because we know that it is not migrating/
	 * recovering/in-progress, it is fine to reserve asts and
	 * basts right before queueing them all throughout
	 */
	assert_spin_locked(&dlm->ast_lock);
	assert_spin_locked(&res->spinlock);
	BUG_ON((res->state & (DLM_LOCK_RES_MIGRATING|
			      DLM_LOCK_RES_RECOVERING|
			      DLM_LOCK_RES_IN_PROGRESS)));

converting:
	if (list_empty(&res->converting))
		goto blocked;
	mlog(0, "%s: res %.*s has locks on the convert queue\n", dlm->name,
	     res->lockname.len, res->lockname.name);

	target = list_entry(res->converting.next, struct dlm_lock, list);
	if (target->ml.convert_type == LKM_IVMODE) {
		mlog(ML_ERROR, "%s: res %.*s converting lock to invalid mode\n",
		     dlm->name, res->lockname.len, res->lockname.name);
		BUG();
	}
	list_for_each_entry(lock, &res->granted, list) {
		if (lock==target)
			continue;
		if (!dlm_lock_compatible(lock->ml.type,
					 target->ml.convert_type)) {
			can_grant = 0;
			/* queue the BAST if not already */
			if (lock->ml.highest_blocked == LKM_IVMODE) {
				__dlm_lockres_reserve_ast(res);
				__dlm_queue_bast(dlm, lock);
			}
			/* update the highest_blocked if needed */
			if (lock->ml.highest_blocked < target->ml.convert_type)
				lock->ml.highest_blocked =
					target->ml.convert_type;
		}
	}

	list_for_each_entry(lock, &res->converting, list) {
		if (lock==target)
			continue;
		if (!dlm_lock_compatible(lock->ml.type,
					 target->ml.convert_type)) {
			can_grant = 0;
			if (lock->ml.highest_blocked == LKM_IVMODE) {
				__dlm_lockres_reserve_ast(res);
				__dlm_queue_bast(dlm, lock);
			}
			if (lock->ml.highest_blocked < target->ml.convert_type)
				lock->ml.highest_blocked =
					target->ml.convert_type;
		}
	}

	/* we can convert the lock */
	if (can_grant) {
		spin_lock(&target->spinlock);
		BUG_ON(target->ml.highest_blocked != LKM_IVMODE);

		mlog(0, "%s: res %.*s, AST for Converting lock %u:%llu, type "
		     "%d => %d, node %u\n", dlm->name, res->lockname.len,
		     res->lockname.name,
		     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),
		     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),
		     target->ml.type,
		     target->ml.convert_type, target->ml.node);

		target->ml.type = target->ml.convert_type;
		target->ml.convert_type = LKM_IVMODE;
		list_move_tail(&target->list, &res->granted);

		BUG_ON(!target->lksb);
		target->lksb->status = DLM_NORMAL;

		spin_unlock(&target->spinlock);

		__dlm_lockres_reserve_ast(res);
		__dlm_queue_ast(dlm, target);
		/* go back and check for more */
		goto converting;
	}

blocked:
	if (list_empty(&res->blocked))
		goto leave;
	target = list_entry(res->blocked.next, struct dlm_lock, list);

	list_for_each_entry(lock, &res->granted, list) {
		if (lock==target)
			continue;
		if (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {
			can_grant = 0;
			if (lock->ml.highest_blocked == LKM_IVMODE) {
				__dlm_lockres_reserve_ast(res);
				__dlm_queue_bast(dlm, lock);
			}
			if (lock->ml.highest_blocked < target->ml.type)
				lock->ml.highest_blocked = target->ml.type;
		}
	}

	list_for_each_entry(lock, &res->converting, list) {
		if (lock==target)
			continue;
		if (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {
			can_grant = 0;
			if (lock->ml.highest_blocked == LKM_IVMODE) {
				__dlm_lockres_reserve_ast(res);
				__dlm_queue_bast(dlm, lock);
			}
			if (lock->ml.highest_blocked < target->ml.type)
				lock->ml.highest_blocked = target->ml.type;
		}
	}

	/* we can grant the blocked lock (only
	 * possible if converting list empty) */
	if (can_grant) {
		spin_lock(&target->spinlock);
		BUG_ON(target->ml.highest_blocked != LKM_IVMODE);

		mlog(0, "%s: res %.*s, AST for Blocked lock %u:%llu, type %d, "
		     "node %u\n", dlm->name, res->lockname.len,
		     res->lockname.name,
		     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),
		     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),
		     target->ml.type, target->ml.node);

		/* target->ml.type is already correct */
		list_move_tail(&target->list, &res->granted);

		BUG_ON(!target->lksb);
		target->lksb->status = DLM_NORMAL;

		spin_unlock(&target->spinlock);

		__dlm_lockres_reserve_ast(res);
		__dlm_queue_ast(dlm, target);
		/* go back and check for more */
		goto converting;
	}

leave:
	return;
}

/* must have NO locks when calling this with res !=NULL * */
void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)
{
	if (res) {
		spin_lock(&dlm->spinlock);
		spin_lock(&res->spinlock);
		__dlm_dirty_lockres(dlm, res);
		spin_unlock(&res->spinlock);
		spin_unlock(&dlm->spinlock);
	}
	wake_up(&dlm->dlm_thread_wq);
}

void __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)
{
	assert_spin_locked(&dlm->spinlock);
	assert_spin_locked(&res->spinlock);

	/* don't shuffle secondary queues */
	if ((res->owner == dlm->node_num)) {
		if (res->state & (DLM_LOCK_RES_MIGRATING |
				  DLM_LOCK_RES_BLOCK_DIRTY))
		    return;

		if (list_empty(&res->dirty)) {
			/* ref for dirty_list */
			dlm_lockres_get(res);
			list_add_tail(&res->dirty, &dlm->dirty_list);
			res->state |= DLM_LOCK_RES_DIRTY;
		}
	}

	mlog(0, "%s: res %.*s\n", dlm->name, res->lockname.len,
	     res->lockname.name);
}


/* Launch the NM thread for the mounted volume */
int dlm_launch_thread(struct dlm_ctxt *dlm)
{
	mlog(0, "Starting dlm_thread...\n");

	dlm->dlm_thread_task = kthread_run(dlm_thread, dlm, "dlm_thread");
	if (IS_ERR(dlm->dlm_thread_task)) {
		mlog_errno(PTR_ERR(dlm->dlm_thread_task));
		dlm->dlm_thread_task = NULL;
		return -EINVAL;
	}

	return 0;
}

void dlm_complete_thread(struct dlm_ctxt *dlm)
{
	if (dlm->dlm_thread_task) {
		mlog(ML_KTHREAD, "Waiting for dlm thread to exit\n");
		kthread_stop(dlm->dlm_thread_task);
		dlm->dlm_thread_task = NULL;
	}
}

static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)
{
	int empty;

	spin_lock(&dlm->spinlock);
	empty = list_empty(&dlm->dirty_list);
	spin_unlock(&dlm->spinlock);

	return empty;
}

static void dlm_flush_asts(struct dlm_ctxt *dlm)
{
	int ret;
	struct dlm_lock *lock;
	struct dlm_lock_resource *res;
	u8 hi;

	spin_lock(&dlm->ast_lock);
	while (!list_empty(&dlm->pending_asts)) {
		lock = list_entry(dlm->pending_asts.next,
				  struct dlm_lock, ast_list);
		/* get an extra ref on lock */
		dlm_lock_get(lock);
		res = lock->lockres;
		mlog(0, "%s: res %.*s, Flush AST for lock %u:%llu, type %d, "
		     "node %u\n", dlm->name, res->lockname.len,
		     res->lockname.name,
		     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),
		     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),
		     lock->ml.type, lock->ml.node);

		BUG_ON(!lock->ast_pending);

		/* remove from list (including ref) */
		list_del_init(&lock->ast_list);
		dlm_lock_put(lock);
		spin_unlock(&dlm->ast_lock);

		if (lock->ml.node != dlm->node_num) {
			ret = dlm_do_remote_ast(dlm, res, lock);
			if (ret < 0)
				mlog_errno(ret);
		} else
			dlm_do_local_ast(dlm, res, lock);

		spin_lock(&dlm->ast_lock);

		/* possible that another ast was queued while
		 * we were delivering the last one */
		if (!list_empty(&lock->ast_list)) {
			mlog(0, "%s: res %.*s, AST queued while flushing last "
			     "one\n", dlm->name, res->lockname.len,
			     res->lockname.name);
		} else
			lock->ast_pending = 0;

		/* drop the extra ref.
		 * this may drop it completely. */
		dlm_lock_put(lock);
		dlm_lockres_release_ast(dlm, res);
	}

	while (!list_empty(&dlm->pending_basts)) {
		lock = list_entry(dlm->pending_basts.next,
				  struct dlm_lock, bast_list);
		/* get an extra ref on lock */
		dlm_lock_get(lock);
		res = lock->lockres;

		BUG_ON(!lock->bast_pending);

		/* get the highest blocked lock, and reset */
		spin_lock(&lock->spinlock);
		BUG_ON(lock->ml.highest_blocked <= LKM_IVMODE);
		hi = lock->ml.highest_blocked;
		lock->ml.highest_blocked = LKM_IVMODE;
		spin_unlock(&lock->spinlock);

		/* remove from list (including ref) */
		list_del_init(&lock->bast_list);
		dlm_lock_put(lock);
		spin_unlock(&dlm->ast_lock);

		mlog(0, "%s: res %.*s, Flush BAST for lock %u:%llu, "
		     "blocked %d, node %u\n",
		     dlm->name, res->lockname.len, res->lockname.name,
		     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),
		     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),
		     hi, lock->ml.node);

		if (lock->ml.node != dlm->node_num) {
			ret = dlm_send_proxy_bast(dlm, res, lock, hi);
			if (ret < 0)
				mlog_errno(ret);
		} else
			dlm_do_local_bast(dlm, res, lock, hi);

		spin_lock(&dlm->ast_lock);

		/* possible that another bast was queued while
		 * we were delivering the last one */
		if (!list_empty(&lock->bast_list)) {
			mlog(0, "%s: res %.*s, BAST queued while flushing last "
			     "one\n", dlm->name, res->lockname.len,
			     res->lockname.name);
		} else
			lock->bast_pending = 0;

		/* drop the extra ref.
		 * this may drop it completely. */
		dlm_lock_put(lock);
		dlm_lockres_release_ast(dlm, res);
	}
	wake_up(&dlm->ast_wq);
	spin_unlock(&dlm->ast_lock);
}


#define DLM_THREAD_TIMEOUT_MS (4 * 1000)
#define DLM_THREAD_MAX_DIRTY  100
#define DLM_THREAD_MAX_ASTS   10

static int dlm_thread(void *data)
{
	struct dlm_lock_resource *res;
	struct dlm_ctxt *dlm = data;
	unsigned long timeout = msecs_to_jiffies(DLM_THREAD_TIMEOUT_MS);

	mlog(0, "dlm thread running for %s...\n", dlm->name);

	while (!kthread_should_stop()) {
		int n = DLM_THREAD_MAX_DIRTY;

		/* dlm_shutting_down is very point-in-time, but that
		 * doesn't matter as we'll just loop back around if we
		 * get false on the leading edge of a state
		 * transition. */
		dlm_run_purge_list(dlm, dlm_shutting_down(dlm));

		/* We really don't want to hold dlm->spinlock while
		 * calling dlm_shuffle_lists on each lockres that
		 * needs to have its queues adjusted and AST/BASTs
		 * run.  So let's pull each entry off the dirty_list
		 * and drop dlm->spinlock ASAP.  Once off the list,
		 * res->spinlock needs to be taken again to protect
		 * the queues while calling dlm_shuffle_lists.  */
		spin_lock(&dlm->spinlock);
		while (!list_empty(&dlm->dirty_list)) {
			int delay = 0;
			res = list_entry(dlm->dirty_list.next,
					 struct dlm_lock_resource, dirty);

			/* peel a lockres off, remove it from the list,
			 * unset the dirty flag and drop the dlm lock */
			BUG_ON(!res);
			dlm_lockres_get(res);

			spin_lock(&res->spinlock);
			/* We clear the DLM_LOCK_RES_DIRTY state once we shuffle lists below */
			list_del_init(&res->dirty);
			spin_unlock(&res->spinlock);
			spin_unlock(&dlm->spinlock);
			/* Drop dirty_list ref */
			dlm_lockres_put(res);

		 	/* lockres can be re-dirtied/re-added to the
			 * dirty_list in this gap, but that is ok */

			spin_lock(&dlm->ast_lock);
			spin_lock(&res->spinlock);
			if (res->owner != dlm->node_num) {
				__dlm_print_one_lock_resource(res);
				mlog(ML_ERROR, "%s: inprog %d, mig %d, reco %d,"
				     " dirty %d\n", dlm->name,
				     !!(res->state & DLM_LOCK_RES_IN_PROGRESS),
				     !!(res->state & DLM_LOCK_RES_MIGRATING),
				     !!(res->state & DLM_LOCK_RES_RECOVERING),
				     !!(res->state & DLM_LOCK_RES_DIRTY));
			}
			BUG_ON(res->owner != dlm->node_num);

			/* it is now ok to move lockreses in these states
			 * to the dirty list, assuming that they will only be
			 * dirty for a short while. */
			BUG_ON(res->state & DLM_LOCK_RES_MIGRATING);
			if (res->state & (DLM_LOCK_RES_IN_PROGRESS |
					  DLM_LOCK_RES_RECOVERING)) {
				/* move it to the tail and keep going */
				res->state &= ~DLM_LOCK_RES_DIRTY;
				spin_unlock(&res->spinlock);
				spin_unlock(&dlm->ast_lock);
				mlog(0, "%s: res %.*s, inprogress, delay list "
				     "shuffle, state %d\n", dlm->name,
				     res->lockname.len, res->lockname.name,
				     res->state);
				delay = 1;
				goto in_progress;
			}

			/* at this point the lockres is not migrating/
			 * recovering/in-progress.  we have the lockres
			 * spinlock and do NOT have the dlm lock.
			 * safe to reserve/queue asts and run the lists. */

			/* called while holding lockres lock */
			dlm_shuffle_lists(dlm, res);
			res->state &= ~DLM_LOCK_RES_DIRTY;
			spin_unlock(&res->spinlock);
			spin_unlock(&dlm->ast_lock);

			dlm_lockres_calc_usage(dlm, res);

in_progress:

			spin_lock(&dlm->spinlock);
			/* if the lock was in-progress, stick
			 * it on the back of the list */
			if (delay) {
				spin_lock(&res->spinlock);
				__dlm_dirty_lockres(dlm, res);
				spin_unlock(&res->spinlock);
			}
			dlm_lockres_put(res);

			/* unlikely, but we may need to give time to
			 * other tasks */
			if (!--n) {
				mlog(0, "%s: Throttling dlm thread\n",
				     dlm->name);
				break;
			}
		}

		spin_unlock(&dlm->spinlock);
		dlm_flush_asts(dlm);

		/* yield and continue right away if there is more work to do */
		if (!n) {
			cond_resched();
			continue;
		}

		wait_event_interruptible_timeout(dlm->dlm_thread_wq,
						 !dlm_dirty_list_empty(dlm) ||
						 kthread_should_stop(),
						 timeout);
	}

	mlog(0, "quitting DLM thread\n");
	return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * linux/include/linux/lockd/xdr.h
 *
 * XDR types for the NLM protocol
 *
 * Copyright (C) 1996 Olaf Kirch <okir@monad.swb.de>
 */

#ifndef LOCKD_XDR_H
#define LOCKD_XDR_H

#include <linux/fs.h>
#include <linux/nfs.h>
#include <linux/sunrpc/xdr.h>

#define SM_MAXSTRLEN		1024
#define SM_PRIV_SIZE		16

struct nsm_private {
	unsigned char		data[SM_PRIV_SIZE];
};

struct svc_rqst;

#define NLM_MAXCOOKIELEN    	32
#define NLM_MAXSTRLEN		1024

#define	nlm_granted		cpu_to_be32(NLM_LCK_GRANTED)
#define	nlm_lck_denied		cpu_to_be32(NLM_LCK_DENIED)
#define	nlm_lck_denied_nolocks	cpu_to_be32(NLM_LCK_DENIED_NOLOCKS)
#define	nlm_lck_blocked		cpu_to_be32(NLM_LCK_BLOCKED)
#define	nlm_lck_denied_grace_period	cpu_to_be32(NLM_LCK_DENIED_GRACE_PERIOD)

#define nlm_drop_reply		cpu_to_be32(30000)

/* Lock info passed via NLM */
struct nlm_lock {
	char *			caller;
	unsigned int		len; 	/* length of "caller" */
	struct nfs_fh		fh;
	struct xdr_netobj	oh;
	u32			svid;
	struct file_lock	fl;
};

/*
 *	NLM cookies. Technically they can be 1K, but Linux only uses 8 bytes.
 *	FreeBSD uses 16, Apple Mac OS X 10.3 uses 20. Therefore we set it to
 *	32 bytes.
 */
 
struct nlm_cookie
{
	unsigned char data[NLM_MAXCOOKIELEN];
	unsigned int len;
};

/*
 * Generic lockd arguments for all but sm_notify
 */
struct nlm_args {
	struct nlm_cookie	cookie;
	struct nlm_lock		lock;
	u32			block;
	u32			reclaim;
	u32			state;
	u32			monitor;
	u32			fsm_access;
	u32			fsm_mode;
};

typedef struct nlm_args nlm_args;

/*
 * Generic lockd result
 */
struct nlm_res {
	struct nlm_cookie	cookie;
	__be32			status;
	struct nlm_lock		lock;
};

/*
 * statd callback when client has rebooted
 */
struct nlm_reboot {
	char			*mon;
	unsigned int		len;
	u32			state;
	struct nsm_private	priv;
};

/*
 * Contents of statd callback when monitored host rebooted
 */
#define NLMSVC_XDRSIZE		sizeof(struct nlm_args)

int	nlmsvc_decode_testargs(struct svc_rqst *, __be32 *, struct nlm_args *);
int	nlmsvc_encode_testres(struct svc_rqst *, __be32 *, struct nlm_res *);
int	nlmsvc_decode_lockargs(struct svc_rqst *, __be32 *, struct nlm_args *);
int	nlmsvc_decode_cancargs(struct svc_rqst *, __be32 *, struct nlm_args *);
int	nlmsvc_decode_unlockargs(struct svc_rqst *, __be32 *, struct nlm_args *);
int	nlmsvc_encode_res(struct svc_rqst *, __be32 *, struct nlm_res *);
int	nlmsvc_decode_res(struct svc_rqst *, __be32 *, struct nlm_res *);
int	nlmsvc_encode_void(struct svc_rqst *, __be32 *, void *);
int	nlmsvc_decode_void(struct svc_rqst *, __be32 *, void *);
int	nlmsvc_decode_shareargs(struct svc_rqst *, __be32 *, struct nlm_args *);
int	nlmsvc_encode_shareres(struct svc_rqst *, __be32 *, struct nlm_res *);
int	nlmsvc_decode_notify(struct svc_rqst *, __be32 *, struct nlm_args *);
int	nlmsvc_decode_reboot(struct svc_rqst *, __be32 *, struct nlm_reboot *);
/*
int	nlmclt_encode_testargs(struct rpc_rqst *, u32 *, struct nlm_args *);
int	nlmclt_encode_lockargs(struct rpc_rqst *, u32 *, struct nlm_args *);
int	nlmclt_encode_cancargs(struct rpc_rqst *, u32 *, struct nlm_args *);
int	nlmclt_encode_unlockargs(struct rpc_rqst *, u32 *, struct nlm_args *);
 */

#endif /* LOCKD_XDR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef _NET_MRP_H
#define _NET_MRP_H

#define MRP_END_MARK		0x0

struct mrp_pdu_hdr {
	u8	version;
};

struct mrp_msg_hdr {
	u8	attrtype;
	u8	attrlen;
};

struct mrp_vecattr_hdr {
	__be16	lenflags;
	unsigned char	firstattrvalue[];
#define MRP_VECATTR_HDR_LEN_MASK cpu_to_be16(0x1FFF)
#define MRP_VECATTR_HDR_FLAG_LA cpu_to_be16(0x2000)
};

enum mrp_vecattr_event {
	MRP_VECATTR_EVENT_NEW,
	MRP_VECATTR_EVENT_JOIN_IN,
	MRP_VECATTR_EVENT_IN,
	MRP_VECATTR_EVENT_JOIN_MT,
	MRP_VECATTR_EVENT_MT,
	MRP_VECATTR_EVENT_LV,
	__MRP_VECATTR_EVENT_MAX
};

struct mrp_skb_cb {
	struct mrp_msg_hdr	*mh;
	struct mrp_vecattr_hdr	*vah;
	unsigned char		attrvalue[];
};

static inline struct mrp_skb_cb *mrp_cb(struct sk_buff *skb)
{
	BUILD_BUG_ON(sizeof(struct mrp_skb_cb) >
		     FIELD_SIZEOF(struct sk_buff, cb));
	return (struct mrp_skb_cb *)skb->cb;
}

enum mrp_applicant_state {
	MRP_APPLICANT_INVALID,
	MRP_APPLICANT_VO,
	MRP_APPLICANT_VP,
	MRP_APPLICANT_VN,
	MRP_APPLICANT_AN,
	MRP_APPLICANT_AA,
	MRP_APPLICANT_QA,
	MRP_APPLICANT_LA,
	MRP_APPLICANT_AO,
	MRP_APPLICANT_QO,
	MRP_APPLICANT_AP,
	MRP_APPLICANT_QP,
	__MRP_APPLICANT_MAX
};
#define MRP_APPLICANT_MAX	(__MRP_APPLICANT_MAX - 1)

enum mrp_event {
	MRP_EVENT_NEW,
	MRP_EVENT_JOIN,
	MRP_EVENT_LV,
	MRP_EVENT_TX,
	MRP_EVENT_R_NEW,
	MRP_EVENT_R_JOIN_IN,
	MRP_EVENT_R_IN,
	MRP_EVENT_R_JOIN_MT,
	MRP_EVENT_R_MT,
	MRP_EVENT_R_LV,
	MRP_EVENT_R_LA,
	MRP_EVENT_REDECLARE,
	MRP_EVENT_PERIODIC,
	__MRP_EVENT_MAX
};
#define MRP_EVENT_MAX		(__MRP_EVENT_MAX - 1)

enum mrp_tx_action {
	MRP_TX_ACTION_NONE,
	MRP_TX_ACTION_S_NEW,
	MRP_TX_ACTION_S_JOIN_IN,
	MRP_TX_ACTION_S_JOIN_IN_OPTIONAL,
	MRP_TX_ACTION_S_IN_OPTIONAL,
	MRP_TX_ACTION_S_LV,
};

struct mrp_attr {
	struct rb_node			node;
	enum mrp_applicant_state	state;
	u8				type;
	u8				len;
	unsigned char			value[];
};

enum mrp_applications {
	MRP_APPLICATION_MVRP,
	__MRP_APPLICATION_MAX
};
#define MRP_APPLICATION_MAX	(__MRP_APPLICATION_MAX - 1)

struct mrp_application {
	enum mrp_applications	type;
	unsigned int		maxattr;
	struct packet_type	pkttype;
	unsigned char		group_address[ETH_ALEN];
	u8			version;
};

struct mrp_applicant {
	struct mrp_application	*app;
	struct net_device	*dev;
	struct timer_list	join_timer;
	struct timer_list	periodic_timer;

	spinlock_t		lock;
	struct sk_buff_head	queue;
	struct sk_buff		*pdu;
	struct rb_root		mad;
	struct rcu_head		rcu;
};

struct mrp_port {
	struct mrp_applicant __rcu	*applicants[MRP_APPLICATION_MAX + 1];
	struct rcu_head			rcu;
};

int mrp_register_application(struct mrp_application *app);
void mrp_unregister_application(struct mrp_application *app);

int mrp_init_applicant(struct net_device *dev, struct mrp_application *app);
void mrp_uninit_applicant(struct net_device *dev, struct mrp_application *app);

int mrp_request_join(const struct net_device *dev,
		     const struct mrp_application *app,
		     const void *value, u8 len, u8 type);
void mrp_request_leave(const struct net_device *dev,
		       const struct mrp_application *app,
		       const void *value, u8 len, u8 type);

#endif /* _NET_MRP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Read-Copy Update mechanism for mutual exclusion (tree-based version)
 * Internal non-public definitions.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you can access it online at
 * http://www.gnu.org/licenses/gpl-2.0.html.
 *
 * Copyright IBM Corporation, 2008
 *
 * Author: Ingo Molnar <mingo@elte.hu>
 *	   Paul E. McKenney <paulmck@linux.vnet.ibm.com>
 */

#include <linux/cache.h>
#include <linux/spinlock.h>
#include <linux/threads.h>
#include <linux/cpumask.h>
#include <linux/seqlock.h>
#include <linux/irq_work.h>

/*
 * Define shape of hierarchy based on NR_CPUS, CONFIG_RCU_FANOUT, and
 * CONFIG_RCU_FANOUT_LEAF.
 * In theory, it should be possible to add more levels straightforwardly.
 * In practice, this did work well going from three levels to four.
 * Of course, your mileage may vary.
 */
#define MAX_RCU_LVLS 4
#define RCU_FANOUT_1	      (CONFIG_RCU_FANOUT_LEAF)
#define RCU_FANOUT_2	      (RCU_FANOUT_1 * CONFIG_RCU_FANOUT)
#define RCU_FANOUT_3	      (RCU_FANOUT_2 * CONFIG_RCU_FANOUT)
#define RCU_FANOUT_4	      (RCU_FANOUT_3 * CONFIG_RCU_FANOUT)

#if NR_CPUS <= RCU_FANOUT_1
#  define RCU_NUM_LVLS	      1
#  define NUM_RCU_LVL_0	      1
#  define NUM_RCU_LVL_1	      (NR_CPUS)
#  define NUM_RCU_LVL_2	      0
#  define NUM_RCU_LVL_3	      0
#  define NUM_RCU_LVL_4	      0
#elif NR_CPUS <= RCU_FANOUT_2
#  define RCU_NUM_LVLS	      2
#  define NUM_RCU_LVL_0	      1
#  define NUM_RCU_LVL_1	      DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_1)
#  define NUM_RCU_LVL_2	      (NR_CPUS)
#  define NUM_RCU_LVL_3	      0
#  define NUM_RCU_LVL_4	      0
#elif NR_CPUS <= RCU_FANOUT_3
#  define RCU_NUM_LVLS	      3
#  define NUM_RCU_LVL_0	      1
#  define NUM_RCU_LVL_1	      DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_2)
#  define NUM_RCU_LVL_2	      DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_1)
#  define NUM_RCU_LVL_3	      (NR_CPUS)
#  define NUM_RCU_LVL_4	      0
#elif NR_CPUS <= RCU_FANOUT_4
#  define RCU_NUM_LVLS	      4
#  define NUM_RCU_LVL_0	      1
#  define NUM_RCU_LVL_1	      DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_3)
#  define NUM_RCU_LVL_2	      DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_2)
#  define NUM_RCU_LVL_3	      DIV_ROUND_UP(NR_CPUS, RCU_FANOUT_1)
#  define NUM_RCU_LVL_4	      (NR_CPUS)
#else
# error "CONFIG_RCU_FANOUT insufficient for NR_CPUS"
#endif /* #if (NR_CPUS) <= RCU_FANOUT_1 */

#define RCU_SUM (NUM_RCU_LVL_0 + NUM_RCU_LVL_1 + NUM_RCU_LVL_2 + NUM_RCU_LVL_3 + NUM_RCU_LVL_4)
#define NUM_RCU_NODES (RCU_SUM - NR_CPUS)

extern int rcu_num_lvls;
extern int rcu_num_nodes;

/*
 * Dynticks per-CPU state.
 */
struct rcu_dynticks {
	long long dynticks_nesting; /* Track irq/process nesting level. */
				    /* Process level is worth LLONG_MAX/2. */
	int dynticks_nmi_nesting;   /* Track NMI nesting level. */
	atomic_t dynticks;	    /* Even value for idle, else odd. */
#ifdef CONFIG_NO_HZ_FULL_SYSIDLE
	long long dynticks_idle_nesting;
				    /* irq/process nesting level from idle. */
	atomic_t dynticks_idle;	    /* Even value for idle, else odd. */
				    /*  "Idle" excludes userspace execution. */
	unsigned long dynticks_idle_jiffies;
				    /* End of last non-NMI non-idle period. */
#endif /* #ifdef CONFIG_NO_HZ_FULL_SYSIDLE */
#ifdef CONFIG_RCU_FAST_NO_HZ
	bool all_lazy;		    /* Are all CPU's CBs lazy? */
	unsigned long nonlazy_posted;
				    /* # times non-lazy CBs posted to CPU. */
	unsigned long nonlazy_posted_snap;
				    /* idle-period nonlazy_posted snapshot. */
	unsigned long last_accelerate;
				    /* Last jiffy CBs were accelerated. */
	unsigned long last_advance_all;
				    /* Last jiffy CBs were all advanced. */
	int tick_nohz_enabled_snap; /* Previously seen value from sysfs. */
#endif /* #ifdef CONFIG_RCU_FAST_NO_HZ */
};

/* RCU's kthread states for tracing. */
#define RCU_KTHREAD_STOPPED  0
#define RCU_KTHREAD_RUNNING  1
#define RCU_KTHREAD_WAITING  2
#define RCU_KTHREAD_OFFCPU   3
#define RCU_KTHREAD_YIELDING 4
#define RCU_KTHREAD_MAX      4

/*
 * Definition for node within the RCU grace-period-detection hierarchy.
 */
struct rcu_node {
	raw_spinlock_t lock;	/* Root rcu_node's lock protects some */
				/*  rcu_state fields as well as following. */
	unsigned long gpnum;	/* Current grace period for this node. */
				/*  This will either be equal to or one */
				/*  behind the root rcu_node's gpnum. */
	unsigned long completed; /* Last GP completed for this node. */
				/*  This will either be equal to or one */
				/*  behind the root rcu_node's gpnum. */
	unsigned long qsmask;	/* CPUs or groups that need to switch in */
				/*  order for current grace period to proceed.*/
				/*  In leaf rcu_node, each bit corresponds to */
				/*  an rcu_data structure, otherwise, each */
				/*  bit corresponds to a child rcu_node */
				/*  structure. */
	unsigned long expmask;	/* Groups that have ->blkd_tasks */
				/*  elements that need to drain to allow the */
				/*  current expedited grace period to */
				/*  complete (only for TREE_PREEMPT_RCU). */
	unsigned long qsmaskinit;
				/* Per-GP initial value for qsmask & expmask. */
	unsigned long grpmask;	/* Mask to apply to parent qsmask. */
				/*  Only one bit will be set in this mask. */
	int	grplo;		/* lowest-numbered CPU or group here. */
	int	grphi;		/* highest-numbered CPU or group here. */
	u8	grpnum;		/* CPU/group number for next level up. */
	u8	level;		/* root is at level 0. */
	struct rcu_node *parent;
	struct list_head blkd_tasks;
				/* Tasks blocked in RCU read-side critical */
				/*  section.  Tasks are placed at the head */
				/*  of this list and age towards the tail. */
	struct list_head *gp_tasks;
				/* Pointer to the first task blocking the */
				/*  current grace period, or NULL if there */
				/*  is no such task. */
	struct list_head *exp_tasks;
				/* Pointer to the first task blocking the */
				/*  current expedited grace period, or NULL */
				/*  if there is no such task.  If there */
				/*  is no current expedited grace period, */
				/*  then there can cannot be any such task. */
#ifdef CONFIG_RCU_BOOST
	struct list_head *boost_tasks;
				/* Pointer to first task that needs to be */
				/*  priority boosted, or NULL if no priority */
				/*  boosting is needed for this rcu_node */
				/*  structure.  If there are no tasks */
				/*  queued on this rcu_node structure that */
				/*  are blocking the current grace period, */
				/*  there can be no such task. */
	struct completion boost_completion;
				/* Used to ensure that the rt_mutex used */
				/*  to carry out the boosting is fully */
				/*  released with no future boostee accesses */
				/*  before that rt_mutex is re-initialized. */
	struct rt_mutex boost_mtx;
				/* Used only for the priority-boosting */
				/*  side effect, not as a lock. */
	unsigned long boost_time;
				/* When to start boosting (jiffies). */
	struct task_struct *boost_kthread_task;
				/* kthread that takes care of priority */
				/*  boosting for this rcu_node structure. */
	unsigned int boost_kthread_status;
				/* State of boost_kthread_task for tracing. */
	unsigned long n_tasks_boosted;
				/* Total number of tasks boosted. */
	unsigned long n_exp_boosts;
				/* Number of tasks boosted for expedited GP. */
	unsigned long n_normal_boosts;
				/* Number of tasks boosted for normal GP. */
	unsigned long n_balk_blkd_tasks;
				/* Refused to boost: no blocked tasks. */
	unsigned long n_balk_exp_gp_tasks;
				/* Refused to boost: nothing blocking GP. */
	unsigned long n_balk_boost_tasks;
				/* Refused to boost: already boosting. */
	unsigned long n_balk_notblocked;
				/* Refused to boost: RCU RS CS still running. */
	unsigned long n_balk_notyet;
				/* Refused to boost: not yet time. */
	unsigned long n_balk_nos;
				/* Refused to boost: not sure why, though. */
				/*  This can happen due to race conditions. */
#endif /* #ifdef CONFIG_RCU_BOOST */
#ifdef CONFIG_RCU_NOCB_CPU
	wait_queue_head_t nocb_gp_wq[2];
				/* Place for rcu_nocb_kthread() to wait GP. */
#endif /* #ifdef CONFIG_RCU_NOCB_CPU */
	int need_future_gp[2];
				/* Counts of upcoming no-CB GP requests. */
	raw_spinlock_t fqslock ____cacheline_internodealigned_in_smp;
} ____cacheline_internodealigned_in_smp;

/*
 * Do a full breadth-first scan of the rcu_node structures for the
 * specified rcu_state structure.
 */
#define rcu_for_each_node_breadth_first(rsp, rnp) \
	for ((rnp) = &(rsp)->node[0]; \
	     (rnp) < &(rsp)->node[rcu_num_nodes]; (rnp)++)

/*
 * Do a breadth-first scan of the non-leaf rcu_node structures for the
 * specified rcu_state structure.  Note that if there is a singleton
 * rcu_node tree with but one rcu_node structure, this loop is a no-op.
 */
#define rcu_for_each_nonleaf_node_breadth_first(rsp, rnp) \
	for ((rnp) = &(rsp)->node[0]; \
	     (rnp) < (rsp)->level[rcu_num_lvls - 1]; (rnp)++)

/*
 * Scan the leaves of the rcu_node hierarchy for the specified rcu_state
 * structure.  Note that if there is a singleton rcu_node tree with but
 * one rcu_node structure, this loop -will- visit the rcu_node structure.
 * It is still a leaf node, even if it is also the root node.
 */
#define rcu_for_each_leaf_node(rsp, rnp) \
	for ((rnp) = (rsp)->level[rcu_num_lvls - 1]; \
	     (rnp) < &(rsp)->node[rcu_num_nodes]; (rnp)++)

/* Index values for nxttail array in struct rcu_data. */
#define RCU_DONE_TAIL		0	/* Also RCU_WAIT head. */
#define RCU_WAIT_TAIL		1	/* Also RCU_NEXT_READY head. */
#define RCU_NEXT_READY_TAIL	2	/* Also RCU_NEXT head. */
#define RCU_NEXT_TAIL		3
#define RCU_NEXT_SIZE		4

/* Per-CPU data for read-copy update. */
struct rcu_data {
	/* 1) quiescent-state and grace-period handling : */
	unsigned long	completed;	/* Track rsp->completed gp number */
					/*  in order to detect GP end. */
	unsigned long	gpnum;		/* Highest gp number that this CPU */
					/*  is aware of having started. */
	bool		passed_quiesce;	/* User-mode/idle loop etc. */
	bool		qs_pending;	/* Core waits for quiesc state. */
	bool		beenonline;	/* CPU online at least once. */
	struct rcu_node *mynode;	/* This CPU's leaf of hierarchy */
	unsigned long grpmask;		/* Mask to apply to leaf qsmask. */
#ifdef CONFIG_RCU_CPU_STALL_INFO
	unsigned long	ticks_this_gp;	/* The number of scheduling-clock */
					/*  ticks this CPU has handled */
					/*  during and after the last grace */
					/* period it is aware of. */
#endif /* #ifdef CONFIG_RCU_CPU_STALL_INFO */

	/* 2) batch handling */
	/*
	 * If nxtlist is not NULL, it is partitioned as follows.
	 * Any of the partitions might be empty, in which case the
	 * pointer to that partition will be equal to the pointer for
	 * the following partition.  When the list is empty, all of
	 * the nxttail elements point to the ->nxtlist pointer itself,
	 * which in that case is NULL.
	 *
	 * [nxtlist, *nxttail[RCU_DONE_TAIL]):
	 *	Entries that batch # <= ->completed
	 *	The grace period for these entries has completed, and
	 *	the other grace-period-completed entries may be moved
	 *	here temporarily in rcu_process_callbacks().
	 * [*nxttail[RCU_DONE_TAIL], *nxttail[RCU_WAIT_TAIL]):
	 *	Entries that batch # <= ->completed - 1: waiting for current GP
	 * [*nxttail[RCU_WAIT_TAIL], *nxttail[RCU_NEXT_READY_TAIL]):
	 *	Entries known to have arrived before current GP ended
	 * [*nxttail[RCU_NEXT_READY_TAIL], *nxttail[RCU_NEXT_TAIL]):
	 *	Entries that might have arrived after current GP ended
	 *	Note that the value of *nxttail[RCU_NEXT_TAIL] will
	 *	always be NULL, as this is the end of the list.
	 */
	struct rcu_head *nxtlist;
	struct rcu_head **nxttail[RCU_NEXT_SIZE];
	unsigned long	nxtcompleted[RCU_NEXT_SIZE];
					/* grace periods for sublists. */
	long		qlen_lazy;	/* # of lazy queued callbacks */
	long		qlen;		/* # of queued callbacks, incl lazy */
	long		qlen_last_fqs_check;
					/* qlen at last check for QS forcing */
	unsigned long	n_cbs_invoked;	/* count of RCU cbs invoked. */
	unsigned long	n_nocbs_invoked; /* count of no-CBs RCU cbs invoked. */
	unsigned long   n_cbs_orphaned; /* RCU cbs orphaned by dying CPU */
	unsigned long   n_cbs_adopted;  /* RCU cbs adopted from dying CPU */
	unsigned long	n_force_qs_snap;
					/* did other CPU force QS recently? */
	long		blimit;		/* Upper limit on a processed batch */

	/* 3) dynticks interface. */
	struct rcu_dynticks *dynticks;	/* Shared per-CPU dynticks state. */
	int dynticks_snap;		/* Per-GP tracking for dynticks. */

	/* 4) reasons this CPU needed to be kicked by force_quiescent_state */
	unsigned long dynticks_fqs;	/* Kicked due to dynticks idle. */
	unsigned long offline_fqs;	/* Kicked due to being offline. */
	unsigned long cond_resched_completed;
					/* Grace period that needs help */
					/*  from cond_resched(). */

	/* 5) __rcu_pending() statistics. */
	unsigned long n_rcu_pending;	/* rcu_pending() calls since boot. */
	unsigned long n_rp_qs_pending;
	unsigned long n_rp_report_qs;
	unsigned long n_rp_cb_ready;
	unsigned long n_rp_cpu_needs_gp;
	unsigned long n_rp_gp_completed;
	unsigned long n_rp_gp_started;
	unsigned long n_rp_nocb_defer_wakeup;
	unsigned long n_rp_need_nothing;

	/* 6) _rcu_barrier() and OOM callbacks. */
	struct rcu_head barrier_head;
#ifdef CONFIG_RCU_FAST_NO_HZ
	struct rcu_head oom_head;
#endif /* #ifdef CONFIG_RCU_FAST_NO_HZ */

	/* 7) Callback offloading. */
#ifdef CONFIG_RCU_NOCB_CPU
	struct rcu_head *nocb_head;	/* CBs waiting for kthread. */
	struct rcu_head **nocb_tail;
	atomic_long_t nocb_q_count;	/* # CBs waiting for kthread */
	atomic_long_t nocb_q_count_lazy; /*  (approximate). */
	struct rcu_head *nocb_follower_head; /* CBs ready to invoke. */
	struct rcu_head **nocb_follower_tail;
	atomic_long_t nocb_follower_count; /* # CBs ready to invoke. */
	atomic_long_t nocb_follower_count_lazy; /*  (approximate). */
	int nocb_p_count;		/* # CBs being invoked by kthread */
	int nocb_p_count_lazy;		/*  (approximate). */
	wait_queue_head_t nocb_wq;	/* For nocb kthreads to sleep on. */
	struct task_struct *nocb_kthread;
	int nocb_defer_wakeup;		/* Defer wakeup of nocb_kthread. */

	/* The following fields are used by the leader, hence own cacheline. */
	struct rcu_head *nocb_gp_head ____cacheline_internodealigned_in_smp;
					/* CBs waiting for GP. */
	struct rcu_head **nocb_gp_tail;
	long nocb_gp_count;
	long nocb_gp_count_lazy;
	bool nocb_leader_sleep;		/* Is the nocb leader thread asleep? */
	struct rcu_data *nocb_next_follower;
					/* Next follower in wakeup chain. */

	/* The following fields are used by the follower, hence new cachline. */
	struct rcu_data *nocb_leader ____cacheline_internodealigned_in_smp;
					/* Leader CPU takes GP-end wakeups. */
#endif /* #ifdef CONFIG_RCU_NOCB_CPU */

	/* 8) RCU CPU stall data. */
#ifdef CONFIG_RCU_CPU_STALL_INFO
	unsigned int softirq_snap;	/* Snapshot of softirq activity. */
#endif /* #ifdef CONFIG_RCU_CPU_STALL_INFO */

	int cpu;
	struct rcu_state *rsp;
};

/* Values for fqs_state field in struct rcu_state. */
#define RCU_GP_IDLE		0	/* No grace period in progress. */
#define RCU_GP_INIT		1	/* Grace period being initialized. */
#define RCU_SAVE_DYNTICK	2	/* Need to scan dyntick state. */
#define RCU_FORCE_QS		3	/* Need to force quiescent state. */
#define RCU_SIGNAL_INIT		RCU_SAVE_DYNTICK

/* Values for nocb_defer_wakeup field in struct rcu_data. */
#define RCU_NOGP_WAKE_NOT	0
#define RCU_NOGP_WAKE		1
#define RCU_NOGP_WAKE_FORCE	2

#define RCU_JIFFIES_TILL_FORCE_QS (1 + (HZ > 250) + (HZ > 500))
					/* For jiffies_till_first_fqs and */
					/*  and jiffies_till_next_fqs. */

#define RCU_JIFFIES_FQS_DIV	256	/* Very large systems need more */
					/*  delay between bouts of */
					/*  quiescent-state forcing. */

#define RCU_STALL_RAT_DELAY	2	/* Allow other CPUs time to take */
					/*  at least one scheduling clock */
					/*  irq before ratting on them. */

#define rcu_wait(cond)							\
do {									\
	for (;;) {							\
		set_current_state(TASK_INTERRUPTIBLE);			\
		if (cond)						\
			break;						\
		schedule();						\
	}								\
	__set_current_state(TASK_RUNNING);				\
} while (0)

/*
 * RCU global state, including node hierarchy.  This hierarchy is
 * represented in "heap" form in a dense array.  The root (first level)
 * of the hierarchy is in ->node[0] (referenced by ->level[0]), the second
 * level in ->node[1] through ->node[m] (->node[1] referenced by ->level[1]),
 * and the third level in ->node[m+1] and following (->node[m+1] referenced
 * by ->level[2]).  The number of levels is determined by the number of
 * CPUs and by CONFIG_RCU_FANOUT.  Small systems will have a "hierarchy"
 * consisting of a single rcu_node.
 */
struct rcu_state {
	struct rcu_node node[NUM_RCU_NODES];	/* Hierarchy. */
	struct rcu_node *level[RCU_NUM_LVLS];	/* Hierarchy levels. */
	u32 levelcnt[MAX_RCU_LVLS + 1];		/* # nodes in each level. */
	u8 levelspread[RCU_NUM_LVLS];		/* kids/node in each level. */
	u8 flavor_mask;				/* bit in flavor mask. */
	struct rcu_data __percpu *rda;		/* pointer of percu rcu_data. */
	void (*call)(struct rcu_head *head,	/* call_rcu() flavor. */
		     void (*func)(struct rcu_head *head));

	/* The following fields are guarded by the root rcu_node's lock. */

	u8	fqs_state ____cacheline_internodealigned_in_smp;
						/* Force QS state. */
	u8	boost;				/* Subject to priority boost. */
	unsigned long gpnum;			/* Current gp number. */
	unsigned long completed;		/* # of last completed gp. */
	struct task_struct *gp_kthread;		/* Task for grace periods. */
	wait_queue_head_t gp_wq;		/* Where GP task waits. */
	short gp_flags;				/* Commands for GP task. */
	short gp_state;				/* GP kthread sleep state. */

	/* End of fields guarded by root rcu_node's lock. */

	raw_spinlock_t orphan_lock ____cacheline_internodealigned_in_smp;
						/* Protect following fields. */
	struct rcu_head *orphan_nxtlist;	/* Orphaned callbacks that */
						/*  need a grace period. */
	struct rcu_head **orphan_nxttail;	/* Tail of above. */
	struct rcu_head *orphan_donelist;	/* Orphaned callbacks that */
						/*  are ready to invoke. */
	struct rcu_head **orphan_donetail;	/* Tail of above. */
	long qlen_lazy;				/* Number of lazy callbacks. */
	long qlen;				/* Total number of callbacks. */
	/* End of fields guarded by orphan_lock. */

	struct mutex onoff_mutex;		/* Coordinate hotplug & GPs. */

	struct mutex barrier_mutex;		/* Guards barrier fields. */
	atomic_t barrier_cpu_count;		/* # CPUs waiting on. */
	struct completion barrier_completion;	/* Wake at barrier end. */
	unsigned long n_barrier_done;		/* ++ at start and end of */
						/*  _rcu_barrier(). */
	/* End of fields guarded by barrier_mutex. */

	atomic_long_t expedited_start;		/* Starting ticket. */
	atomic_long_t expedited_done;		/* Done ticket. */
	atomic_long_t expedited_wrap;		/* # near-wrap incidents. */
	atomic_long_t expedited_tryfail;	/* # acquisition failures. */
	atomic_long_t expedited_workdone1;	/* # done by others #1. */
	atomic_long_t expedited_workdone2;	/* # done by others #2. */
	atomic_long_t expedited_normal;		/* # fallbacks to normal. */
	atomic_long_t expedited_stoppedcpus;	/* # successful stop_cpus. */
	atomic_long_t expedited_done_tries;	/* # tries to update _done. */
	atomic_long_t expedited_done_lost;	/* # times beaten to _done. */
	atomic_long_t expedited_done_exit;	/* # times exited _done loop. */

	unsigned long jiffies_force_qs;		/* Time at which to invoke */
						/*  force_quiescent_state(). */
	unsigned long n_force_qs;		/* Number of calls to */
						/*  force_quiescent_state(). */
	unsigned long n_force_qs_lh;		/* ~Number of calls leaving */
						/*  due to lock unavailable. */
	unsigned long n_force_qs_ngp;		/* Number of calls leaving */
						/*  due to no GP active. */
	unsigned long gp_start;			/* Time at which GP started, */
						/*  but in jiffies. */
	unsigned long jiffies_stall;		/* Time at which to check */
						/*  for CPU stalls. */
	unsigned long jiffies_resched;		/* Time at which to resched */
						/*  a reluctant CPU. */
	unsigned long gp_max;			/* Maximum GP duration in */
						/*  jiffies. */
	const char *name;			/* Name of structure. */
	char abbr;				/* Abbreviated name. */
	struct list_head flavors;		/* List of RCU flavors. */
};

/* Values for rcu_state structure's gp_flags field. */
#define RCU_GP_FLAG_INIT 0x1	/* Need grace-period initialization. */
#define RCU_GP_FLAG_FQS  0x2	/* Need grace-period quiescent-state forcing. */

/* Values for rcu_state structure's gp_flags field. */
#define RCU_GP_WAIT_INIT 0	/* Initial state. */
#define RCU_GP_WAIT_GPS  1	/* Wait for grace-period start. */
#define RCU_GP_WAIT_FQS  2	/* Wait for force-quiescent-state time. */

extern struct list_head rcu_struct_flavors;

/* Sequence through rcu_state structures for each RCU flavor. */
#define for_each_rcu_flavor(rsp) \
	list_for_each_entry((rsp), &rcu_struct_flavors, flavors)

/* Return values for rcu_preempt_offline_tasks(). */

#define RCU_OFL_TASKS_NORM_GP	0x1		/* Tasks blocking normal */
						/*  GP were moved to root. */
#define RCU_OFL_TASKS_EXP_GP	0x2		/* Tasks blocking expedited */
						/*  GP were moved to root. */

/*
 * RCU implementation internal declarations:
 */
extern struct rcu_state rcu_sched_state;
DECLARE_PER_CPU(struct rcu_data, rcu_sched_data);

extern struct rcu_state rcu_bh_state;
DECLARE_PER_CPU(struct rcu_data, rcu_bh_data);

#ifdef CONFIG_TREE_PREEMPT_RCU
extern struct rcu_state rcu_preempt_state;
DECLARE_PER_CPU(struct rcu_data, rcu_preempt_data);
#endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */

#ifdef CONFIG_RCU_BOOST
DECLARE_PER_CPU(unsigned int, rcu_cpu_kthread_status);
DECLARE_PER_CPU(int, rcu_cpu_kthread_cpu);
DECLARE_PER_CPU(unsigned int, rcu_cpu_kthread_loops);
DECLARE_PER_CPU(char, rcu_cpu_has_work);
#endif /* #ifdef CONFIG_RCU_BOOST */

#ifndef RCU_TREE_NONCORE

/* Forward declarations for rcutree_plugin.h */
static void rcu_bootup_announce(void);
long rcu_batches_completed(void);
static void rcu_preempt_note_context_switch(int cpu);
static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp);
#ifdef CONFIG_HOTPLUG_CPU
static void rcu_report_unblock_qs_rnp(struct rcu_node *rnp,
				      unsigned long flags);
#endif /* #ifdef CONFIG_HOTPLUG_CPU */
static void rcu_print_detail_task_stall(struct rcu_state *rsp);
static int rcu_print_task_stall(struct rcu_node *rnp);
static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp);
#ifdef CONFIG_HOTPLUG_CPU
static int rcu_preempt_offline_tasks(struct rcu_state *rsp,
				     struct rcu_node *rnp,
				     struct rcu_data *rdp);
#endif /* #ifdef CONFIG_HOTPLUG_CPU */
static void rcu_preempt_check_callbacks(int cpu);
void call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *rcu));
#if defined(CONFIG_HOTPLUG_CPU) || defined(CONFIG_TREE_PREEMPT_RCU)
static void rcu_report_exp_rnp(struct rcu_state *rsp, struct rcu_node *rnp,
			       bool wake);
#endif /* #if defined(CONFIG_HOTPLUG_CPU) || defined(CONFIG_TREE_PREEMPT_RCU) */
static void __init __rcu_init_preempt(void);
static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags);
static void rcu_preempt_boost_start_gp(struct rcu_node *rnp);
static void invoke_rcu_callbacks_kthread(void);
static bool rcu_is_callbacks_kthread(void);
#ifdef CONFIG_RCU_BOOST
static void rcu_preempt_do_callbacks(void);
static int rcu_spawn_one_boost_kthread(struct rcu_state *rsp,
						 struct rcu_node *rnp);
#endif /* #ifdef CONFIG_RCU_BOOST */
static void __init rcu_spawn_boost_kthreads(void);
static void rcu_prepare_kthreads(int cpu);
static void rcu_cleanup_after_idle(int cpu);
static void rcu_prepare_for_idle(int cpu);
static void rcu_idle_count_callbacks_posted(void);
static void print_cpu_stall_info_begin(void);
static void print_cpu_stall_info(struct rcu_state *rsp, int cpu);
static void print_cpu_stall_info_end(void);
static void zero_cpu_stall_ticks(struct rcu_data *rdp);
static void increment_cpu_stall_ticks(void);
static bool rcu_nocb_cpu_needs_barrier(struct rcu_state *rsp, int cpu);
static void rcu_nocb_gp_set(struct rcu_node *rnp, int nrq);
static void rcu_nocb_gp_cleanup(struct rcu_state *rsp, struct rcu_node *rnp);
static void rcu_init_one_nocb(struct rcu_node *rnp);
static bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,
			    bool lazy, unsigned long flags);
static bool rcu_nocb_adopt_orphan_cbs(struct rcu_state *rsp,
				      struct rcu_data *rdp,
				      unsigned long flags);
static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp);
static void do_nocb_deferred_wakeup(struct rcu_data *rdp);
static void rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp);
static void rcu_spawn_all_nocb_kthreads(int cpu);
static void __init rcu_spawn_nocb_kthreads(void);
#ifdef CONFIG_RCU_NOCB_CPU
static void __init rcu_organize_nocb_kthreads(struct rcu_state *rsp);
#endif /* #ifdef CONFIG_RCU_NOCB_CPU */
static void __maybe_unused rcu_kick_nohz_cpu(int cpu);
static bool init_nocb_callback_list(struct rcu_data *rdp);
static void rcu_sysidle_enter(struct rcu_dynticks *rdtp, int irq);
static void rcu_sysidle_exit(struct rcu_dynticks *rdtp, int irq);
static void rcu_sysidle_check_cpu(struct rcu_data *rdp, bool *isidle,
				  unsigned long *maxj);
static bool is_sysidle_rcu_state(struct rcu_state *rsp);
static void rcu_sysidle_report_gp(struct rcu_state *rsp, int isidle,
				  unsigned long maxj);
static void rcu_bind_gp_kthread(void);
static void rcu_sysidle_init_percpu_data(struct rcu_dynticks *rdtp);
static bool rcu_nohz_full_cpu(struct rcu_state *rsp);
static void rcu_dynticks_task_enter(void);
static void rcu_dynticks_task_exit(void);

#endif /* #ifndef RCU_TREE_NONCORE */

#ifdef CONFIG_RCU_TRACE
#ifdef CONFIG_RCU_NOCB_CPU
/* Sum up queue lengths for tracing. */
static inline void rcu_nocb_q_lengths(struct rcu_data *rdp, long *ql, long *qll)
{
	*ql = atomic_long_read(&rdp->nocb_q_count) +
	      rdp->nocb_p_count +
	      atomic_long_read(&rdp->nocb_follower_count) +
	      rdp->nocb_p_count + rdp->nocb_gp_count;
	*qll = atomic_long_read(&rdp->nocb_q_count_lazy) +
	       rdp->nocb_p_count_lazy +
	       atomic_long_read(&rdp->nocb_follower_count_lazy) +
	       rdp->nocb_p_count_lazy + rdp->nocb_gp_count_lazy;
}
#else /* #ifdef CONFIG_RCU_NOCB_CPU */
static inline void rcu_nocb_q_lengths(struct rcu_data *rdp, long *ql, long *qll)
{
	*ql = 0;
	*qll = 0;
}
#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */

#ifdef CONFIG_MT_RCU_MONITOR
#include <linux/sched.h>

#define MAX_RCU_BUFF_LEN			1024
#define MAX_SERVICE_NAME_LEN		16

#define CALL_RCU			0
#define INVOKE_RCU			1

struct rcu_callback_log_entry {
	int cpu;
	char rcuname[MAX_SERVICE_NAME_LEN];
	char comm[TASK_COMM_LEN];
	unsigned long rhp;
	unsigned long func;
	long qlen;
	unsigned long gpnum;
	unsigned long ip;
	ktime_t time;
};

struct rcu_callback_log {
	int next;
	int full;
	unsigned size;
	struct rcu_callback_log_entry *entry;
};

struct rcu_invoke_log_entry {
	int cpu;
	char rcuname[MAX_SERVICE_NAME_LEN];
	unsigned long rhp;
	unsigned long func;
	long qlen;
	unsigned long gpnum;
	ktime_t time_start;
	s64 time_dur;
	ktime_t timestamp;
};

struct rcu_invoke_log {
	int next;
	int full;
	unsigned size;
	struct rcu_invoke_log_entry *entry;
};

DECLARE_PER_CPU(struct rcu_callback_log, rcu_callback_log_head);
DECLARE_PER_CPU(struct rcu_invoke_log, rcu_invoke_callback_log);
extern struct rcu_callback_log_entry *rcu_callback_log_add(void);
extern struct rcu_invoke_log_entry *rcu_invoke_log_add(void);
#endif /* #ifdef RCU_MONITOR */
#endif /* #ifdef CONFIG_RCU_TRACE */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* IP tables module for matching the value of the IPv4/IPv6 DSCP field
 *
 * (C) 2002 by Harald Welte <laforge@netfilter.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
#include <linux/module.h>
#include <linux/skbuff.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <net/dsfield.h>

#include <linux/netfilter/x_tables.h>
#include <linux/netfilter/xt_dscp.h>

MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
MODULE_DESCRIPTION("Xtables: DSCP/TOS field match");
MODULE_LICENSE("GPL");
MODULE_ALIAS("ipt_dscp");
MODULE_ALIAS("ip6t_dscp");
MODULE_ALIAS("ipt_tos");
MODULE_ALIAS("ip6t_tos");

static bool
dscp_mt(const struct sk_buff *skb, struct xt_action_param *par)
{
	const struct xt_dscp_info *info = par->matchinfo;
	u_int8_t dscp = ipv4_get_dsfield(ip_hdr(skb)) >> XT_DSCP_SHIFT;

	return (dscp == info->dscp) ^ !!info->invert;
}

static bool
dscp_mt6(const struct sk_buff *skb, struct xt_action_param *par)
{
	const struct xt_dscp_info *info = par->matchinfo;
	u_int8_t dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> XT_DSCP_SHIFT;

	return (dscp == info->dscp) ^ !!info->invert;
}

static int dscp_mt_check(const struct xt_mtchk_param *par)
{
	const struct xt_dscp_info *info = par->matchinfo;

	if (info->dscp > XT_DSCP_MAX) {
		pr_info("dscp %x out of range\n", info->dscp);
		return -EDOM;
	}

	return 0;
}

static bool tos_mt(const struct sk_buff *skb, struct xt_action_param *par)
{
	const struct xt_tos_match_info *info = par->matchinfo;

	if (par->family == NFPROTO_IPV4)
		return ((ip_hdr(skb)->tos & info->tos_mask) ==
		       info->tos_value) ^ !!info->invert;
	else
		return ((ipv6_get_dsfield(ipv6_hdr(skb)) & info->tos_mask) ==
		       info->tos_value) ^ !!info->invert;
}

static struct xt_match dscp_mt_reg[] __read_mostly = {
	{
		.name		= "dscp",
		.family		= NFPROTO_IPV4,
		.checkentry	= dscp_mt_check,
		.match		= dscp_mt,
		.matchsize	= sizeof(struct xt_dscp_info),
		.me		= THIS_MODULE,
	},
	{
		.name		= "dscp",
		.family		= NFPROTO_IPV6,
		.checkentry	= dscp_mt_check,
		.match		= dscp_mt6,
		.matchsize	= sizeof(struct xt_dscp_info),
		.me		= THIS_MODULE,
	},
	{
		.name		= "tos",
		.revision	= 1,
		.family		= NFPROTO_IPV4,
		.match		= tos_mt,
		.matchsize	= sizeof(struct xt_tos_match_info),
		.me		= THIS_MODULE,
	},
	{
		.name		= "tos",
		.revision	= 1,
		.family		= NFPROTO_IPV6,
		.match		= tos_mt,
		.matchsize	= sizeof(struct xt_tos_match_info),
		.me		= THIS_MODULE,
	},
};

static int __init dscp_mt_init(void)
{
	return xt_register_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
}

static void __exit dscp_mt_exit(void)
{
	xt_unregister_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
}

module_init(dscp_mt_init);
module_exit(dscp_mt_exit);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Aztech AZT1605 Driver
 * Copyright (C) 2007,2010  Rene Herman
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#define AZT1605

#define CRD_NAME "Aztech AZT1605"
#define DRV_NAME "AZT1605"
#define DEV_NAME "azt1605"

#define GALAXY_DSP_MAJOR		2
#define GALAXY_DSP_MINOR		1

#define GALAXY_CONFIG_SIZE		3

/*
 * 24-bit config register
 */

#define GALAXY_CONFIG_SBA_220		(0 << 0)
#define GALAXY_CONFIG_SBA_240		(1 << 0)
#define GALAXY_CONFIG_SBA_260		(2 << 0)
#define GALAXY_CONFIG_SBA_280		(3 << 0)
#define GALAXY_CONFIG_SBA_MASK		GALAXY_CONFIG_SBA_280

#define GALAXY_CONFIG_MPUA_300		(0 << 2)
#define GALAXY_CONFIG_MPUA_330		(1 << 2)

#define GALAXY_CONFIG_MPU_ENABLE	(1 << 3)

#define GALAXY_CONFIG_GAME_ENABLE	(1 << 4)

#define GALAXY_CONFIG_CD_PANASONIC	(1 << 5)
#define GALAXY_CONFIG_CD_MITSUMI	(1 << 6)
#define GALAXY_CONFIG_CD_MASK		(\
	GALAXY_CONFIG_CD_PANASONIC | GALAXY_CONFIG_CD_MITSUMI)

#define GALAXY_CONFIG_UNUSED		(1 << 7)
#define GALAXY_CONFIG_UNUSED_MASK	GALAXY_CONFIG_UNUSED

#define GALAXY_CONFIG_SBIRQ_2		(1 << 8)
#define GALAXY_CONFIG_SBIRQ_3		(1 << 9)
#define GALAXY_CONFIG_SBIRQ_5		(1 << 10)
#define GALAXY_CONFIG_SBIRQ_7		(1 << 11)

#define GALAXY_CONFIG_MPUIRQ_2		(1 << 12)
#define GALAXY_CONFIG_MPUIRQ_3		(1 << 13)
#define GALAXY_CONFIG_MPUIRQ_5		(1 << 14)
#define GALAXY_CONFIG_MPUIRQ_7		(1 << 15)

#define GALAXY_CONFIG_WSSA_530		(0 << 16)
#define GALAXY_CONFIG_WSSA_604		(1 << 16)
#define GALAXY_CONFIG_WSSA_E80		(2 << 16)
#define GALAXY_CONFIG_WSSA_F40		(3 << 16)

#define GALAXY_CONFIG_WSS_ENABLE	(1 << 18)

#define GALAXY_CONFIG_CDIRQ_11		(1 << 19)
#define GALAXY_CONFIG_CDIRQ_12		(1 << 20)
#define GALAXY_CONFIG_CDIRQ_15		(1 << 21)
#define GALAXY_CONFIG_CDIRQ_MASK	(\
	GALAXY_CONFIG_CDIRQ_11 | GALAXY_CONFIG_CDIRQ_12 |\
	GALAXY_CONFIG_CDIRQ_15)

#define GALAXY_CONFIG_CDDMA_DISABLE	(0 << 22)
#define GALAXY_CONFIG_CDDMA_0		(1 << 22)
#define GALAXY_CONFIG_CDDMA_1		(2 << 22)
#define GALAXY_CONFIG_CDDMA_3		(3 << 22)
#define GALAXY_CONFIG_CDDMA_MASK	GALAXY_CONFIG_CDDMA_3

#define GALAXY_CONFIG_MASK		(\
	GALAXY_CONFIG_SBA_MASK | GALAXY_CONFIG_CD_MASK |\
	GALAXY_CONFIG_UNUSED_MASK | GALAXY_CONFIG_CDIRQ_MASK |\
	GALAXY_CONFIG_CDDMA_MASK)

#include "galaxy.c"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/*****************************************************************************
 *                     C O M P I L E R   F L A G S
 *****************************************************************************/


/*****************************************************************************
 *                E X T E R N A L   R E F E R E N C E S
 *****************************************************************************/

#include <linux/dma-mapping.h>
#include "mt_soc_afe_common.h"
#include "mt_soc_afe_def.h"
#include "mt_soc_afe_reg.h"
#include "mt_soc_afe_clk.h"
#include "mt_soc_afe_control.h"
#include "mt_soc_pcm_common.h"


/* information about */
static struct AFE_MEM_CONTROL_T *I2S0_AWB_Control_context;
static struct snd_dma_buffer *Awb_Capture_dma_buf;

static DEFINE_SPINLOCK(auddrv_Dl1AWBInCtl_lock);

/*
 *    function implementation
 */
static void StartAudioI2S0AWBHardware(struct snd_pcm_substream *substream);
static void StopAudioI2S0AWBHardware(struct snd_pcm_substream *substream);
static int mtk_i2s0_awb_probe(struct platform_device *pdev);
static int mtk_i2s0_awb_pcm_close(struct snd_pcm_substream *substream);
static int mtk_asoc_i2s0_awb_pcm_new(struct snd_soc_pcm_runtime *rtd);
static int mtk_i2s0_dl1_awb_probe(struct snd_soc_platform *platform);

static struct snd_pcm_hardware mtk_I2S0_awb_hardware = {

	.info = (SNDRV_PCM_INFO_INTERLEAVED),
	.formats = SND_SOC_STD_MT_FMTS,
	.rates = SOC_NORMAL_USE_RATE,
	.rate_min = SOC_NORMAL_USE_RATE_MIN,
	.rate_max = SOC_NORMAL_USE_RATE_MAX,
	.channels_min = SOC_NORMAL_USE_CHANNELS_MIN,
	.channels_max = SOC_NORMAL_USE_CHANNELS_MAX,
	.buffer_bytes_max = AWB_MAX_BUFFER_SIZE,
	.period_bytes_max = AWB_MAX_BUFFER_SIZE,
	.periods_min = AWB_MIN_PERIOD_SIZE,
	.periods_max = AWB_MAX_PERIOD_SIZE,
	.fifo_size = 0,
};

static void StopAudioI2S0AWBHardware(struct snd_pcm_substream *substream)
{
	pr_debug("StopAudioI2S0AWBHardware\n");

	mt_afe_disable_memory_path(Soc_Aud_Digital_Block_I2S_IN_2);
	mt_afe_disable_memory_path(Soc_Aud_Digital_Block_MEM_AWB);

	/* here to set interrupt */
	mt_afe_set_irq_state(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, false);

	/* stop I2S */
	mt_afe_set_reg(AFE_I2S_CON, 0x0, 0x1);

	/* here to turn off digital part */
	mt_afe_set_connection(Soc_Aud_InterCon_DisConnect, Soc_Aud_InterConnectionInput_I00,
		      Soc_Aud_InterConnectionOutput_O05);
	mt_afe_set_connection(Soc_Aud_InterCon_DisConnect, Soc_Aud_InterConnectionInput_I01,
		      Soc_Aud_InterConnectionOutput_O06);

	mt_afe_enable_afe(false);
}

static void StartAudioI2S0AWBHardware(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime = substream->runtime;

	uint32_t Audio_I2S_Dac = 0;
/*	uint32_t MclkDiv0 = 0;*/

	const bool bEnablePhaseShiftFix = true;

	pr_debug("StartAudioI2S0AWBHardware\n");

#if 0
	MclkDiv0 = SetCLkMclk(Soc_Aud_I2S0, runtime->rate);	/* select I2S */
	SetCLkBclk(MclkDiv0, runtime->rate, runtime->channels, Soc_Aud_I2S_WLEN_WLEN_32BITS);
#endif
	/* 2nd I2S In */
	mt_afe_set_sample_rate(Soc_Aud_Digital_Block_MEM_I2S, runtime->rate);

	Audio_I2S_Dac |= (bEnablePhaseShiftFix << 31);
	Audio_I2S_Dac |= (Soc_Aud_I2S_IN_PAD_SEL_I2S_IN_FROM_IO_MUX << 28);	/* I2S in from io_mux */
	Audio_I2S_Dac |= Soc_Aud_LOW_JITTER_CLOCK << 12;	/* Low jitter mode */
	Audio_I2S_Dac |= (Soc_Aud_INV_LRCK_NO_INVERSE << 5);
	Audio_I2S_Dac |= (Soc_Aud_I2S_FORMAT_I2S << 3);
	Audio_I2S_Dac |= (Soc_Aud_I2S_WLEN_WLEN_32BITS << 1);
	mt_afe_set_reg(AFE_I2S_CON, Audio_I2S_Dac | 0x1, MASK_ALL);
	/* here to set interrupt */
	mt_afe_set_irq_counter(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, substream->runtime->period_size >> 1);
	mt_afe_set_irq_rate(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, substream->runtime->rate);
	mt_afe_set_irq_state(Soc_Aud_IRQ_MCU_MODE_IRQ2_MCU_MODE, true);

	mt_afe_set_sample_rate(Soc_Aud_Digital_Block_MEM_AWB, substream->runtime->rate);
	mt_afe_enable_memory_path(Soc_Aud_Digital_Block_MEM_AWB);
	mt_afe_enable_memory_path(Soc_Aud_Digital_Block_I2S_IN_2);

	/* here to turn off digital part */
	mt_afe_set_connection(Soc_Aud_InterCon_Connection, Soc_Aud_InterConnectionInput_I00,
		      Soc_Aud_InterConnectionOutput_O05);
	mt_afe_set_connection(Soc_Aud_InterCon_Connection, Soc_Aud_InterConnectionInput_I01,
		      Soc_Aud_InterConnectionOutput_O06);

	mt_afe_enable_afe(true);
}

static int mtk_i2s0_awb_pcm_prepare(struct snd_pcm_substream *substream)
{
	pr_debug("%s, substream->rate = %d, substream->channels = %d\n",
		__func__, substream->runtime->rate, substream->runtime->channels);
	return 0;
}

static int mtk_i2s0_awb_alsa_stop(struct snd_pcm_substream *substream)
{
	/* AFE_BLOCK_T *Awb_Block = &(I2S0_AWB_Control_context->rBlock); */
	pr_debug("mtk_i2s0_awb_alsa_stop\n");
	StopAudioI2S0AWBHardware(substream);
	RemoveMemifSubStream(Soc_Aud_Digital_Block_MEM_AWB, substream);
	return 0;
}

static snd_pcm_uframes_t mtk_i2s0_awb_pcm_pointer(struct snd_pcm_substream *substream)
{
	uint32_t Frameidx = 0;
	struct AFE_BLOCK_T *Awb_Block = &(I2S0_AWB_Control_context->rBlock);

	PRINTK_AUD_AWB("%s Awb_Block->u4WriteIdx= 0x%x\n", __func__, Awb_Block->u4WriteIdx);

	if (mt_afe_get_memory_path_state(Soc_Aud_Digital_Block_MEM_AWB) == true) {
		/* get total bytes to copysinewavetohdmi */
		Frameidx = audio_bytes_to_frame(substream, Awb_Block->u4WriteIdx);
		return Frameidx;
	}
	return 0;
}


static void SetAWBBuffer(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *hw_params)
{
	struct AFE_BLOCK_T *pblock = &I2S0_AWB_Control_context->rBlock;
	struct snd_pcm_runtime *runtime = substream->runtime;

	pr_debug("SetAWBBuffer\n");
	pblock->pucPhysBufAddr = runtime->dma_addr;
	pblock->pucVirtBufAddr = runtime->dma_area;
	pblock->u4BufferSize = runtime->dma_bytes;
	pblock->u4SampleNumMask = 0x001f;	/* 32 byte align */
	pblock->u4WriteIdx = 0;
	pblock->u4DMAReadIdx = 0;
	pblock->u4DataRemained = 0;
	pblock->u4fsyncflag = false;
	pblock->uResetFlag = true;

	pr_debug("dma_bytes = %d dma_area = %p dma_addr = 0x%x\n",
		pblock->u4BufferSize, pblock->pucVirtBufAddr, pblock->pucPhysBufAddr);

	/* set sram address top hardware */
	mt_afe_set_reg(AFE_AWB_BASE, pblock->pucPhysBufAddr, 0xffffffff);
	mt_afe_set_reg(AFE_AWB_END, pblock->pucPhysBufAddr + (pblock->u4BufferSize - 1), 0xffffffff);

}

static int mtk_i2s0_awb_pcm_hw_params(struct snd_pcm_substream *substream,
				      struct snd_pcm_hw_params *hw_params)
{
	struct snd_pcm_runtime *runtime = substream->runtime;
	struct snd_dma_buffer *dma_buf = &substream->dma_buffer;
	int ret = 0;

	pr_debug("mtk_i2s0_awb_pcm_hw_params\n");

	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
	dma_buf->dev.dev = substream->pcm->card->dev;
	dma_buf->private_data = NULL;

	if (Awb_Capture_dma_buf->area) {
		pr_debug("mtk_i2s0_awb_pcm_hw_params Awb_Capture_dma_buf->area\n");
		runtime->dma_bytes = params_buffer_bytes(hw_params);
		runtime->dma_area = Awb_Capture_dma_buf->area;
		runtime->dma_addr = Awb_Capture_dma_buf->addr;
	} else {
		pr_debug("mtk_i2s0_awb_pcm_hw_params snd_pcm_lib_malloc_pages\n");
		ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
	}

	pr_debug("%s, dma_bytes = %zu, dma_area = %p, dma_addr = 0x%lx\n",
		__func__, runtime->dma_bytes, runtime->dma_area,
		(long)runtime->dma_addr);

	pr_debug("runtime->hw.buffer_bytes_max = %zu\n", runtime->hw.buffer_bytes_max);
	SetAWBBuffer(substream, hw_params);

	return ret;
}

static int mtk_i2s0_capture_pcm_hw_free(struct snd_pcm_substream *substream)
{
	pr_debug("mtk_i2s0_capture_pcm_hw_free\n");

	if (Awb_Capture_dma_buf->area)
		return 0;
	else
		return snd_pcm_lib_free_pages(substream);
}

static struct snd_pcm_hw_constraint_list dl1_awb_constraints_sample_rates = {

	.count = ARRAY_SIZE(soc_normal_supported_sample_rates),
	.list = soc_normal_supported_sample_rates,
};

static int mtk_i2s0_awb_pcm_open(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime = substream->runtime;
	int ret = 0;

	pr_debug("mtk_i2s0_awb_pcm_open\n");
	I2S0_AWB_Control_context = get_mem_control_t(Soc_Aud_Digital_Block_MEM_AWB);
	runtime->hw = mtk_I2S0_awb_hardware;
	memcpy((void *)(&(runtime->hw)), (void *)&mtk_I2S0_awb_hardware,
	       sizeof(struct snd_pcm_hardware));

	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
					 &dl1_awb_constraints_sample_rates);
	ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);

	if (ret < 0)
		pr_warn("snd_pcm_hw_constraint_integer failed\n");

	/* here open audio clocks */
	mt_afe_main_clk_on();

	/* print for hw pcm information */
	pr_debug("mtk_i2s0_awb_pcm_open, runtime->rate = %d, channels = %d\n",
		runtime->rate, runtime->channels);

	runtime->hw.info |= SNDRV_PCM_INFO_INTERLEAVED;
	runtime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;
	runtime->hw.info |= SNDRV_PCM_INFO_MMAP_VALID;

	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
		pr_debug("SNDRV_PCM_STREAM_CAPTURE\n");
	else
		return -1;

	if (ret < 0) {
		pr_warn("mtk_i2s0_awb_pcm_close\n");
		mtk_i2s0_awb_pcm_close(substream);
		return ret;
	}

	pr_debug("mtk_i2s0_awb_pcm_open return\n");
	return 0;
}

static int mtk_i2s0_awb_pcm_close(struct snd_pcm_substream *substream)
{
	return 0;
}

static int mtk_i2s0_awb_alsa_start(struct snd_pcm_substream *substream)
{
	pr_debug("mtk_i2s0_awb_alsa_start\n");
	set_memif_substream(Soc_Aud_Digital_Block_MEM_AWB, substream);
	StartAudioI2S0AWBHardware(substream);
	return 0;
}

static int mtk_i2s0_awb_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
{
	pr_debug("mtk_i2s0_awb_pcm_trigger cmd = %d\n", cmd);

	switch (cmd) {
	case SNDRV_PCM_TRIGGER_START:
	case SNDRV_PCM_TRIGGER_RESUME:
		return mtk_i2s0_awb_alsa_start(substream);
	case SNDRV_PCM_TRIGGER_STOP:
	case SNDRV_PCM_TRIGGER_SUSPEND:
		return mtk_i2s0_awb_alsa_stop(substream);
	}
	return -EINVAL;
}

static bool CheckNullPointer(void *pointer)
{
	if (pointer == NULL) {
		pr_debug("CheckNullPointer pointer = NULL");
		return true;
	}
	return false;
}

static int mtk_i2s0_awb_pcm_copy(struct snd_pcm_substream *substream,
				 int channel, snd_pcm_uframes_t pos,
				 void __user *dst, snd_pcm_uframes_t count)
{
	struct AFE_MEM_CONTROL_T *pAWB_MEM_ConTrol = NULL;
	struct AFE_BLOCK_T *Awb_Block = NULL;
	char *Read_Data_Ptr = (char *)dst;
	ssize_t DMA_Read_Ptr = 0, read_size = 0, read_count = 0;
	unsigned long flags;

	/* get total bytes to copy */
	count = align64bytesize(audio_frame_to_bytes(substream, count));

	pr_debug("%s, pos = %lu, count = %lu\n", __func__, pos, count);

	/* check which memif nned to be write */
	pAWB_MEM_ConTrol = I2S0_AWB_Control_context;
	Awb_Block = &(pAWB_MEM_ConTrol->rBlock);

	if (pAWB_MEM_ConTrol == NULL) {
		pr_err("cannot find MEM control !!!!!!!\n");
		msleep(50);
		return 0;
	}

	if (Awb_Block->u4BufferSize <= 0) {
		msleep(50);
		return 0;
	}

	if (CheckNullPointer((void *)Awb_Block->pucVirtBufAddr)) {
		pr_err("CheckNullPointer pucVirtBufAddr = %p\n", Awb_Block->pucVirtBufAddr);
		return 0;
	}

	spin_lock_irqsave(&auddrv_Dl1AWBInCtl_lock, flags);
	if (Awb_Block->u4DataRemained > Awb_Block->u4BufferSize) {
		pr_debug("AudDrv_MEMIF_Read u4DataRemained=%x > u4BufferSize=%x\n",
		       Awb_Block->u4DataRemained, Awb_Block->u4BufferSize);
		Awb_Block->u4DataRemained = 0;
		Awb_Block->u4DMAReadIdx = Awb_Block->u4WriteIdx;
	}

	if (count > Awb_Block->u4DataRemained)
		read_size = Awb_Block->u4DataRemained;
	else
		read_size = count;

	DMA_Read_Ptr = Awb_Block->u4DMAReadIdx;
	spin_unlock_irqrestore(&auddrv_Dl1AWBInCtl_lock, flags);

	PRINTK_AUD_AWB
	("%s finish0, read_count:%x, read_size:%x, u4DataRemained:%x, u4DMAReadIdx:%x, u4WriteIdx:%x\n",
	__func__, read_count, read_size, Awb_Block->u4DataRemained, Awb_Block->u4DMAReadIdx,
	Awb_Block->u4WriteIdx);

	if (DMA_Read_Ptr + read_size < Awb_Block->u4BufferSize) {
		if (DMA_Read_Ptr != Awb_Block->u4DMAReadIdx) {
			PRINTK_AUD_AWB
			("%s 1, read_size:%zu, DataRemained:0x%x, DMA_Read_Ptr:%zu, DMAReadIdx:0x%x\n",
			__func__, read_size, Awb_Block->u4DataRemained, DMA_Read_Ptr,
			Awb_Block->u4DMAReadIdx);
		}

		if (copy_to_user((void __user *)Read_Data_Ptr,
			(Awb_Block->pucVirtBufAddr + DMA_Read_Ptr), read_size)) {
			pr_err("%s Fail 1 copy to user Read_Data_Ptr:%p, pucVirtBufAddr:%p,",
				__func__, Read_Data_Ptr, Awb_Block->pucVirtBufAddr);
			pr_err(" u4DMAReadIdx:0x%x, DMA_Read_Ptr:%zu, read_size:%zu\n",
				Awb_Block->u4DMAReadIdx, DMA_Read_Ptr, read_size);
			return 0;
		}

		read_count += read_size;
		spin_lock(&auddrv_Dl1AWBInCtl_lock);
		Awb_Block->u4DataRemained -= read_size;
		Awb_Block->u4DMAReadIdx += read_size;
		Awb_Block->u4DMAReadIdx %= Awb_Block->u4BufferSize;
		DMA_Read_Ptr = Awb_Block->u4DMAReadIdx;
		spin_unlock(&auddrv_Dl1AWBInCtl_lock);

		Read_Data_Ptr += read_size;
		count -= read_size;

		PRINTK_AUD_AWB
			("%s finish1, copy size:%x, u4DMAReadIdx:%x, u4WriteIdx:%x, u4DataRemained:%x\n",
			__func__, read_size, Awb_Block->u4DMAReadIdx, Awb_Block->u4WriteIdx,
			Awb_Block->u4DataRemained);

	} else {
		uint32_t size_1 = Awb_Block->u4BufferSize - DMA_Read_Ptr;
		uint32_t size_2 = read_size - size_1;

		if (DMA_Read_Ptr != Awb_Block->u4DMAReadIdx) {
			PRINTK_AUD_AWB
				("%s 2, read_size1:%x, DataRemained:%x, DMA_Read_Ptr:%zu, DMAReadIdx:%x\n",
				__func__, size_1, Awb_Block->u4DataRemained, DMA_Read_Ptr,
				Awb_Block->u4DMAReadIdx);
		}
		if (copy_to_user((void __user *)Read_Data_Ptr,
			(Awb_Block->pucVirtBufAddr + DMA_Read_Ptr), size_1)) {
			pr_err("%s Fail 2 copy to user Read_Data_Ptr:%p, pucVirtBufAddr:%p,",
				__func__, Read_Data_Ptr, Awb_Block->pucVirtBufAddr);
			pr_err(" u4DMAReadIdx:0x%x, DMA_Read_Ptr:%zu, read_size:%zu\n",
				Awb_Block->u4DMAReadIdx, DMA_Read_Ptr, read_size);
			return 0;
		}

		read_count += size_1;
		spin_lock(&auddrv_Dl1AWBInCtl_lock);
		Awb_Block->u4DataRemained -= size_1;
		Awb_Block->u4DMAReadIdx += size_1;
		Awb_Block->u4DMAReadIdx %= Awb_Block->u4BufferSize;
		DMA_Read_Ptr = Awb_Block->u4DMAReadIdx;
		spin_unlock(&auddrv_Dl1AWBInCtl_lock);

		PRINTK_AUD_AWB
			("%s finish2, copy size_1:%x, u4DMAReadIdx:%x, u4WriteIdx:%x, u4DataRemained:%x\n",
			__func__, size_1, Awb_Block->u4DMAReadIdx, Awb_Block->u4WriteIdx,
			Awb_Block->u4DataRemained);

		if (DMA_Read_Ptr != Awb_Block->u4DMAReadIdx) {
			PRINTK_AUD_AWB
				("%s 3, read_size2:%x, DataRemained:%x, DMA_Read_Ptr:%zu, DMAReadIdx:%x\n",
				__func__, size_2, Awb_Block->u4DataRemained, DMA_Read_Ptr,
				Awb_Block->u4DMAReadIdx);
		}
		if (copy_to_user((void __user *)(Read_Data_Ptr + size_1),
			(Awb_Block->pucVirtBufAddr + DMA_Read_Ptr), size_2)) {
			pr_err("%s Fail 3 copy to user Read_Data_Ptr:%p, pucVirtBufAddr:%p,",
				__func__, Read_Data_Ptr, Awb_Block->pucVirtBufAddr);
			pr_err(" u4DMAReadIdx:0x%x, DMA_Read_Ptr:%zu, read_size:%zu\n",
				Awb_Block->u4DMAReadIdx, DMA_Read_Ptr, read_size);
			return read_count << 2;
		}

		read_count += size_2;
		spin_lock(&auddrv_Dl1AWBInCtl_lock);
		Awb_Block->u4DataRemained -= size_2;
		Awb_Block->u4DMAReadIdx += size_2;
		DMA_Read_Ptr = Awb_Block->u4DMAReadIdx;
		spin_unlock(&auddrv_Dl1AWBInCtl_lock);

		count -= read_size;
		Read_Data_Ptr += read_size;

		PRINTK_AUD_AWB
			("%s finish3, copy size_2:%x, u4DMAReadIdx:%x, u4WriteIdx:%x, u4DataRemained:%x\n",
			__func__, size_2, Awb_Block->u4DMAReadIdx, Awb_Block->u4WriteIdx,
			Awb_Block->u4DataRemained);
	}

	return read_count >> 2;
}

static int mtk_capture_pcm_silence(struct snd_pcm_substream *substream,
				   int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
{
	pr_debug("dummy_pcm_silence\n");
	return 0;		/* do nothing */
}


static void *dummy_page[2];

static struct page *mtk_i2s0_capture_pcm_page(struct snd_pcm_substream *substream,
					      unsigned long offset)
{
	pr_debug("dummy_pcm_page\n");
	return virt_to_page(dummy_page[substream->stream]);	/* the same page */
}


static struct snd_pcm_ops mtk_i2s0_awb_ops = {

	.open = mtk_i2s0_awb_pcm_open,
	.close = mtk_i2s0_awb_pcm_close,
	.ioctl = snd_pcm_lib_ioctl,
	.hw_params = mtk_i2s0_awb_pcm_hw_params,
	.hw_free = mtk_i2s0_capture_pcm_hw_free,
	.prepare = mtk_i2s0_awb_pcm_prepare,
	.trigger = mtk_i2s0_awb_pcm_trigger,
	.pointer = mtk_i2s0_awb_pcm_pointer,
	.copy = mtk_i2s0_awb_pcm_copy,
	.silence = mtk_capture_pcm_silence,
	.page = mtk_i2s0_capture_pcm_page,
};

static struct snd_soc_platform_driver mtk_soc_platform = {

	.ops = &mtk_i2s0_awb_ops,
	.pcm_new = mtk_asoc_i2s0_awb_pcm_new,
	.probe = mtk_i2s0_dl1_awb_probe,
};

static int mtk_i2s0_awb_probe(struct platform_device *pdev)
{
	pr_debug("mtk_i2s0_awb_probe\n");

	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);

	if (!pdev->dev.dma_mask)
		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;

	if (pdev->dev.of_node)
		dev_set_name(&pdev->dev, "%s", MT_SOC_I2S0_AWB_PCM);

	pr_debug("%s: dev name %s\n", __func__, dev_name(&pdev->dev));
	return snd_soc_register_platform(&pdev->dev, &mtk_soc_platform);
}

static int mtk_asoc_i2s0_awb_pcm_new(struct snd_soc_pcm_runtime *rtd)
{
	pr_debug("mtk_asoc_i2s0_awb_pcm_new\n");
	return 0;
}

static int mtk_i2s0_dl1_awb_probe(struct snd_soc_platform *platform)
{
	pr_debug("mtk_i2s0_dl1_awb_probe\n");
	afe_allocate_mem_buffer(platform->dev, Soc_Aud_Digital_Block_MEM_AWB,
				   AWB_MAX_BUFFER_SIZE);
	Awb_Capture_dma_buf = afe_get_mem_buffer(Soc_Aud_Digital_Block_MEM_AWB);
	return 0;
}

static int mtk_dl1_awb_remove(struct platform_device *pdev)
{
	pr_debug("%s\n", __func__);
	snd_soc_unregister_platform(&pdev->dev);
	return 0;
}

#ifdef CONFIG_OF
static const struct of_device_id mt_soc_pcm_i2s0_awb_of_ids[] = {

	{.compatible = "mediatek," MT_SOC_I2S0_AWB_PCM,},
	{}
};
MODULE_DEVICE_TABLE(of, mt_soc_pcm_i2s0_awb_of_ids);

#endif

static struct platform_driver mtk_i2s0_awb_capture_driver = {

	.driver = {
		   .name = MT_SOC_I2S0_AWB_PCM,
		   .owner = THIS_MODULE,
#ifdef CONFIG_OF
		   .of_match_table = mt_soc_pcm_i2s0_awb_of_ids,
#endif
		   },
	.probe = mtk_i2s0_awb_probe,
	.remove = mtk_dl1_awb_remove,
};

#ifndef CONFIG_OF
static struct platform_device *soc_i2s0_awb_capture_dev;
#endif
#ifdef CONFIG_OF
module_platform_driver(mtk_i2s0_awb_capture_driver);
#else
static int __init mtk_soc_i2s0_awb_platform_init(void)
{
	int ret = 0;

	pr_debug("%s\n", __func__);
#ifndef CONFIG_OF
	soc_i2s0_awb_capture_dev = platform_device_alloc(MT_SOC_I2S0_AWB_PCM, -1);

	if (!soc_i2s0_awb_capture_dev)
		return -ENOMEM;

	ret = platform_device_add(soc_i2s0_awb_capture_dev);
	if (ret != 0) {
		platform_device_put(soc_i2s0_awb_capture_dev);
		return ret;
	}
#endif
	ret = platform_driver_register(&mtk_i2s0_awb_capture_driver);
	return ret;
}

static void __exit mtk_soc_i2s0_awb_platform_exit(void)
{
	pr_debug("%s\n", __func__);
	platform_driver_unregister(&mtk_i2s0_awb_capture_driver);
}
module_init(mtk_soc_i2s0_awb_platform_init);
module_exit(mtk_soc_i2s0_awb_platform_exit);
#endif
MODULE_DESCRIPTION("I2S0 AWB module platform driver");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * NFSv3 protocol definitions
 */
#ifndef _LINUX_NFS3_H
#define _LINUX_NFS3_H

#define NFS3_PORT		2049
#define NFS3_MAXDATA		32768
#define NFS3_MAXPATHLEN		PATH_MAX
#define NFS3_MAXNAMLEN		NAME_MAX
#define NFS3_MAXGROUPS		16
#define NFS3_FHSIZE		64
#define NFS3_COOKIESIZE		4
#define NFS3_CREATEVERFSIZE	8
#define NFS3_COOKIEVERFSIZE	8
#define NFS3_WRITEVERFSIZE	8
#define NFS3_FIFO_DEV		(-1)
#define NFS3MODE_FMT		0170000
#define NFS3MODE_DIR		0040000
#define NFS3MODE_CHR		0020000
#define NFS3MODE_BLK		0060000
#define NFS3MODE_REG		0100000
#define NFS3MODE_LNK		0120000
#define NFS3MODE_SOCK		0140000
#define NFS3MODE_FIFO		0010000

/* Flags for access() call */
#define NFS3_ACCESS_READ	0x0001
#define NFS3_ACCESS_LOOKUP	0x0002
#define NFS3_ACCESS_MODIFY	0x0004
#define NFS3_ACCESS_EXTEND	0x0008
#define NFS3_ACCESS_DELETE	0x0010
#define NFS3_ACCESS_EXECUTE	0x0020
#define NFS3_ACCESS_FULL	0x003f

/* Flags for create mode */
enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2
};

/* NFSv3 file system properties */
#define NFS3_FSF_LINK		0x0001
#define NFS3_FSF_SYMLINK	0x0002
#define NFS3_FSF_HOMOGENEOUS	0x0008
#define NFS3_FSF_CANSETTIME	0x0010
/* Some shorthands. See fs/nfsd/nfs3proc.c */
#define NFS3_FSF_DEFAULT	0x001B
#define NFS3_FSF_BILLYBOY	0x0018
#define NFS3_FSF_READONLY	0x0008

enum nfs3_ftype {
	NF3NON  = 0,
	NF3REG  = 1,
	NF3DIR  = 2,
	NF3BLK  = 3,
	NF3CHR  = 4,
	NF3LNK  = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,	/* changed from NFSv2 (was 8) */
	NF3BAD  = 8
};

struct nfs3_fh {
	unsigned short size;
	unsigned char  data[NFS3_FHSIZE];
};

#define NFS3_VERSION		3
#define NFS3PROC_NULL		0
#define NFS3PROC_GETATTR	1
#define NFS3PROC_SETATTR	2
#define NFS3PROC_LOOKUP		3
#define NFS3PROC_ACCESS		4
#define NFS3PROC_READLINK	5
#define NFS3PROC_READ		6
#define NFS3PROC_WRITE		7
#define NFS3PROC_CREATE		8
#define NFS3PROC_MKDIR		9
#define NFS3PROC_SYMLINK	10
#define NFS3PROC_MKNOD		11
#define NFS3PROC_REMOVE		12
#define NFS3PROC_RMDIR		13
#define NFS3PROC_RENAME		14
#define NFS3PROC_LINK		15
#define NFS3PROC_READDIR	16
#define NFS3PROC_READDIRPLUS	17
#define NFS3PROC_FSSTAT		18
#define NFS3PROC_FSINFO		19
#define NFS3PROC_PATHCONF	20
#define NFS3PROC_COMMIT		21

#define NFS_MNT3_VERSION	3
 

#endif /* _LINUX_NFS3_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0   P-    pZ     x     x  x      z     z      z  M   3z  E   z  &   z  (   z     {     ({     @{     R{     a{     u{     {     {     {  1   {     
|     |     |  "   |  #   |      }  $   9}     ^}     t}     }     }     }     }     }     ~     $~     @~     Z~     w~     ~     ~     ~     ~     ~     ~     ~  3   ~  3   1  4   e  )     .     %     -        G  %              =     Q     k            +          C   
  (   N     w  -          2     -     0   /  3   `  ,     )               !   "     D     [     u  )          &     &     &   #  &   J  &   q       <          (   
  )   3  >   ]  H     =        #  Z   9  H     -     /     =   ;  J   y  <     $     (   &  B   O  I     *     )     )   1      [  *   |  #          )     &     3   7  "   k                       ?     A   <  @   ~            0     )   '  :   Q  #          6     6         :  *   [       5     0     ,     2   9     l       !     *     3     1   -     _  /   x  2     %     4     '   6  7   ^       '     ,          .   (  '   W  '     &     '     (     )     .   I  4   x  3     5             6  3   U            9     H     B   C       5     3     #     !   %     G  .   f  E     D     !      +   B     n  "     7          .     3   '  4   [  #          +     0          1     R     r      3     1     4   3  o   h  5     2     4   A  ,   v  9                       /     O     o  '     ,               "     4   1     f  (   x  =                        #     D     c  1   t  >     6     ,        I  2   d  =     "     @     1   9  5   k  *     ?             '  7   A     y       8     <     #   /  
   S  <   ^             )     (         /  
   P     [     ]     e  !   v  $     *     
          )   
  (   4     ]     z            ,               #     /   !     Q     c     x                                                  (  	   4     >     D     I     N     U     m  &   {  -          !             !  $   ?     d     r       #                            	        &   @  %   g       0               !          -   5     c  #     '     %     (     %     )   A     k  '   z  %     &     (     *        C     _     y            7     >              ;  V   R  U                  8  +   Q     }            	     =                   2            7   (  3   `  2     *               $     
   =  %   H     n       !                                 *     B     ]  2   q            3     /      -   0  B   ^  2                            )  +   E     q       %     (     +     1   !  *   S  4   ~  +                                  :  $   X  &   }            <          B   7  <   z  $     )     0        7     E  1   W       8               4          .   8     g  )                         !        >  "   ]                                     .        J     b     {                 0     4     +   N  "   z                      +        !     ?  N          $   6     [  )   p                                      $   =     b  0   i  "     "     %     %        ,     J     W  	   p     z  >               /        %     =  !   Q     s                 !          .             0     =     J     d  "   |                                	        "     :  +   R     ~                                   +     C     ]      n  #                    1     %   6  $   \                                        "     1  
   F     Q     f     v            2                       	          -     F     b     x       0          !          %   +  %   Q     w  ^     s     #   j       *                            %     D     W     k            -     +     .        5  K   :       9                    ,     
   A     L     S     `     {                                #   *     N     ^     u       #                    *        @     S  #   e       6                                 ?     ^     t                                        *     :     P  *   o                      	          !     	   .     8     F     `      x                                        6  K   T  (     .                  )  %   A     g                                          
   3     >     C     G     P  &   f            .                    !     #   =     a  0   m  &                                 ,     =     P     c     v                                   %  R   D                                        '     A     S     e                      !             )     D     `     y       "                                 ,     B  -   Q  -     .     !                  (  ,   C     p       !     !               /        J  #   f                                         #     ?     W     q                                                   4     O      h  &     
              F     4   ,  A   a  I     -             1     K     e     |             $             	          '     <     R     j     r                                        %     -  F   C  *     (                    "     g         h     n  	   u  4          $     
              m               #          !                  '     E  "   X     {         $     :     S     f  '   v  #     9     '     6   $     [  
   i     t     |  "     "          "             6     P     n  
                                                %     :     I     [     n                                           6          m       Z    q       ?    6   M                                 %        4  >   J  "          !           "         !     B     \     y                           F        F  	   O     Y     `  +     *     !     $     .     6   L  -     1     /             +     E  +   U  +     &          	             	  &     ,   C     p       C     $          1   '     Y  &   v       )     *            . "   J '   m :        .    2        O (   p ,    5    5    C   2    v -    %         !    )   * #   T    x (    !    0    4       G    `     &        !          !   !    C "   ^ 8    .        !       & %   F    l    x A    (    ;       ; N   Z             +       (	    B	    [	     z	    	    	    	    	    	    
    
 '   5
    ]
    t
    
 '   
    
    
 .       <    [    r     &        (    $       >    Z    p                            #    7    S    m     '        )           0    P    o !            $            2   ( 6   [ +    7    ;    $   2 "   W \   z !    4    $   .    S    p 0    ,                %   2 -   X      $    7    #    3   ( &   \ *    )    .    ,       4 $   S    x     ]    )       0 5   E 8   { 3        #       )    7 &   P    w     :        '       $ "   4 %   W *   } *                .       N    m +    $        *    "   '    J $   h $        !    #    !       3 (   N &   w $    %    !    7    ,   C    p 0        -    (    !   - "   O 6   r             3           : .   G    v     +        /    <       P 9   f             ;    ,   . %   [ -        (    &    &        B     Y  @   l  <     7     &   "!    I!    e!    !    ! #   !    ! 1   !    "    '"    9" "   U"    x"    "    "    "    "    "    "    #    #    ,#    C# !   V#    x# )   #    #    #    #    #    $ %   "$    H$    _$    s$    $ "   $    $    $ #   $ #    % #   D% H   h%    %    % #   %    %    &     && 6   G& 0   ~&    & ?   &    & +   ' (   ?' -   h'    ' '   ' )   ' #   '    (    4( #   P( (   t( *   ( "   ( >   (    *) "   I)    l)    )    ) <   ) #   )     * 9   5* ;   o* +   * *   * #   +    &+    @+ %   C+ &   i+    + E   +     + *   , 7   =, F   u, 2   , 4   ,    $- '   ;-    c- B   ~- E   -    . .   .    G. V   Z. "   . $   . #   . %   / C   C/ 	   / *   /    /    /    /    /    / (   0    D0 >   [0 -   0    0    0 1   0    *1    E1    a1 :   1    1    1    1    
2 #   (2    L2 $   l2 +   2    2 -   2 !   3 9   *3    d3 &   3    3    3 "   3 6   3 =   .4 -   l4 ,   4    4    4 N   4     N5 '   o5    5 "   5    5 (   5 $   6    06    F6 *   T6    6 C   6 &   6 3   6     -7 S   N7    7    7    7 (   7 '   8 ,   58 )   b8 "   8 &   8 2   8    	9 #   &9    J9 $   V9    {9    9 /   9    9 !   9    : -   !: 4   O:    :    :    :    : 2   : 2    ; .   3; <   b; ?   ; #   ;    < $   <    ;<    V<    l<    < .   <    <    <    =    '= #   9=    ]= 	   v=    =    =    = $   =    =    =    >    >    0>    D>    P>    k>    >    >    > 0   >    >    ?    ,? #   L? =   p? <   ?    ?    ? 	   @ 1   @    P@    o@    @ "   @ ,   @ I   @ I   ?A L   A    A    A    B    !B    =B #   WB #   {B #   B 0   B #   B #   C    <C *   @C %   kC   C     E    7E S   LE P   E :   E >   ,F    kF    |F    F    F    F    F    F    G %   G D   EG    G    G    _H $   qH %   H    H &   H     I    I    2I    PI    gI    I #   I    I #   I    J     !J    BJ    VJ 
   qJ    |J 
   J 	   J    J <   J 9   J 9   "K K   \K 7   K 4   K )   L 9   ?L    yL '   EM 7   mM     M )   M )   M F   N ;   aN C   N ,   N ]   O (   lO #   O 0   O    O 5   O O   5P M   P 8   P D   Q B   QQ 6   Q .   Q 2   Q (   -R .   VR 1   R ;   R    R 5   S 5   IS 5   S 5   S 5   S    !T N   >T .   T 5   T >   T F   1U q   xU H   U %   3V    YV ]   V C   <W Q   W K   W H   X O   gX 3   X ,   X \   Y _   uY 5   Y 1   Z 2   =Z +   pZ 6   Z 5   Z "   	[ 9   ,[ 0   f[ @   [ 0   [ 1   	\ /   ;\ /   k\    \ g   \ k   !] k   ]    ] (   ^ C   =^ F   ^ Y   ^ 1   "_     T_ `   u_ `   _ /   7` >   g` +   ` K   ` V   a D   ua M   a "   b ,   +b .   Xb 7   b D   b D   c     Ic 9   jc H   c 4   c :   "d ;   ]d A   d .   d =   
e 9   He /   e D   e /   e .   'f .   Vf 3   f 4   f 5   f B   $g O   gg O   g R   h )   Zh )   h b   h ,   i )   >i U   hi V   i X   j    nj F   j @   j 5   k /   >k &   nk F   k M   k U   *l -   l J   l    l -   m 6   Fm "   }m 7   m M   m J   &n =   qn '   n @   n 5   o (   No '   wo    o   rp >   r ?   r ?   s r   Hs ;   s 7   s 7   /t '   gt ?   t 4   t !   u !   &u 3   Hu 1   |u    u J   u N   v 9   fv    v 6   v =   v    $w A   Cw m   w    w    x 3   x 1   Mx    x    x C   x J   x ;   ;y ,   wy 3   y D   y Z   z 0   xz Q   z I   z =   E{ 4   { 5   { "   { %   | =   7| .   u| %   | W   | N   "} (   q}    } X   } 2    ~ -   3~ G   a~ 7   ~ '   ~    	     	        #   / 3   S D        $    @    -   P -   ~         #    ;       +    C 7   _ G                    #   ' '   K    s                             '    5    >    G    P    Y    u >    B    /    3   5 $   i $    4    "    0    0   < =   m ,         !    "    '   > .   f B    ;    /    B   D !    +    >    '    <   < 4   y 5    9    7    :   V 8    >        	 P   * E   { J    O    H   \ !                     ' W   E ^    .       + b   C X            #   3 8   W             	    Y    #   ;    _    v (   w     C    C    1   F D   x          @       8 ;   F         6    )           .    L    g             H    #   !     E <   f 2    M    O   $ P   t      7    $       C 3   ^ @    .    *    >   - A   l 9    >    8   ' U   ` M    
            )   . 6   X %    5    *    #        : K   [ +    Y    P   - .   ~ B    C       4    I H   \     \        "    L   7 .    S         *   ( =   S     *    4    ?    ;   Q 8    :        )    !   B !   d !        K           . $   F "   k         C    G    9   V 4    &        %    #    :   > &   y     c   B     ;        :    %   Q *   w $                '    &   , 	   S J   ] <    ?    ?   % <   e !                     U   "    x     ;             .       H    b    |     (    #    *           *    2 1   A    s                                 *    7    U 8   m             $    *    &   @    g (            $    <    ,   ? ,   l '    D    -        4    U    m     #            &           2 
   O    Z    w &    	        T       " "   5    X    k    { !    '             #     U   D -        7    :    :   W 8           S =       2 I   @         *        '       *    A     Y    z     B    @    8   2    k U   t     U    0   1    b )   u X                   ( 8   H :    /        *    >   ,    k 5        )    %    3   ( 0   \ '        (    D       9 !   W *   y !    O    &       =    O +   c ;        3    %    !   C !   e     %    0        .       D $   b (    1            )       -    J +   \ +                    !   # !   E    g    z         -    '         Z   9 4    D           *    J #   h                            -    <    K    b             )    F            G   - +   u         .    +        O   , '   | $            *     *   +    V    g    x     )         '       $     2    S    k $    v    $   % 	   J    T    f -   o     !    $    #       % #   =    a ,   t ,    '    #        "   4 (   W "    "        6           &    9    V    s         A    A    P   A /                L    ;   i >    A    >   &    e #   } G    A    E   + *   q     +            #       1 "   O    r &        -    *       !    '    8    D    b C   |     -    )       0 :   K F           ?    .   ? 8   n <    '         $   -     R !   s     *    6    )       ?    N    \ +   t $        	                6   *    a    | #            !    _    B   a :                  	 z   (     
        O        )   9 	   c    m U   q       N    _ +   p     (            .       C 3   a            =            7   6 7   n P    :    M   2             ,    ,    #       ) .   E ,   t "    +             (   - (   V                                  =    V    u                           ,    M 
   h   s :   v T             +       F    ,    ,   F '   s             2        ;   & >   b     7    4    4    0   T "    !                    7   , )   d m                5   # <   Y 9    5    8    :   ? I   z I    E    :   T &    (        6    6   ( *   _         !        C    7   4 5   l /    `    <   3 "   p B    .    B    1   H E   z ?    .     .   / 5   ^ 5    O    .     <   I  @     +     <     I   0 ^   z ^    n   8 1    Z    @   4 /   u /    H    9    7   X 8    1    J    ]   F +    /    (     >   ) (   h /    ,    7    +   & 7   R Z    ?    .   % 8   T .    >        (   	 n   =	 8   	 ]   	 4   C
 q   x
 4   
 3    +   S X    1    1   
 8   < :   u 9    6       !    6    V !   v 6    >    %    *   4 0   _ 8    %    1    G   ! 2   i "    -    ,    E    .   ` :    1    (    +   % !   Q ,   s '    %    .    .    7   L "    +    5    2   	 8   < F   u ;    J    7   C =   { >    :    3   3 "   g "    8            S   
 W   ^ 9    c    g   T 2    /    w    3    6    #    :   & 7   a +    0    	         %    .   < 9   k *    1    N    .   Q I    ;    >    .   E <   t <    &    :    2   P         :   G !    G    L    F   9 &    5        *    4        K     i  Y          ,        ! 4   +! 1   `! 8   ! 6   !    "    " (   (" 5   Q" *   " ,   " ?   " I   # (   i# 6   # +   # /   # +   %$ 4   Q$ !   $ <   $ ;   $ =   !% 1   _% :   % 9   % <   & &   C& 1   j& 6   & 6   &     
' D   +' ,   p' 7   ' :   ' ;   ( <   L( X   ( -   ( $   )    5) E   S) *   )    ) 9   ) +   *    7* >   R*    * 0   * 9   *    + E   .+    t+    + $   + @   + L   
, *   W, 2   , $   , >   , 2   - 2   L- 3   -     - S   - P   (. <   y. =   .    . "   /    2/    J/ (   X/ "   / G   /    /    0    0 .   60    e0    0 )   0    0 &   0    
1    1    /1    C1     c1    1 $   1    1 4   1    2 "   42    W2    o2    2 ?   2    2    3    *3    E3 )   V3 .   3    3 ?   3 ?   4 ?   M4 u   4    5    5 .   ,5 +   [5 "   5 4   5 >   5 <   6    [6 V   h6 !   6 D   6 5   &7 <   \7    7 H   7 9   7 +   38    _8 4   }8 6   8 9   8 9   #9 8   ]9 U   9 )   9 @   : #   W: "   {:    : V   : '   	;     1; X   R; ^   ; 6   
< 9   A< 1   {< $   < 	   < >   < 4   = &   P= R   w= ?   = O   
> F   Z> R   > D   > D   9?     ~? 1   ? !   ? Y   ? \   M@    @ ,   @ &   @ W   A 4   nA E   A 0   A 5   B E   PB    B 7   B    B    B    B >   C    GC .   bC    C l   C C   D    YD $   mD =   D    D !   D 7   
E b   BE    E #   E    E .   F %   4F *   ZF &   F M   F +   F B   &G .   iG T   G    G I   H    VH )   mH :   H F   H L   I 8   fI <   I    I    I h   J 2   J 8   J    J 3   J 0   3K )   dK (   K '   K    K 0   K    $L Z   2L 1   L O   L D   M j   TM #   M    M    M /   N $   FN )   kN 0   N %   N &   N E   O .   YO 4   O    O 8   O +   P    .P E   CP    P %   P    P /   P 3   Q #   @Q    dQ    |Q !   Q 0   Q +   Q 1   R H   LR D   R 4   R    S 4   -S .   bS    S .   S $   S ,   T 8   0T 5   iT #   T #   T 5   T !   U    ?U    SU    qU    U ,   U     U    U    V    V    :V    VV !   jV    V    V !   V !   V 3   W    @W    ^W *   }W /   W B   W J   X    fX    tX    X 6   X $   X (   X    Y 1   5Y 0   gY M   Y M   Y W   4Z     Z 2   Z ,   Z ,   [ #   :[ /   ^[ &   [ /   [ <   [ /   "\ +   R\    ~\ C   \ 4   \                                   <                        @  x    T            V         t      (      k                                      !              d  j                      /          q     U  p  =      ?      R        k         6    C             	  i  o   N            @      
                 >     z        :             4             w  O        -       u  <                       |         H           X         V           u    C    a  h                         7        &  P              O  .      u  a     b                 S  ~                           ^     /    '      '                    %                     G               8  v      '  `  R          y     ^  n        r      J           	  3    v       )  
  E        m      V  l  4          F   c    C                      0          .  +          *                                                                    S                   ]      I  5                                     B                  T                         l        C  W    *                        :  j                  /  ]          1    $      D              j                 g  V              3           }         }  8  8          %  J          i                 g    Y                a            x  5    O      B          !        q                    $                  K  Z      4                 w           U     t  #         r         m   #                        <                                       6  d                  i               d    J  =                 9         k      W                      W         O  4    E     g                                )   B               J  n        #                                                )                     U  "  K            y         l                        g     P     X  !  ,                    |           n       o                 m    S                R           }  "       0    $  s           &            G   q                    !     [             6  }   7  9  [          K            v        2        P        {                   Q  l                A                        k                  ,            I  B        :         s      Z  [            z                   D     h    =  b                          z         %    O                           1        7              J  g             +          X            h  ~     f            A        @  y  _                      I  "    P  ;  6  e  u  G           D    f     4        o              F       <              ]        '   5      (    m                ?  Y  z     p        |       2         &   ?         >  W        w  s              Z   B  ;          F             A      ,    F        s  ,   )     X                  L             M  T    >    r  ?  '            }  -  @        W          c  S    r                     _  2         )  G                             A         !          ;     T        v  j    ,  {                 (         M  ^     c                    a                5          G      I  d                    6   x          a                \    I     X    s  F        3                                                       |    3    2    p                R                                     y        M      x      2    p  k                -  .   c  ^                      %  \     J   j  +                  
         ;          #         n  /  %  8    E             `                       >                                c  3  1        p  e           V                     	           '  0   K               o  ~        *          l                :        _  N                  )     [                        q    A   t      o                   >  x    S  &  Y        0  n          
  #              Y       N          r           N  q          d    {  .            v             b    	  Z  {    1       G  ~    L  [      `    6              O        j          &  !  z                      0       M             _                  $       b   9  U    ^           H  h                *  B  H  N                         D              L                           "                <        @  @            {  `      y            2      #     L   *         /     .  E  .  y                    m           e        H      u      `  i  H         -             5  \              ]         ,  8  ~              (                      i    Q                +        f                  U  f                  	                               h  f  n           $    P                   %  "      M  D  Z  R        Q                           0        U                    7            T  =     5   9        K        u                 >                7   :           N     R                             C  <  F                               s  +      
  ^       x   =  1  H      e          A                           (  t    k              ?          ;          e  \  7  {      _  Y                                         X      Z      }    P              [                      \        -  |       I                      Y               o  	  b  ]    -      4        f       E    (   Q         9  d         b                  t                +                   ;                  ~  $           l     _     a    S      C                     e  w                             w  3                          Q  i                               
    `   ?     g          1  L       |        D      q  T    m      *            r  p                M          V                                                =           h  K    ]               L    :        E                Q           w                     v    &      t     9      z  W    8  /         c   \  "     \    ]    
] x  x  <y  Py  dy  xy  y  y  y  y  ] $          7]      $      $      &                          =   _          _           ` )         +` &          R` A     8      8      8            $      *      H   wc          c          c            		Access Rights :  		Attributes    :  	%s [-abkCLNTM][-Dname[=value]] [-i size] [-I [-K seconds]] [-Y path] infile
 	%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o outfile] [infile]
 	%s [-n netid]* [-o outfile] [infile]
 	%s [-s nettype]* [-o outfile] [infile]
 	Access rights:  	Entry data of type %s
 	Name       : %s
 	Public Key :  	Type         : %s
 	Universal addresses (%u)
 	[%d]	Name          : %s
 	[%u] - [%u bytes]  	not a dynamic executable 
For bug reporting instructions, please see:
%s.
 
Group Members :
 
SELinux AVC Statistics:

%15u  entry lookups
%15u  entry hits
%15u  entry misses
%15u  entry discards
%15u  CAV lookups
%15u  CAV hits
%15u  CAV probes
%15u  CAV misses
 
Time to Live  :              %2lus  server runtime
         %2um %2lus  server runtime
        %s -a [pathname]
     %2uh %2um %2lus  server runtime
     Data Length = %u
     Explicit members:
     Explicit nonmembers:
     Implicit members:
     Implicit nonmembers:
     No explicit members
     No explicit nonmembers
     No implicit members
     No implicit nonmembers
     No recursive members
     No recursive nonmembers
     Recursive members:
     Recursive nonmembers:
   or:   (SKIPPED)
  (changed)
  (first)  [OPTION...] "%s" is no directory; ignored "Zone %s" line and -l option are mutually exclusive "Zone %s" line and -p option are mutually exclusive "infile" is required for template generation flags.
 %%z UTC offset magnitude exceeds 99:59:59 %.*s: ARGP_HELP_FMT parameter requires a value %.*s: Unknown ARGP_HELP_FMT parameter %1$s: definition does not end with `END %1$s' %15d  current number of threads
%15d  maximum number of threads
%15lu  number of times clients had to wait
%15s  paranoia mode enabled
%15lu  restart internal
%15u  reload count
 %3ud %2uh %2um %2lus  server runtime
 %d libs found in cache `%s'
 %s in ruleless zone %s is a 32 bit ELF file.
 %s is a 64 bit ELF file.
 %s is for unknown machine %d.
 %s is not a known library type %s is not a shared object file (Type: %d).
 %s is not a symbolic link
 %s is not an ELF file - it has the wrong magic bytes at the start.
 %s%s%s:%u: %s%sAssertion `%s' failed.
%n %s%sUnknown signal %d
 %s: %s; low version = %lu, high version = %lu %s: %s; why = %s
 %s: %s; why = (unknown authentication error - %d)
 %s: '%s' without matching 'ifdef' or 'ifndef' %s: 'endif' without matching 'ifdef' or 'ifndef' %s: <mb_cur_max> must be greater than <mb_cur_min>
 %s: C preprocessor failed with exit code %d
 %s: C preprocessor failed with signal %d
 %s: Can't chdir to %s: %s
 %s: Can't create %s/%s: %s
 %s: Can't create directory %s: %s %s: Can't open %s: %s
 %s: Can't read %s/%s: %s
 %s: Can't remove %s/%s: %s
 %s: Leap line in non leap seconds file %s %s: Memory exhausted: %s
 %s: More than one -L option specified
 %s: More than one -d option specified
 %s: More than one -l option specified
 %s: More than one -p option specified
 %s: More than one -y option specified
 %s: Too many arguments
 %s: `%s' mentioned more than once in definition of weight %d %s: `%s' must be a character %s: `%s' value does not match `%s' value %s: `-1' must be last entry in `%s' field %s: `forward' and `backward' are mutually excluding each other %s: `position' must be used for a specific level in all sections or none %s: `translit_start' section does not end with `translit_end' %s: bad symbol <%.*s> %s: byte sequence of first character of range is not lower than that of the last character %s: byte sequences of first and last character must have the same length %s: cannot have `%s' as end of ellipsis range %s: cannot reorder after %.*s: symbol not known %s: character `%s' in charmap not representable with one byte %s: character `%s' needed as default value not representable with one byte %s: character `%s' not defined while needed as default value %s: command was '%s', result was %d
 %s: destination must not be a directory
 %s: direction flag in string %Zd in `era' field is not '+' nor '-' %s: direction flag in string %Zd in `era' field is not a single character %s: duplicate `default_missing' definition %s: duplicate category version definition %s: duplicate declaration of section `%s' %s: duplicate definition of `%s' %s: empty category description not allowed %s: empty weight string not allowed %s: error in state machine %s: failed to remove the old destination
 %s: field `%s' declared more than once %s: field `%s' does not contain exactly ten entries %s: field `%s' must not be defined %s: field `%s' must not be empty %s: field `%s' not defined %s: field `%s' undefined %s: file open error: %m
 %s: garbage at end of offset value in string %Zd in `era' field %s: garbage at end of starting date in string %Zd in `era' field  %s: garbage at end of stopping date in string %Zd in `era' field %s: incomplete `END' line %s: invalid destination: %s
 %s: invalid escape `%%%c' sequence in field `%s' %s: invalid escape sequence in field `%s' %s: invalid number for offset in string %Zd in `era' field %s: invalid number of sorting rules %s: invalid option -- '%c'
 %s: invalid starting date in string %Zd in `era' field %s: invalid stopping date in string %Zd in `era' field %s: invalid value for field `%s' %s: language abbreviation `%s' not defined %s: line %d: bad command `%s'
 %s: line %d: cannot specify more than %d trim domains %s: line %d: expected `on' or `off', found `%s'
 %s: line %d: ignoring trailing garbage `%s'
 %s: line %d: list delimiter not followed by domain %s: link from %s/%s failed: %s
 %s: missing `order_end' keyword %s: missing `reorder-end' keyword %s: missing `reorder-sections-end' keyword %s: missing era format in string %Zd in `era' field %s: missing era name in string %Zd in `era' field %s: more than one 'else' %s: multiple order definitions for section `%s' %s: multiple order definitions for unnamed section %s: nested conditionals not supported %s: no correct regular expression for field `%s': %s %s: no identification for category `%s' %s: no representable `default_missing' definition found %s: not enough sorting rules %s: numeric country code `%d' not valid %s: option '%s%s' doesn't allow an argument
 %s: option '%s%s' is ambiguous
 %s: option '%s%s' is ambiguous; possibilities: %s: option '%s%s' requires an argument
 %s: option '%s' requires an argument.\n %s: option '%s' requires an argument\n %s: option is ambiguous; possibilities: %s: option requires an argument -- '%c'
 %s: option requires an argument -- '%s'\n %s: order for `%.*s' already defined at %s:%Zu %s: order for collating element %.*s not yet defined %s: order for collating symbol %.*s not yet defined %s: out of memory to store relocation results for %s
 %s: output would overwrite %s
 %s: panic: Invalid l_value %d
 %s: pre-%d clients may mishandle distant timestamps %s: premature end of file %s: section `%.*s' not known %s: starting date is invalid in string %Zd in `era' field %s: symbolic range ellipsis must not be directly followed by `order_end' %s: symbolic range ellipsis must not directly follow `order_start' %s: syntax error %s: syntax error in definition of new character class %s: syntax error in definition of new character map %s: table for class "%s": %lu bytes %s: table for map "%s": %lu bytes %s: table for width: %lu bytes %s: terminology language code `%s' not defined %s: the start and the end symbol of a range must stand for characters %s: third operand for value of field `%s' must not be larger than %d %s: too few values for field `%s' %s: too many rules; first entry only had %d %s: too many values %s: too many values for field `%s' %s: transliteration data from locale `%s' not available %s: unable to open %s: %m
 %s: unknown character in collating symbol name %s: unknown character in equivalent definition name %s: unknown character in equivalent definition value %s: unknown character in field `%s' %s: unknown section name `%.*s' %s: unknown standard `%s' for category `%s' %s: unknown symbol `%s' in equivalent definition %s: unrecognized option '%c%s'\n %s: unrecognized option '%s%s'
 %s: usage is %s [ --version ] [ --help ] [ -v ] \
	[ -l localtime ] [ -p posixrules ] [ -d directory ] \
	[ -L leapseconds ] [ filename ... ]

Report bugs to %s.
 %s: usage: %s OPTIONS ZONENAME ...
Options include:
  -c [L,]U   Start at year L (default -500), end before year U (default 2500)
  -t [L,]U   Start at time L, end before time U (in seconds since 1970)
  -i         List transitions briefly (format is experimental)
  -v         List transitions verbosely
  -V         List transitions a bit less verbosely
  --help     Output this help
  --version  Output version info

Report bugs to %s.
 %s: value for field `%s' must be a single character %s: value for field `%s' must be in range %d...%d %s: value for field `%s' must not be an empty string %s: value of field `int_curr_symbol' does not correspond to a valid name in ISO 4217 [--no-warnings=intcurrsym] %s: value of field `int_curr_symbol' has wrong length %s: values for field `%s' must be smaller than 127 %s: values for field `%s' must not be larger than %d %s: warning: zone "%s" abbreviation "%s" %s
 %s: weights must use the same ellipsis symbol as the name %s: while writing output %s: %m %s: wild -c argument %s
 %s: wild -t argument %s
 %s:%u: bad syntax in hwcap line %s:%u: cannot read directory %s %s:%u: duplicate hwcap %lu %s %s:%u: hwcap index %lu above maximum %u %s:%u: hwcap index %lu already defined as %s '%s' is not a known database 'wait' failed
 (PROGRAM ERROR) No version known!? (PROGRAM ERROR) Option should have been recognized!? (Unknown object)
 *** Cannot read debuginfo file name: %m
 *** The file `%s' is stripped: no detailed analysis possible
 *standard input* , OS ABI: %s %d.%d.%d --help		give this help list
 --version	print program version
 -5		SysVr4 compatibility mode
 -C		ANSI C mode
 -Dname[=value]	define a symbol (same as #define)
 -I		generate code for inetd support in server (for SunOS 4.1)
 -K seconds	server exits after K seconds of inactivity
 -L		server errors will be printed to syslog
 -M		generate MT-safe code
 -N		supports multiple arguments and call-by-value
 -Sc		generate sample client code that uses remote procedures
 -Sm 		generate makefile template 
 -Ss		generate sample server code that defines remote procedures
 -T		generate code to support RPC dispatch tables
 -Y path		directory name to find C preprocessor (cpp)
 -a		generate all files, including samples
 -b		backward compatibility mode (generates code for SunOS 4.1)
 -c		generate XDR routines
 -h		generate header file
 -i size		size at which to start generating inline code
 -l		generate client side stubs
 -m		generate server side stubs
 -n netid	generate server code that supports named netid
 -o OUTPUT-FILE [INPUT-FILE]...
[OUTPUT-FILE [INPUT-FILE]...] -o outfile	name of the output file
 -s ignored -s nettype	generate server code that supports named nettype
 -t		generate RPC dispatch table
 .lib section in a.out corrupted <%s> and <%s> are invalid names for range <SP> character must not be in class `%s' <SP> character not in class `%s' <warnings> ? Aborted Access Rights :  Access Vector Cache (AVC) started Accessing a corrupted shared library Add locales named by parameters to archive Adding %s
 Address already in use Address family for hostname not supported Address family not supported by protocol Address not mapped to object Advertise error Alarm clock All requests done Also draw graph for total memory consumption Archive control: Argument list too long Attempt to remove a non-empty table Attempting to link in too many shared libraries Authentication OK Authentication error BOGUS OBJECT
 Bad address Bad file descriptor Bad font file format Bad message Bad system call Bad value for ai_flags Binary data
 Block device required Broadcast poll problem Broken pipe Bus error CACHE CHAR CONF CONFIG CPU time limit exceeded Cache expired Can not access a needed shared library Can't bind to server which serves this domain Can't chdir to / Can't communicate with portmapper Can't communicate with ypbind Can't communicate with ypserv Can't create temporary cache file %s Can't find %s Can't link %s to %s Can't open cache file %s
 Can't open cache file directory %s
 Can't open directory %s Can't stat %s Can't stat %s
 Can't unlink %s Cannot allocate memory Cannot assign requested address Cannot create socket for broadcast rpc Cannot exec a shared library directly Cannot fstat file %s.
 Cannot have more than one file generation flag!
 Cannot lstat %s Cannot mmap file %s.
 Cannot receive reply to broadcast Cannot register service Cannot send after transport endpoint shutdown Cannot send broadcast packet Cannot set LC_ALL to default locale Cannot set LC_COLLATE to default locale Cannot set LC_CTYPE to default locale Cannot set LC_MESSAGES to default locale Cannot set socket option SO_BROADCAST Cannot specify more than one input file!
 Cannot stat %s Cannot use netid flag with inetd flag!
 Cannot use netid flag without TIRPC!
 Cannot use table flags with newstyle!
 Change to and use ROOT as root directory Changing access rights of %s to %#o failed Channel number out of range Character Separator : %c
 Child exited Child has exited Child has stopped Child has terminated abnormally and created a core file Child has terminated abnormally and did not create a core file Client credential too weak Columns             :
 Comma-separated list of warnings to disable; supported warnings are: ascii, intcurrsym Comma-separated list of warnings to enable; supported warnings are: ascii, intcurrsym Communication error on send Compile locale specification Computer bought the farm Configure Dynamic Linker Run Time Bindings. Connection refused Connection reset by peer Connection timed out Continued Convert encoding of given files from one encoding to another. Convert key to lower case Coprocessor error Copyright (C) %s Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 Could not create log file Couldn't execute %s Create C header file NAME containing symbol definitions Create fastloading iconv module configuration file. Create output even if warning messages were issued Create simple database from textual input. Creation Time : %s DATAFILE [OUTFILE] DES entry for netname %s not unique
 DIRECTORY
 DST not allowed in SUID/SGID programs DYNAMIC LINKER BUG!!! Data input available Database for table does not exist Database is busy Default Access rights :
 Destination address required Device disconnected Device not a stream Device or resource busy Diffie-Hellmann (%d bits)
 Directory     : %s
 Directory arguments required when using --nostdlib Directory not empty Disk quota exceeded Do not fork and display messages on the current tty Do not fork, but otherwise behave like a daemon Do not print messages while building database Do not search standard directories, only those on the command line Do not use existing catalog, force new output file Domain not bound Don't add new data to archive Don't buffer output Don't build cache Don't update symbolic links Dump information generated by PC profiling. ELF file ABI version invalid ELF file OS ABI invalid ELF file data encoding not big-endian ELF file data encoding not little-endian ELF file version does not match current one ELF file version ident does not match current one ELF file's phentsize not the expected size ELF load command address/offset not properly aligned ELF load command alignment not page-aligned EMT trap ENTRY
 Encrypted data
 Entry/table type mismatch Enumeration not supported on %s
 Error getting context of nscd Error getting context of socket peer Error getting security class for nscd. Error getting sid from context Error in RPC subsystem Error in accessing NIS+ cold start file.  Is NIS+ installed? Error in unknown error system:  Error querying policy for undefined object classes or permissions. Error translating permission name "%s" to access vector bit. Error while talking to callback proc Error: .netrc file is readable by others. Exactly one parameter with process ID required.
 Exchange full Exec format error FATAL: system does not define `_POSIX2_LOCALEDEF' FILE FILE contains mapping from symbolic names to UCS4 values FORMAT Failed (unspecified error) Failed opening connection to the audit subsystem: %m Failed to create AVC lock Failed to determine if kernel supports SELinux Failed to drop capabilities Failed to initialize drop of capabilities Failed to run nscd as user '%s' Failed to set keep-capabilities Failed to start AVC Failed to start AVC thread Failed to unset keep-capabilities File %s is empty, not checked. File %s is too small, not checked. File descriptor in bad state File exists File is not a cache file.
 File locking deadlock error File name too long File size limit exceeded File too large Filters not supported with LD_TRACE_PRELINKING First/next chain broken Floating point exception Floating-poing inexact result Floating-point divide by zero Floating-point overflow Floating-point underflow For bug reporting instructions, please see:
%s.
 For bug reporting instructions, please see:\\n%s.\\n Format to use: new, old or compat (default) Full resync required for directory Function not implemented GROUP
 Garbage in ARGP_HELP_FMT: %s Generate big-endian output Generate graphic from memory profiling data Generate little-endian output Generate message catalog.If INPUT-FILE is -, input is read from standard input.  If OUTPUT-FILE
is -, output is written to standard output.
 Generate output linear to time (default is linear to number of function calls) Generate verbose messages Generated line not part of iteration Generic system error Get entries from administrative database. Get locale-specific information. Give a short usage message Give this help list Gratuitous error Group         : %s
 Group Flags : Group entry for "%s.%s" group:
 Hang for SECS seconds (default 3600) Hangup Haven't found "%s (%s,%s,%s)" in netgroup cache! Haven't found "%s" in group cache! Haven't found "%s" in hosts cache! Haven't found "%s" in netgroup cache! Haven't found "%s" in services cache! High priority input available Host is down Host name lookup failure I/O error I/O possible INPUT-FILE OUTPUT-FILE
-o OUTPUT-FILE INPUT-FILE
-u INPUT-FILE Identifier removed Ignore auxiliary cache file Ignored file %s since it is not a regular file. Illegal addressing mode Illegal instruction Illegal object type for operation Illegal opcode Illegal operand Illegal seek Illegal trap Inappropriate file type or format Inappropriate ioctl for device Inappropriate operation for background process Information request Information: Input Files: Input file %s not found.
 Input message available Input/Output format specification: Input/output error Integer divide by zero Integer overflow Internal NIS error Internal stack error Internal ypbind error Interrupt Interrupted by a signal Interrupted system call Interrupted system call should be restarted Invalid address alignment Invalid argument Invalid back reference Invalid character class name Invalid client credential Invalid client verifier Invalid collation character Invalid content of \{\} Invalid cross-device link Invalid exchange Invalid floating-point operation Invalid link from "%s" to "%s": %s
 Invalid numeric gid "%s"! Invalid numeric uid "%s"! Invalid object for operation Invalid or incomplete multibyte or wide character Invalid permissions for mapped object Invalid preceding regular expression Invalid range end Invalid regular expression Invalid request code Invalid request descriptor Invalid server verifier Invalid slot Invalidate the specified cache Is a directory Is a named type file Kerberos.
 Key has been revoked Key has expired Key was rejected by service Killed LINK
 LOCAL entry for UID %d in directory %s not unique
 Level 2 halted Level 2 not synchronized Level 3 halted Level 3 reset Link has been severed Link number out of range Link points to illegal name Linked Object Type :  Linked to : %s
 List content of archive List dynamic shared objects loaded into process. Local domain name not set Local resource allocation failure Machine is not on the network Make output graphic VALUE pixels high Make output graphic VALUE pixels wide Malformed name, or illegal name Mandatory arguments to long options are also mandatory for any corresponding\nshort options.\n Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options. Manually link individual libraries. Master Server :
 Master server busy, full dump rescheduled. Memory allocation failure Memory exhausted Memory page has hardware error Message too long Missing or malformed attribute Mod. Time     : %s Modification failed Modify operation failed Modify output format: Multihop attempted Must specify user name for server-user option Must specify user name for stat-user option Must specify value for restart-interval option NAME NAME
[--add-to-archive|--delete-from-archive] FILE...
--list-archive [FILE] NAME
[-a|-m] NIS client/server version mismatch - can't supply service NIS map database is bad NIS+ operation failed NIS+ servers unreachable NIS+ service is unavailable or not installed NO OBJECT
 NUMBER Name : `%s'
 Name Service Cache Daemon. Name not served by this server Name not unique on network Name or service not known Name output file Name/entry isn't unique Named object is not searchable Need authenticator Network dropped connection on reset Network is down Network is unreachable No CSI structure available No XENIX semaphores available No address associated with hostname No address associated with name No anode No buffer space available No character set name specified in charmap No child processes No data available No definition for %s category found No file space on server No link created since soname could not be found for %s No locks available No match No medium found No message of desired type No more records in map database No previous regular expression No program name given No program name given\n No route to host No space left on device No such device No such device or address No such file or directory No such key in map No such map in server's domain No such process No target in line %d
 Non NIS+ namespace encountered Non-recoverable failure in name resolution None.
 Nonexisting physical address Not a XENIX named type file Not a directory Not found Not found, no such name Not master server for this domain Not owner Not supported Number of Columns   : %d
 Number of objects : %u
 Numerical argument out of domain Numerical result out of range Object #%d:
 Object Name   : %s
 Object Type   :  Object is remote Object with same name exists Object-specific hardware error Odd number of quotation marks Only process directories specified on the command line.  Don't build cache. Only root is allowed to use this option! Only root or %s is allowed to use this option! Operation already in progress Operation canceled Operation not permitted Operation not possible due to RF-kill Operation not supported Operation now in progress Operation would block Optional output file prefix Out of streams resources Output buffers available Output control: Output selection: Owner         : %s
 Owner died PATH PID PRIVATE
 Package not installed Parameter string not correctly encoded Parse error: %s Partial success Passed object is not the same object on server Path `%s' given more than once Permission denied Power failure Prefix used for all file accesses Premature end of regular expression Print cache Print content of database file, one entry a line Print current configuration statistics Print more information Print more messages Print program version Privileged opcode Privileged register Probable success Probably not found Process breakpoint Process trace trap Processing request in progress Profiling timer expired Protocol driver not attached Protocol error Protocol family not supported Protocol not available Protocol not supported Protocol wrong type for socket Put output in FILE instead of installed location (--prefix does not apply to FILE) Query illegal for named table Quit RFS specific error ROOT RPC bad procedure for program RPC failure on NIS operation RPC program not available RPC program version wrong RPC struct is bad RPC version wrong RPC: (unknown error code) RPC: Authentication error RPC: Can't decode result RPC: Can't encode arguments RPC: Failed (unspecified error) RPC: Incompatible versions of RPC RPC: Port mapper failure RPC: Procedure unavailable RPC: Program not registered RPC: Program unavailable RPC: Program/version mismatch RPC: Remote system error RPC: Server can't decode arguments RPC: Success RPC: Timed out RPC: Unable to receive RPC: Unable to send RPC: Unknown host RPC: Unknown protocol RSA (%d bits)
 RTLD_NEXT used in code not dynamically loaded RTLD_SELF used in code not dynamically loaded Read and display shared object profiling data. Read configuration data from NAME Read-only file system Real-time signal %d Regular expression too big Reloading "%s (%s,%s,%s)" in netgroup cache! Reloading "%s" in group cache! Reloading "%s" in hosts cache! Reloading "%s" in netgroup cache! Reloading "%s" in services cache! Remote I/O error Remote address changed Remove locales named by parameters from archive Renaming of %s to %s failed Reopening shared object `%s' failed Replace existing archive content Replicate :
 Report bugs to %s.
 Request arguments bad Request canceled Request not canceled Required key not available Resolver Error 0 (no error) Resolver internal error Resource deadlock avoided Resource lost Resource temporarily unavailable Results sent to callback proc SECS SHOBJ [PROFDATA] STRING Search Path         : %s
 Segmentation fault Server busy, try again Server out of memory Server rejected credential Server rejected verifier Service configuration to be used Servname not supported for ai_socktype Set the owner, group and access permission of the slave pseudo terminal corresponding to the master pseudo terminal passed on file descriptor `%d'.  This is the helper program for the `grantpt' function.  It is not intended to be run directly from the command line.
 Set the program name Shut the server down Signal generated by the arrival of a message on an empty message queue Signal generated by the completion of an I/O request Signal generated by the completion of an asynchronous I/O request Signal generated by the completion of an asynchronous name lookup request Signal generated by the expiration of a timer Signal sent by kill() Signal sent by sigqueue() Signal sent by the kernel Signal sent by tkill() Socket operation on non-socket Socket type not supported Software caused connection abort Source definitions are found in FILE Srmount error Stack fault Stale file handle Start NUMBER threads State not recoverable Status            : %s
 Stopped Stopped (signal) Stopped (tty input) Stopped (tty output) Stopped child has continued Streams pipe error Strictly conform to POSIX Structure needs cleaning Subscript out of range Success Supported databases:
 Supported tables:
%s

For bug reporting instructions, please see:
%s.
 Suppress warnings and information messages Symbolic character names defined in FILE Syntax: memusage [--data=FILE] [--progname=NAME] [--png=FILE] [--unbuffered]
	    [--buffer=SIZE] [--no-timer] [--time-based] [--total]
	    [--title=STRING] [--x-size=SIZE] [--y-size=SIZE]
	    PROGRAM [PROGRAMOPTION]... System error System information: System resource allocation failure System's directory for character maps : %s
		       repertoire maps: %s
		       locale path    : %s
%s TABLE TABLE
 TABLE,yes TLS generation counter wrapped!  Please report this. Table Type          : %s
 Temporary failure in name resolution Terminated Text file busy The following list contains all the coded character sets known.  This does
not necessarily mean that all combinations of these names can be used for
the FROM and TO command line parameters.  One coded character set can be
listed with several different names (aliases).

   The owner is set to the current user, the group is set to `%s', and the access permission is set to `%o'.

%s Time to live :  Timer expired Title string used in output graphic Too many attributes Too many levels of symbolic links Too many links Too many open files Too many open files in system Too many processes Too many references: cannot splice Too many users Trace execution of program by printing currently executed function.

     --data=FILE          Don't run the program, just print the data from FILE.

   -?,--help              Print this help and exit
      --usage             Give a short usage message
   -V,--version           Print version information and exit

Mandatory arguments to long options are also mandatory for any corresponding
short options.

 Trace/breakpoint trap Traced child has trapped Trailing backslash Translator died Transport endpoint is already connected Transport endpoint is not connected Try \`%s --help' or \`%s --usage' for more information.\n Try \`ldd --help' for more information. Try `%s --help' or `%s --usage' for more information.
 Trying %s...
 Type : %s
 UNKNOWN UT offset out of range Unable to authenticate NIS+ client Unable to authenticate NIS+ server Unable to create callback Unable to create process on server Unknown (type = %d, bits = %d)
 Unknown .netrc keyword %s Unknown ELFCLASS in file %s.
 Unknown NIS error code Unknown OS Unknown database name Unknown database: %s
 Unknown error Unknown error  Unknown host Unknown object Unknown option: %s %s %s Unknown resolver error Unknown server error Unknown signal Unknown signal %d Unknown signal %d
 Unknown system error Unknown ypbind error Unmatched ( or \( Unmatched ) or \) Unmatched \{ Unrecognized variable `%s' Urgent I/O condition Usage: Usage: %s [-ef] [-F FROMLIST] [-o FILENAME] [-T TOLIST] [--exit]
	    [--follow] [--from FROMLIST] [--output FILENAME] [--to TOLIST]
	    [--help] [--usage] [--version] [--]
	    EXECUTABLE [EXECUTABLE-OPTION...]\n Usage: %s [-v specification] variable_name [pathname]
 Usage: getconf [-v SPEC] VAR
  or:  getconf [-v SPEC] PATH_VAR PATH

Get the configuration value for variable VAR, or for variable PATH_VAR
for path PATH.  If SPEC is given, give values for compilation
environment SPEC.

 Usage: ldd [OPTION]... FILE...
      --help              print this help and exit
      --version           print version information and exit
  -d, --data-relocs       process data relocations
  -r, --function-relocs   process data and function relocations
  -u, --unused            print unused direct dependencies
  -v, --verbose           print all information
 Usage: lddlibc4 FILE

 Usage: memusage [OPTION]... PROGRAM [PROGRAMOPTION]...
Profile memory usage of PROGRAM.

   -n,--progname=NAME     Name of the program file to profile
   -p,--png=FILE          Generate PNG graphic and store it in FILE
   -d,--data=FILE         Generate binary data file and store it in FILE
   -u,--unbuffered        Don't buffer output
   -b,--buffer=SIZE       Collect SIZE entries before writing them out
      --no-timer          Don't collect additional information through timer
   -m,--mmap              Also trace mmap & friends

   -?,--help              Print this help and exit
      --usage             Give a short usage message
   -V,--version           Print version information and exit

 The following options only apply when generating graphical output:
   -t,--time-based        Make graph linear in time
   -T,--total             Also draw graph of total memory use
      --title=STRING      Use STRING as title of the graph
   -x,--x-size=SIZE       Make graphic SIZE pixels wide
   -y,--y-size=SIZE       Make graphic SIZE pixels high

Mandatory arguments to long options are also mandatory for any corresponding
short options.

 Usage: sln src dest|file

 Usage: sotruss [OPTION...] [--] EXECUTABLE [EXECUTABLE-OPTION...]
  -F, --from FROMLIST     Trace calls from objects on FROMLIST
  -T, --to TOLIST         Trace calls to objects on TOLIST

  -e, --exit              Also show exits from the function calls
  -f, --follow            Trace child processes
  -o, --output FILENAME   Write output to FILENAME (or FILENAME.$PID in case
			  -f is also used) instead of standard error

  -?, --help              Give this help list
      --usage             Give a short usage message
      --version           Print program version Usage: xtrace [OPTION]... PROGRAM [PROGRAMOPTION]...\n Use CACHE as cache file Use CONF as configuration file Use separate cache for each user User defined signal 1 User defined signal 2 VALUE Value too large for defined data type Virtual timer expired Warning: ignoring configuration file that cannot be opened: %s Wild result from command execution Window changed Write names of available charmaps Write names of available locales Write names of selected categories Write names of selected keywords Write output to file NAME Writing of cache data failed Written by %s and %s.
 Written by %s.
 Written by %s.\n Wrong medium type Yes, 42 is the meaning of life You really blew it this time Zone continuation line end time is not after end time of previous line [DIR...] [FILE...] [FILE] \`$program' is no executable\n `%.*s' already defined as collating element `%.*s' already defined as collating symbol `%.*s' already defined in charmap `%.*s' already defined in repertoire `%1$s' definition does not end with `END %1$s' `%s' and `%.*s' are not valid names for symbolic range `%s' is no correct profile data file for `%s' `digit' category has not entries in groups of ten add new entry "%s" of type %s for %s to cache%s ai_family not supported ai_socktype not supported already running argument to <%s> must be a single character argument to `%s' must be a single character auth_unix.c: Fatal marshalling problem bad argument bad owner blank FROM field on Link line block freed twice
 bogus mcheck_status, library is buggy
 cache_set: could not allocate new rpc_buffer cache_set: victim alloc failed cache_set: victim not found can't determine time zone abbreviation to use just after until time can't reassign procedure number %ld
 cannot access '%s' cannot add already read locale `%s' a second time cannot add to locale archive cannot allocate buffer for object name cannot allocate dependency list cannot allocate memory for program header cannot allocate memory in static TLS block cannot allocate name record cannot allocate symbol data cannot allocate symbol search list cannot allocate version reference table cannot apply additional memory protection after relocation cannot attach to process %lu cannot change current working directory to "/" cannot change current working directory to "/": %s cannot change memory protections cannot change mode of new locale archive cannot change mode of resized locale archive cannot change to old GID: %s; disabling paranoia mode cannot change to old UID: %s; disabling paranoia mode cannot change to old working directory: %s; disabling paranoia mode cannot close file descriptor cannot create %s; no persistent database used cannot create %s; no sharing possible cannot create RUNPATH/RPATH copy cannot create TLS data structures cannot create a pipe to talk to the child cannot create cache for search path cannot create capability list cannot create directory for output files cannot create internal descriptor cannot create output file `%s' for category `%s' cannot create read-only descriptor for "%s"; no mmap cannot create scope list cannot create search path array cannot create search tree cannot create shared object descriptor cannot create temporary file cannot create temporary file name cannot create temporary file: %s cannot determine escape character cannot determine file name cannot dynamically load executable cannot enable executable stack as shared object requires cannot enable socket to accept connections: %s cannot extend global scope cannot extend locale archive file cannot find C preprocessor: %s
 cannot find program header of process cannot fork cannot generate output file cannot get current working directory: %s; disabling paranoia mode cannot get information about process %lu cannot handle old request version %d; current version is %d cannot initialize archive file cannot load auxiliary `%s' because of empty dynamic string token substitution
 cannot load profiling data cannot lock locale archive "%s" cannot lock new archive cannot make segment writable for relocation cannot map archive header cannot map database file cannot map locale archive file cannot map pages for fdesc table cannot map pages for fptr table cannot map zero-fill pages cannot open cannot open %s cannot open %s/task cannot open `%s' cannot open database file `%s' cannot open directory "%s": %s: ignored cannot open input file cannot open input file `%s' cannot open locale archive "%s" cannot open locale definition file `%s' cannot open output file cannot open output file `%s' cannot open output file `%s' for category `%s' cannot open shared object file cannot open socket: %s cannot open zero fill device cannot prepare reading %s/task cannot read all files in "%s": ignored cannot read archive header cannot read character map directory `%s' cannot read data from locale archive cannot read dynamic section cannot read file data cannot read header cannot read header from `%s' cannot read invalidate ACK cannot read link map cannot read object name cannot read program header cannot read program interpreter cannot read r_debug cannot read statistics data cannot rename new archive cannot rename temporary file cannot resize archive file cannot restore segment prot after reloc cannot save new repertoire map cannot set file creation context for `%s' cannot stat database file cannot stat locale archive "%s" cannot stat newly created file cannot stat shared object cannot write output files to `%s' cannot write result: %s cannot write statistics: %s cannot write to database file %s: %s cap_init failed cap_set_proc failed character '%s' in class `%s' must be in class `%s' character '%s' in class `%s' must not be in class `%s' character <SP> not defined in character map character L'\u%0*x' in class `%s' must be in class `%s' character L'\u%0*x' in class `%s' must not be in class `%s' character class `%s' already defined character map `%s' already defined character map `%s' is not ASCII compatible, locale not ISO C compliant [--no-warnings=ascii] character map file `%s' not found character sets with locking states are not supported checking for monitored file `%s': %s child exited with status %d
 child terminated by signal %d
 circular dependencies between locale definitions clnt_raw.c: fatal header serialization error command line connect to address %s:  constant or identifier expected conversion from `%s' is not supported conversion from `%s' to `%s' is not supported conversion modules not available conversion rate value cannot be zero conversion stopped due to problem in writing the output conversion to `%s' is not supported conversions from `%s' and to `%s' are not supported copy used because hard link failed: %s copy used because symbolic link failed: %s could not initialize conditional variable could not start any worker thread; terminating could not start clean-up thread; terminating couldn't create an rpc server
 couldn't register prog %ld vers %ld
 database %s is not supported database [key ...] database for %s corrupted or simultaneously used; remove %s manually if necessary and restart default character map file `%s' not found disable IDN encoding disabled inotify-based monitoring after read error %d disabled inotify-based monitoring for directory `%s': %s disabled inotify-based monitoring for file `%s': %s duplicate definition of <%s> duplicate definition of script `%s' duplicate key duplicate set definition duplicated definition for mapping `%s' duplicated message identifier duplicated message number ellipsis range must be marked by two operands of same type empty char string empty dynamic string token substitution empty file name enablecache: cache already enabled enablecache: could not allocate cache enablecache: could not allocate cache data enablecache: could not allocate cache fifo encoding for output encoding of original text error getting caller's id: %s error while adding equivalent collating symbol error while closing input `%s' error while closing output file error while closing the profiling data file error while loading shared libraries error while reading the input error: you do not have read permission for executable \`$program' not found\n exited with unknown exit code expected continuation line not found expecting string argument for `copy' extra trailing semicolon failed to add file watch `%s`: %s failed to create new locale archive failed to load shared object `%s' failed to load symbol data failed to map segment from shared object failed to mmap the profiling data file failed to remove file watch `%s`: %s failed to start conversion processing failed to write new database file failure while reading configuration file; this is fatal failure while writing data for category `%s' file %s is truncated
 file `%s' already exists and may be overwritten
 file name '%s' begins with '/' file name '%s' component contains leading '-' file name '%s' contains '%.*s' component file name '%s' contains byte '%c' file name '%s' contains byte '\%o' file name '%s' contains overlength component '%.*s...' file not a database file file size does not match file too short format '%s' not handled by pre-2015 versions of zic freed %zu bytes in %s cache fstat failed garbage at end of character code specification garbage at end of number generate call graph generate flat profile with counts and ticks getgrouplist failed handle_request: request received (Version = %d) handle_request: request received (Version = %d) from PID %ld hard linked somewhere has characters other than ASCII alphanumerics, '-' or '+' has fewer than 3 characters has more than 6 characters header size does not match hexadecimal range format should use only capital characters ignored inotify event for `%s` (file exists) illegal CORRECTION field on Leap line illegal Rolling/Stationary field on Leap line illegal character in file:  illegal escape sequence at end of string illegal input sequence at position %Zd illegal input sequence at position %ld illegal nettype: `%s'
 illegal set number implementation limit: no more than %Zd character classes allowed implementation limit: no more than %d character maps allowed incomplete character or shift sequence at end of buffer incomplete set of locale files in "%s" initial getgrouplist failed input line of unknown type integer overflow internal error internal error (illegal descriptor) internal error in %s, line %u internal error: symidx out of range of fptr table invalid ELF header invalid UT offset invalid abbreviation format invalid character: message ignored invalid day of month invalid definition invalid encoding given invalid ending year invalid escape sequence invalid leaping year invalid line invalid mode invalid mode for dlopen() invalid mode parameter invalid month name invalid names for character range invalid namespace invalid persistent database file "%s": %s invalid pointer size invalid process ID '%s' invalid quote character invalid saved time invalid starting year invalid target namespace in dlmopen() invalid thread ID '%s' invalid time of day invalid weekday name invalidation failed key length in request too long: %d ldd: option \`$1' is ambiguous leap second precedes Big Bang libc4 library %s in wrong directory libc5 library %s in wrong directory libc6 library %s in wrong directory libraries %s and %s in directory %s have same soname but different type. line too long link to link list all known coded character sets locale "%s" not in archive locale '%s' already exists locale alias file `%s' not found locale name should consist only of portable characters locale.alias file to consult when making archive lstat failed makecontext: does not know how to handle more than 8 arguments
 malformed line ignored maximum file size for %s database too small memory clobbered before allocated block
 memory clobbered past end of allocated block
 memory exhausted memory is consistent, library is buggy
 memusage: option \`${1##*=}' is ambiguous memusage: unrecognized option \`$1' missing file arguments mmap of cache file failed.
 monitored file `%s` changed (mtime) monitored file `%s` was %s, adding watch monitored file `%s` was %s, removing watch monitored file `%s` was written to monitored parent directory `%s` was %s, removing watch on `%s` monitoring directory `%s` (%d) monitoring file %s for database %s monitoring file `%s` (%d) more than one dynamic segment
 nameless rule need absolute file name for configuration file when using -r needs to be installed setuid `root' netname2user: (nis+ lookup): %s
 netname2user: DES entry for %s in directory %s not unique netname2user: LOCAL entry for %s in directory %s not unique netname2user: missing group id list in `%s' netname2user: principal name `%s' too long netname2user: should not have uid 0 never registered prog %d
 no no <Uxxxx> or <Uxxxxxxxx> value given no POSIX environment variable for zone no entries to be processed no input digits defined and none of the standard names in the charmap no more memory for database '%s' no more namespaces available for dlmopen() no other keyword shall be specified when `copy' is used no output digits defined and none of the standard names in the charmap no output file produced because errors were issued no output file produced because warnings were issued no symbolic name given no symbolic name given for end of range nonzero padding in e_ident not all characters used in `outdigit' are available in the charmap not all characters used in `outdigit' are available in the repertoire not regular file nscd configuration:

%15d  server debug level
 nscd not running!
 number of bytes for byte sequence of beginning and end of range not the same: %d vs %d object file has no dynamic section object file has no loadable segments omit invalid characters from output only ET_DYN and ET_EXEC can be loaded only WIDTH definitions are allowed to follow the CHARMAP definition options:
 order for `%.*s' already defined at %s:%Zu out of memory out of memory
 output file parameter null or not set pmap_getmaps.c: rpc problem poll: protocol failure in circuit setup
 prctl(KEEPCAPS) failed pre-2014 clients may mishandle more than 1200 transition times premature end of `translit_ignore' definition preprocessor error previous definition was here print list of count paths and their number of use print progress information problems while reading `%s' process %lu is no ELF program profiling data file `%s' does not match shared object `%s' provide access to FD %d, for %s pruning %s cache; time %ld rcmd: %s: short read rcmd: Cannot allocate memory
 rcmd: poll (setting up stderr): %m
 rcmd: socket: All ports in use
 rcmd: write (setting up stderr): %m
 re-exec failed: %s; disabling paranoia mode reading of ELF header failed reading of section header string table failed reading of section headers failed reference clients mishandle more than %d transition times registerrpc: out of memory
 relative path `%s' used to build cache relocation error repeated leap second moment repertoire map file `%s' not found request from %ld not handled due to missing permission request from '%s' [%ld] not handled due to missing permission request not handled due to missing permission resulting bytes for range not representable. rpcgen: arglist coding error
 rpcgen: too many defines
 rule goes past start/end of month; will not work with pre-2004 versions of zic same rule name in multiple files secure services not implemented anymore setgroups failed shared object cannot be dlopen()ed shared object not open short read while reading request key: %s short read while reading request: %s short write in %s: %s size overflow socket: protocol failure in circuit setup
 standard input start and end character sequence of range must have the same length starting year greater than ending year stat failed for file `%s'; will try again later: %s stat of "%s" failed: %s: ignored suggested size of table for database %s larger than the persistent database's table suppress warnings svc_run: - out of memory svc_run: - poll failed svc_tcp.c - cannot getsockname or listen svc_tcp.c - tcp socket creation problem svc_unix.c - AF_UNIX socket creation problem svc_unix.c - cannot getsockname or listen svcudp_create - cannot getsockname svcudp_create: socket creation problem svcudp_create: xp_pad is too small for IP_PKTINFO
 symbol `%.*s' not in charmap symbol `%.*s' not in repertoire map symbol `%s' symbol `%s' has the same encoding as symbol `%s' not defined symbol lookup error symbolic link used because hard link failed: %s syntax error syntax error in %s definition: %s syntax error in prolog: %s syntax error in repertoire map definition: %s syntax error: not inside a locale definition section this is the first definition time overflow time too large time too small time zone abbreviation differs from POSIX standard time zone abbreviation has fewer than 3 characters time zone abbreviation has too many characters to-value <U%0*X> of range is smaller than from-value <U%0*X> to-value character sequence is smaller than from-value sequence too few bytes in character encoding too many arguments too many bytes in character encoding too many errors; giving up too many leap seconds too many local time types too many transition times too many, or too long, time zone abbreviations trailing garbage at end of line trouble replying to prog %d
 two rules for same instant typed single year unable to allocate buffer for input unable to free arguments undefined uninitialized header unknown unknown character `%s' unknown directive `%s': line ignored unknown iconv() error %d unknown name "%s" unknown set `%s' unknown specification "%s" unrecognized option unruly zone unsupported dlinfo request unterminated message unterminated string unterminated string constant unterminated symbolic name upper limit in range is smaller than lower limit usage: %s infile
 use of 2/29 in non leap-year value for %s must be an integer value for <%s> must be 1 or greater value of <%s> must be greater or equal than the value of <%s> values over 24 hours not handled by pre-2007 versions of zic verification failed version lookup error warning:  warning: you do not have execution permission for while inserting in search tree while opening old catalog file while preparing output while stat'ing profiling data file wild compilation-time specification of zic_t with UCS range values one must use the hexadecimal symbolic ellipsis `..' with character code range values one must use the absolute ellipsis `...' with symbolic name range values the absolute ellipsis `...' must not be used write incomplete writeable by other than owner wrong ELF class: ELFCLASS32 wrong ELF class: ELFCLASS64 wrong number of arguments wrong number of fields on Leap line wrong number of fields on Link line wrong number of fields on Rule line wrong number of fields on Zone continuation line wrong number of fields on Zone line xtrace: unrecognized option \`$1'\n yes yp_update: cannot convert host to netname
 yp_update: cannot get server address
 Project-Id-Version: GNU libc 2.26.9000
POT-Creation-Date: 2018-07-26 22:19-0400
PO-Revision-Date: 2018-01-11 14:24+0900
Last-Translator: Changwoo Ryu <cwryu@debian.org>
Language-Team: Korean <translation-team-ko@googlegroups.com>
Language: ko
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8-bit
X-Bugs: Report translation errors to the Language-Team address.
 		      :  		          :  	%s [-abkCLNTM][-D[=]] [-i ] [-I [-K ]] [-Y ] 
 	%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o ] []
 	%s [-n ID]* [-o ] []
 	%s [-s ]* [-o ] []
 	 :  	 %s entry 
 	       : %s
 	     :  	         : %s
 	 (%u)
 	[%d]	          : %s
 	[%u] - [%u ]  	    
    :
%s.
 
  :
 
SELinux AVC :

%15u   
%15u   
%15u   
%15u   
%15u  CAV 
%15u  CAV 
%15u  CAV 
%15u  CAV 
 
  :              %2lus   
         %2um %2lus   
        %s -a []
     %2uh %2um %2lus   
       = %u
      :
       :
      :
       :
       
        
       
        
       
        
      :
       :
   :   ()
  ()
  () [...] "%s"   :  " %s"  -l    " %s"  -p        "" .
 %%z UTC   99:59:59  %.*s: ARGP_HELP_FMT    %.*s:    ARGP_HELP_FMT  %1$s:  `END %1$s'()   %15d    
%15d    
%15lu    
%15s    
%15lu    
%15u    
 %3ud %2uh %2um %2lus   
 %2$s   %1$d 
   %s  %s() 32 ELF .
 %s() 64 ELF .
 %s()    %d()  .
 %s()     %s()    (: %d).
 %s()   
 %s() ELF   -    .
 %s%s%s:%u: %s%sassertion `%s' .
%n %s%s    %d
 %s: %s;   = %lu,   = %lu %s: %s;  = %s
 %s: %s;  = (     - %d)
 %s: '%s'()  'ifdef'  'ifndef'   %s: 'endif'  'ifdef'  'ifndef'   %s: <mb_cur_max> <mb_cur_min>  
 %s: C  exit  %d 
 %s: C   %d 
 %s: %s    : %s
 %s: %s/%s()   : %s
 %s: %s    : %s %s: %s()   : %s
 %s: %s/%s()   : %s
 %s: %s/%s()   : %s
 %s:    %s  Leap   %s:  : %s
 %s:   -L  
 %s:   -d  
 %s:   -l  
 %s:   -p  
 %s:   -y  
 %s:   
 %1$s:  %3$d  `%2$s'()    %s: `%s'()    %s: `%s'  `%s'    %s: `-1' `%s'     %s:   `forward' `backward'   %s: `position'          %s: `translit_start'  `translit_end'  . %s:  : <%.*s> %s:             %s:          %s:    `%s'()    %s: %.*s     :     %s:  `%s'       %s:  `%s'       %s: `%s'      %s:  '%s',  %d
 %s:    
 %s: `era'    `%Zd'   '+' '-'  %s: `era'    `%Zd'      %s: `default_missing'   %s:     %s:  `%s'   %s: `%s'   %s:       %s:  weight    %s:     %s:     
 %s: `%s'     %s: `%s'     10  %s: `%s'     %s: `%s'      %s: `%s'    %s: `%s'    %s:   : %m
 %s: `era'    %Zd       %s: `era'    %Zd        %s: `era'    %Zd        %s:  `END'  %s:  : %s
 %1$s: `%3$s'    `%%%2$c'  %s: `%s'      %s: `era'    %Zd     %s:     %s:   -- '%c'
 %s: `era'    %Zd      %s: `era'    %Zd      %s: `%s'    %s:   `%s'()   %s: %d :   `%s'
 %s: %d : %d  trim domain    %s: %d : `on'  `off'  , `%s'() 
 %s: %d :     : `%s'
 %s: %d :    domain   %s: %s/%s  : %s
 %s: `order_end'   %s: `reorder-end'   %s: `reorder-sections-end'   %s: era    %Zd era   %s: era    %Zd era   %s: 'else'  %s: `%s'     %s:       %s:     %s: `%s'    : %s %s: `%s'   identification  %s:    `default_missing'   %s:     %s:    `%d'   %s: '%s%s'    
 %s: '%s%s'   
 %s: '%s%s'   .  : %s: '%s%s'   
 %s: '%s'   \n %s: '%s'   \n %s:  .  : %s:     -- '%c'
 %s:     -- '%s'\n %s: `%.*s'    %s:%Zu  %s:   `%.*s'     %s:   `%.*s'     %s: %s      
 %s:  %s() 
 %s: :   %d
 %s: %d       . %s:      %s: `%.*s'     %s: `era'    %Zd    %s:    `order_end'      %s:    `order_start'      %s:   %s:        %s:        %s: "%s"   : %lu  %s: "%s"   : %lu  %s:   : %lu bytes %s: terminology  `%s'()   %s:         %s:  `%s'     %d    %s: `%s'     %s:   ;    %d  %s:    %s: `%s'     %s:  `%s'    %s: %s()   : %m
 %s:        %s:         %s:         %s: `%s'      %s:      `%.*s' %1$s: `%3$s'   `%2$s' standard  %s:       `%s' %s:     '%c%s'\n %s:     '%s%s'
 %s:  %s [ --version ] [ --help ] [ -v ] \
	[ -l <> ] [ -p <POSIX> ] [ -d <> ] \
	[ -L <> ] [ <> ... ]

 %s   .
 %s: : %s <> <> ...
:
  -c [L,]U    L  ( -500), U   ( 2500)
  -t [L,]U    L , U   (1970    )
  -i             ( )
  -v            
  -V              
  --help       
  --version    

Report bugs to %s.
 %s: `%s'       %s: `%s'   %d...%d    %s: `%s'        %s: `int_curr_symbol'   ISO 4217     [--no-warnings=intcurrsym] %s: curr_symbol'     %s: `%s'   127   %s: `%s'   %d    %s: :  "%s"  "%s" %s
 %s:       %s: %s()    : %m %s:  -c  %s
 %s:  -t  %s
 %s:%u: hwcap    %s:%u: %s     %s:%u:  hwcap %lu %s %s:%u: hwcap  %lu()  %u()  %s:%u: hwcap  %lu()  %s()   '%s'()    'wait' 
 ( )    !? ( )     !? (   )
 ***      : %m
 *** `%s'     :    
 * * , OS ABI: %s %d.%d.%d --help		   
 --version	  
 -5		SysVr4  
 -C		ANSI C 
 -D<>[=]	   (#define )
 -I		 inetd   (SunOS 4.1 )
 -K 		 K   
 -L		  syslog 
 -M		    
 -N		      
 -Sc		      
 -Sm 		  
 -Sc		      
 -T		RPC     
 -Y 		C (cpp)   
 -a		  ( )
 -b		  (SunOS 4.1  )
 -c		XDR  
 -h		  
 -i 		    
 -l		  
 -m		  
 -n netid	netid      
 -o <-> [<->]...
[<-> [<->]...] -o 	  
 -s  -s nettype	nettype      
 -t		RPC   
 a.out .lib   <%s>() <%s>()     <SP>  `%s'    <SP>  `%s'   <> ?    :    (AVC)            %s  
                                :                     
               ai_flags    
           <> <> <> <> CPU                   /     rpcinfo:     ypbind    ypserv       %s()    %s()    %s() %s()      `%s'()   
    `%s'()   
  %s()    %s stat()   %s stat()  
 %s()              rpc            `%s' fstat()   .
         
 %s lstat()    `%s' mmap()  .
                       LC_ALL      LC_COLLATE      LC_CTYPE      LC_MESSAGES        SO_BROADCAST          !
 %s stat()    ID  inetd     !
 ID  TIRPC    !
       !
 <>   <>    %s  to %#o()                    : %c
                                                :
     ( ).  : ascii, intcurrsym    ( ).  : ascii, intcurrsym               .                 .      Copyright (C) %s Free Software Foundation, Inc.
   ;   .  
         .
      %s        C   NAME   iconv      .          .   : %s <> [] netname %s  DES   
 
 SUID/SGID  DST      !!!              :
              Diffie-Hellman (%d )
       : %s
 --nostdlib            fork   TTY   fork ,            ,        ,                       PC    . ELF  ABI   ELF  OS ABI  ELF      ELF      ELF       ELF   ident  ident   ELF  phentsize    ELF   /  align   ELF   align  align   EMT  ENTRY
  
 entry/table    %s   
 NSCD          NSCD    .    RPC   :  NIS+     .  NIS+ ?      :         .   "%s"()     .      : .netrc      .  1  ID  .
    Exec   :  `_POSIX2_LOCALEDEF'   <> <>    UCS4     <> (  )       : %m AVC      SELinux              nscd '%s'     keep-capabilities   AVC    AVC     keep-capabilities     %s     . %s     .           .
                LD_TRACE_PRELINKING      first/next            0            :
%s.
     :\\n%s.\\n    : new, old, compat ()    resync     
 ARGP_HELP_FMT  : %s              .^K<-> -     .  <-> - 
  .
    (    )                 .    .                     : %s
   : "%s.%s"    entry:
 <>  ( 3600)    "%s (%s,%s,%s)"()   !   "%s"()   !   "%s"()   !   "%s"()   !   "%s"()   !               <-> <->
-o <-> <->
-u <->          %s  .                           ioctl       :  :   %s()  .
    /  : /   0      NIS      ypbind                                     \{\}             "%s" "%s"()  : %s
 gid  "%s" ! UID  "%s" !                                      named   Kerberos.
         
  %2$s UID %1$d  LOCAL entry  
  2   2    3   3               :    : %s
          .                <>      <>      ,                 \n  .\n                .    .   :
   ,   .                       : %s         :  hop  server-user     stat-user     restart-interval     <> <>
[--add-to-archive|--delete-from-archive] <>...
--list-archive [] <>
[-a|-m] NIS /   -     NIS    NIS+   NIS+     NIS+     NIS+     
 <>  : `%s'
    .                     /            reset          CSI     XENIX           anode                    %s         %s  soname                                   \n                                 %d   
 NIS+    name resolution     .
    XENIX named           .                            : %d
       : %u
          #%d:
   : %s
   :                  .    . root     ! root %s      !           , RF-kill             ()        :  :         : %s
   <> <PID> 
          : %s         `%s'                                                                                          <> (--prefix <>  )      RFS   <> RPC    NIS   RPC  RPC    RPC    RPC   RPC   RPC: (    ) RPC:   RPC:     RPC:     RPC: (  ) RPC:   RPC  RPC:    RPC:    RPC:    RPC:    RPC: /  RPC:    RPC:      RPC:  RPC:   RPC:    RPC:    RPC:     RPC:     RSA (%d )
     RTLD_NEXT      RTLD_SELF         . <>          %d      "%s (%s,%s,%s)"()  !   "%s"()  !   "%s"()  !   "%s"()  !   "%s"()  !             %s %s()       `%s'()             :
  %s  .
              0 ( )                 <> SHOBJ [PROFDATA] <>             : %s
       ,                ai_socktype servname     `%d'         , ,   .   `grantpt'   .       .
                                   kill()   sigqueue()      tkill()              <>    srmount       <>                     : %s
  () (tty ) (tty )         POSIX          :
  :
%s

    :
%s.
        <>      : memusage [--data=<>] [--progname=<>] [--png=<>] [--unbuffered]
	    [--buffer=<>] [--no-timer] [--time-based] [--total]
	    [--title=<>] [--x-size=<>] [--y-size=<>]
	    <> []...    :      ,           : %s
		         : %s
		             : %s
%s <> 
 <>, TLS   !     .           : %s
 name resolution               .   
  FROM TO         
  .       ()  
  .

      ,  `%s'() ,   `%o'() .

%s   :                                  :              .

     --data=<>          , <>  

   -?,--help                
      --usage                
   -V,--version              

   ,     .

 /                         \`%s --help'  \`%s --usage' .\n     \`ldd --help' .     `%s --help'  `%s --usage' .
 %s ...
  : %s
  UT    NIS+     NIS+                ( = %d,  = %d)
    .netrc  %s %s    ELFCLASS.
    NIS               : `%s'
                    : %s %s %s                   %d     %d
         ypbind     (  \(    )  \)    \{     `%s'    : : %s [-ef] [-F <>] [-o <>] [-T <>] [--exit]
	    [--follow] [--from <>] [--output <>]
	    [--to <>] [--help] [--usage] [--version] [--]
	    <> [-...]\n : %s [-v <>] <> []
 : getconf [-v <>] <>
 :  getconf [-v <>] <> <>

<>      .  <>   
<_>      . SPEC  
 SPEC   .

 : ldd []... <>...
      --help                 
      --version              
  -d, --data-relocs         
  -r, --function-relocs       
  -u, --unused                
  -v, --verbose             
 : lddlibc4 <>

 : memusage []... <> []...
<>   .

   -n,--progname=<>      
   -p,--png=<>        PNG   <> 
   -d,--data=<>           <> 
   -u,--unbuffered          
   -b,--buffer=<>       <>   
      --no-timer               
   -m,--mmap              mmap    

   -?,--help                 
      --usage               
   -V,--version              

         :
   -t,--time-based           
   -T,--total                 
      --title=<>    <>   
   -x,--x-size=<>      <>   
   -y,--y-size=<>      <>   

   ,     .

 : sln <> <>|<>

 : sotruss [...] [--] <> [< >...]
  -F, --from <>    <>    
  -T, --to <>      <>    

  -e, --exit                  
  -f, --follow               
  -o, --output <>     <>  
                           ( -f    FILENAME.$PID )

  -?, --help                 
  -?, --usage                
      --version               : xtrace []... <> []...\n   <>    <>         1    2 <>          :      : %s                            <>        : %s  %s.
  : %s.
  : %s.\n    , 42        Zone            [...] [...] [] \`$program'    \n `%.*s'()     `%.*s'()     `%.*s'()    `%.*s'()    `%1$s'  `END %1$s'()   `%s'  `%.*s'()      `%s'() `%s'      `digit'  10       "%s" ,  %s,  %s,  %s ai_family   ai_socktype      <%s>      `%s'      auth_unix.c:        Link  FROM     
  mcheck_status,   
 cache_set:  rpc_buffer    cache_set:     cache_set:                 %ld   
 '%s'      `%s'                                TLS                                     %lu       "/"       "/"   : %s                      GID   : %s:      UID   : %s:          : %s:          %s()   :     %s()   :   RUNPATH/RPATH     TLS                                      `%s'   `%s'     "%s"       : mmap                                       : %s                               : %s            C    : %s
       fork             : %s:      %lu        %d    ;   %d             `%s'     
      "%s"                                   fdesc      fptr      0         %s()    %s/task    `%s'()    `%s'      "%s"    : %s:       `%s'      "%s"         `%s'            `%s'       `%s'   `%s'              : %s 0      %s/task     "%s"      :       `%s'                          `%s'      ACK                       r_debug                             prot           `%s'             "%s"                stat()    `%s'       : %s    : %s %s     : %s cap_init  cap_set_proc  `%2$s'  '%1$s'  `%3$s'     `%2$s'  '%1$s'  `%3$s'       <SP>     L'\u%0*x'  `%s'    `%s'     L'\u%0*x'  `%s'    `%s'      `%s'     `%s'     `%s'   ASCII  .  ISO C    [--no-warnings=ascii] `%s'           `%s`  : %s    %d 
    %d 
      clnt_raw.c:       %s :       `%s'    `%s' `%s'           0           `%s'    `%s'   `%s'()        : %s     : %s          :      :  RPC    
  %ld %ld    
 %s     [ ...] %s      .  %s()     `%s'       IDN      %d  inotify     `%s'   inotify    : %s `%s'   inotify    : %s <%s>()   `%s'            `%s'()                              enablecache:     enablecache:     enablecache:      enablecache:  FIFO           ID  : %s       `%s'                             :      \`$program'   \n            `copy'         `%s`    : %s         `%s'()                mmap   `%s`    : %s             :   `%s'     %s  
 `%s'   .     
 '%s'   '/'  '%s'    '-'   '%s'   '%.*s'    '%s'   '%c'    '%s'   '\%o'    '%s'      '%.*s...'               '%s'  2015   zic   %zu   (%s )  fstat                       getgrouplist  handle_request:  ( = %d) handle_request:  ( = %d), PID %ld    ASCII   , '-', '+'    3  6      16      `%s`  inotify (  )  Leap  CORRECTION   Leap  Rolling/Stationary             %Zd      %ld        : `%s'
     : %Zd       : %d              "%s"        getgrouplist             ( ) %s,  %u     : symidx fptr    ELF   UT       :                        dlopen()                    "%s": %s     ID , '%s'          dlmopen()     ID , '%s'              : %d ldd: \`$1'       libc4 library %s()    libc5 library %s()    libc6 library %s()     %s  %s() %s()  soname    .           "%s"    '%s'    `%s'                  locale.alias  lstat  makecontext: 8        
     %s           
      
    ,   
 memusage: \`${1##*=}'    memusage:     \`$1'      mmap  .
  `%s`   (mtime)  `%s`  %s,    `%s`  %s,    `%s`     `%s`   %s, `%s`    `%s`   (%d) %2$s   %1$s   `%s`   (%d)    
   -r          setuid `root'   netname2user: (NIS+ ): %s
 netname2user:  %2$s %1$s  DES entry   netname2user:  %2$s %1$s  LOCAL    netname2user: `%s'  ID   netname2user:   `%s'()   netname2user: UID 0       %d
  <Uxxxx>  <Uxxxxxxxx>      POSIX               '%s'      dlmopen()        `copy'                                    e_ident  0    `outdigit'        `outdigit'          nscd :

%15d    
 nscd  !
        : %d  %d                 ET_DYN ET_EXEC    CHARMAP    WIDTH   :
 `%.*s'   %s:%Zu     
    NULL    pmap_getmaps.c: RPC  poll:    
 prctl(KEEPCAPS)  2014     1200      `translit_ignore'                       `%s'()     %lu ELF      `%s'()   `%s'()   FD %d ,  %s : %s ;  %ld rcmd: %s:   rcmd:    
 rcmd: poll ( ): %m
 rcmd: socket:    
 rcmd: write ( ): %m
   : %s:     ELF                     %d    registerrpc:  
     `%s'           `%s'      %ld        '%s'[%ld]                 . rcpgen: arglist  
 rpcgen:   
  /   2004   zic               setgroups    dlopen()           : %s    : %s %s   : %s   socket:    
                  `%s'  stat .   : %s "%s"    : %s:  %s            svc_run: -   svc_run: - poll  svc_tcp.c - getsockname  listen  svc_tcp.c - tcp    svc_unix.c - AF_UNIX    svc_unix.c - getsockname  listen  svcudp_create - getsockname  svcudp_create:    svcudp_create: xp_pad IP_PKTINFO   
 `%.*s'     `%.*s'      `%s'  `%s'()   : `%s'            : %s   %s    : %s   : %s     : %s  :                     POSIX     3        to-value <U%0*X>() from-value <U%0*X>  to-value   from-value                  ;                           %d    
     2                          `%s'     `%s':      iconv()  %d     "%s"     `%s'     "%s"         dlinfo                    : %s <>
  2 29  %s     %s   1   <%s>   <%s>     24   2007   zic        :  :                        zic_t    UCS   16   `..'        `..'        `..'             ELF  : ELFCLASS32 ELF  : ELFCLASS64    Leap     Link     Rule     Zone continuation     Zone     xtrace:     \`$1'\n  yp_update:     
 yp_update:     
 PRIu64 PRIuMAX PRIdMAX considering %s entry "%s", timeout % 
%s cache:

%15s  cache is enabled
%15s  cache is persistent
%15s  cache is shared
%15zu  suggested size
%15zu  total data pool size
%15zu  used data pool size
%15lu  seconds time to live for positive entries
%15lu  seconds time to live for negative entries
%15  cache hits on positive entries
%15  cache hits on negative entries
%15  cache misses on positive entries
%15  cache misses on negative entries
%15lu%% cache hit rate
%15zu  current number of cached values
%15zu  maximum number of cached values
%15zu  maximum chain length searched
%15  number of delays on rdlock
%15  number of delays on wrlock
%15  memory allocations failed
%15s  check /etc/%s for changes
 "%s", line %:   (rule from "%s", line %) duplicate zone name %s (file "%s", line %) : %s  "%s",  % 
%s :

%15s     
%15s    
%15s    
%15zu    
%15zu      
%15zu      
%15lu      
%15lu      
%15       
%15       
%15       
%15       
%15lu%%  
%15zu    
%15zu    
%15zu     
%15     
%15     
%15    
%15s     /etc/%s 
 "%s",  %:   ("%s"  ,  %)  %s ( "%s",  %)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ELF                              .         @     @     @ T_{@SA[BcCkD+@_{  S[ck+  *a    s   B       B       	B          o    ~   T  `@s  Z               @ Z`4 |~  cja!  cZbaTB s 	       @ Z 4 |~  cja! ?  cZbaTb  sT  R      @ %sdma-window %s#dma-address-cells %s#dma-size-cells #address-cells <V                                         -   -   P   >       I                   int q          }                  s8 U   u16 j   s32 q   u32    s64    u64    	-      
-      q                    -       q       0       1       G      H  	q   l  
-        W       X      Y      Zq       [q   I       #}         j       %                      0       ;      -l      6F      ;Q                              d      q         O                o                                                                  )      )       :     :  )   /      M  S  q   ^  	B  j       _      _      _      _  	I                             X            	(-   	P            

      
      
      
q   	q   *       
_      
q       
q       
q       V      
6[      ;      <g       =4       l      q                q       q       q       q       q       q       q                O                                              3      jD  (         val                                            !       "?      $j      &        	?      
w                Ej      FM       G    E   )      *       +q       ,q       --       .-          (            '      /p       0  fn                      (-       h.      /-        0#      1      2      3       4q   Pcpu 5q   T    6@  X    7q   `      W  !    X   !    Y@  !    Zd  !    [   !    \   !    _(&   !    `q   (!    a  0!    b-   8!    c-   @!    eq   H!    gq   L!    iq   P!    iq   T!    iq   X!    j   \!    kH  `"se lF  h#rt mF  ($    oH  p%dl qG  x$    |   $    }q   $    ~{   $    q   ($    `H  ,$      0$    H  @$    ?  H$      h$    %  x&    N  #mm 0  $    0  '       $       $    H  $    $  $    q    $    q   $    q   $    q   $       $       '       '       '       '       $    -    #pid   ($      ,$      0$      8$      @$      P$      `$      h$      x$    H  $      $      $    8  $    M  $    M   $    &  $    &  $    &  $    &   $    &  ($       0$    ;  8$    -   H$    -   P$       X$       `$    -   h$    -   p$    -   x$    -   $    -   $    ;  $    /  $     H  $    H  $    H  $    	q   $    	q   $       #fs H  	$    H  	$    8  	$    H  	$    H  	$    0)  	$    0)  	$     0)  	$    !+  	$    #-   
$    $  
$    %I  
$    &@   
$    'I  (
$    ()  0
$    * I  8
$    ,@(  @
$    -   D
$    /%6  H
$    2   X
$    3   \
&    6g  `
&    90  d
$    =  h
$    >  p
$    @+I  x
$    `@  
$    c6I  
$    gAI  
$    kLI  
$    mWI  
$    obI  
$    q-   
$    rhI  
$    s8  
$    sI  
$      
$    ~I  
$    I  
$      
$    I  
$    I   &      $      8$    -   H#rcu   P$    I  `$    #  h$    q   x$    q   |$    q   $    -   $    -   $    -   $    -   $    -            (    M-   )                  *    !  %      &         '      q       q       0          *       +AR  ,    B       @g  -<    *    LR                s            4       4       7-   .    J      K   /    L}    /    M}    	    
-        0":      #   /    $    /    %    1 T      !  2
   .     u  :   3cpu )    4pmu     u  .    2      4q        6q       7q       9      :   	    
-              h=  x19 >-    x20 ?-   x21 @-   x22 A-   x23 B-    x24 C-   (x25 D-   0x26 E-   8x27 F-   @x28 G-   Hfp H-   Psp I-   Xpc J-   ` .    M      N       O-   h    PT  p/    Q-   /    R-   /    S             d        (2M      4d       5g      6      8  osq ;        f      k    M  	-   {  
-         M      q       O  f        P      Q      R  5      	M    
-     	4     
-             	4     
-   @
-           
       .E       /     6 k  !     ,   7     g   8     E      !'      !(g       !)   *    !+x       "      "        "       #1q       $R-       $S-       $`q    %#      %%      %&   	-   -  
-    .    0%s      %q        % q   ary %!s  /    %"q   9   	    
-    -  :idr (%*      %+   top %,      %-q   cur %.q       %/g      %0q       %1        %      %       %   	-   !  
-    :ida 0%H  ;idr %       %H  (       &#      &$-        &%      &&   N      &*      &+        'J      'K-        'M      'S'       p''  kn '       '       '!      '  @    '  H    '  X       'VF      'W        x'j      'kd       'ld      'v      'w>   ;rb 'yN  ns '{  0    '|   8  @    '@  `    'j   h    '  jino '   l    '  p F       'Z,  ops '[       '\      ']      '^       @'      '       '      '0      'F      'p       '  (    'p  0    'l  8 ,           '}  <dir '~      '-      '     =          ('4      'S       'x      '      '      '    q   M  '  M     q   4  q   m  m  '   s      Y  q       >      ~  q          q         >            p'Q  kn '       'V      '@      '      'q   @    '  H    '  X    '  `    '  h     Q  >    @(   !    (K   !    (K  !    (K  !    (K  !    (K   !    (L  (!    (+L  0!    (/OL  8 \    q     m  @     @    m         @  0  m  @       F  m  @   6    j  j           L  q     j           )l      )-        )-       )      )  7    )N   !    )	-   8!    )0  @!    )  H!    )-   P7    )!$  X!    ))  x!    )+E$  !    ).  !    )1-   !    )3V  !    )4@   v  ?       *                    0*(      *)r       **      *+       *,       *-+       *.<  (       @                     &  <  @   1      +q       +f  cap +f    	}   v  
-        +M  v      ++      +,            q        q        ,	      -L       -M9       --   @    .%      .&        .)      /q       /      /q           0$1      8),t      ).-    "  "  >#   -x#  0 A      1       1       1?z      1O      1Sz      2tt  	    A-        2      2      (30      3       3      30  osq 3       3%    6       )^!  !    )_   !    )`  !    )a   !    )c6%  !    )g-    !    )h-   (!    )i-   0!    )j-   8Bpgd )k<%  @!    )ld  H!    )md  L!    )n  P!    )oq   X7    )qg  \7    )r  `!    )t  !    )z-   !    ){-   !    )}-   !    )~-   !    )-   !    )-   !    )-   !    )-   !    )-   !    )-   !    )-   !    )-   !    )-   $    )-    #brk )-   $    )-   $    )-   $    )-    $    )-   ($    )-   0$    )B%  8$    )$  $    )W%  $    )  &    )"  $    )-   $    )]%  &    )g  $    )h%  $    )V  $    )  $    )!   C     R)4"  id 4        40      4@   *    4!  )0."      )13"      )8@       ."  )=c"      )>-       )?@      )@   )n"  D    )o    D    )p    D    )q      )["      )ld  2c"      )sq    )Y"  "       )ud   )K"      )V   2"      )w    )<#  9"   "   )>#      )t       )q       )q    )|m#  <lru )}  2#      )r#      )       m#  +)#      )-   Eptl )g      )#      )t       #      )#      )t       )}       )}    6 )$  "rb )N   !    )-    F )@$  G    )#  H    )  H    ) >        @$  >    )>s$  !    )?   !    )@s$   K$  I    8)C$  !    )Dd   !    )EK$  7    )F   >    )S$  !    )Tq    !    )U$   	q   $  
-    >    )Y%  !    )Z%    	  %  
-    -   6%  V  -   -   -   -    %    	-   R%  
-   )     R%  y$      c%      5 k         61%  y%      7-       7-       (8U%      8Vq        8W      8X   9b%      9bk        9b%      9c%  	%  &  
-        9&      :-       ;AA&      ;BA&    (&      <   b&            =3m&  R&      ==&      =>@        =@s&      @<?'      <@        <A       <B       <C       <D        <E   (    <F   0    <G   8     <J'  &  @<S~'      <T>        <Uq       <V       <W       <X-        <Y-   (    <Z-   0    <[-   8 .    K<R'  rec <\'   /    <^    K/    <_   K 	'  '  A-   +     <a~'      <bg      <c       <       >"q       >#q       >Qq       >Rq           ?(  ?@(  val ?        ?+(  ?`(  val ?        ?K(  >    X)  !    d   !    d  !    d  !    d  !    d  !       !    -    !    -   (!      0!      8Buid @(  H!      P k(  @W0)  sig @Xk        @Y)      A       AQ)  ;)      A^      Am)  W)  @    B)      Bq       B	@       B
s)  B9)      B:%       B;0   B?*      B@       BAq       BB*      BC)      BDq    	I   *  J-    BHC*      BI%       BJ0      BK)    BO*      BP%       BQ0      BRq       BS      BT   BX*      BY@       B]c    Ba*      Bb   _fd Bcq    Bg*      Bh@       Biq       Bj    pB5X+      B6X+      B<)      BE)  <_rt BL*      BUC*      B^*      Bd*      Bk*   	q   h+  
-        B0+      B1q        B2q       B3q       Bl*       Bmh+      Cq       C+      C       C0)       Cq        C(,      CF)       C-       Cb)      C0)   >     CB,  Bsa C+        C,#       D4},  nr D6q    ns D7s-      D8   .    Es-      EkM       EM  3rcu E  /    Eq   /    E   /    E   /    E#  (/    E   0/    E s-  8/    E"M  @/    E#M  H/    E$M  P/    E):  X/    E*3  `/    E+`(  /    E,q   /    E-q   /    E.    },  Kpid PD;-      D=d       D>       D@-  rcu DA       DB-  0 	  -  
-    	N,  -  
-         DEy-      DG.      DI   pid DJ.   y-      De},  	-   3.  
-        F#.      G8@      G9T.  4   ?       GN.                    	D   .  
-    .      GU.      GWZ.      HLq       hH\.      H].       H^-   ` 	  .  
-         @Hj/  x Hk/    	I   /  J-         H;/      H        H        pH`/      H`/       H/  P 	  p/  
-        @H/      Hq        Hq       Hq   !    H/   	  /  
-    >    hH/  Bpcp Hp/   !    H   @!    H/  A 	   0  
-            H.0                         @HG1  !    HK1   !    HU2  !    H_   0!    Ha2  8!    Hb2  @!    Hh-   H!    H{-   P!    H-   X!    H-   `!    H-   h!    H>   p!    Hq   x!    H-   !    H2  !    H-   !    H-   7    H.  @7    Hg  !    H2  $    H-   @&    H.  @&    Hg  $    H;/  $    H  $    H-    $    H-   $    H   $    H    $    H   $$    Hq   ($    H  ,&    H.  @@$    H2  @ 	-   2  
-    	  2  
-         @@H2  7    H3  @ $    H3  $    Hq   $    H-   $    H-   $    H-   $    Hq   &    H  &    H  $    H   $    Hq   ($    H0  , 2  /    	.  2  
-   
 	  
3  
-     >    H23  !    H23   !    Hq    .0  >    HH`3  !    He3   !    Hk3       `3  	
3  {3  
-        Ht  L.0  @3  
-    	83  3  
-         I3  3  3  3   3       Id3      Ie       If      Ig3       3      Ie 4      If 4      Ig 4      Ih 4      Ii 4      Ij 4      Ik 4      2e4  k4  q   4  4  -   @   4      54      6Z4       74      8q        0@4      A       B4  (     E4      F4        4      4      H      HRq       H\      H      H2  >    H@u5  !    HM-    !    HPu5   -   	5  5  A-    M5      Hr{5       J5      J	q        J
q       Jq       J       J{      J{   	5  6  
-        J5      K.      Lq       MJ6      Mq        MO6       J6      Nq       O*6      O+       O,        P6      P	N       P
       P6      P       P6   6  ?       Q,6                @Ql@7      Qm6       Qn       QoU7  (    Qp7  0    Qq-   8 6  O7  O7   6  @7      @Q7      Qn8       Qq       Q      Q6      Q       Qy8  (    Q  0    Q  8 [7  M    @Qn8      Q0   cpu Q       Q       Q       Q      Qq       Qq       Q-        Q-   (    Q-   0    Q  8    Q8  @ 7    t8  	[7  8  
-            QI8  C     S    8      0T9      Td       T9M      T DM      T!OM      T"s-       T#ZM  (     U X9      U!d       U"q       U#q       U$X9      U%h9   	`(  h9  
-    	w9  w9  J-    `(      UB9      Ug:      Uhd   uid Up@(  gid Uq`(      Ur@(      Us`(      Ut@(      Uu`(      Uv@(      Uw`(       Ux   $    Uyv  (    Uzv  0    U{v  8    U|v  @    U}v  H    U@  P    U)  X    U:  `    U:  hrcu U  p 9  (  9  	-   :       :      -       q       -   	I   :  
-         :            g      y      y       (`;  !    d   !    `;  &    g  &       	(,  p;  
-   ? >    ;  !    &   !    &  !       !        >    ;  !    &   !    &   >    <  !    &   !    &  !        I     +F<  !    ,;   !    -q   7    .0        ;?  !    <d   !    =d  !    >q   !    ?  7    A   !    D  8!    G+  @!    Jq   X!    Pq   \!    Q  `!    Tq   h!    U   lN    `   pN    a   p!    dq   t!    e  x7    h6  !    i.  !    j  Bit q?  &    w<  $    z;  ($    |/  @$    ~.  p$    q   x#tty ?  &    k  $    &  $    &  $    &  $    &  $    &  $    &  $    ;  $    -   $    -   $    -   $    -   $    -   $    -   $    -    $    -   $    -   $    -   $    -    $    -   ($    -   0$    -   8$    8  @$       @$    ?  H$       H$       L$    ?  P&      X$    9  $    c   $    c   &       	p;  ?  
-        ?  	`6  ?  
-        ?      k(  >     $@  !    &-    !    '   !    *   !    +        q   O9@  H    @  Prcu    Q    (B  !    B   !    B  !    B  !    -   !    -    !       (!       ,!       0!       4!       8!       <!       @!       D!       H!    q   L!    q   P!    q   T!    -   X!       `!       d!       h!    -   p!    B  x!    B  !    B  !    B  !    B  !    B  !    B  !    B  !       !       !       !       !       !       !       !       !       !       $        $       $      9@  $        $    B  ( 9@      B  	   B  
-    	-   B  J-    5    B  B    B  q    5    M  >    -C  Bsd -C   Bsg  3C  Bsgc !>C   B  B      DC  9C  >    8$C  !    %B   !    &B  !    'q   !    (q   !    )B  !    +  0     /C  JC  >    hC  !    i-    !    j    >    `mD  !    n    !    o   !    x-   !    x-   !    x-    !       (!       ,!       0!    -   8!       @!       D!       H!       P!       X >    F  !        !       !       !       !        !       (!       0!       8!       @!       H!       P!       X!       `!       h!       p!       x!       !       !       !       !       !       !       !       !       !       !             F  !    C   7    N  !      (!       8!       @!       H!       P!       X!       `!    D  h$    q   @$    F  H$    F  P$    F  X#avg C  ` F      F  >    HqG  !       !    -   !    -   !        !    qG  (!    qG  0!    |G  8!    |G  @ F      wG  I    <H  7    N   !       !        !       (!       0!       8!       @!       H!    q   L!    q   P!    q   T!    q   X7    "6  ` R&`H  !    '   !    (   S    %H  Pb )<H  Ps *c        H  H      H      H  	  H  
-    	-  H  
-    :  	I   H  
-        H      H  F<  ;  q   I  @    I  0)      I      &I      1I      <I      GI      RI      ]I  +      nI      yI      I      I  	I  I  
-    I          I      .      X	  T     @Z	I  H    [	.  H    \	I   	-   J  A-        i	I      j	      l	6      %H      V
q       Vq       W{J      W	       W
X       (.-       (8-       (9@      (:q       (=q       (Cx       (Dx       (Eq       (Hx       (Ix       (Jq       (U-       (V-       (Xq       (Yq       (Z-       (r#  	  FK  
-        (6K      0(K      (        (-       (@      (t      (-    pte (K  (   K     K  q   K    K   QK  K  K    K   K  q   L    -   @  q   q    K  >   +L     L  q   OL    -   -   -    1L      Xq   .    XzL      XzL    	-   L  
-   5     X`L      Xo2  	D   L   L      X L      (q       (      (-       (q       (q       (q       (q       (      (VJ      (VJ      4M      ?M      JM  4net UM      T%8      YM      Yd        EM      Ed       E@   	M  M  
-        M      M      %       ZM      Z>        Z   N      @[?N      [@>        [A      [BM      [C+P       [DzP  (sd [E  0    [FkM  8D    [J   <D    [K   <D    [L   <D    [M   <D    [N   < M  N      8ZO      ZM       Z      Z@      Z?O       Z?O  (    ZcO  0 N    ?O  V  M  O         O  q   cO  V  M  O     EO      ZO      ZO       ZO   iO    O  M  N     O    O  M  N  >      O      [%      [)       `[+P      [       [g      [N      [Q  X O      ([szP      [tP       [uP      [vN      [wP      [xP    1P  P  M   P  O  P  P  M     P    P  M   P  .     	[{Q      [|Q       [}$Q  /    [~q   3buf [4Q  /    [q   	 	  $Q  
-    	  4Q  
-    	I   EQ  A-        [vQ      [Q       [Q      [Q   EQ  q   Q  +P  M   {Q  Q  >   Q  +P  M   Q  Q  q   Q  +P  M  Q   P  Q  Q      [O  vQ      [M      [M      [M      [M      [M             h"R      #       $q       %@      &R      '-        (   (    )N  0 6R      0RS      1>        2>       3+R      4>       6R       7R  (    8RS  0    9RS  8    :RS  @    ;RS  H    <RS  P    =N  X    >-       ?@   R      O1P      pRS      qRS      rRS      sRS      t0  U    'q                 mU  Vdn 'RS      W    '>       W    'q       W    (u5      W    (mU      W    (8      X    *sU  Yend *sU      Z    +q       X    +q   [    ,yU  z[    ,yU  |[    ,yU  ~\    8U  X    >   X    ?  ]U              LT  ^U  ^U  _    `U        ]U              ST  ^U  ^U  _    `U        a        V  a        V  a        V  a        V  a        'V   a        3V  a        3V  a        3V  a        V   #    	I   U  
-    b       U  c    sU  c    q   dr     b    \O}   U  ep \OsU   b    ]}   U  ep ]U      b    ]9}   V  eval ]9}    f        f        #f        $f         %  $ >  & I  5 I   I  $ >   :;I   :;I  	I  
! I/  '   I  :;   :;I8  :;      'I   '  !   4 :;I?<   <  4 :;I?<  :;   :;I8  'I  >I:;  (    :;I8  :;   :;I   I8   :;  ! :;I8  " :;I8  # :;I8  $ :;I8  % :;I8  & :;I8  ' :;I8  (4 :;I?  ):;  * :;I  +:;  , :;I  - I8  .:;  / :;I8  0:;  1:;  2 I  3 :;I8  4 <  5 :;I  6:;  7 :;I8  8 :;I  9 I8  ::;  ; :;I8  < :;I  =&   >:;  ?>I:;  @:;  A! I/  B :;I8  C :;  D :;I8  E :;I  F:;  G :;I  H :;I  I:;  J! I  K:;  LI  M:;  N :;I8  O:;  P :;I  Q:;  R:;  S:;  T:;  U.?:;'I@B  V :;I  W :;I  X4 :;I  Y4 :;I  Z4 :;I  [4 :;I  \U  ]1RUXY  ^ 1  _U  `4 1  a 1  b.:;'I   c :;I  d4 :;I  e :;I  f. ?<n:;                   P                d8              P                                Q               c                                R               f                                S              i                                T              j                                U       \        k\              U                       $        e              e                               z               e                T             R                       8        R              R             R                ,                                                                                                 P      T      `      p                                                              k           ../drivers/iommu ../include/linux ../include/asm-generic ../include/uapi/asm-generic ../include/uapi/linux ../arch/arm64/include/asm ../arch/arm64/include/uapi/asm ../include/clocksource ../include/uapi/linux/byteorder  of_iommu.c   of.h   int-ll64.h   int-ll64.h   posix_types.h   types.h   types.h   init.h   cachetype.h   printk.h   notifier.h   kernel.h   memory.h   thread_info.h   time.h   compat.h   thread_info.h   sched.h   spinlock_types.h   lockdep.h   spinlock_types.h   rwlock_types.h   atomic-long.h   hwcap.h   ptrace.h   fpsimd.h   hw_breakpoint.h   processor.h   osq_lock.h   mutex.h   cpumask.h   seqlock.h   wait.h   completion.h   rcupdate.h   rcutree.h   idr.h   rbtree.h   kernfs.h   mm.h   mm_types.h   kobject_ns.h   capability.h   time.h   jiffies.h   ktime.h   timekeeping.h   timer.h   pgtable-types.h   pgtable.h   rwsem.h   mmu.h   cpufeature.h   arm_arch_timer.h   timex.h   plist.h   nodemask.h   cputime_jiffies.h   llist.h   smp.h   smp.h   highuid.h   uidgid.h   signal.h   signal-defs.h   siginfo.h   signal.h   pid.h   pid_namespace.h   percpu.h   percpu.h   mmzone.h   workqueue.h   topology.h   gfp.h   percpu_counter.h   seccomp.h   rtmutex.h   resource.h   timerqueue.h   hrtimer.h   uprobes.h   task_io_accounting.h   nsproxy.h   cred.h   debug_locks.h   page_ext.h   vmstat.h   kref.h   sysfs.h   kobject.h   little_endian.h 	  swab.h     	        (=+ U +  O i!0gghY" t<""3/>K!L = .  <!- !"K = .  <!- /"1 p. Cj< sched_entity long long int audit_context notifier_call line console_printk vm_page_prot init_pid_ns shared_vm vm_stat_diff si_errno tasks read long unsigned int ino_ida compact_